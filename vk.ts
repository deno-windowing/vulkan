/// This file is auto-generated. Do not edit.

/// Type definitions

export type MTLDevice_id = Deno.PointerValue;

export type MTLCommandQueue_id = Deno.PointerValue;

export type MTLBuffer_id = Deno.PointerValue;

export type MTLTexture_id = Deno.PointerValue;

export type MTLSharedEvent_id = Deno.PointerValue;

export type IOSurfaceRef = Deno.PointerValue;

export type VkSampleMask = number;

export type VkBool32 = number;

export type VkFlags = number;

export type VkFlags64 = Deno.PointerValue;

export type VkDeviceSize = Deno.PointerValue;

export type VkDeviceAddress = Deno.PointerValue;

export type VkFramebufferCreateFlags = VkFlags;

export type VkQueryPoolCreateFlags = VkFlags;

export type VkRenderPassCreateFlags = VkFlags;

export type VkSamplerCreateFlags = VkFlags;

export type VkPipelineLayoutCreateFlags = VkFlags;

export type VkPipelineCacheCreateFlags = VkFlags;

export type VkPipelineDepthStencilStateCreateFlags = VkFlags;

export type VkPipelineDynamicStateCreateFlags = VkFlags;

export type VkPipelineColorBlendStateCreateFlags = VkFlags;

export type VkPipelineMultisampleStateCreateFlags = VkFlags;

export type VkPipelineRasterizationStateCreateFlags = VkFlags;

export type VkPipelineViewportStateCreateFlags = VkFlags;

export type VkPipelineTessellationStateCreateFlags = VkFlags;

export type VkPipelineInputAssemblyStateCreateFlags = VkFlags;

export type VkPipelineVertexInputStateCreateFlags = VkFlags;

export type VkPipelineShaderStageCreateFlags = VkFlags;

export type VkDescriptorSetLayoutCreateFlags = VkFlags;

export type VkBufferViewCreateFlags = VkFlags;

export type VkInstanceCreateFlags = VkFlags;

export type VkDeviceCreateFlags = VkFlags;

export type VkDeviceQueueCreateFlags = VkFlags;

export type VkQueueFlags = VkFlags;

export type VkMemoryPropertyFlags = VkFlags;

export type VkMemoryHeapFlags = VkFlags;

export type VkAccessFlags = VkFlags;

export type VkBufferUsageFlags = VkFlags;

export type VkBufferCreateFlags = VkFlags;

export type VkShaderStageFlags = VkFlags;

export type VkImageUsageFlags = VkFlags;

export type VkImageCreateFlags = VkFlags;

export type VkImageViewCreateFlags = VkFlags;

export type VkPipelineCreateFlags = VkFlags;

export type VkColorComponentFlags = VkFlags;

export type VkFenceCreateFlags = VkFlags;

export type VkSemaphoreCreateFlags = VkFlags;

export type VkFormatFeatureFlags = VkFlags;

export type VkQueryControlFlags = VkFlags;

export type VkQueryResultFlags = VkFlags;

export type VkShaderModuleCreateFlags = VkFlags;

export type VkEventCreateFlags = VkFlags;

export type VkCommandPoolCreateFlags = VkFlags;

export type VkCommandPoolResetFlags = VkFlags;

export type VkCommandBufferResetFlags = VkFlags;

export type VkCommandBufferUsageFlags = VkFlags;

export type VkQueryPipelineStatisticFlags = VkFlags;

export type VkMemoryMapFlags = VkFlags;

export type VkImageAspectFlags = VkFlags;

export type VkSparseMemoryBindFlags = VkFlags;

export type VkSparseImageFormatFlags = VkFlags;

export type VkSubpassDescriptionFlags = VkFlags;

export type VkPipelineStageFlags = VkFlags;

export type VkSampleCountFlags = VkFlags;

export type VkAttachmentDescriptionFlags = VkFlags;

export type VkStencilFaceFlags = VkFlags;

export type VkCullModeFlags = VkFlags;

export type VkDescriptorPoolCreateFlags = VkFlags;

export type VkDescriptorPoolResetFlags = VkFlags;

export type VkDependencyFlags = VkFlags;

export type VkSubgroupFeatureFlags = VkFlags;

export type VkIndirectCommandsLayoutUsageFlagsNV = VkFlags;

export type VkIndirectStateFlagsNV = VkFlags;

export type VkGeometryFlagsKHR = VkFlags;

export type VkGeometryFlagsNV = VkGeometryFlagsKHR;

export type VkGeometryInstanceFlagsKHR = VkFlags;

export type VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;

export type VkBuildAccelerationStructureFlagsKHR = VkFlags;

export type VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;

export type VkPrivateDataSlotCreateFlags = VkFlags;

export type VkPrivateDataSlotCreateFlagsEXT = VkPrivateDataSlotCreateFlags;

export type VkAccelerationStructureCreateFlagsKHR = VkFlags;

export type VkDescriptorUpdateTemplateCreateFlags = VkFlags;

export type VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;

export type VkPipelineCreationFeedbackFlags = VkFlags;

export type VkPipelineCreationFeedbackFlagsEXT = VkPipelineCreationFeedbackFlags;

export type VkPerformanceCounterDescriptionFlagsKHR = VkFlags;

export type VkAcquireProfilingLockFlagsKHR = VkFlags;

export type VkSemaphoreWaitFlags = VkFlags;

export type VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;

export type VkPipelineCompilerControlFlagsAMD = VkFlags;

export type VkShaderCorePropertiesFlagsAMD = VkFlags;

export type VkDeviceDiagnosticsConfigFlagsNV = VkFlags;

export type VkAccessFlags2 = VkFlags64;

export type VkAccessFlags2KHR = VkAccessFlags2;

export type VkPipelineStageFlags2 = VkFlags64;

export type VkPipelineStageFlags2KHR = VkPipelineStageFlags2;

export type VkAccelerationStructureMotionInfoFlagsNV = VkFlags;

export type VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;

export type VkFormatFeatureFlags2 = VkFlags64;

export type VkFormatFeatureFlags2KHR = VkFormatFeatureFlags2;

export type VkRenderingFlags = VkFlags;

export type VkMemoryDecompressionMethodFlagsNV = VkFlags64;

export type VkRenderingFlagsKHR = VkRenderingFlags;

export type VkBuildMicromapFlagsEXT = VkFlags;

export type VkMicromapCreateFlagsEXT = VkFlags;

export type VkCompositeAlphaFlagsKHR = VkFlags;

export type VkDisplayPlaneAlphaFlagsKHR = VkFlags;

export type VkSurfaceTransformFlagsKHR = VkFlags;

export type VkSwapchainCreateFlagsKHR = VkFlags;

export type VkDisplayModeCreateFlagsKHR = VkFlags;

export type VkDisplaySurfaceCreateFlagsKHR = VkFlags;

export type VkAndroidSurfaceCreateFlagsKHR = VkFlags;

export type VkViSurfaceCreateFlagsNN = VkFlags;

export type VkWaylandSurfaceCreateFlagsKHR = VkFlags;

export type VkWin32SurfaceCreateFlagsKHR = VkFlags;

export type VkXlibSurfaceCreateFlagsKHR = VkFlags;

export type VkXcbSurfaceCreateFlagsKHR = VkFlags;

export type VkDirectFBSurfaceCreateFlagsEXT = VkFlags;

export type VkIOSSurfaceCreateFlagsMVK = VkFlags;

export type VkMacOSSurfaceCreateFlagsMVK = VkFlags;

export type VkMetalSurfaceCreateFlagsEXT = VkFlags;

export type VkImagePipeSurfaceCreateFlagsFUCHSIA = VkFlags;

export type VkStreamDescriptorSurfaceCreateFlagsGGP = VkFlags;

export type VkHeadlessSurfaceCreateFlagsEXT = VkFlags;

export type VkScreenSurfaceCreateFlagsQNX = VkFlags;

export type VkPeerMemoryFeatureFlags = VkFlags;

export type VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;

export type VkMemoryAllocateFlags = VkFlags;

export type VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;

export type VkDeviceGroupPresentModeFlagsKHR = VkFlags;

export type VkDebugReportFlagsEXT = VkFlags;

export type VkCommandPoolTrimFlags = VkFlags;

export type VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;

export type VkExternalMemoryHandleTypeFlagsNV = VkFlags;

export type VkExternalMemoryFeatureFlagsNV = VkFlags;

export type VkExternalMemoryHandleTypeFlags = VkFlags;

export type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;

export type VkExternalMemoryFeatureFlags = VkFlags;

export type VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;

export type VkExternalSemaphoreHandleTypeFlags = VkFlags;

export type VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;

export type VkExternalSemaphoreFeatureFlags = VkFlags;

export type VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;

export type VkSemaphoreImportFlags = VkFlags;

export type VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;

export type VkExternalFenceHandleTypeFlags = VkFlags;

export type VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;

export type VkExternalFenceFeatureFlags = VkFlags;

export type VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;

export type VkFenceImportFlags = VkFlags;

export type VkFenceImportFlagsKHR = VkFenceImportFlags;

export type VkSurfaceCounterFlagsEXT = VkFlags;

export type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;

export type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;

export type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;

export type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;

export type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;

export type VkValidationCacheCreateFlagsEXT = VkFlags;

export type VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;

export type VkDebugUtilsMessageTypeFlagsEXT = VkFlags;

export type VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;

export type VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;

export type VkDeviceMemoryReportFlagsEXT = VkFlags;

export type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;

export type VkDescriptorBindingFlags = VkFlags;

export type VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;

export type VkConditionalRenderingFlagsEXT = VkFlags;

export type VkResolveModeFlags = VkFlags;

export type VkResolveModeFlagsKHR = VkResolveModeFlags;

export type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;

export type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;

export type VkSwapchainImageUsageFlagsANDROID = VkFlags;

export type VkToolPurposeFlags = VkFlags;

export type VkToolPurposeFlagsEXT = VkToolPurposeFlags;

export type VkSubmitFlags = VkFlags;

export type VkSubmitFlagsKHR = VkSubmitFlags;

export type VkImageFormatConstraintsFlagsFUCHSIA = VkFlags;

export type VkImageConstraintsInfoFlagsFUCHSIA = VkFlags;

export type VkGraphicsPipelineLibraryFlagsEXT = VkFlags;

export type VkImageCompressionFlagsEXT = VkFlags;

export type VkImageCompressionFixedRateFlagsEXT = VkFlags;

export type VkExportMetalObjectTypeFlagsEXT = VkFlags;

export type VkDeviceAddressBindingFlagsEXT = VkFlags;

export type VkOpticalFlowGridSizeFlagsNV = VkFlags;

export type VkOpticalFlowUsageFlagsNV = VkFlags;

export type VkOpticalFlowSessionCreateFlagsNV = VkFlags;

export type VkOpticalFlowExecuteFlagsNV = VkFlags;

export type VkVideoCodecOperationFlagsKHR = VkFlags;

export type VkVideoCapabilityFlagsKHR = VkFlags;

export type VkVideoSessionCreateFlagsKHR = VkFlags;

export type VkVideoSessionParametersCreateFlagsKHR = VkFlags;

export type VkVideoBeginCodingFlagsKHR = VkFlags;

export type VkVideoEndCodingFlagsKHR = VkFlags;

export type VkVideoCodingControlFlagsKHR = VkFlags;

export type VkVideoDecodeUsageFlagsKHR = VkFlags;

export type VkVideoDecodeCapabilityFlagsKHR = VkFlags;

export type VkVideoDecodeFlagsKHR = VkFlags;

export type VkVideoDecodeH264PictureLayoutFlagsEXT = VkFlags;

export type VkVideoEncodeFlagsKHR = VkFlags;

export type VkVideoEncodeUsageFlagsKHR = VkFlags;

export type VkVideoEncodeContentFlagsKHR = VkFlags;

export type VkVideoEncodeCapabilityFlagsKHR = VkFlags;

export type VkVideoEncodeRateControlFlagsKHR = VkFlags;

export type VkVideoEncodeRateControlModeFlagsKHR = VkFlags;

export type VkVideoChromaSubsamplingFlagsKHR = VkFlags;

export type VkVideoComponentBitDepthFlagsKHR = VkFlags;

export type VkVideoEncodeH264CapabilityFlagsEXT = VkFlags;

export type VkVideoEncodeH264InputModeFlagsEXT = VkFlags;

export type VkVideoEncodeH264OutputModeFlagsEXT = VkFlags;

export type VkVideoEncodeH265CapabilityFlagsEXT = VkFlags;

export type VkVideoEncodeH265InputModeFlagsEXT = VkFlags;

export type VkVideoEncodeH265OutputModeFlagsEXT = VkFlags;

export type VkVideoEncodeH265CtbSizeFlagsEXT = VkFlags;

export type VkVideoEncodeH265TransformBlockSizeFlagsEXT = VkFlags;

export type VkInstance = Deno.PointerValue;

export type VkPhysicalDevice = Deno.PointerValue;

export type VkDevice = Deno.PointerValue;

export type VkQueue = Deno.PointerValue;

export type VkCommandBuffer = Deno.PointerValue;

export type VkDeviceMemory = Deno.PointerValue;

export type VkCommandPool = Deno.PointerValue;

export type VkBuffer = Deno.PointerValue;

export type VkBufferView = Deno.PointerValue;

export type VkImage = Deno.PointerValue;

export type VkImageView = Deno.PointerValue;

export type VkShaderModule = Deno.PointerValue;

export type VkPipeline = Deno.PointerValue;

export type VkPipelineLayout = Deno.PointerValue;

export type VkSampler = Deno.PointerValue;

export type VkDescriptorSet = Deno.PointerValue;

export type VkDescriptorSetLayout = Deno.PointerValue;

export type VkDescriptorPool = Deno.PointerValue;

export type VkFence = Deno.PointerValue;

export type VkSemaphore = Deno.PointerValue;

export type VkEvent = Deno.PointerValue;

export type VkQueryPool = Deno.PointerValue;

export type VkFramebuffer = Deno.PointerValue;

export type VkRenderPass = Deno.PointerValue;

export type VkPipelineCache = Deno.PointerValue;

export type VkIndirectCommandsLayoutNV = Deno.PointerValue;

export type VkDescriptorUpdateTemplate = Deno.PointerValue;

export type VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;

export type VkSamplerYcbcrConversion = Deno.PointerValue;

export type VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;

export type VkValidationCacheEXT = Deno.PointerValue;

export type VkAccelerationStructureKHR = Deno.PointerValue;

export type VkAccelerationStructureNV = Deno.PointerValue;

export type VkPerformanceConfigurationINTEL = Deno.PointerValue;

export type VkBufferCollectionFUCHSIA = Deno.PointerValue;

export type VkDeferredOperationKHR = Deno.PointerValue;

export type VkPrivateDataSlot = Deno.PointerValue;

export type VkPrivateDataSlotEXT = VkPrivateDataSlot;

export type VkCuModuleNVX = Deno.PointerValue;

export type VkCuFunctionNVX = Deno.PointerValue;

export type VkOpticalFlowSessionNV = Deno.PointerValue;

export type VkMicromapEXT = Deno.PointerValue;

export type VkDisplayKHR = Deno.PointerValue;

export type VkDisplayModeKHR = Deno.PointerValue;

export type VkSurfaceKHR = Deno.PointerValue;

export type VkSwapchainKHR = Deno.PointerValue;

export type VkDebugReportCallbackEXT = Deno.PointerValue;

export type VkDebugUtilsMessengerEXT = Deno.PointerValue;

export type VkVideoSessionKHR = Deno.PointerValue;

export type VkVideoSessionParametersKHR = Deno.PointerValue;

export type VkPrivateDataSlotCreateFlagBitsEXT = VkPrivateDataSlotCreateFlagBits;

export type VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;

export type VkPointClippingBehaviorKHR = VkPointClippingBehavior;

export type VkQueueGlobalPriorityEXT = VkQueueGlobalPriorityKHR;

export type VkResolveModeFlagBitsKHR = VkResolveModeFlagBits;

export type VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlagBits;

export type VkSemaphoreTypeKHR = VkSemaphoreType;

export type VkGeometryFlagBitsNV = VkGeometryFlagBitsKHR;

export type VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagBitsKHR;

export type VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagBitsKHR;

export type VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;

export type VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;

export type VkGeometryTypeNV = VkGeometryTypeKHR;

export type VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;

export type VkPipelineCreationFeedbackFlagBitsEXT = VkPipelineCreationFeedbackFlagBits;

export type VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlagBits;

export type VkToolPurposeFlagBitsEXT = VkToolPurposeFlagBits;

export type VkAccessFlagBits2KHR = VkAccessFlagBits2;

export type VkPipelineStageFlagBits2KHR = VkPipelineStageFlagBits2;

export type VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlagBits2;

export type VkRenderingFlagBitsKHR = VkRenderingFlagBits;

export type VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;

export type VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;

export type VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;

export type VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;

export type VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;

export type VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;

export type VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;

export type VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;

export type VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;

export type VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;

export type VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;

export type VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;

export type VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;

export type VkChromaLocationKHR = VkChromaLocation;

export type VkSamplerReductionModeEXT = VkSamplerReductionMode;

export type VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;

export type VkSubmitFlagBitsKHR = VkSubmitFlagBits;

export type VkDriverIdKHR = VkDriverId;

export type VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;

export type VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;

export type VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;

export type VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;

export type VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;

export type VkFormatProperties2KHR = VkFormatProperties2;

export type VkImageFormatProperties2KHR = VkImageFormatProperties2;

export type VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;

export type VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;

export type VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;

export type VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;

export type VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;

export type VkConformanceVersionKHR = VkConformanceVersion;

export type VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;

export type VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

export type VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

export type VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;

export type VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;

export type VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;

export type VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;

export type VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;

export type VkExternalBufferPropertiesKHR = VkExternalBufferProperties;

export type VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;

export type VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;

export type VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;

export type VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;

export type VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;

export type VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;

export type VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;

export type VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;

export type VkExternalFencePropertiesKHR = VkExternalFenceProperties;

export type VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;

export type VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;

export type VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;

export type VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;

export type VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;

export type VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;

export type VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;

export type VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;

export type VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;

export type VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;

export type VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;

export type VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;

export type VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;

export type VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;

export type VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;

export type VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;

export type VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;

export type VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;

export type VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;

export type VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;

export type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

export type VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;

export type VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;

export type VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;

export type VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;

export type VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;

export type VkMemoryRequirements2KHR = VkMemoryRequirements2;

export type VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;

export type VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;

export type VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;

export type VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;

export type VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;

export type VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;

export type VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;

export type VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;

export type VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;

export type VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;

export type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;

export type VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;

export type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;

export type VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;

export type VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;

export type VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;

export type VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;

export type VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;

export type VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;

export type VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;

export type VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;

export type VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;

export type VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;

export type VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;

export type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;

export type VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;

export type VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;

export type VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;

export type VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfoKHR;

export type VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;

export type VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityPropertiesKHR;

export type VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;

export type VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;

export type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;

export type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;

export type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;

export type VkAttachmentDescription2KHR = VkAttachmentDescription2;

export type VkAttachmentReference2KHR = VkAttachmentReference2;

export type VkSubpassDescription2KHR = VkSubpassDescription2;

export type VkSubpassDependency2KHR = VkSubpassDependency2;

export type VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;

export type VkSubpassBeginInfoKHR = VkSubpassBeginInfo;

export type VkSubpassEndInfoKHR = VkSubpassEndInfo;

export type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;

export type VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;

export type VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;

export type VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;

export type VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;

export type VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;

export type VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;

export type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;

export type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;

export type VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;

export type VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;

export type VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;

export type VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;

export type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;

export type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

export type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;

export type VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

export type VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;

export type VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;

export type VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;

export type VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;

export type VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;

export type VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;

export type VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;

export type VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;

export type VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;

export type VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;

export type VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;

export type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

export type VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;

export type VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;

export type VkPipelineInfoEXT = VkPipelineInfoKHR;

export type VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;

export type VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;

export type VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;

export type VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;

export type VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

export type VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;

export type VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;

export type VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;

export type VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;

export type VkAabbPositionsNV = VkAabbPositionsKHR;

export type VkTransformMatrixNV = VkTransformMatrixKHR;

export type VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;

export type VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;

export type VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;

export type VkBufferCopy2KHR = VkBufferCopy2;

export type VkImageCopy2KHR = VkImageCopy2;

export type VkImageBlit2KHR = VkImageBlit2;

export type VkBufferImageCopy2KHR = VkBufferImageCopy2;

export type VkImageResolve2KHR = VkImageResolve2;

export type VkCopyBufferInfo2KHR = VkCopyBufferInfo2;

export type VkCopyImageInfo2KHR = VkCopyImageInfo2;

export type VkBlitImageInfo2KHR = VkBlitImageInfo2;

export type VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;

export type VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;

export type VkResolveImageInfo2KHR = VkResolveImageInfo2;

export type VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;

export type VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;

export type VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;

export type VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;

export type VkMemoryBarrier2KHR = VkMemoryBarrier2;

export type VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;

export type VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;

export type VkDependencyInfoKHR = VkDependencyInfo;

export type VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;

export type VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;

export type VkSubmitInfo2KHR = VkSubmitInfo2;

export type VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;

export type VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;

export type VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;

export type VkFormatProperties3KHR = VkFormatProperties3;

export type VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;

export type VkRenderingInfoKHR = VkRenderingInfo;

export type VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;

export type VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;

export type VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;

export type VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;

export type VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;

/// Constants

/// API Constants
/// Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate

export const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
export const VK_UUID_SIZE = 16;
export const VK_LUID_SIZE = 8;
export const VK_LUID_SIZE_KHR = undefined;
export const VK_MAX_EXTENSION_NAME_SIZE = 256;
export const VK_MAX_DESCRIPTION_SIZE = 256;
export const VK_MAX_MEMORY_TYPES = 32;
/** The maximum number of unique memory heaps, each of which supporting 1 or more memory types */
export const VK_MAX_MEMORY_HEAPS = 16;
export const VK_LOD_CLAMP_NONE = 1000.0;
export const VK_REMAINING_MIP_LEVELS = (~0);
export const VK_REMAINING_ARRAY_LAYERS = (~0);
export const VK_WHOLE_SIZE = (~0n);
export const VK_ATTACHMENT_UNUSED = (~0);
export const VK_TRUE = 1;
export const VK_FALSE = 0;
export const VK_QUEUE_FAMILY_IGNORED = (~0);
export const VK_QUEUE_FAMILY_EXTERNAL = (~1);
export const VK_QUEUE_FAMILY_EXTERNAL_KHR = undefined;
export const VK_QUEUE_FAMILY_FOREIGN_EXT = (~2);
export const VK_SUBPASS_EXTERNAL = (~0);
export const VK_MAX_DEVICE_GROUP_SIZE = 32;
export const VK_MAX_DEVICE_GROUP_SIZE_KHR = undefined;
export const VK_MAX_DRIVER_NAME_SIZE = 256;
export const VK_MAX_DRIVER_NAME_SIZE_KHR = undefined;
export const VK_MAX_DRIVER_INFO_SIZE = 256;
export const VK_MAX_DRIVER_INFO_SIZE_KHR = undefined;
export const VK_SHADER_UNUSED_KHR = (~0);
export const VK_SHADER_UNUSED_NV = undefined;
export const VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = 16;
export const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = undefined;
export const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32;

/// Enums

export enum StdVideoH264ChromaFormatIdc {
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 2147483647,
}

export enum StdVideoH264ProfileIdc {
  /** Only constrained baseline is supported */
  STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
  STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
  STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
  STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
  STD_VIDEO_H264_PROFILE_IDC_INVALID = 2147483647,
}

export enum StdVideoH264LevelIdc {
  STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
  STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
  STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
  STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
  STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
  STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
  STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
  STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
  STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
  STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
  STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
  STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
  STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
  STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
  STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
  STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
  STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
  STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
  STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
  STD_VIDEO_H264_LEVEL_IDC_INVALID = 2147483647,
}

export enum StdVideoH264PocType {
  STD_VIDEO_H264_POC_TYPE_0 = 0,
  STD_VIDEO_H264_POC_TYPE_1 = 1,
  STD_VIDEO_H264_POC_TYPE_2 = 2,
  STD_VIDEO_H264_POC_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264AspectRatioIdc {
  STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 2147483647,
}

export enum StdVideoH264WeightedBipredIdc {
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 2147483647,
}

export enum StdVideoH264ModificationOfPicNumsIdc {
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 2147483647,
}

export enum StdVideoH264MemMgmtControlOp {
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 2147483647,
}

export enum StdVideoH264CabacInitIdc {
  STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
  STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
  STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
  STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 2147483647,
}

export enum StdVideoH264DisableDeblockingFilterIdc {
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 2147483647,
}

export enum StdVideoH264SliceType {
  STD_VIDEO_H264_SLICE_TYPE_P = 0,
  STD_VIDEO_H264_SLICE_TYPE_B = 1,
  STD_VIDEO_H264_SLICE_TYPE_I = 2,
  STD_VIDEO_H264_SLICE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264PictureType {
  STD_VIDEO_H264_PICTURE_TYPE_P = 0,
  STD_VIDEO_H264_PICTURE_TYPE_B = 1,
  STD_VIDEO_H264_PICTURE_TYPE_I = 2,
  STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
  STD_VIDEO_H264_PICTURE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264NonVclNaluType {
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 2147483647,
}

export enum StdVideoDecodeH264FieldOrderCount {
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 2147483647,
}

export enum StdVideoH265ChromaFormatIdc {
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 2147483647,
}

export enum StdVideoH265ProfileIdc {
  STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
  STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
  STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
  STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
  STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
  STD_VIDEO_H265_PROFILE_IDC_INVALID = 2147483647,
}

export enum StdVideoH265LevelIdc {
  STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
  STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
  STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
  STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
  STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
  STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
  STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
  STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
  STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
  STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
  STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
  STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
  STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
  STD_VIDEO_H265_LEVEL_IDC_INVALID = 2147483647,
}

export enum StdVideoH265SliceType {
  STD_VIDEO_H265_SLICE_TYPE_B = 0,
  STD_VIDEO_H265_SLICE_TYPE_P = 1,
  STD_VIDEO_H265_SLICE_TYPE_I = 2,
  STD_VIDEO_H265_SLICE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH265PictureType {
  STD_VIDEO_H265_PICTURE_TYPE_P = 0,
  STD_VIDEO_H265_PICTURE_TYPE_B = 1,
  STD_VIDEO_H265_PICTURE_TYPE_I = 2,
  STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
  STD_VIDEO_H265_PICTURE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH265AspectRatioIdc {
  STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 2147483647,
}

export enum VkImageLayout {
  /** Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation) */
  VK_IMAGE_LAYOUT_UNDEFINED = 0,
  /** General layout when image can be used for any kind of access */
  VK_IMAGE_LAYOUT_GENERAL = 1,
  /** Optimal layout when image is only used for color attachment read/write */
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
  /** Optimal layout when image is only used for depth/stencil attachment read/write */
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
  /** Optimal layout when image is used for read only depth/stencil attachment and shader access */
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
  /** Optimal layout when image is used for read only shader access */
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
  /** Optimal layout when image is used only as source of transfer operations */
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
  /** Optimal layout when image is used only as destination of transfer operations */
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
  /** Initial layout used when the data is populated by the CPU */
  VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
  VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
  VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
  VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
  VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
  VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
  VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003,
  VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
  VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001,
  VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002,
  VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
  VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000,
  VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001,
  VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
}

export enum VkAttachmentLoadOp {
  VK_ATTACHMENT_LOAD_OP_LOAD = 0,
  VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
  VK_ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000,
}

export enum VkAttachmentStoreOp {
  VK_ATTACHMENT_STORE_OP_STORE = 0,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
  VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
  VK_ATTACHMENT_STORE_OP_NONE_KHR = 1000301000,
  VK_ATTACHMENT_STORE_OP_NONE_QCOM = 1000301000,
  VK_ATTACHMENT_STORE_OP_NONE_EXT = 1000301000,
}

export enum VkImageType {
  VK_IMAGE_TYPE_1D = 0,
  VK_IMAGE_TYPE_2D = 1,
  VK_IMAGE_TYPE_3D = 2,
}

export enum VkImageTiling {
  VK_IMAGE_TILING_OPTIMAL = 0,
  VK_IMAGE_TILING_LINEAR = 1,
  VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
}

export enum VkImageViewType {
  VK_IMAGE_VIEW_TYPE_1D = 0,
  VK_IMAGE_VIEW_TYPE_2D = 1,
  VK_IMAGE_VIEW_TYPE_3D = 2,
  VK_IMAGE_VIEW_TYPE_CUBE = 3,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
}

export enum VkCommandBufferLevel {
  VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
}

export enum VkComponentSwizzle {
  VK_COMPONENT_SWIZZLE_IDENTITY = 0,
  VK_COMPONENT_SWIZZLE_ZERO = 1,
  VK_COMPONENT_SWIZZLE_ONE = 2,
  VK_COMPONENT_SWIZZLE_R = 3,
  VK_COMPONENT_SWIZZLE_G = 4,
  VK_COMPONENT_SWIZZLE_B = 5,
  VK_COMPONENT_SWIZZLE_A = 6,
}

export enum VkDescriptorType {
  VK_DESCRIPTOR_TYPE_SAMPLER = 0,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
  VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
  VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = 1000351000,
  VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
  VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
  VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
}

export enum VkQueryType {
  VK_QUERY_TYPE_OCCLUSION = 0,
  /** Optional */
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
  VK_QUERY_TYPE_TIMESTAMP = 2,
  VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
  VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
  VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR = 1000299000,
  VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
  VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
  VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
  VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
}

export enum VkBorderColor {
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
  VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
  VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
}

export enum VkPipelineBindPoint {
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
  VK_PIPELINE_BIND_POINT_COMPUTE = 1,
  VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
  VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000,
  VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
}

export enum VkPipelineCacheHeaderVersion {
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

export enum VkPipelineCacheCreateFlagBits {
  VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 1 << 0,
  VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT = 1 << 1,
  VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = 1 << 0,
  VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_KHR = 1 << 1,
  VK_PIPELINE_CACHE_CREATE_RESERVED_2_BIT_KHR = 1 << 2,
}

export enum VkPrimitiveTopology {
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
}

export enum VkSharingMode {
  VK_SHARING_MODE_EXCLUSIVE = 0,
  VK_SHARING_MODE_CONCURRENT = 1,
}

export enum VkIndexType {
  VK_INDEX_TYPE_UINT16 = 0,
  VK_INDEX_TYPE_UINT32 = 1,
  VK_INDEX_TYPE_NONE_KHR = 1000165000,
  VK_INDEX_TYPE_NONE_NV = 1000165000,
  VK_INDEX_TYPE_UINT8_EXT = 1000265000,
}

export enum VkFilter {
  VK_FILTER_NEAREST = 0,
  VK_FILTER_LINEAR = 1,
  VK_FILTER_CUBIC_IMG = 1000015000,
  VK_FILTER_CUBIC_EXT = 1000015000,
}

export enum VkSamplerMipmapMode {
  /** Choose nearest mip level */
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
  /** Linear filter between mip levels */
  VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
}

export enum VkSamplerAddressMode {
  VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
  /** No need to add an extnumber attribute, since this uses a core enum value */
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
  /** Alias introduced for consistency with extension suffixing rules */
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = 4,
}

export enum VkCompareOp {
  VK_COMPARE_OP_NEVER = 0,
  VK_COMPARE_OP_LESS = 1,
  VK_COMPARE_OP_EQUAL = 2,
  VK_COMPARE_OP_LESS_OR_EQUAL = 3,
  VK_COMPARE_OP_GREATER = 4,
  VK_COMPARE_OP_NOT_EQUAL = 5,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
  VK_COMPARE_OP_ALWAYS = 7,
}

export enum VkPolygonMode {
  VK_POLYGON_MODE_FILL = 0,
  VK_POLYGON_MODE_LINE = 1,
  VK_POLYGON_MODE_POINT = 2,
  VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
}

export enum VkFrontFace {
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
  VK_FRONT_FACE_CLOCKWISE = 1,
}

export enum VkBlendFactor {
  VK_BLEND_FACTOR_ZERO = 0,
  VK_BLEND_FACTOR_ONE = 1,
  VK_BLEND_FACTOR_SRC_COLOR = 2,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
  VK_BLEND_FACTOR_DST_COLOR = 4,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
  VK_BLEND_FACTOR_SRC_ALPHA = 6,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
  VK_BLEND_FACTOR_DST_ALPHA = 8,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
  VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
  VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
  VK_BLEND_FACTOR_SRC1_COLOR = 15,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
  VK_BLEND_FACTOR_SRC1_ALPHA = 17,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
}

export enum VkBlendOp {
  VK_BLEND_OP_ADD = 0,
  VK_BLEND_OP_SUBTRACT = 1,
  VK_BLEND_OP_REVERSE_SUBTRACT = 2,
  VK_BLEND_OP_MIN = 3,
  VK_BLEND_OP_MAX = 4,
  VK_BLEND_OP_ZERO_EXT = 1000148000,
  VK_BLEND_OP_SRC_EXT = 1000148001,
  VK_BLEND_OP_DST_EXT = 1000148002,
  VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
  VK_BLEND_OP_DST_OVER_EXT = 1000148004,
  VK_BLEND_OP_SRC_IN_EXT = 1000148005,
  VK_BLEND_OP_DST_IN_EXT = 1000148006,
  VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
  VK_BLEND_OP_DST_OUT_EXT = 1000148008,
  VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
  VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
  VK_BLEND_OP_XOR_EXT = 1000148011,
  VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
  VK_BLEND_OP_SCREEN_EXT = 1000148013,
  VK_BLEND_OP_OVERLAY_EXT = 1000148014,
  VK_BLEND_OP_DARKEN_EXT = 1000148015,
  VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
  VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
  VK_BLEND_OP_COLORBURN_EXT = 1000148018,
  VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
  VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
  VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
  VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
  VK_BLEND_OP_INVERT_EXT = 1000148023,
  VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
  VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
  VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
  VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
  VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
  VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
  VK_BLEND_OP_HARDMIX_EXT = 1000148030,
  VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
  VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
  VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
  VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
  VK_BLEND_OP_PLUS_EXT = 1000148035,
  VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
  VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
  VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
  VK_BLEND_OP_MINUS_EXT = 1000148039,
  VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
  VK_BLEND_OP_CONTRAST_EXT = 1000148041,
  VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
  VK_BLEND_OP_RED_EXT = 1000148043,
  VK_BLEND_OP_GREEN_EXT = 1000148044,
  VK_BLEND_OP_BLUE_EXT = 1000148045,
}

export enum VkStencilOp {
  VK_STENCIL_OP_KEEP = 0,
  VK_STENCIL_OP_ZERO = 1,
  VK_STENCIL_OP_REPLACE = 2,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
  VK_STENCIL_OP_INVERT = 5,
  VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
  VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
}

export enum VkLogicOp {
  VK_LOGIC_OP_CLEAR = 0,
  VK_LOGIC_OP_AND = 1,
  VK_LOGIC_OP_AND_REVERSE = 2,
  VK_LOGIC_OP_COPY = 3,
  VK_LOGIC_OP_AND_INVERTED = 4,
  VK_LOGIC_OP_NO_OP = 5,
  VK_LOGIC_OP_XOR = 6,
  VK_LOGIC_OP_OR = 7,
  VK_LOGIC_OP_NOR = 8,
  VK_LOGIC_OP_EQUIVALENT = 9,
  VK_LOGIC_OP_INVERT = 10,
  VK_LOGIC_OP_OR_REVERSE = 11,
  VK_LOGIC_OP_COPY_INVERTED = 12,
  VK_LOGIC_OP_OR_INVERTED = 13,
  VK_LOGIC_OP_NAND = 14,
  VK_LOGIC_OP_SET = 15,
}

export enum VkInternalAllocationType {
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
}

export enum VkSystemAllocationScope {
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
}

export enum VkPhysicalDeviceType {
  VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
  VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
}

export enum VkVertexInputRate {
  VK_VERTEX_INPUT_RATE_VERTEX = 0,
  VK_VERTEX_INPUT_RATE_INSTANCE = 1,
}

/** Vulkan format definitions */
export enum VkFormat {
  VK_FORMAT_UNDEFINED = 0,
  VK_FORMAT_R4G4_UNORM_PACK8 = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
  VK_FORMAT_R8_UNORM = 9,
  VK_FORMAT_R8_SNORM = 10,
  VK_FORMAT_R8_USCALED = 11,
  VK_FORMAT_R8_SSCALED = 12,
  VK_FORMAT_R8_UINT = 13,
  VK_FORMAT_R8_SINT = 14,
  VK_FORMAT_R8_SRGB = 15,
  VK_FORMAT_R8G8_UNORM = 16,
  VK_FORMAT_R8G8_SNORM = 17,
  VK_FORMAT_R8G8_USCALED = 18,
  VK_FORMAT_R8G8_SSCALED = 19,
  VK_FORMAT_R8G8_UINT = 20,
  VK_FORMAT_R8G8_SINT = 21,
  VK_FORMAT_R8G8_SRGB = 22,
  VK_FORMAT_R8G8B8_UNORM = 23,
  VK_FORMAT_R8G8B8_SNORM = 24,
  VK_FORMAT_R8G8B8_USCALED = 25,
  VK_FORMAT_R8G8B8_SSCALED = 26,
  VK_FORMAT_R8G8B8_UINT = 27,
  VK_FORMAT_R8G8B8_SINT = 28,
  VK_FORMAT_R8G8B8_SRGB = 29,
  VK_FORMAT_B8G8R8_UNORM = 30,
  VK_FORMAT_B8G8R8_SNORM = 31,
  VK_FORMAT_B8G8R8_USCALED = 32,
  VK_FORMAT_B8G8R8_SSCALED = 33,
  VK_FORMAT_B8G8R8_UINT = 34,
  VK_FORMAT_B8G8R8_SINT = 35,
  VK_FORMAT_B8G8R8_SRGB = 36,
  VK_FORMAT_R8G8B8A8_UNORM = 37,
  VK_FORMAT_R8G8B8A8_SNORM = 38,
  VK_FORMAT_R8G8B8A8_USCALED = 39,
  VK_FORMAT_R8G8B8A8_SSCALED = 40,
  VK_FORMAT_R8G8B8A8_UINT = 41,
  VK_FORMAT_R8G8B8A8_SINT = 42,
  VK_FORMAT_R8G8B8A8_SRGB = 43,
  VK_FORMAT_B8G8R8A8_UNORM = 44,
  VK_FORMAT_B8G8R8A8_SNORM = 45,
  VK_FORMAT_B8G8R8A8_USCALED = 46,
  VK_FORMAT_B8G8R8A8_SSCALED = 47,
  VK_FORMAT_B8G8R8A8_UINT = 48,
  VK_FORMAT_B8G8R8A8_SINT = 49,
  VK_FORMAT_B8G8R8A8_SRGB = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
  VK_FORMAT_R16_UNORM = 70,
  VK_FORMAT_R16_SNORM = 71,
  VK_FORMAT_R16_USCALED = 72,
  VK_FORMAT_R16_SSCALED = 73,
  VK_FORMAT_R16_UINT = 74,
  VK_FORMAT_R16_SINT = 75,
  VK_FORMAT_R16_SFLOAT = 76,
  VK_FORMAT_R16G16_UNORM = 77,
  VK_FORMAT_R16G16_SNORM = 78,
  VK_FORMAT_R16G16_USCALED = 79,
  VK_FORMAT_R16G16_SSCALED = 80,
  VK_FORMAT_R16G16_UINT = 81,
  VK_FORMAT_R16G16_SINT = 82,
  VK_FORMAT_R16G16_SFLOAT = 83,
  VK_FORMAT_R16G16B16_UNORM = 84,
  VK_FORMAT_R16G16B16_SNORM = 85,
  VK_FORMAT_R16G16B16_USCALED = 86,
  VK_FORMAT_R16G16B16_SSCALED = 87,
  VK_FORMAT_R16G16B16_UINT = 88,
  VK_FORMAT_R16G16B16_SINT = 89,
  VK_FORMAT_R16G16B16_SFLOAT = 90,
  VK_FORMAT_R16G16B16A16_UNORM = 91,
  VK_FORMAT_R16G16B16A16_SNORM = 92,
  VK_FORMAT_R16G16B16A16_USCALED = 93,
  VK_FORMAT_R16G16B16A16_SSCALED = 94,
  VK_FORMAT_R16G16B16A16_UINT = 95,
  VK_FORMAT_R16G16B16A16_SINT = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT = 97,
  VK_FORMAT_R32_UINT = 98,
  VK_FORMAT_R32_SINT = 99,
  VK_FORMAT_R32_SFLOAT = 100,
  VK_FORMAT_R32G32_UINT = 101,
  VK_FORMAT_R32G32_SINT = 102,
  VK_FORMAT_R32G32_SFLOAT = 103,
  VK_FORMAT_R32G32B32_UINT = 104,
  VK_FORMAT_R32G32B32_SINT = 105,
  VK_FORMAT_R32G32B32_SFLOAT = 106,
  VK_FORMAT_R32G32B32A32_UINT = 107,
  VK_FORMAT_R32G32B32A32_SINT = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT = 109,
  VK_FORMAT_R64_UINT = 110,
  VK_FORMAT_R64_SINT = 111,
  VK_FORMAT_R64_SFLOAT = 112,
  VK_FORMAT_R64G64_UINT = 113,
  VK_FORMAT_R64G64_SINT = 114,
  VK_FORMAT_R64G64_SFLOAT = 115,
  VK_FORMAT_R64G64B64_UINT = 116,
  VK_FORMAT_R64G64B64_SINT = 117,
  VK_FORMAT_R64G64B64_SFLOAT = 118,
  VK_FORMAT_R64G64B64A64_UINT = 119,
  VK_FORMAT_R64G64B64A64_SINT = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
  VK_FORMAT_D16_UNORM = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
  VK_FORMAT_D32_SFLOAT = 126,
  VK_FORMAT_S8_UINT = 127,
  VK_FORMAT_D16_UNORM_S8_UINT = 128,
  VK_FORMAT_D24_UNORM_S8_UINT = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
  VK_FORMAT_BC2_UNORM_BLOCK = 135,
  VK_FORMAT_BC2_SRGB_BLOCK = 136,
  VK_FORMAT_BC3_UNORM_BLOCK = 137,
  VK_FORMAT_BC3_SRGB_BLOCK = 138,
  VK_FORMAT_BC4_UNORM_BLOCK = 139,
  VK_FORMAT_BC4_SNORM_BLOCK = 140,
  VK_FORMAT_BC5_UNORM_BLOCK = 141,
  VK_FORMAT_BC5_SNORM_BLOCK = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
  VK_FORMAT_BC7_UNORM_BLOCK = 145,
  VK_FORMAT_BC7_SRGB_BLOCK = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
  VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
  VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
  VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
  VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
  VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
  VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
  VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
  VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
  VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
  VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
  VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
  VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
  VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
  VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
  VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
  VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
  VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
  VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
  VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
  VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
  VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
  VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
  VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
  VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
  VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
  VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
  VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
  VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
  VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
  VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
  VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
  VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
  VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
  VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
  VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
  VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
  VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
  VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
  VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
  VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
  VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
  VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
  VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
  VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
  VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
  VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
  VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
  VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
  VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
  VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
  VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
  VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
  VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
  VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
  VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
  VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
  VK_FORMAT_G8B8G8R8_422_UNORM_KHR = 1000156000,
  VK_FORMAT_B8G8R8G8_422_UNORM_KHR = 1000156001,
  VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002,
  VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003,
  VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004,
  VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005,
  VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006,
  VK_FORMAT_R10X6_UNORM_PACK16_KHR = 1000156007,
  VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = 1000156008,
  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009,
  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010,
  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016,
  VK_FORMAT_R12X4_UNORM_PACK16_KHR = 1000156017,
  VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = 1000156018,
  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019,
  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020,
  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026,
  VK_FORMAT_G16B16G16R16_422_UNORM_KHR = 1000156027,
  VK_FORMAT_B16G16R16G16_422_UNORM_KHR = 1000156028,
  VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029,
  VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030,
  VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031,
  VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032,
  VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033,
  VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT = 1000288000,
  VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT = 1000288001,
  VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT = 1000288002,
  VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT = 1000288003,
  VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT = 1000288004,
  VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT = 1000288005,
  VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT = 1000288006,
  VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT = 1000288007,
  VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT = 1000288008,
  VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT = 1000288009,
  VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT = 1000288010,
  VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT = 1000288011,
  VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT = 1000288012,
  VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT = 1000288013,
  VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT = 1000288014,
  VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT = 1000288015,
  VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT = 1000288016,
  VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT = 1000288017,
  VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT = 1000288018,
  VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT = 1000288019,
  VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT = 1000288020,
  VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT = 1000288021,
  VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT = 1000288022,
  VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT = 1000288023,
  VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT = 1000288024,
  VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT = 1000288025,
  VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT = 1000288026,
  VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT = 1000288027,
  VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT = 1000288028,
  VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT = 1000288029,
  VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002,
  VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003,
  VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
  VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001,
  VK_FORMAT_R16G16_S10_5_NV = 1000464000,
}

/** Structure type enumerant */
export enum VkStructureType {
  VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
  /** Reserved for internal use by the loader, layers, and ICDs */
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
  /** Reserved for internal use by the loader, layers, and ICDs */
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
  VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
  VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
  VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
  VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
  VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
  VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
  VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
  VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
  VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
  VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
  VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
  VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
  VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
  VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
  VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
  VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
  VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
  VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
  VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
  VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
  VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
  VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
  VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
  VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
  VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
  VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
  VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
  VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
  VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
  VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
  VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
  VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
  VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
  VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
  VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
  VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
  VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
  VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
  VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
  VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,
  VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID = 1000010001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID = 1000010002,
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
  /** Backwards-compatible alias containing a typo */
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
  VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
  VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
  VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
  VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
  VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
  VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
  VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
  VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
  VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
  VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
  VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
  VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
  VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT = 1000038003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038004,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT = 1000038005,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000038006,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT = 1000038007,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038008,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038009,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT = 1000038010,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT = 1000039003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039004,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT = 1000039005,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000039006,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT = 1000039007,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT = 1000039008,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039009,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039010,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT = 1000040000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT = 1000040001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_EXT = 1000040003,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000040004,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000040005,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT = 1000040006,
  VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
  VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = 1000044000,
  VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = 1000044001,
  VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = 1000044002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 1000044003,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 1000044004,
  VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
  VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
  VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
  VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = 1000044008,
  VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
  VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014,
  VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
  VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
  VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
  VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
  VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
  VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
  VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
  VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
  VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
  VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
  /** Backwards-compatible alias containing a typo */
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = 1000090000,
  VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
  VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
  VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
  VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
  VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
  VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
  VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002,
  VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
  VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
  VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
  VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
  VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
  VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
  VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
  VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
  VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
  VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
  VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
  VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = 1000120000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
  VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
  VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
  VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
  VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
  VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
  VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
  VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
  VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
  VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
  VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
  VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 1000146003,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
  VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
  VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
  VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
  VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
  VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
  VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
  VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
  VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
  VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
  VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
  VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
  VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
  VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
  VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
  VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT = 1000187000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000187001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000187002,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_EXT = 1000187003,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT = 1000187004,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT = 1000187005,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
  VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
  VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
  VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001,
  VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002,
  VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 1000207003,
  VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 1000207004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 1000207005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
  /** Backwards-compatible alias containing a typo */
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
  VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
  VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
  VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
  VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
  VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
  VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
  VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
  VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000,
  VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
  VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
  VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
  VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
  VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000,
  VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
  VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
  VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
  VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = 1000244001,
  VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 1000257002,
  VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
  /** Not promoted to 1.3 */
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
  VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
  VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 1000280000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 1000280001,
  /** Not promoted to 1.3 */
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
  VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
  VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
  VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
  VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
  VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000,
  VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001,
  VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
  VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
  VK_STRUCTURE_TYPE_RESERVED_QCOM = 1000309000,
  VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
  VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
  VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
  VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
  VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
  VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
  VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
  VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
  VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
  VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
  VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
  VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002,
  VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003,
  VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
  VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
  VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
  VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
  VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
  VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
  VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
  VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
  VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
  VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
  VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000,
  VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001,
  VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003,
  VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004,
  VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005,
  VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006,
  VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007,
  VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008,
  VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009,
  VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
  VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
  VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = 1000338002,
  VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = 1000338003,
  VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
  VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
  VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 1000342000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
  VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000,
  VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
  VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
  VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
  VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = 1000360000,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
  VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
  VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
  VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
  VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
  VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
  VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
  VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
  VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
  VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = 1000269001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
  VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
  VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
  /** Not promoted to 1.3 */
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
  VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 1000388000,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 1000388001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
  VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
  VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
  VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
  VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
  VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
  VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
  VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 1000413000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 1000413001,
  VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 1000413002,
  VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 1000413003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
  VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
  VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
  VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
  VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
  VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
  VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
}

export enum VkSubpassContents {
  VK_SUBPASS_CONTENTS_INLINE = 0,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
}

/** API result codes */
export enum VkResult {
  /** Command completed successfully */
  VK_SUCCESS = 0,
  /** A fence or query has not yet completed */
  VK_NOT_READY = 1,
  /** A wait operation has not completed in the specified time */
  VK_TIMEOUT = 2,
  /** An event is signaled */
  VK_EVENT_SET = 3,
  /** An event is unsignaled */
  VK_EVENT_RESET = 4,
  /** A return array was too small for the result */
  VK_INCOMPLETE = 5,
  /** A host memory allocation has failed */
  VK_ERROR_OUT_OF_HOST_MEMORY = -1,
  /** A device memory allocation has failed */
  VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
  /** Initialization of an object has failed */
  VK_ERROR_INITIALIZATION_FAILED = -3,
  /** The logical device has been lost. See <<devsandqueues-lost-device>> */
  VK_ERROR_DEVICE_LOST = -4,
  /** Mapping of a memory object has failed */
  VK_ERROR_MEMORY_MAP_FAILED = -5,
  /** Layer specified does not exist */
  VK_ERROR_LAYER_NOT_PRESENT = -6,
  /** Extension specified does not exist */
  VK_ERROR_EXTENSION_NOT_PRESENT = -7,
  /** Requested feature is not available on this device */
  VK_ERROR_FEATURE_NOT_PRESENT = -8,
  /** Unable to find a Vulkan driver */
  VK_ERROR_INCOMPATIBLE_DRIVER = -9,
  /** Too many objects of the type have already been created */
  VK_ERROR_TOO_MANY_OBJECTS = -10,
  /** Requested format is not supported on this device */
  VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
  /** A requested pool allocation has failed due to fragmentation of the pool's memory */
  VK_ERROR_FRAGMENTED_POOL = -12,
  /** An unknown error has occurred, due to an implementation or application bug */
  VK_ERROR_UNKNOWN = -13,
  VK_ERROR_OUT_OF_POOL_MEMORY = 1000069000,
  VK_ERROR_INVALID_EXTERNAL_HANDLE = 1000072003,
  VK_ERROR_FRAGMENTATION = 1000161000,
  VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = 1000257000,
  VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
  VK_ERROR_SURFACE_LOST_KHR = 1000000000,
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = 1000000001,
  VK_SUBOPTIMAL_KHR = 1000001003,
  VK_ERROR_OUT_OF_DATE_KHR = 1000001004,
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = 1000003001,
  VK_ERROR_VALIDATION_FAILED_EXT = 1000011001,
  VK_ERROR_INVALID_SHADER_NV = 1000012000,
  VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = 1000023000,
  VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = 1000023001,
  VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = 1000023002,
  VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = 1000023003,
  VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = 1000023004,
  VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = 1000023005,
  VK_ERROR_OUT_OF_POOL_MEMORY_KHR = 1000069000,
  VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = 1000072003,
  VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = 1000158000,
  VK_ERROR_FRAGMENTATION_EXT = 1000161000,
  VK_ERROR_NOT_PERMITTED_EXT = 1000174001,
  VK_ERROR_NOT_PERMITTED_KHR = 1000174001,
  VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = 1000257000,
  VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = 1000255000,
  VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = 1000257000,
  VK_THREAD_IDLE_KHR = 1000268000,
  VK_THREAD_DONE_KHR = 1000268001,
  VK_OPERATION_DEFERRED_KHR = 1000268002,
  VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
  VK_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
  VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
  VK_ERROR_COMPRESSION_EXHAUSTED_EXT = 1000338000,
}

export enum VkDynamicState {
  VK_DYNAMIC_STATE_VIEWPORT = 0,
  VK_DYNAMIC_STATE_SCISSOR = 1,
  VK_DYNAMIC_STATE_LINE_WIDTH = 2,
  VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
  VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
  VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
  VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
  VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
  VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
  VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
  VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
  VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
  VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
  VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
  VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
  VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
  VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
  VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
  VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
  VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
  VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
  VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
  VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
  VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
  VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
  VK_DYNAMIC_STATE_CULL_MODE_EXT = 1000267000,
  VK_DYNAMIC_STATE_FRONT_FACE_EXT = 1000267001,
  VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 1000267002,
  VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 1000267003,
  VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 1000267004,
  VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005,
  VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 1000267006,
  VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 1000267007,
  VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 1000267008,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009,
  VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 1000267010,
  VK_DYNAMIC_STATE_STENCIL_OP_EXT = 1000267011,
  VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
  /** Not promoted to 1.3 */
  VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
  VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = 1000377001,
  VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = 1000377002,
  /** Not promoted to 1.3 */
  VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
  VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = 1000377004,
  VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
  VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
  VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
  VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
  VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
  VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
  VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
  VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
  VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
  VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
  VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
  VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
  VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
  VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
  VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
  VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
  VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
  VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
  VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
  VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
  VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
  VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
  VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
  VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
  VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
  VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
  VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
  VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
}

export enum VkDescriptorUpdateTemplateType {
  /** Create descriptor update template for descriptor set updates */
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
  /** Create descriptor update template for pushed descriptor updates */
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0,
}

/** Enums to track objects of various types - also see objtypeenum attributes on type tags */
export enum VkObjectType {
  VK_OBJECT_TYPE_UNKNOWN = 0,
  VK_OBJECT_TYPE_INSTANCE = 1,
  VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
  VK_OBJECT_TYPE_DEVICE = 3,
  VK_OBJECT_TYPE_QUEUE = 4,
  VK_OBJECT_TYPE_SEMAPHORE = 5,
  VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
  VK_OBJECT_TYPE_FENCE = 7,
  VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
  VK_OBJECT_TYPE_BUFFER = 9,
  VK_OBJECT_TYPE_IMAGE = 10,
  VK_OBJECT_TYPE_EVENT = 11,
  VK_OBJECT_TYPE_QUERY_POOL = 12,
  VK_OBJECT_TYPE_BUFFER_VIEW = 13,
  VK_OBJECT_TYPE_IMAGE_VIEW = 14,
  VK_OBJECT_TYPE_SHADER_MODULE = 15,
  VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
  VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
  VK_OBJECT_TYPE_RENDER_PASS = 18,
  VK_OBJECT_TYPE_PIPELINE = 19,
  VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
  VK_OBJECT_TYPE_SAMPLER = 21,
  VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
  VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
  VK_OBJECT_TYPE_FRAMEBUFFER = 24,
  VK_OBJECT_TYPE_COMMAND_POOL = 25,
  VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
  VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
  VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
  VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
  VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
  VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
  VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
  VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
  /** VkVideoSessionKHR */
  VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
  /** VkVideoSessionParametersKHR */
  VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
  VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
  VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
  VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
  VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
  VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
  VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
  VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
  VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = 1000295000,
  /** VkBufferCollectionFUCHSIA */
  VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
  VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
  VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
}

export enum VkRayTracingInvocationReorderModeNV {
  VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
  VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
}

export enum VkQueueFlagBits {
  /** Queue supports graphics operations */
  VK_QUEUE_GRAPHICS_BIT = 1 << 0,
  /** Queue supports compute operations */
  VK_QUEUE_COMPUTE_BIT = 1 << 1,
  /** Queue supports transfer operations */
  VK_QUEUE_TRANSFER_BIT = 1 << 2,
  /** Queue supports sparse resource memory management operations */
  VK_QUEUE_SPARSE_BINDING_BIT = 1 << 3,
  /** Queues may support protected operations */
  VK_QUEUE_PROTECTED_BIT = 1 << 4,
  VK_QUEUE_VIDEO_DECODE_BIT_KHR = 1 << 5,
  VK_QUEUE_RESERVED_9_BIT_EXT = 1 << 9,
  VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 1 << 6,
  VK_QUEUE_RESERVED_7_BIT_QCOM = 1 << 7,
  VK_QUEUE_OPTICAL_FLOW_BIT_NV = 1 << 8,
}

export enum VkCullModeFlagBits {
  VK_CULL_MODE_NONE = 0,
  VK_CULL_MODE_FRONT_BIT = 1 << 0,
  VK_CULL_MODE_BACK_BIT = 1 << 1,
  VK_CULL_MODE_FRONT_AND_BACK = 3,
}

export enum VkRenderPassCreateFlagBits {
  VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR = 1 << 0,
  VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 1 << 1,
}

export enum VkDeviceQueueCreateFlagBits {
  /** Queue is a protected-capable device queue */
  VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 1 << 0,
  VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM = 1 << 1,
}

export enum VkMemoryPropertyFlagBits {
  /** If otherwise stated, then allocate memory on device */
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1 << 0,
  /** Memory is mappable by host */
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 1 << 1,
  /** Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache */
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 1 << 2,
  /** Memory will be cached by the host */
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 1 << 3,
  /** Memory may be allocated by the driver when it is required */
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 1 << 4,
  /** Memory is protected */
  VK_MEMORY_PROPERTY_PROTECTED_BIT = 1 << 5,
  VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 1 << 6,
  VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 1 << 7,
  VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 1 << 8,
}

export enum VkMemoryHeapFlagBits {
  /** If set, heap represents device memory */
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1 << 0,
  /** If set, heap allocations allocate multiple instances by default */
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 1 << 1,
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = 1 << 1,
  VK_MEMORY_HEAP_RESERVED_2_BIT_KHR = 1 << 2,
}

export enum VkAccessFlagBits {
  /** Controls coherency of indirect command reads */
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1 << 0,
  /** Controls coherency of index reads */
  VK_ACCESS_INDEX_READ_BIT = 1 << 1,
  /** Controls coherency of vertex attribute reads */
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 1 << 2,
  /** Controls coherency of uniform buffer reads */
  VK_ACCESS_UNIFORM_READ_BIT = 1 << 3,
  /** Controls coherency of input attachment reads */
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 1 << 4,
  /** Controls coherency of shader reads */
  VK_ACCESS_SHADER_READ_BIT = 1 << 5,
  /** Controls coherency of shader writes */
  VK_ACCESS_SHADER_WRITE_BIT = 1 << 6,
  /** Controls coherency of color attachment reads */
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 1 << 7,
  /** Controls coherency of color attachment writes */
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 1 << 8,
  /** Controls coherency of depth/stencil attachment reads */
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 1 << 9,
  /** Controls coherency of depth/stencil attachment writes */
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1 << 10,
  /** Controls coherency of transfer reads */
  VK_ACCESS_TRANSFER_READ_BIT = 1 << 11,
  /** Controls coherency of transfer writes */
  VK_ACCESS_TRANSFER_WRITE_BIT = 1 << 12,
  /** Controls coherency of host reads */
  VK_ACCESS_HOST_READ_BIT = 1 << 13,
  /** Controls coherency of host writes */
  VK_ACCESS_HOST_WRITE_BIT = 1 << 14,
  /** Controls coherency of memory reads */
  VK_ACCESS_MEMORY_READ_BIT = 1 << 15,
  /** Controls coherency of memory writes */
  VK_ACCESS_MEMORY_WRITE_BIT = 1 << 16,
  VK_ACCESS_NONE = 0,
  VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 1 << 25,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 1 << 26,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 1 << 27,
  /** read access flag for reading conditional rendering predicate */
  VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1 << 20,
  VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 1 << 19,
  VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 1 << 21,
  VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 1 << 22,
  VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 1 << 23,
  VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 1 << 21,
  VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 1 << 22,
  VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 1 << 24,
  VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 1 << 23,
  VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 1 << 17,
  VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 1 << 18,
  VK_ACCESS_NONE_KHR = 0,
}

export enum VkBufferUsageFlagBits {
  /** Can be used as a source of transfer operations */
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1 << 0,
  /** Can be used as a destination of transfer operations */
  VK_BUFFER_USAGE_TRANSFER_DST_BIT = 1 << 1,
  /** Can be used as TBO */
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 1 << 2,
  /** Can be used as IBO */
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 1 << 3,
  /** Can be used as UBO */
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 1 << 4,
  /** Can be used as SSBO */
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 1 << 5,
  /** Can be used as source of fixed-function index fetch (index buffer) */
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 1 << 6,
  /** Can be used as source of fixed-function vertex fetch (VBO) */
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 1 << 7,
  /** Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer) */
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 1 << 8,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 1 << 17,
  VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 1 << 13,
  VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 1 << 14,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 1 << 11,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 1 << 12,
  /** Specifies the buffer can be used as predicate in conditional rendering */
  VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 << 9,
  VK_BUFFER_USAGE_RESERVED_25_BIT_AMD = 1 << 25,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 1 << 19,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 1 << 20,
  VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 1 << 10,
  VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 1 << 10,
  VK_BUFFER_USAGE_RESERVED_18_BIT_QCOM = 1 << 18,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 1 << 17,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = 1 << 17,
  VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 1 << 15,
  VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 1 << 16,
  VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 21,
  VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 22,
  VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 26,
  VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 1 << 23,
  VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 1 << 24,
}

export enum VkBufferCreateFlagBits {
  /** Buffer should support sparse backing */
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1 << 0,
  /** Buffer should support sparse backing with partial residency */
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 1 << 1,
  /** Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers */
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 1 << 2,
  /** Buffer requires protected memory */
  VK_BUFFER_CREATE_PROTECTED_BIT = 1 << 3,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 1 << 4,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1 << 4,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 4,
  VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 5,
}

export enum VkShaderStageFlagBits {
  VK_SHADER_STAGE_VERTEX_BIT = 1 << 0,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 1 << 1,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 1 << 2,
  VK_SHADER_STAGE_GEOMETRY_BIT = 1 << 3,
  VK_SHADER_STAGE_FRAGMENT_BIT = 1 << 4,
  VK_SHADER_STAGE_COMPUTE_BIT = 1 << 5,
  VK_SHADER_STAGE_ALL_GRAPHICS = 31,
  VK_SHADER_STAGE_ALL = 2147483647,
  VK_SHADER_STAGE_RAYGEN_BIT_KHR = 1 << 8,
  VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 1 << 9,
  VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 1 << 10,
  VK_SHADER_STAGE_MISS_BIT_KHR = 1 << 11,
  VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 1 << 12,
  VK_SHADER_STAGE_CALLABLE_BIT_KHR = 1 << 13,
  VK_SHADER_STAGE_RAYGEN_BIT_NV = 1 << 8,
  VK_SHADER_STAGE_ANY_HIT_BIT_NV = 1 << 9,
  VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 1 << 10,
  VK_SHADER_STAGE_MISS_BIT_NV = 1 << 11,
  VK_SHADER_STAGE_INTERSECTION_BIT_NV = 1 << 12,
  VK_SHADER_STAGE_CALLABLE_BIT_NV = 1 << 13,
  VK_SHADER_STAGE_TASK_BIT_NV = 1 << 6,
  VK_SHADER_STAGE_MESH_BIT_NV = 1 << 7,
  VK_SHADER_STAGE_TASK_BIT_EXT = 1 << 6,
  VK_SHADER_STAGE_MESH_BIT_EXT = 1 << 7,
  VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 1 << 14,
  VK_SHADER_STAGE_RESERVED_19_BIT_HUAWEI = 1 << 19,
  VK_SHADER_STAGE_EXT_483_RESERVE_15 = 1 << 15,
  VK_SHADER_STAGE_EXT_483_RESERVE_16 = 1 << 16,
  VK_SHADER_STAGE_EXT_483_RESERVE_17 = 1 << 17,
}

export enum VkImageUsageFlagBits {
  /** Can be used as a source of transfer operations */
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1 << 0,
  /** Can be used as a destination of transfer operations */
  VK_IMAGE_USAGE_TRANSFER_DST_BIT = 1 << 1,
  /** Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types) */
  VK_IMAGE_USAGE_SAMPLED_BIT = 1 << 2,
  /** Can be used as storage image (STORAGE_IMAGE descriptor type) */
  VK_IMAGE_USAGE_STORAGE_BIT = 1 << 3,
  /** Can be used as framebuffer color attachment */
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 1 << 4,
  /** Can be used as framebuffer depth/stencil attachment */
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 5,
  /** Image data not needed outside of rendering */
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 1 << 6,
  /** Can be used as framebuffer input attachment */
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 1 << 7,
  VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 1 << 10,
  VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 1 << 11,
  VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 1 << 12,
  VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 1 << 8,
  VK_IMAGE_USAGE_RESERVED_16_BIT_QCOM = 1 << 16,
  VK_IMAGE_USAGE_RESERVED_17_BIT_QCOM = 1 << 17,
  VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 9,
  VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 8,
  VK_IMAGE_USAGE_RESERVED_22_BIT_EXT = 1 << 22,
  VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 1 << 13,
  VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 1 << 14,
  VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 15,
  VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 19,
  VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 1 << 18,
  VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 1 << 20,
  VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 1 << 21,
}

export enum VkImageCreateFlagBits {
  /** Image should support sparse backing */
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1 << 0,
  /** Image should support sparse backing with partial residency */
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 1 << 1,
  /** Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images */
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 1 << 2,
  /** Allows image views to have different format than the base image */
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 1 << 3,
  /** Allows creating image views with cube type from the created image */
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 1 << 4,
  VK_IMAGE_CREATE_ALIAS_BIT = 1 << 10,
  /** Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image */
  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 1 << 6,
  /** The 3D image can be viewed as a 2D or 2D array image */
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 1 << 5,
  VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 1 << 7,
  VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 1 << 8,
  /** Image requires protected memory */
  VK_IMAGE_CREATE_PROTECTED_BIT = 1 << 11,
  VK_IMAGE_CREATE_DISJOINT_BIT = 1 << 9,
  VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 1 << 13,
  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1 << 6,
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 1 << 5,
  VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 1 << 7,
  VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = 1 << 8,
  VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 1 << 12,
  VK_IMAGE_CREATE_DISJOINT_BIT_KHR = 1 << 9,
  VK_IMAGE_CREATE_ALIAS_BIT_KHR = 1 << 10,
  VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 1 << 14,
  VK_IMAGE_CREATE_RESERVED_19_BIT_EXT = 1 << 19,
  VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 16,
  VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 1 << 18,
  /** Image is created with a layout where individual slices are capable of being used as 2D images */
  VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 1 << 17,
  VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 1 << 15,
}

export enum VkImageViewCreateFlagBits {
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1 << 0,
  VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 2,
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 1 << 1,
  VK_IMAGE_VIEW_CREATE_RESERVED_3_BIT_EXT = 1 << 3,
}

export enum VkSamplerCreateFlagBits {
  VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 1 << 0,
  VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 1 << 1,
  VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 3,
  VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 1 << 2,
  VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 1 << 4,
}

/** Note that the gap at bitpos 10 is unused, and can be reserved */
export enum VkPipelineCreateFlagBits {
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1 << 0,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 1 << 1,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT = 1 << 2,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 1 << 3,
  VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 1 << 4,
  VK_PIPELINE_CREATE_DISPATCH_BASE = 1 << 4,
  VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 1 << 8,
  VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 1 << 9,
  VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 21,
  /** Backwards-compatible alias containing a typo */
  VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 21,
  VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 1 << 22,
  /** Backwards-compatible alias containing a typo */
  VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 1 << 22,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 1 << 3,
  VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 1 << 14,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 1 << 15,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 1 << 16,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 1 << 17,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 1 << 12,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 1 << 13,
  VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 1 << 19,
  VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 1 << 5,
  VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 1 << 6,
  VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 1 << 7,
  VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 1 << 18,
  VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 1 << 11,
  VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 1 << 8,
  VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = 1 << 9,
  VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 29,
  VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 1 << 23,
  VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 1 << 10,
  VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 1 << 20,
  VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 25,
  VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 26,
  VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 1 << 24,
  VK_PIPELINE_CREATE_RESERVED_BIT_28_NV = 1 << 28,
  VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 1 << 27,
  VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 1 << 30,
}

export enum VkPipelineShaderStageCreateFlagBits {
  VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 1 << 0,
  VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 1 << 1,
  VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 1 << 0,
  VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 1 << 1,
  VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR = 1 << 3,
}

export enum VkColorComponentFlagBits {
  VK_COLOR_COMPONENT_R_BIT = 1 << 0,
  VK_COLOR_COMPONENT_G_BIT = 1 << 1,
  VK_COLOR_COMPONENT_B_BIT = 1 << 2,
  VK_COLOR_COMPONENT_A_BIT = 1 << 3,
}

export enum VkFenceCreateFlagBits {
  VK_FENCE_CREATE_SIGNALED_BIT = 1 << 0,
}

export enum VkSemaphoreCreateFlagBits {
}

export enum VkFormatFeatureFlagBits {
  /** Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types) */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1 << 0,
  /** Format can be used for storage images (STORAGE_IMAGE descriptor type) */
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 1 << 1,
  /** Format supports atomic operations in case it is used for storage images */
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 1 << 2,
  /** Format can be used for uniform texel buffers (TBOs) */
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 1 << 3,
  /** Format can be used for storage texel buffers (IBOs) */
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 1 << 4,
  /** Format supports atomic operations in case it is used for storage texel buffers */
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 1 << 5,
  /** Format can be used for vertex buffers (VBOs) */
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 1 << 6,
  /** Format can be used for color attachment images */
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 1 << 7,
  /** Format supports blending in case it is used for color attachment images */
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 1 << 8,
  /** Format can be used for depth/stencil attachment images */
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 9,
  /** Format can be used as the source image of blits with vkCmdBlitImage */
  VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1 << 10,
  /** Format can be used as the destination image of blits with vkCmdBlitImage */
  VK_FORMAT_FEATURE_BLIT_DST_BIT = 1 << 11,
  /** Format can be filtered with VK_FILTER_LINEAR when being sampled */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 1 << 12,
  /** Format can be used as the source image of image transfer commands */
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 1 << 14,
  /** Format can be used as the destination image of image transfer commands */
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 1 << 15,
  /** Format can have midpoint rather than cosited chroma samples */
  VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 1 << 17,
  /** Format can be used with linear filtering whilst color conversion is enabled */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 1 << 18,
  /** Format can have different chroma, min and mag filters */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 1 << 19,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1 << 20,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 1 << 21,
  /** Format supports disjoint planes */
  VK_FORMAT_FEATURE_DISJOINT_BIT = 1 << 22,
  /** Format can have cosited rather than midpoint chroma samples */
  VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 1 << 23,
  /** Format can be used with min/max reduction filtering */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 1 << 16,
  /** Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled */
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 1 << 13,
  VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 1 << 25,
  VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 1 << 26,
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 1 << 14,
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 1 << 15,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 1 << 16,
  VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 1 << 29,
  VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 1 << 17,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 1 << 18,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 1 << 19,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1 << 20,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 1 << 21,
  VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = 1 << 22,
  VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = 1 << 23,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 1 << 13,
  VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 24,
  VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 30,
  VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 1 << 27,
  VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 28,
}

export enum VkQueryControlFlagBits {
  /** Require precise results to be collected by the query */
  VK_QUERY_CONTROL_PRECISE_BIT = 1 << 0,
}

export enum VkQueryResultFlagBits {
  /** Results of the queries are written to the destination buffer as 64-bit values */
  VK_QUERY_RESULT_64_BIT = 1 << 0,
  /** Results of the queries are waited on before proceeding with the result copy */
  VK_QUERY_RESULT_WAIT_BIT = 1 << 1,
  /** Besides the results of the query, the availability of the results is also written */
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 1 << 2,
  /** Copy the partial results of the query even if the final results are not available */
  VK_QUERY_RESULT_PARTIAL_BIT = 1 << 3,
  VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 1 << 4,
}

export enum VkCommandBufferUsageFlagBits {
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1 << 0,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 1 << 1,
  /** Command buffer may be submitted/executed more than once simultaneously */
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 1 << 2,
}

export enum VkQueryPipelineStatisticFlagBits {
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1 << 0,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 1 << 1,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 1 << 2,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 1 << 3,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 1 << 4,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 1 << 5,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 1 << 6,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 1 << 7,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 1 << 8,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 1 << 9,
  /** Optional */
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1 << 10,
  VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 1 << 11,
  VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 1 << 12,
}

export enum VkImageAspectFlagBits {
  VK_IMAGE_ASPECT_COLOR_BIT = 1 << 0,
  VK_IMAGE_ASPECT_DEPTH_BIT = 1 << 1,
  VK_IMAGE_ASPECT_STENCIL_BIT = 1 << 2,
  VK_IMAGE_ASPECT_METADATA_BIT = 1 << 3,
  VK_IMAGE_ASPECT_PLANE_0_BIT = 1 << 4,
  VK_IMAGE_ASPECT_PLANE_1_BIT = 1 << 5,
  VK_IMAGE_ASPECT_PLANE_2_BIT = 1 << 6,
  VK_IMAGE_ASPECT_NONE = 0,
  VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = 1 << 4,
  VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = 1 << 5,
  VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = 1 << 6,
  VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 1 << 7,
  VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 1 << 8,
  VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 1 << 9,
  VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 1 << 10,
  VK_IMAGE_ASPECT_NONE_KHR = 0,
}

export enum VkSparseImageFormatFlagBits {
  /** Image uses a single mip tail region for all array layers */
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1 << 0,
  /** Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels. */
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 1 << 1,
  /** Image uses a non-standard sparse image block dimensions */
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 1 << 2,
}

export enum VkSparseMemoryBindFlagBits {
  /** Operation binds resource metadata to memory */
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1 << 0,
}

export enum VkPipelineStageFlagBits {
  /** Before subsequent commands are processed */
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1 << 0,
  /** Draw/DispatchIndirect command fetch */
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 1 << 1,
  /** Vertex/index fetch */
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 1 << 2,
  /** Vertex shading */
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 1 << 3,
  /** Tessellation control shading */
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 1 << 4,
  /** Tessellation evaluation shading */
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 1 << 5,
  /** Geometry shading */
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 1 << 6,
  /** Fragment shading */
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 1 << 7,
  /** Early fragment (depth and stencil) tests */
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 1 << 8,
  /** Late fragment (depth and stencil) tests */
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 1 << 9,
  /** Color attachment writes */
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1 << 10,
  /** Compute shading */
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 1 << 11,
  /** Transfer/copy operations */
  VK_PIPELINE_STAGE_TRANSFER_BIT = 1 << 12,
  /** After previous commands have completed */
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 1 << 13,
  /** Indicates host (CPU) is a source/sink of the dependency */
  VK_PIPELINE_STAGE_HOST_BIT = 1 << 14,
  /** All stages of the graphics pipeline */
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 1 << 15,
  /** All stages supported on the queue */
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 1 << 16,
  VK_PIPELINE_STAGE_NONE = 0,
  VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 1 << 24,
  /** A pipeline stage for conditional rendering predicate fetch */
  VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 << 18,
  VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 1 << 25,
  VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 1 << 21,
  VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 1 << 22,
  VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 1 << 21,
  VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 1 << 25,
  VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 1 << 19,
  VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 1 << 20,
  VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 1 << 23,
  VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 22,
  VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 1 << 17,
  VK_PIPELINE_STAGE_NONE_KHR = 0,
  VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 1 << 19,
  VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 1 << 20,
}

export enum VkCommandPoolCreateFlagBits {
  /** Command buffers have a short lifetime */
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1 << 0,
  /** Command buffers may release their memory individually */
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 1 << 1,
  /** Command buffers allocated from pool are protected command buffers */
  VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 1 << 2,
}

export enum VkCommandPoolResetFlagBits {
  /** Release resources owned by the pool */
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1 << 0,
  VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI = 1 << 1,
}

export enum VkCommandBufferResetFlagBits {
  /** Release resources owned by the buffer */
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1 << 0,
}

export enum VkSampleCountFlagBits {
  /** Sample count 1 supported */
  VK_SAMPLE_COUNT_1_BIT = 1 << 0,
  /** Sample count 2 supported */
  VK_SAMPLE_COUNT_2_BIT = 1 << 1,
  /** Sample count 4 supported */
  VK_SAMPLE_COUNT_4_BIT = 1 << 2,
  /** Sample count 8 supported */
  VK_SAMPLE_COUNT_8_BIT = 1 << 3,
  /** Sample count 16 supported */
  VK_SAMPLE_COUNT_16_BIT = 1 << 4,
  /** Sample count 32 supported */
  VK_SAMPLE_COUNT_32_BIT = 1 << 5,
  /** Sample count 64 supported */
  VK_SAMPLE_COUNT_64_BIT = 1 << 6,
}

export enum VkAttachmentDescriptionFlagBits {
  /** The attachment may alias physical memory of another attachment in the same render pass */
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1 << 0,
}

export enum VkStencilFaceFlagBits {
  /** Front face */
  VK_STENCIL_FACE_FRONT_BIT = 1 << 0,
  /** Back face */
  VK_STENCIL_FACE_BACK_BIT = 1 << 1,
  /** Front and back faces */
  VK_STENCIL_FACE_FRONT_AND_BACK = 3,
  /** Backwards-compatible alias containing a typo */
  VK_STENCIL_FRONT_AND_BACK = 3,
}

export enum VkDescriptorPoolCreateFlagBits {
  /** Descriptor sets may be freed individually */
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1 << 0,
  VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 1 << 1,
  VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 1 << 1,
  VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 1 << 2,
  VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 1 << 2,
}

export enum VkDependencyFlagBits {
  /** Dependency is per pixel region */
  VK_DEPENDENCY_BY_REGION_BIT = 1 << 0,
  /** Dependency is across devices */
  VK_DEPENDENCY_DEVICE_GROUP_BIT = 1 << 2,
  VK_DEPENDENCY_VIEW_LOCAL_BIT = 1 << 1,
  VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = 1 << 1,
  VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = 1 << 2,
  /** Dependency may be a feedback loop */
  VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 1 << 3,
}

export enum VkSemaphoreType {
  VK_SEMAPHORE_TYPE_BINARY = 0,
  VK_SEMAPHORE_TYPE_TIMELINE = 1,
  VK_SEMAPHORE_TYPE_BINARY_KHR = 0,
  VK_SEMAPHORE_TYPE_TIMELINE_KHR = 1,
}

export enum VkSemaphoreWaitFlagBits {
  VK_SEMAPHORE_WAIT_ANY_BIT = 1 << 0,
  VK_SEMAPHORE_WAIT_ANY_BIT_KHR = 1 << 0,
}

export enum VkPresentModeKHR {
  VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
  VK_PRESENT_MODE_MAILBOX_KHR = 1,
  VK_PRESENT_MODE_FIFO_KHR = 2,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
  VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
  VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
}

export enum VkColorSpaceKHR {
  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
  /** Backwards-compatible alias containing a typo */
  VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
  VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
  VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
  VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
  VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
  VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
  VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
  VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
  VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
  VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
  VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
  VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
  VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
  VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
  VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
  /** Backwards-compatible alias containing a typo */
  VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
  VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
}

export enum VkDisplayPlaneAlphaFlagBitsKHR {
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1 << 0,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 1 << 1,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 1 << 2,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 1 << 3,
}

export enum VkCompositeAlphaFlagBitsKHR {
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1 << 0,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 1 << 1,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 1 << 2,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 1 << 3,
}

export enum VkSurfaceTransformFlagBitsKHR {
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1 << 0,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 1 << 1,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 1 << 2,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 1 << 3,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 1 << 4,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 1 << 5,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 1 << 6,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 1 << 7,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 1 << 8,
}

export enum VkSwapchainImageUsageFlagBitsANDROID {
  VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 1 << 0,
}

export enum VkTimeDomainEXT {
  VK_TIME_DOMAIN_DEVICE_EXT = 0,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
  VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
}

export enum VkDebugReportFlagBitsEXT {
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1 << 0,
  VK_DEBUG_REPORT_WARNING_BIT_EXT = 1 << 1,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 1 << 2,
  VK_DEBUG_REPORT_ERROR_BIT_EXT = 1 << 3,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT = 1 << 4,
}

export enum VkDebugReportObjectTypeEXT {
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
  /** Backwards-compatible alias containing a typo */
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
  /** Backwards-compatible alias containing a typo */
  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = 33,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
  VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
  VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
}

export enum VkDeviceMemoryReportEventTypeEXT {
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
}

export enum VkRasterizationOrderAMD {
  VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
  VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
}

export enum VkExternalMemoryHandleTypeFlagBitsNV {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1 << 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 1 << 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 1 << 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 1 << 3,
}

export enum VkExternalMemoryFeatureFlagBitsNV {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1 << 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 1 << 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 1 << 2,
}

export enum VkValidationCheckEXT {
  VK_VALIDATION_CHECK_ALL_EXT = 0,
  VK_VALIDATION_CHECK_SHADERS_EXT = 1,
}

export enum VkValidationFeatureEnableEXT {
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
  VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
  VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
  VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
}

export enum VkValidationFeatureDisableEXT {
  VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
  VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
  VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
  VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
  VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
  VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
  VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
  VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
}

export enum VkSubgroupFeatureFlagBits {
  /** Basic subgroup operations */
  VK_SUBGROUP_FEATURE_BASIC_BIT = 1 << 0,
  /** Vote subgroup operations */
  VK_SUBGROUP_FEATURE_VOTE_BIT = 1 << 1,
  /** Arithmetic subgroup operations */
  VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 1 << 2,
  /** Ballot subgroup operations */
  VK_SUBGROUP_FEATURE_BALLOT_BIT = 1 << 3,
  /** Shuffle subgroup operations */
  VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 1 << 4,
  /** Shuffle relative subgroup operations */
  VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 1 << 5,
  /** Clustered subgroup operations */
  VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 1 << 6,
  /** Quad subgroup operations */
  VK_SUBGROUP_FEATURE_QUAD_BIT = 1 << 7,
  VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 1 << 8,
}

export enum VkIndirectCommandsLayoutUsageFlagBitsNV {
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 1 << 0,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 1 << 1,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 1 << 2,
}

export enum VkIndirectStateFlagBitsNV {
  VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 1 << 0,
}

export enum VkIndirectCommandsTokenTypeNV {
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
}

export enum VkPrivateDataSlotCreateFlagBits {
}

export enum VkDescriptorSetLayoutCreateFlagBits {
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 1 << 1,
  /** Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR */
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 1 << 0,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 1 << 1,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 4,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 1 << 5,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD = 1 << 3,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 1 << 2,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 1 << 2,
}

export enum VkExternalMemoryHandleTypeFlagBits {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 1 << 3,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 1 << 4,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 1 << 5,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 1 << 6,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 1 << 3,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 1 << 4,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 1 << 5,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 1 << 6,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 1 << 9,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1 << 10,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 1 << 7,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 1 << 8,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 1 << 11,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 1 << 12,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_RESERVED_13_BIT_NV = 1 << 13,
}

export enum VkExternalMemoryFeatureFlagBits {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1 << 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 1 << 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 1 << 2,
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 1 << 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 1 << 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 1 << 2,
}

export enum VkExternalSemaphoreHandleTypeFlagBits {
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 1 << 3,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = 1 << 3,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 1 << 4,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 1 << 3,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 1 << 4,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 1 << 7,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_RESERVED_5_BIT_NV = 1 << 5,
}

export enum VkExternalSemaphoreFeatureFlagBits {
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1 << 0,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 1 << 1,
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 1 << 0,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 1 << 1,
}

export enum VkSemaphoreImportFlagBits {
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1 << 0,
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 1 << 0,
}

export enum VkExternalFenceHandleTypeFlagBits {
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 1 << 3,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 1 << 3,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_4_BIT_NV = 1 << 4,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_5_BIT_NV = 1 << 5,
}

export enum VkExternalFenceFeatureFlagBits {
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1 << 0,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 1 << 1,
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 1 << 0,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 1 << 1,
}

export enum VkFenceImportFlagBits {
  VK_FENCE_IMPORT_TEMPORARY_BIT = 1 << 0,
  VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = 1 << 0,
}

export enum VkSurfaceCounterFlagBitsEXT {
  VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 1 << 0,
  /** Backwards-compatible alias containing a typo */
  VK_SURFACE_COUNTER_VBLANK_EXT = 1 << 0,
}

export enum VkDisplayPowerStateEXT {
  VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
  VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
  VK_DISPLAY_POWER_STATE_ON_EXT = 2,
}

export enum VkDeviceEventTypeEXT {
  VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
}

export enum VkDisplayEventTypeEXT {
  VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
}

export enum VkPeerMemoryFeatureFlagBits {
  /** Can read with vkCmdCopy commands */
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1 << 0,
  /** Can write with vkCmdCopy commands */
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 1 << 1,
  /** Can read with any access type/command */
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 1 << 2,
  /** Can write with and access type/command */
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 1 << 3,
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = 1 << 0,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = 1 << 1,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = 1 << 2,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = 1 << 3,
}

export enum VkMemoryAllocateFlagBits {
  /** Force allocation on specific devices */
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1 << 0,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 1 << 1,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 1 << 2,
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = 1 << 0,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = 1 << 1,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 2,
}

export enum VkDeviceGroupPresentModeFlagBitsKHR {
  /** Present from local memory */
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1 << 0,
  /** Present from remote memory */
  VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 1 << 1,
  /** Present sum of local and/or remote memory */
  VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 1 << 2,
  /** Each physical device presents from local memory */
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 1 << 3,
}

export enum VkSwapchainCreateFlagBitsKHR {
  /** Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT */
  VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1 << 0,
  /** Swapchain is protected */
  VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 1 << 1,
  VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 1 << 2,
  VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT = 1 << 4,
  VK_SWAPCHAIN_CREATE_RESERVED_3_BIT_SEC = 1 << 3,
}

export enum VkViewportCoordinateSwizzleNV {
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
}

export enum VkDiscardRectangleModeEXT {
  VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
  VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}

export enum VkSubpassDescriptionFlagBits {
  VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 1 << 0,
  VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 1 << 1,
  VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 1 << 2,
  VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 1 << 3,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 1 << 4,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 1 << 5,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 1 << 6,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 1 << 4,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 1 << 5,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 1 << 6,
  VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 1 << 7,
}

export enum VkPointClippingBehavior {
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = 0,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = 1,
}

export enum VkSamplerReductionMode {
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
  VK_SAMPLER_REDUCTION_MODE_MIN = 1,
  VK_SAMPLER_REDUCTION_MODE_MAX = 2,
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
  VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
  VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2,
}

export enum VkTessellationDomainOrigin {
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = 0,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = 1,
}

export enum VkSamplerYcbcrModelConversion {
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
  /** just range expansion */
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
  /** aka HD YUV */
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
  /** aka SD YUV */
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
  /** aka UHD YUV */
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = 0,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = 1,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = 2,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = 3,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = 4,
}

export enum VkSamplerYcbcrRange {
  /** Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped) */
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
  /** Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240 */
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = 0,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = 1,
}

export enum VkChromaLocation {
  VK_CHROMA_LOCATION_COSITED_EVEN = 0,
  VK_CHROMA_LOCATION_MIDPOINT = 1,
  VK_CHROMA_LOCATION_COSITED_EVEN_KHR = 0,
  VK_CHROMA_LOCATION_MIDPOINT_KHR = 1,
}

export enum VkBlendOverlapEXT {
  VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
  VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
  VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
}

export enum VkCoverageModulationModeNV {
  VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
  VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
  VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
  VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
}

export enum VkCoverageReductionModeNV {
  VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
  VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
}

export enum VkValidationCacheHeaderVersionEXT {
  VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
}

export enum VkShaderInfoTypeAMD {
  VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
  VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
  VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
}

export enum VkQueueGlobalPriorityKHR {
  VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128,
  VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256,
  VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512,
  VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024,
  VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
  VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
  VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
  VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024,
}

export enum VkDebugUtilsMessageSeverityFlagBitsEXT {
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1 << 0,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 1 << 4,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 1 << 8,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 1 << 12,
}

export enum VkDebugUtilsMessageTypeFlagBitsEXT {
  VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1 << 0,
  VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 1 << 1,
  VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 1 << 2,
  VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 1 << 3,
}

export enum VkConservativeRasterizationModeEXT {
  VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
  VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
  VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
}

export enum VkDescriptorBindingFlagBits {
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1 << 0,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 1 << 1,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 1 << 2,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 1 << 3,
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 1 << 0,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 1 << 1,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 1 << 2,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 1 << 3,
  VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM = 1 << 4,
}

export enum VkVendorId {
  /** Vivante vendor ID */
  VK_VENDOR_ID_VIV = 65537,
  /** VeriSilicon vendor ID */
  VK_VENDOR_ID_VSI = 65538,
  /** Kazan Software Renderer */
  VK_VENDOR_ID_KAZAN = 65539,
  /** Codeplay Software Ltd. vendor ID */
  VK_VENDOR_ID_CODEPLAY = 65540,
  /** Mesa vendor ID */
  VK_VENDOR_ID_MESA = 65541,
  /** PoCL vendor ID */
  VK_VENDOR_ID_POCL = 65542,
}

export enum VkDriverId {
  /** Advanced Micro Devices, Inc. */
  VK_DRIVER_ID_AMD_PROPRIETARY = 1,
  /** Advanced Micro Devices, Inc. */
  VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_RADV = 3,
  /** NVIDIA Corporation */
  VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
  /** Intel Corporation */
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
  /** Intel Corporation */
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
  /** Imagination Technologies */
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
  /** Qualcomm Technologies, Inc. */
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
  /** Arm Limited */
  VK_DRIVER_ID_ARM_PROPRIETARY = 9,
  /** Google LLC */
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
  /** Google LLC */
  VK_DRIVER_ID_GGP_PROPRIETARY = 11,
  /** Broadcom Inc. */
  VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
  /** Mesa */
  VK_DRIVER_ID_MESA_LLVMPIPE = 13,
  /** MoltenVK */
  VK_DRIVER_ID_MOLTENVK = 14,
  /** Core Avionics & Industrial Inc. */
  VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
  /** Juice Technologies, Inc. */
  VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
  /** Verisilicon, Inc. */
  VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_TURNIP = 18,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_V3DV = 19,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_PANVK = 20,
  /** Samsung Electronics Co., Ltd. */
  VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_VENUS = 22,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_DOZEN = 23,
  /** Mesa open source project */
  VK_DRIVER_ID_MESA_NVK = 24,
  VK_DRIVER_ID_AMD_PROPRIETARY_KHR = 1,
  VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = 2,
  VK_DRIVER_ID_MESA_RADV_KHR = 3,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 4,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 5,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 6,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 7,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 8,
  VK_DRIVER_ID_ARM_PROPRIETARY_KHR = 9,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = 10,
  VK_DRIVER_ID_GGP_PROPRIETARY_KHR = 11,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = 12,
}

export enum VkConditionalRenderingFlagBitsEXT {
  VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1 << 0,
}

export enum VkResolveModeFlagBits {
  VK_RESOLVE_MODE_NONE = 0,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 1 << 0,
  VK_RESOLVE_MODE_AVERAGE_BIT = 1 << 1,
  VK_RESOLVE_MODE_MIN_BIT = 1 << 2,
  VK_RESOLVE_MODE_MAX_BIT = 1 << 3,
  VK_RESOLVE_MODE_NONE_KHR = 0,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 1 << 0,
  VK_RESOLVE_MODE_AVERAGE_BIT_KHR = 1 << 1,
  VK_RESOLVE_MODE_MIN_BIT_KHR = 1 << 2,
  VK_RESOLVE_MODE_MAX_BIT_KHR = 1 << 3,
}

export enum VkShadingRatePaletteEntryNV {
  VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
  VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
  VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
  VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
  VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
}

export enum VkCoarseSampleOrderTypeNV {
  VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
  VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
  VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
  VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
}

export enum VkGeometryInstanceFlagBitsKHR {
  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1 << 0,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 1 << 1,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 1 << 2,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 1 << 3,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = 1 << 1,
  VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 1 << 0,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 1 << 2,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 1 << 3,
  VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 1 << 4,
  VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 1 << 5,
}

export enum VkGeometryFlagBitsKHR {
  VK_GEOMETRY_OPAQUE_BIT_KHR = 1 << 0,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 1 << 1,
  VK_GEOMETRY_OPAQUE_BIT_NV = 1 << 0,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 1 << 1,
}

export enum VkBuildAccelerationStructureFlagBitsKHR {
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 1 << 0,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 1 << 1,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 1 << 2,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 1 << 3,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 1 << 4,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 1 << 0,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 1 << 1,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 1 << 2,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 1 << 3,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 1 << 4,
  VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 1 << 5,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 1 << 6,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 1 << 7,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 1 << 8,
  VK_BUILD_ACCELERATION_STRUCTURE_RESERVED_BIT_9_NV = 1 << 9,
  VK_BUILD_ACCELERATION_STRUCTURE_RESERVED_BIT_10_NV = 1 << 10,
}

export enum VkAccelerationStructureCreateFlagBitsKHR {
  VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 0,
  VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 3,
  VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 1 << 2,
}

export enum VkCopyAccelerationStructureModeKHR {
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 1,
}

export enum VkBuildAccelerationStructureModeKHR {
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
}

export enum VkAccelerationStructureTypeKHR {
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
  VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 1,
}

export enum VkGeometryTypeKHR {
  VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
  VK_GEOMETRY_TYPE_AABBS_KHR = 1,
  VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
  VK_GEOMETRY_TYPE_TRIANGLES_NV = 0,
  VK_GEOMETRY_TYPE_AABBS_NV = 1,
}

export enum VkAccelerationStructureMemoryRequirementsTypeNV {
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
}

export enum VkAccelerationStructureBuildTypeKHR {
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
}

export enum VkRayTracingShaderGroupTypeKHR {
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 1,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 2,
}

export enum VkAccelerationStructureCompatibilityKHR {
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
}

export enum VkShaderGroupShaderKHR {
  VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
  VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
  VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
  VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
}

export enum VkMemoryOverallocationBehaviorAMD {
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
}

export enum VkFramebufferCreateFlagBits {
  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 1 << 0,
  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 1 << 0,
}

export enum VkScopeNV {
  VK_SCOPE_DEVICE_NV = 1,
  VK_SCOPE_WORKGROUP_NV = 2,
  VK_SCOPE_SUBGROUP_NV = 3,
  VK_SCOPE_QUEUE_FAMILY_NV = 5,
}

export enum VkComponentTypeNV {
  VK_COMPONENT_TYPE_FLOAT16_NV = 0,
  VK_COMPONENT_TYPE_FLOAT32_NV = 1,
  VK_COMPONENT_TYPE_FLOAT64_NV = 2,
  VK_COMPONENT_TYPE_SINT8_NV = 3,
  VK_COMPONENT_TYPE_SINT16_NV = 4,
  VK_COMPONENT_TYPE_SINT32_NV = 5,
  VK_COMPONENT_TYPE_SINT64_NV = 6,
  VK_COMPONENT_TYPE_UINT8_NV = 7,
  VK_COMPONENT_TYPE_UINT16_NV = 8,
  VK_COMPONENT_TYPE_UINT32_NV = 9,
  VK_COMPONENT_TYPE_UINT64_NV = 10,
}

export enum VkDeviceDiagnosticsConfigFlagBitsNV {
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1 << 0,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 1 << 1,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 1 << 2,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 1 << 3,
}

export enum VkPipelineCreationFeedbackFlagBits {
  VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 1 << 0,
  VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1 << 0,
  VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 1 << 1,
  VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 1 << 1,
  VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 1 << 2,
  VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 1 << 2,
}

export enum VkFullScreenExclusiveEXT {
  VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
  VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
  VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
  VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
}

export enum VkPerformanceCounterScopeKHR {
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
  VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
  /** Backwards-compatible alias containing a typo */
  VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = 0,
  /** Backwards-compatible alias containing a typo */
  VK_QUERY_SCOPE_RENDER_PASS_KHR = 1,
  /** Backwards-compatible alias containing a typo */
  VK_QUERY_SCOPE_COMMAND_KHR = 2,
}

export enum VkMemoryDecompressionMethodFlagBitsNV {
  VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = 1 << 0,
}

export enum VkPerformanceCounterUnitKHR {
  VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
  VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
  VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
  VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
  VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
  VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
  VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
  VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
  VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
}

export enum VkPerformanceCounterStorageKHR {
  VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
  VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
}

export enum VkPerformanceCounterDescriptionFlagBitsKHR {
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 1 << 0,
  /** Backwards-compatible alias containing a typo */
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 1 << 0,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 1 << 1,
  /** Backwards-compatible alias containing a typo */
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 1 << 1,
}

export enum VkAcquireProfilingLockFlagBitsKHR {
}

export enum VkShaderCorePropertiesFlagBitsAMD {
}

export enum VkPerformanceConfigurationTypeINTEL {
  VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}

export enum VkQueryPoolSamplingModeINTEL {
  VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
}

export enum VkPerformanceOverrideTypeINTEL {
  VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
  VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
}

export enum VkPerformanceParameterTypeINTEL {
  VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
  VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
}

export enum VkPerformanceValueTypeINTEL {
  VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
  VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
  VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
  VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
  VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
}

export enum VkShaderFloatControlsIndependence {
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = 0,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = 1,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = 2,
}

export enum VkPipelineExecutableStatisticFormatKHR {
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
}

export enum VkLineRasterizationModeEXT {
  VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
  VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
}

export enum VkShaderModuleCreateFlagBits {
}

export enum VkPipelineCompilerControlFlagBitsAMD {
}

export enum VkToolPurposeFlagBits {
  VK_TOOL_PURPOSE_VALIDATION_BIT = 1 << 0,
  VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 1 << 0,
  VK_TOOL_PURPOSE_PROFILING_BIT = 1 << 1,
  VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 1 << 1,
  VK_TOOL_PURPOSE_TRACING_BIT = 1 << 2,
  VK_TOOL_PURPOSE_TRACING_BIT_EXT = 1 << 2,
  VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 1 << 3,
  VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 1 << 3,
  VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 1 << 4,
  VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 1 << 4,
  VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 1 << 5,
  VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 1 << 6,
}

export enum VkFragmentShadingRateCombinerOpKHR {
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
}

export enum VkFragmentShadingRateNV {
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
  VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
  VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
  VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
  VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
  VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
}

export enum VkFragmentShadingRateTypeNV {
  VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
  VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
}

export enum VkSubpassMergeStatusEXT {
  VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
  VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
}

export enum VkAccessFlagBits2 {
  VK_ACCESS_2_NONE = 0,
  VK_ACCESS_2_NONE_KHR = 0,
  VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 1 << 0,
  VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 1 << 0,
  VK_ACCESS_2_INDEX_READ_BIT = 1 << 1,
  VK_ACCESS_2_INDEX_READ_BIT_KHR = 1 << 1,
  VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 1 << 2,
  VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 1 << 2,
  VK_ACCESS_2_UNIFORM_READ_BIT = 1 << 3,
  VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 1 << 3,
  VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 1 << 4,
  VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 1 << 4,
  VK_ACCESS_2_SHADER_READ_BIT = 1 << 5,
  VK_ACCESS_2_SHADER_READ_BIT_KHR = 1 << 5,
  VK_ACCESS_2_SHADER_WRITE_BIT = 1 << 6,
  VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 1 << 6,
  VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 1 << 7,
  VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 1 << 7,
  VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 1 << 8,
  VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 1 << 8,
  VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 1 << 9,
  VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 1 << 9,
  VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1 << 10,
  VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 1 << 10,
  VK_ACCESS_2_TRANSFER_READ_BIT = 1 << 11,
  VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 1 << 11,
  VK_ACCESS_2_TRANSFER_WRITE_BIT = 1 << 12,
  VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 1 << 12,
  VK_ACCESS_2_HOST_READ_BIT = 1 << 13,
  VK_ACCESS_2_HOST_READ_BIT_KHR = 1 << 13,
  VK_ACCESS_2_HOST_WRITE_BIT = 1 << 14,
  VK_ACCESS_2_HOST_WRITE_BIT_KHR = 1 << 14,
  VK_ACCESS_2_MEMORY_READ_BIT = 1 << 15,
  VK_ACCESS_2_MEMORY_READ_BIT_KHR = 1 << 15,
  VK_ACCESS_2_MEMORY_WRITE_BIT = 1 << 16,
  VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 1 << 16,
  VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 1 << 32,
  VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 1 << 32,
  VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 1 << 33,
  VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 1 << 33,
  VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 1 << 34,
  VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 1 << 34,
  VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 1 << 35,
  VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 1 << 36,
  VK_ACCESS_2_RESERVED_46_BIT_EXT = 1 << 46,
  VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 1 << 37,
  VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 1 << 38,
  VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 1 << 25,
  VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 1 << 26,
  VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 1 << 27,
  /** read access flag for reading conditional rendering predicate */
  VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 1 << 20,
  VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 1 << 17,
  VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 1 << 18,
  VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 1 << 23,
  VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 1 << 23,
  VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 1 << 21,
  VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 1 << 22,
  VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 1 << 21,
  VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 1 << 22,
  VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 1 << 24,
  VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 1 << 19,
  VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 1 << 41,
  VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 1 << 39,
  VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 1 << 40,
  VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 1 << 44,
  VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 1 << 45,
  VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 1 << 42,
  VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 1 << 43,
}

export enum VkPipelineStageFlagBits2 {
  VK_PIPELINE_STAGE_2_NONE = 0,
  VK_PIPELINE_STAGE_2_NONE_KHR = 0,
  VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 1 << 0,
  VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 1 << 0,
  VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 1 << 1,
  VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 1 << 1,
  VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 1 << 2,
  VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 1 << 2,
  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 1 << 3,
  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 1 << 3,
  VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 1 << 4,
  VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 1 << 4,
  VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 1 << 5,
  VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 1 << 5,
  VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 1 << 6,
  VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 1 << 6,
  VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 1 << 7,
  VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 1 << 7,
  VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 1 << 8,
  VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 1 << 8,
  VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 1 << 9,
  VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 1 << 9,
  VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 1 << 10,
  VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 1 << 10,
  VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 1 << 11,
  VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 1 << 11,
  VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 1 << 12,
  VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 1 << 12,
  VK_PIPELINE_STAGE_2_TRANSFER_BIT = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,
  VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 1 << 12,
  VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 1 << 13,
  VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 1 << 13,
  VK_PIPELINE_STAGE_2_HOST_BIT = 1 << 14,
  VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 1 << 14,
  VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 1 << 15,
  VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 1 << 15,
  VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 1 << 16,
  VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 1 << 16,
  VK_PIPELINE_STAGE_2_COPY_BIT = 1 << 32,
  VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 1 << 32,
  VK_PIPELINE_STAGE_2_RESOLVE_BIT = 1 << 33,
  VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 1 << 33,
  VK_PIPELINE_STAGE_2_BLIT_BIT = 1 << 34,
  VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 1 << 34,
  VK_PIPELINE_STAGE_2_CLEAR_BIT = 1 << 35,
  VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 1 << 35,
  VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 1 << 36,
  VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 1 << 36,
  VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 1 << 37,
  VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 1 << 37,
  VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 1 << 38,
  VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 1 << 38,
  VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 1 << 26,
  VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 1 << 27,
  VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 1 << 24,
  /** A pipeline stage for conditional rendering predicate fetch */
  VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 1 << 18,
  VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 1 << 17,
  VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 22,
  VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 1 << 22,
  VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 1 << 25,
  VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 1 << 21,
  VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 1 << 21,
  VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 1 << 25,
  VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 1 << 23,
  VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 1 << 19,
  VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 1 << 20,
  VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 1 << 19,
  VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 1 << 20,
  VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 1 << 39,
  VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 1 << 40,
  VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 1 << 28,
  VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 1 << 30,
  VK_PIPELINE_STAGE_2_RESEVED_41_BIT_HUAWEI = 1 << 41,
  VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 1 << 29,
}

export enum VkSubmitFlagBits {
  VK_SUBMIT_PROTECTED_BIT = 1 << 0,
  VK_SUBMIT_PROTECTED_BIT_KHR = 1 << 0,
}

export enum VkEventCreateFlagBits {
  VK_EVENT_CREATE_DEVICE_ONLY_BIT = 1 << 0,
  VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = 1 << 0,
}

export enum VkPipelineLayoutCreateFlagBits {
  VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD = 1 << 0,
  VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 1 << 1,
}

export enum VkProvokingVertexModeEXT {
  VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
  VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
}

export enum VkAccelerationStructureMotionInstanceTypeNV {
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
}

export enum VkPipelineColorBlendStateCreateFlagBits {
  VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = 1 << 0,
  VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 1 << 0,
}

export enum VkPipelineDepthStencilStateCreateFlagBits {
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 1 << 0,
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 1 << 1,
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 1 << 0,
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 1 << 1,
}

export enum VkGraphicsPipelineLibraryFlagBitsEXT {
  VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 1 << 0,
  VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 1 << 1,
  VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 1 << 2,
  VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 1 << 3,
}

export enum VkDeviceAddressBindingFlagBitsEXT {
  VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 1 << 0,
}

export enum VkDeviceAddressBindingTypeEXT {
  VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
  VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
}

export enum VkVideoCodecOperationFlagBitsKHR {
  VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
  VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT = 1 << 16,
  VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT = 1 << 17,
  VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT = 1 << 0,
  VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_EXT = 1 << 1,
}

/** Vulkan video chroma subsampling definitions */
export enum VkVideoChromaSubsamplingFlagBitsKHR {
  VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
  VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 1 << 0,
  VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 1 << 1,
  VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 1 << 2,
  VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 1 << 3,
}

/** Vulkan video component bit depth definitions */
export enum VkVideoComponentBitDepthFlagBitsKHR {
  VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
  VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 1 << 0,
  VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 1 << 2,
  VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 1 << 4,
}

export enum VkVideoCapabilityFlagBitsKHR {
  VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 1 << 0,
  VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 1 << 1,
}

export enum VkVideoSessionCreateFlagBitsKHR {
  VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 1 << 0,
}

export enum VkVideoDecodeH264PictureLayoutFlagBitsEXT {
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0,
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 1 << 0,
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 1 << 1,
}

export enum VkVideoCodingControlFlagBitsKHR {
  VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 1 << 0,
  VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 1 << 1,
  VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR = 1 << 2,
}

export enum VkQueryResultStatusKHR {
  VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
  VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
  VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
}

export enum VkVideoDecodeUsageFlagBitsKHR {
  VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
  VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 1 << 0,
  VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 1 << 1,
  VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 1 << 2,
}

export enum VkVideoDecodeCapabilityFlagBitsKHR {
  VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 1 << 0,
  VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 1 << 1,
}

export enum VkVideoEncodeUsageFlagBitsKHR {
  VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 1 << 0,
  VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 1 << 1,
  VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 1 << 2,
  VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 1 << 3,
}

export enum VkVideoEncodeContentFlagBitsKHR {
  VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 1 << 0,
  VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 1 << 1,
  VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 1 << 2,
}

export enum VkVideoEncodeTuningModeKHR {
  VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
  VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
  VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
  VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
}

export enum VkVideoEncodeCapabilityFlagBitsKHR {
  VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 1 << 0,
}

export enum VkVideoEncodeRateControlModeFlagBitsKHR {
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR = 0,
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 1,
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 2,
}

export enum VkVideoEncodeH264CapabilityFlagBitsEXT {
  VK_VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_ENABLED_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_DISABLED_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H264_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 1 << 2,
  VK_VIDEO_ENCODE_H264_CAPABILITY_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_BIT_EXT = 1 << 3,
  VK_VIDEO_ENCODE_H264_CAPABILITY_SCALING_LISTS_BIT_EXT = 1 << 4,
  VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 1 << 5,
  VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 1 << 6,
  VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 1 << 7,
  VK_VIDEO_ENCODE_H264_CAPABILITY_PIC_INIT_QP_MINUS26_BIT_EXT = 1 << 8,
  VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 1 << 9,
  VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_EXPLICIT_BIT_EXT = 1 << 10,
  VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_IMPLICIT_BIT_EXT = 1 << 11,
  VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 1 << 12,
  VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 1 << 13,
  VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 1 << 14,
  VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 1 << 15,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 1 << 16,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 1 << 17,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 1 << 18,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DISABLE_DIRECT_SPATIAL_MV_PRED_BIT_EXT = 1 << 19,
  VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 1 << 20,
  VK_VIDEO_ENCODE_H264_CAPABILITY_SLICE_MB_COUNT_BIT_EXT = 1 << 21,
  VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = 1 << 22,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 1 << 23,
  VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 1 << 24,
}

export enum VkVideoEncodeH264InputModeFlagBitsEXT {
  VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VkVideoEncodeH264OutputModeFlagBitsEXT {
  VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VkVideoEncodeH264RateControlStructureEXT {
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
}

export enum VkImageFormatConstraintsFlagBitsFUCHSIA {
}

export enum VkImageConstraintsInfoFlagBitsFUCHSIA {
  VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = 1 << 0,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = 1 << 1,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = 1 << 2,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = 1 << 3,
  VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = 1 << 4,
}

export enum VkFormatFeatureFlagBits2 {
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 1 << 0,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 1 << 0,
  VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 1 << 1,
  VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 1 << 1,
  VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 1 << 2,
  VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 1 << 2,
  VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 1 << 3,
  VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 1 << 3,
  VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 1 << 4,
  VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 1 << 4,
  VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 1 << 5,
  VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 1 << 5,
  VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 1 << 6,
  VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 1 << 6,
  VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 1 << 7,
  VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 1 << 7,
  VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 1 << 8,
  VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 1 << 8,
  VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 9,
  VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 1 << 9,
  VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 1 << 10,
  VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 1 << 10,
  VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 1 << 11,
  VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 1 << 11,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 1 << 12,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 1 << 12,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 1 << 13,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 1 << 13,
  VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 1 << 14,
  VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 1 << 14,
  VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 1 << 15,
  VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 1 << 15,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 1 << 16,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 1 << 16,
  VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 1 << 17,
  VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 1 << 17,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 1 << 18,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 1 << 18,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 1 << 19,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 1 << 19,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1 << 20,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1 << 20,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 1 << 21,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 1 << 21,
  VK_FORMAT_FEATURE_2_DISJOINT_BIT = 1 << 22,
  VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 1 << 22,
  VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 1 << 23,
  VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 1 << 23,
  VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 1 << 31,
  VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 1 << 31,
  VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 1 << 32,
  VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 1 << 32,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 1 << 33,
  VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 1 << 33,
  VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 1 << 25,
  VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 1 << 26,
  VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 1 << 29,
  VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 24,
  VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 30,
  VK_FORMAT_FEATURE_2_RESERVED_44_BIT_EXT = 1 << 44,
  VK_FORMAT_FEATURE_2_RESERVED_45_BIT_EXT = 1 << 45,
  VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 1 << 27,
  VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 28,
  /** Format support linear image as render target, it cannot be mixed with non linear attachment */
  VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 1 << 38,
  VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 1 << 34,
  VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 1 << 35,
  VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = 1 << 36,
  VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = 1 << 37,
  VK_FORMAT_FEATURE_2_RESERVED_39_BIT_EXT = 1 << 39,
  VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 1 << 40,
  VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 1 << 41,
  VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 1 << 42,
}

export enum VkRenderingFlagBits {
  VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 1 << 0,
  VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = 1 << 0,
  VK_RENDERING_SUSPENDING_BIT = 1 << 1,
  VK_RENDERING_SUSPENDING_BIT_KHR = 1 << 1,
  VK_RENDERING_RESUMING_BIT = 1 << 2,
  VK_RENDERING_RESUMING_BIT_KHR = 1 << 2,
  VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 1 << 3,
}

export enum VkVideoEncodeH265CapabilityFlagBitsEXT {
  VK_VIDEO_ENCODE_H265_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H265_CAPABILITY_SCALING_LISTS_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H265_CAPABILITY_SAMPLE_ADAPTIVE_OFFSET_ENABLED_BIT_EXT = 1 << 2,
  VK_VIDEO_ENCODE_H265_CAPABILITY_PCM_ENABLE_BIT_EXT = 1 << 3,
  VK_VIDEO_ENCODE_H265_CAPABILITY_SPS_TEMPORAL_MVP_ENABLED_BIT_EXT = 1 << 4,
  VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 1 << 5,
  VK_VIDEO_ENCODE_H265_CAPABILITY_INIT_QP_MINUS26_BIT_EXT = 1 << 6,
  VK_VIDEO_ENCODE_H265_CAPABILITY_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = 1 << 7,
  VK_VIDEO_ENCODE_H265_CAPABILITY_SIGN_DATA_HIDING_ENABLED_BIT_EXT = 1 << 8,
  VK_VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_ENABLED_BIT_EXT = 1 << 9,
  VK_VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_DISABLED_BIT_EXT = 1 << 10,
  VK_VIDEO_ENCODE_H265_CAPABILITY_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_BIT_EXT = 1 << 11,
  VK_VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 1 << 12,
  VK_VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_BIPRED_BIT_EXT = 1 << 13,
  VK_VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 1 << 14,
  VK_VIDEO_ENCODE_H265_CAPABILITY_TRANSQUANT_BYPASS_ENABLED_BIT_EXT = 1 << 15,
  VK_VIDEO_ENCODE_H265_CAPABILITY_ENTROPY_CODING_SYNC_ENABLED_BIT_EXT = 1 << 16,
  VK_VIDEO_ENCODE_H265_CAPABILITY_DEBLOCKING_FILTER_OVERRIDE_ENABLED_BIT_EXT = 1 << 17,
  VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_FRAME_BIT_EXT = 1 << 18,
  VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_PER_TILE_BIT_EXT = 1 << 19,
  VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_SLICE_BIT_EXT = 1 << 20,
  VK_VIDEO_ENCODE_H265_CAPABILITY_SLICE_SEGMENT_CTB_COUNT_BIT_EXT = 1 << 21,
  VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = 1 << 22,
  VK_VIDEO_ENCODE_H265_CAPABILITY_DEPENDENT_SLICE_SEGMENT_BIT_EXT = 1 << 23,
  VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 1 << 24,
  VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 1 << 25,
}

export enum VkVideoEncodeH265InputModeFlagBitsEXT {
  VK_VIDEO_ENCODE_H265_INPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H265_INPUT_MODE_SLICE_SEGMENT_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H265_INPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VkVideoEncodeH265OutputModeFlagBitsEXT {
  VK_VIDEO_ENCODE_H265_OUTPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H265_OUTPUT_MODE_SLICE_SEGMENT_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H265_OUTPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VkVideoEncodeH265RateControlStructureEXT {
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
}

export enum VkVideoEncodeH265CtbSizeFlagBitsEXT {
  VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 1 << 2,
}

export enum VkVideoEncodeH265TransformBlockSizeFlagBitsEXT {
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = 1 << 0,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = 1 << 1,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = 1 << 2,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = 1 << 3,
}

export enum VkExportMetalObjectTypeFlagBitsEXT {
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 1 << 0,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 1 << 1,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 1 << 2,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 1 << 3,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 1 << 4,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 1 << 5,
}

export enum VkInstanceCreateFlagBits {
  VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 1 << 0,
}

export enum VkImageCompressionFlagBitsEXT {
  VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 1 << 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 1 << 1,
  VK_IMAGE_COMPRESSION_DISABLED_EXT = 1 << 2,
}

export enum VkImageCompressionFixedRateFlagBitsEXT {
  VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 1 << 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 1 << 1,
  VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 1 << 2,
  VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 1 << 3,
  VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 1 << 4,
  VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 1 << 5,
  VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 1 << 6,
  VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 1 << 7,
  VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 1 << 8,
  VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 1 << 9,
  VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 1 << 10,
  VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 1 << 11,
  VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 1 << 12,
  VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 1 << 13,
  VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 1 << 14,
  VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 1 << 15,
  VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 1 << 16,
  VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 1 << 17,
  VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 1 << 18,
  VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 1 << 19,
  VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 1 << 20,
  VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 1 << 21,
  VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 1 << 22,
  VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 1 << 23,
}

export enum VkPipelineRobustnessBufferBehaviorEXT {
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3,
}

export enum VkPipelineRobustnessImageBehaviorEXT {
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3,
}

export enum VkOpticalFlowGridSizeFlagBitsNV {
  VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 1 << 0,
  VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 1 << 1,
  VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 1 << 2,
  VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 1 << 3,
}

export enum VkOpticalFlowUsageFlagBitsNV {
  VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 1 << 0,
  VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 1 << 1,
  VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 1 << 2,
  VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 1 << 3,
  VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 1 << 4,
}

export enum VkOpticalFlowPerformanceLevelNV {
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
}

export enum VkOpticalFlowSessionBindingPointNV {
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
}

export enum VkOpticalFlowSessionCreateFlagBitsNV {
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 1 << 0,
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 1 << 1,
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 1 << 2,
  VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 1 << 3,
  VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 1 << 4,
}

export enum VkOpticalFlowExecuteFlagBitsNV {
  VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 1 << 0,
}

export enum VkMicromapTypeEXT {
  VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
}

export enum VkBuildMicromapFlagBitsEXT {
  VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 1 << 0,
  VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 1 << 1,
  VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 1 << 2,
}

export enum VkMicromapCreateFlagBitsEXT {
  VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1 << 0,
}

export enum VkCopyMicromapModeEXT {
  VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
  VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
  VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
  VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
}

export enum VkBuildMicromapModeEXT {
  VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
}

export enum VkOpacityMicromapFormatEXT {
  VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
  VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
}

export enum VkOpacityMicromapSpecialIndexEXT {
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
}

export enum VkDeviceFaultAddressTypeEXT {
  /** Currently unused */
  VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
  VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
  VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
  VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
}

export enum VkDeviceFaultVendorBinaryHeaderVersionEXT {
  VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
}

/// Structs

export const BUFFER = Symbol("vkStructBuffer");
export const DATAVIEW = Symbol("vkStructDataView");

export interface IVkStructure {
  readonly [BUFFER]: Uint8Array;
  readonly [DATAVIEW]: DataView;
}

export const LE = new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x78;


export class StdVideoH264SpsVuiFlags implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264SpsVuiFlags(new Uint8Array(StdVideoH264SpsVuiFlags.size));
  }
  
  static create(data: {
    aspect_ratio_info_present_flag: number;
    overscan_info_present_flag: number;
    overscan_appropriate_flag: number;
    video_signal_type_present_flag: number;
    video_full_range_flag: number;
    color_description_present_flag: number;
    chroma_loc_info_present_flag: number;
    timing_info_present_flag: number;
    fixed_frame_rate_flag: number;
    bitstream_restriction_flag: number;
    nal_hrd_parameters_present_flag: number;
    vcl_hrd_parameters_present_flag: number;
  }) {
    const s = StdVideoH264SpsVuiFlags.alloc();
    if (data.aspect_ratio_info_present_flag !== undefined) s.aspect_ratio_info_present_flag = data.aspect_ratio_info_present_flag;
    if (data.overscan_info_present_flag !== undefined) s.overscan_info_present_flag = data.overscan_info_present_flag;
    if (data.overscan_appropriate_flag !== undefined) s.overscan_appropriate_flag = data.overscan_appropriate_flag;
    if (data.video_signal_type_present_flag !== undefined) s.video_signal_type_present_flag = data.video_signal_type_present_flag;
    if (data.video_full_range_flag !== undefined) s.video_full_range_flag = data.video_full_range_flag;
    if (data.color_description_present_flag !== undefined) s.color_description_present_flag = data.color_description_present_flag;
    if (data.chroma_loc_info_present_flag !== undefined) s.chroma_loc_info_present_flag = data.chroma_loc_info_present_flag;
    if (data.timing_info_present_flag !== undefined) s.timing_info_present_flag = data.timing_info_present_flag;
    if (data.fixed_frame_rate_flag !== undefined) s.fixed_frame_rate_flag = data.fixed_frame_rate_flag;
    if (data.bitstream_restriction_flag !== undefined) s.bitstream_restriction_flag = data.bitstream_restriction_flag;
    if (data.nal_hrd_parameters_present_flag !== undefined) s.nal_hrd_parameters_present_flag = data.nal_hrd_parameters_present_flag;
    if (data.vcl_hrd_parameters_present_flag !== undefined) s.vcl_hrd_parameters_present_flag = data.vcl_hrd_parameters_present_flag;
    return s;
  }
  
  get aspect_ratio_info_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspect_ratio_info_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get overscan_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set overscan_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get overscan_appropriate_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set overscan_appropriate_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get video_signal_type_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set video_signal_type_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get video_full_range_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set video_full_range_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get color_description_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set color_description_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get chroma_loc_info_present_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set chroma_loc_info_present_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get timing_info_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set timing_info_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fixed_frame_rate_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set fixed_frame_rate_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get bitstream_restriction_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set bitstream_restriction_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get nal_hrd_parameters_present_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set nal_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get vcl_hrd_parameters_present_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set vcl_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

/** hrd_parameters */
export class StdVideoH264HrdParameters implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264HrdParameters.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264HrdParameters(new Uint8Array(StdVideoH264HrdParameters.size));
  }
  
  static create(data: {
    cpb_cnt_minus1: number;
    bit_rate_scale: number;
    cpb_size_scale: number;
    reserved1: number;
    bit_rate_value_minus1: number;
    cpb_size_value_minus1: number;
    cbr_flag: number;
    initial_cpb_removal_delay_length_minus1: number;
    cpb_removal_delay_length_minus1: number;
    dpb_output_delay_length_minus1: number;
    time_offset_length: number;
  }) {
    const s = StdVideoH264HrdParameters.alloc();
    if (data.cpb_cnt_minus1 !== undefined) s.cpb_cnt_minus1 = data.cpb_cnt_minus1;
    if (data.bit_rate_scale !== undefined) s.bit_rate_scale = data.bit_rate_scale;
    if (data.cpb_size_scale !== undefined) s.cpb_size_scale = data.cpb_size_scale;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.bit_rate_value_minus1 !== undefined) s.bit_rate_value_minus1 = data.bit_rate_value_minus1;
    if (data.cpb_size_value_minus1 !== undefined) s.cpb_size_value_minus1 = data.cpb_size_value_minus1;
    if (data.cbr_flag !== undefined) s.cbr_flag = data.cbr_flag;
    if (data.initial_cpb_removal_delay_length_minus1 !== undefined) s.initial_cpb_removal_delay_length_minus1 = data.initial_cpb_removal_delay_length_minus1;
    if (data.cpb_removal_delay_length_minus1 !== undefined) s.cpb_removal_delay_length_minus1 = data.cpb_removal_delay_length_minus1;
    if (data.dpb_output_delay_length_minus1 !== undefined) s.dpb_output_delay_length_minus1 = data.dpb_output_delay_length_minus1;
    if (data.time_offset_length !== undefined) s.time_offset_length = data.time_offset_length;
    return s;
  }
  
  get cpb_cnt_minus1() {
    return this.#view.getUint8(0);
  }
  
  set cpb_cnt_minus1(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get bit_rate_scale() {
    return this.#view.getUint8(1);
  }
  
  set bit_rate_scale(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get cpb_size_scale() {
    return this.#view.getUint8(2);
  }
  
  set cpb_size_scale(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(3);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(3, Number(value));
  }
  
  get bit_rate_value_minus1() {
    return this.#view.getUint32(4, LE);
  }
  
  set bit_rate_value_minus1(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get cpb_size_value_minus1() {
    return this.#view.getUint32(8, LE);
  }
  
  set cpb_size_value_minus1(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get cbr_flag() {
    return this.#view.getUint8(12);
  }
  
  set cbr_flag(value: number) {
    this.#view.setUint8(12, Number(value));
  }
  
  get initial_cpb_removal_delay_length_minus1() {
    return this.#view.getUint32(16, LE);
  }
  
  set initial_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get cpb_removal_delay_length_minus1() {
    return this.#view.getUint32(20, LE);
  }
  
  set cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dpb_output_delay_length_minus1() {
    return this.#view.getUint32(24, LE);
  }
  
  set dpb_output_delay_length_minus1(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get time_offset_length() {
    return this.#view.getUint32(28, LE);
  }
  
  set time_offset_length(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class StdVideoH264SequenceParameterSetVui implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264SequenceParameterSetVui.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264SequenceParameterSetVui(new Uint8Array(StdVideoH264SequenceParameterSetVui.size));
  }
  
  static create(data: {
    flags: StdVideoH264SpsVuiFlags;
    aspect_ratio_idc: StdVideoH264AspectRatioIdc;
    sar_width: number;
    sar_height: number;
    video_format: number;
    colour_primaries: number;
    transfer_characteristics: number;
    matrix_coefficients: number;
    num_units_in_tick: number;
    time_scale: number;
    max_num_reorder_frames: number;
    max_dec_frame_buffering: number;
    chroma_sample_loc_type_top_field: number;
    chroma_sample_loc_type_bottom_field: number;
    reserved1: number;
    pHrdParameters: Deno.PointerValue;
  }) {
    const s = StdVideoH264SequenceParameterSetVui.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.aspect_ratio_idc !== undefined) s.aspect_ratio_idc = data.aspect_ratio_idc;
    if (data.sar_width !== undefined) s.sar_width = data.sar_width;
    if (data.sar_height !== undefined) s.sar_height = data.sar_height;
    if (data.video_format !== undefined) s.video_format = data.video_format;
    if (data.colour_primaries !== undefined) s.colour_primaries = data.colour_primaries;
    if (data.transfer_characteristics !== undefined) s.transfer_characteristics = data.transfer_characteristics;
    if (data.matrix_coefficients !== undefined) s.matrix_coefficients = data.matrix_coefficients;
    if (data.num_units_in_tick !== undefined) s.num_units_in_tick = data.num_units_in_tick;
    if (data.time_scale !== undefined) s.time_scale = data.time_scale;
    if (data.max_num_reorder_frames !== undefined) s.max_num_reorder_frames = data.max_num_reorder_frames;
    if (data.max_dec_frame_buffering !== undefined) s.max_dec_frame_buffering = data.max_dec_frame_buffering;
    if (data.chroma_sample_loc_type_top_field !== undefined) s.chroma_sample_loc_type_top_field = data.chroma_sample_loc_type_top_field;
    if (data.chroma_sample_loc_type_bottom_field !== undefined) s.chroma_sample_loc_type_bottom_field = data.chroma_sample_loc_type_bottom_field;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.pHrdParameters !== undefined) s.pHrdParameters = data.pHrdParameters;
    return s;
  }
  
  get flags() {
    return new StdVideoH264SpsVuiFlags(this.#data.subarray(0, 0 + StdVideoH264SpsVuiFlags.size));
  }
  
  set flags(value: StdVideoH264SpsVuiFlags) {
    if (value[BUFFER].byteLength < StdVideoH264SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aspect_ratio_idc() {
    return this.#view.getUint32(48, LE);
  }
  
  set aspect_ratio_idc(value: StdVideoH264AspectRatioIdc) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get sar_width() {
    return this.#view.getUint16(52, LE);
  }
  
  set sar_width(value: number) {
    this.#view.setUint16(52, Number(value), LE);
  }
  
  get sar_height() {
    return this.#view.getUint16(54, LE);
  }
  
  set sar_height(value: number) {
    this.#view.setUint16(54, Number(value), LE);
  }
  
  get video_format() {
    return this.#view.getUint8(56);
  }
  
  set video_format(value: number) {
    this.#view.setUint8(56, Number(value));
  }
  
  get colour_primaries() {
    return this.#view.getUint8(57);
  }
  
  set colour_primaries(value: number) {
    this.#view.setUint8(57, Number(value));
  }
  
  get transfer_characteristics() {
    return this.#view.getUint8(58);
  }
  
  set transfer_characteristics(value: number) {
    this.#view.setUint8(58, Number(value));
  }
  
  get matrix_coefficients() {
    return this.#view.getUint8(59);
  }
  
  set matrix_coefficients(value: number) {
    this.#view.setUint8(59, Number(value));
  }
  
  get num_units_in_tick() {
    return this.#view.getUint32(60, LE);
  }
  
  set num_units_in_tick(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get time_scale() {
    return this.#view.getUint32(64, LE);
  }
  
  set time_scale(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get max_num_reorder_frames() {
    return this.#view.getUint8(68);
  }
  
  set max_num_reorder_frames(value: number) {
    this.#view.setUint8(68, Number(value));
  }
  
  get max_dec_frame_buffering() {
    return this.#view.getUint8(69);
  }
  
  set max_dec_frame_buffering(value: number) {
    this.#view.setUint8(69, Number(value));
  }
  
  get chroma_sample_loc_type_top_field() {
    return this.#view.getUint8(70);
  }
  
  set chroma_sample_loc_type_top_field(value: number) {
    this.#view.setUint8(70, Number(value));
  }
  
  get chroma_sample_loc_type_bottom_field() {
    return this.#view.getUint8(71);
  }
  
  set chroma_sample_loc_type_bottom_field(value: number) {
    this.#view.setUint8(71, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint32(72, LE);
  }
  
  set reserved1(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pHrdParameters(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
}

export class StdVideoH264SpsFlags implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264SpsFlags(new Uint8Array(StdVideoH264SpsFlags.size));
  }
  
  static create(data: {
    constraint_set0_flag: number;
    constraint_set1_flag: number;
    constraint_set2_flag: number;
    constraint_set3_flag: number;
    constraint_set4_flag: number;
    constraint_set5_flag: number;
    direct_8x8_inference_flag: number;
    mb_adaptive_frame_field_flag: number;
    frame_mbs_only_flag: number;
    delta_pic_order_always_zero_flag: number;
    separate_colour_plane_flag: number;
    gaps_in_frame_num_value_allowed_flag: number;
    qpprime_y_zero_transform_bypass_flag: number;
    frame_cropping_flag: number;
    seq_scaling_matrix_present_flag: number;
    vui_parameters_present_flag: number;
  }) {
    const s = StdVideoH264SpsFlags.alloc();
    if (data.constraint_set0_flag !== undefined) s.constraint_set0_flag = data.constraint_set0_flag;
    if (data.constraint_set1_flag !== undefined) s.constraint_set1_flag = data.constraint_set1_flag;
    if (data.constraint_set2_flag !== undefined) s.constraint_set2_flag = data.constraint_set2_flag;
    if (data.constraint_set3_flag !== undefined) s.constraint_set3_flag = data.constraint_set3_flag;
    if (data.constraint_set4_flag !== undefined) s.constraint_set4_flag = data.constraint_set4_flag;
    if (data.constraint_set5_flag !== undefined) s.constraint_set5_flag = data.constraint_set5_flag;
    if (data.direct_8x8_inference_flag !== undefined) s.direct_8x8_inference_flag = data.direct_8x8_inference_flag;
    if (data.mb_adaptive_frame_field_flag !== undefined) s.mb_adaptive_frame_field_flag = data.mb_adaptive_frame_field_flag;
    if (data.frame_mbs_only_flag !== undefined) s.frame_mbs_only_flag = data.frame_mbs_only_flag;
    if (data.delta_pic_order_always_zero_flag !== undefined) s.delta_pic_order_always_zero_flag = data.delta_pic_order_always_zero_flag;
    if (data.separate_colour_plane_flag !== undefined) s.separate_colour_plane_flag = data.separate_colour_plane_flag;
    if (data.gaps_in_frame_num_value_allowed_flag !== undefined) s.gaps_in_frame_num_value_allowed_flag = data.gaps_in_frame_num_value_allowed_flag;
    if (data.qpprime_y_zero_transform_bypass_flag !== undefined) s.qpprime_y_zero_transform_bypass_flag = data.qpprime_y_zero_transform_bypass_flag;
    if (data.frame_cropping_flag !== undefined) s.frame_cropping_flag = data.frame_cropping_flag;
    if (data.seq_scaling_matrix_present_flag !== undefined) s.seq_scaling_matrix_present_flag = data.seq_scaling_matrix_present_flag;
    if (data.vui_parameters_present_flag !== undefined) s.vui_parameters_present_flag = data.vui_parameters_present_flag;
    return s;
  }
  
  get constraint_set0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set constraint_set0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get constraint_set1_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set constraint_set1_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get constraint_set2_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set constraint_set2_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get constraint_set3_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set constraint_set3_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get constraint_set4_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set constraint_set4_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get constraint_set5_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set constraint_set5_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get direct_8x8_inference_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set direct_8x8_inference_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get mb_adaptive_frame_field_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set mb_adaptive_frame_field_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get frame_mbs_only_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set frame_mbs_only_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get delta_pic_order_always_zero_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set delta_pic_order_always_zero_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get separate_colour_plane_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set separate_colour_plane_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get gaps_in_frame_num_value_allowed_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set gaps_in_frame_num_value_allowed_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get qpprime_y_zero_transform_bypass_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set qpprime_y_zero_transform_bypass_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get frame_cropping_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set frame_cropping_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get seq_scaling_matrix_present_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set seq_scaling_matrix_present_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get vui_parameters_present_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set vui_parameters_present_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class StdVideoH264ScalingLists implements IVkStructure {
  static size = 6;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264ScalingLists.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264ScalingLists(new Uint8Array(StdVideoH264ScalingLists.size));
  }
  
  static create(data: {
    scaling_list_present_mask: number;
    use_default_scaling_matrix_mask: number;
    ScalingList4x4: number;
    ScalingList8x8: number;
  }) {
    const s = StdVideoH264ScalingLists.alloc();
    if (data.scaling_list_present_mask !== undefined) s.scaling_list_present_mask = data.scaling_list_present_mask;
    if (data.use_default_scaling_matrix_mask !== undefined) s.use_default_scaling_matrix_mask = data.use_default_scaling_matrix_mask;
    if (data.ScalingList4x4 !== undefined) s.ScalingList4x4 = data.ScalingList4x4;
    if (data.ScalingList8x8 !== undefined) s.ScalingList8x8 = data.ScalingList8x8;
    return s;
  }
  
  get scaling_list_present_mask() {
    return this.#view.getUint16(0, LE);
  }
  
  set scaling_list_present_mask(value: number) {
    this.#view.setUint16(0, Number(value), LE);
  }
  
  get use_default_scaling_matrix_mask() {
    return this.#view.getUint16(2, LE);
  }
  
  set use_default_scaling_matrix_mask(value: number) {
    this.#view.setUint16(2, Number(value), LE);
  }
  
  get ScalingList4x4() {
    return this.#view.getUint8(4);
  }
  
  set ScalingList4x4(value: number) {
    this.#view.setUint8(4, Number(value));
  }
  
  get ScalingList8x8() {
    return this.#view.getUint8(5);
  }
  
  set ScalingList8x8(value: number) {
    this.#view.setUint8(5, Number(value));
  }
}

export class StdVideoH264SequenceParameterSet implements IVkStructure {
  static size = 192;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264SequenceParameterSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264SequenceParameterSet(new Uint8Array(StdVideoH264SequenceParameterSet.size));
  }
  
  static create(data: {
    flags: StdVideoH264SpsFlags;
    profile_idc: StdVideoH264ProfileIdc;
    level_idc: StdVideoH264LevelIdc;
    chroma_format_idc: StdVideoH264ChromaFormatIdc;
    seq_parameter_set_id: number;
    bit_depth_luma_minus8: number;
    bit_depth_chroma_minus8: number;
    log2_max_frame_num_minus4: number;
    pic_order_cnt_type: StdVideoH264PocType;
    offset_for_non_ref_pic: number;
    offset_for_top_to_bottom_field: number;
    log2_max_pic_order_cnt_lsb_minus4: number;
    num_ref_frames_in_pic_order_cnt_cycle: number;
    max_num_ref_frames: number;
    reserved1: number;
    pic_width_in_mbs_minus1: number;
    pic_height_in_map_units_minus1: number;
    frame_crop_left_offset: number;
    frame_crop_right_offset: number;
    frame_crop_top_offset: number;
    frame_crop_bottom_offset: number;
    reserved2: number;
    pOffsetForRefFrame: Deno.PointerValue;
    pScalingLists: Deno.PointerValue;
    pSequenceParameterSetVui: Deno.PointerValue;
  }) {
    const s = StdVideoH264SequenceParameterSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.profile_idc !== undefined) s.profile_idc = data.profile_idc;
    if (data.level_idc !== undefined) s.level_idc = data.level_idc;
    if (data.chroma_format_idc !== undefined) s.chroma_format_idc = data.chroma_format_idc;
    if (data.seq_parameter_set_id !== undefined) s.seq_parameter_set_id = data.seq_parameter_set_id;
    if (data.bit_depth_luma_minus8 !== undefined) s.bit_depth_luma_minus8 = data.bit_depth_luma_minus8;
    if (data.bit_depth_chroma_minus8 !== undefined) s.bit_depth_chroma_minus8 = data.bit_depth_chroma_minus8;
    if (data.log2_max_frame_num_minus4 !== undefined) s.log2_max_frame_num_minus4 = data.log2_max_frame_num_minus4;
    if (data.pic_order_cnt_type !== undefined) s.pic_order_cnt_type = data.pic_order_cnt_type;
    if (data.offset_for_non_ref_pic !== undefined) s.offset_for_non_ref_pic = data.offset_for_non_ref_pic;
    if (data.offset_for_top_to_bottom_field !== undefined) s.offset_for_top_to_bottom_field = data.offset_for_top_to_bottom_field;
    if (data.log2_max_pic_order_cnt_lsb_minus4 !== undefined) s.log2_max_pic_order_cnt_lsb_minus4 = data.log2_max_pic_order_cnt_lsb_minus4;
    if (data.num_ref_frames_in_pic_order_cnt_cycle !== undefined) s.num_ref_frames_in_pic_order_cnt_cycle = data.num_ref_frames_in_pic_order_cnt_cycle;
    if (data.max_num_ref_frames !== undefined) s.max_num_ref_frames = data.max_num_ref_frames;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.pic_width_in_mbs_minus1 !== undefined) s.pic_width_in_mbs_minus1 = data.pic_width_in_mbs_minus1;
    if (data.pic_height_in_map_units_minus1 !== undefined) s.pic_height_in_map_units_minus1 = data.pic_height_in_map_units_minus1;
    if (data.frame_crop_left_offset !== undefined) s.frame_crop_left_offset = data.frame_crop_left_offset;
    if (data.frame_crop_right_offset !== undefined) s.frame_crop_right_offset = data.frame_crop_right_offset;
    if (data.frame_crop_top_offset !== undefined) s.frame_crop_top_offset = data.frame_crop_top_offset;
    if (data.frame_crop_bottom_offset !== undefined) s.frame_crop_bottom_offset = data.frame_crop_bottom_offset;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.pOffsetForRefFrame !== undefined) s.pOffsetForRefFrame = data.pOffsetForRefFrame;
    if (data.pScalingLists !== undefined) s.pScalingLists = data.pScalingLists;
    if (data.pSequenceParameterSetVui !== undefined) s.pSequenceParameterSetVui = data.pSequenceParameterSetVui;
    return s;
  }
  
  get flags() {
    return new StdVideoH264SpsFlags(this.#data.subarray(0, 0 + StdVideoH264SpsFlags.size));
  }
  
  set flags(value: StdVideoH264SpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH264SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get profile_idc() {
    return this.#view.getUint32(64, LE);
  }
  
  set profile_idc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get level_idc() {
    return this.#view.getUint32(68, LE);
  }
  
  set level_idc(value: StdVideoH264LevelIdc) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get chroma_format_idc() {
    return this.#view.getUint32(72, LE);
  }
  
  set chroma_format_idc(value: StdVideoH264ChromaFormatIdc) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(76);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(76, Number(value));
  }
  
  get bit_depth_luma_minus8() {
    return this.#view.getUint8(77);
  }
  
  set bit_depth_luma_minus8(value: number) {
    this.#view.setUint8(77, Number(value));
  }
  
  get bit_depth_chroma_minus8() {
    return this.#view.getUint8(78);
  }
  
  set bit_depth_chroma_minus8(value: number) {
    this.#view.setUint8(78, Number(value));
  }
  
  get log2_max_frame_num_minus4() {
    return this.#view.getUint8(79);
  }
  
  set log2_max_frame_num_minus4(value: number) {
    this.#view.setUint8(79, Number(value));
  }
  
  get pic_order_cnt_type() {
    return this.#view.getUint32(80, LE);
  }
  
  set pic_order_cnt_type(value: StdVideoH264PocType) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get offset_for_non_ref_pic() {
    return this.#view.getInt32(84, LE);
  }
  
  set offset_for_non_ref_pic(value: number) {
    this.#view.setInt32(84, Number(value), LE);
  }
  
  get offset_for_top_to_bottom_field() {
    return this.#view.getInt32(88, LE);
  }
  
  set offset_for_top_to_bottom_field(value: number) {
    this.#view.setInt32(88, Number(value), LE);
  }
  
  get log2_max_pic_order_cnt_lsb_minus4() {
    return this.#view.getUint8(92);
  }
  
  set log2_max_pic_order_cnt_lsb_minus4(value: number) {
    this.#view.setUint8(92, Number(value));
  }
  
  get num_ref_frames_in_pic_order_cnt_cycle() {
    return this.#view.getUint8(93);
  }
  
  set num_ref_frames_in_pic_order_cnt_cycle(value: number) {
    this.#view.setUint8(93, Number(value));
  }
  
  get max_num_ref_frames() {
    return this.#view.getUint8(94);
  }
  
  set max_num_ref_frames(value: number) {
    this.#view.setUint8(94, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(95);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(95, Number(value));
  }
  
  get pic_width_in_mbs_minus1() {
    return this.#view.getUint32(96, LE);
  }
  
  set pic_width_in_mbs_minus1(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get pic_height_in_map_units_minus1() {
    return this.#view.getUint32(100, LE);
  }
  
  set pic_height_in_map_units_minus1(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get frame_crop_left_offset() {
    return this.#view.getUint32(104, LE);
  }
  
  set frame_crop_left_offset(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get frame_crop_right_offset() {
    return this.#view.getUint32(108, LE);
  }
  
  set frame_crop_right_offset(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get frame_crop_top_offset() {
    return this.#view.getUint32(112, LE);
  }
  
  set frame_crop_top_offset(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get frame_crop_bottom_offset() {
    return this.#view.getUint32(116, LE);
  }
  
  set frame_crop_bottom_offset(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get reserved2() {
    return this.#view.getUint32(120, LE);
  }
  
  set reserved2(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get pOffsetForRefFrame() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set pOffsetForRefFrame(value: Deno.PointerValue) {
    this.#view.setBigUint64(128, BigInt(value), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(136, LE);
  }
  
  set pScalingLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(136, BigInt(value), LE);
  }
  
  get pSequenceParameterSetVui() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set pSequenceParameterSetVui(value: Deno.PointerValue) {
    this.#view.setBigUint64(144, BigInt(value), LE);
  }
}

export class StdVideoH264PpsFlags implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264PpsFlags(new Uint8Array(StdVideoH264PpsFlags.size));
  }
  
  static create(data: {
    transform_8x8_mode_flag: number;
    redundant_pic_cnt_present_flag: number;
    constrained_intra_pred_flag: number;
    deblocking_filter_control_present_flag: number;
    weighted_pred_flag: number;
    bottom_field_pic_order_in_frame_present_flag: number;
    entropy_coding_mode_flag: number;
    pic_scaling_matrix_present_flag: number;
  }) {
    const s = StdVideoH264PpsFlags.alloc();
    if (data.transform_8x8_mode_flag !== undefined) s.transform_8x8_mode_flag = data.transform_8x8_mode_flag;
    if (data.redundant_pic_cnt_present_flag !== undefined) s.redundant_pic_cnt_present_flag = data.redundant_pic_cnt_present_flag;
    if (data.constrained_intra_pred_flag !== undefined) s.constrained_intra_pred_flag = data.constrained_intra_pred_flag;
    if (data.deblocking_filter_control_present_flag !== undefined) s.deblocking_filter_control_present_flag = data.deblocking_filter_control_present_flag;
    if (data.weighted_pred_flag !== undefined) s.weighted_pred_flag = data.weighted_pred_flag;
    if (data.bottom_field_pic_order_in_frame_present_flag !== undefined) s.bottom_field_pic_order_in_frame_present_flag = data.bottom_field_pic_order_in_frame_present_flag;
    if (data.entropy_coding_mode_flag !== undefined) s.entropy_coding_mode_flag = data.entropy_coding_mode_flag;
    if (data.pic_scaling_matrix_present_flag !== undefined) s.pic_scaling_matrix_present_flag = data.pic_scaling_matrix_present_flag;
    return s;
  }
  
  get transform_8x8_mode_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set transform_8x8_mode_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get redundant_pic_cnt_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set redundant_pic_cnt_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get constrained_intra_pred_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set constrained_intra_pred_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deblocking_filter_control_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set deblocking_filter_control_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get weighted_pred_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set weighted_pred_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bottom_field_pic_order_in_frame_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set bottom_field_pic_order_in_frame_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get entropy_coding_mode_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set entropy_coding_mode_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pic_scaling_matrix_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set pic_scaling_matrix_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class StdVideoH264PictureParameterSet implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH264PictureParameterSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH264PictureParameterSet(new Uint8Array(StdVideoH264PictureParameterSet.size));
  }
  
  static create(data: {
    flags: StdVideoH264PpsFlags;
    seq_parameter_set_id: number;
    pic_parameter_set_id: number;
    num_ref_idx_l0_default_active_minus1: number;
    num_ref_idx_l1_default_active_minus1: number;
    weighted_bipred_idc: StdVideoH264WeightedBipredIdc;
    pic_init_qp_minus26: number;
    pic_init_qs_minus26: number;
    chroma_qp_index_offset: number;
    second_chroma_qp_index_offset: number;
    pScalingLists: Deno.PointerValue;
  }) {
    const s = StdVideoH264PictureParameterSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.seq_parameter_set_id !== undefined) s.seq_parameter_set_id = data.seq_parameter_set_id;
    if (data.pic_parameter_set_id !== undefined) s.pic_parameter_set_id = data.pic_parameter_set_id;
    if (data.num_ref_idx_l0_default_active_minus1 !== undefined) s.num_ref_idx_l0_default_active_minus1 = data.num_ref_idx_l0_default_active_minus1;
    if (data.num_ref_idx_l1_default_active_minus1 !== undefined) s.num_ref_idx_l1_default_active_minus1 = data.num_ref_idx_l1_default_active_minus1;
    if (data.weighted_bipred_idc !== undefined) s.weighted_bipred_idc = data.weighted_bipred_idc;
    if (data.pic_init_qp_minus26 !== undefined) s.pic_init_qp_minus26 = data.pic_init_qp_minus26;
    if (data.pic_init_qs_minus26 !== undefined) s.pic_init_qs_minus26 = data.pic_init_qs_minus26;
    if (data.chroma_qp_index_offset !== undefined) s.chroma_qp_index_offset = data.chroma_qp_index_offset;
    if (data.second_chroma_qp_index_offset !== undefined) s.second_chroma_qp_index_offset = data.second_chroma_qp_index_offset;
    if (data.pScalingLists !== undefined) s.pScalingLists = data.pScalingLists;
    return s;
  }
  
  get flags() {
    return new StdVideoH264PpsFlags(this.#data.subarray(0, 0 + StdVideoH264PpsFlags.size));
  }
  
  set flags(value: StdVideoH264PpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH264PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(32);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(33);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(33, Number(value));
  }
  
  get num_ref_idx_l0_default_active_minus1() {
    return this.#view.getUint8(34);
  }
  
  set num_ref_idx_l0_default_active_minus1(value: number) {
    this.#view.setUint8(34, Number(value));
  }
  
  get num_ref_idx_l1_default_active_minus1() {
    return this.#view.getUint8(35);
  }
  
  set num_ref_idx_l1_default_active_minus1(value: number) {
    this.#view.setUint8(35, Number(value));
  }
  
  get weighted_bipred_idc() {
    return this.#view.getUint32(36, LE);
  }
  
  set weighted_bipred_idc(value: StdVideoH264WeightedBipredIdc) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pic_init_qp_minus26() {
    return this.#view.getInt8(40);
  }
  
  set pic_init_qp_minus26(value: number) {
    this.#view.setInt8(40, Number(value));
  }
  
  get pic_init_qs_minus26() {
    return this.#view.getInt8(41);
  }
  
  set pic_init_qs_minus26(value: number) {
    this.#view.setInt8(41, Number(value));
  }
  
  get chroma_qp_index_offset() {
    return this.#view.getInt8(42);
  }
  
  set chroma_qp_index_offset(value: number) {
    this.#view.setInt8(42, Number(value));
  }
  
  get second_chroma_qp_index_offset() {
    return this.#view.getInt8(43);
  }
  
  set second_chroma_qp_index_offset(value: number) {
    this.#view.setInt8(43, Number(value));
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pScalingLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class StdVideoDecodeH264PictureInfoFlags implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH264PictureInfoFlags(new Uint8Array(StdVideoDecodeH264PictureInfoFlags.size));
  }
  
  static create(data: {
    field_pic_flag: number;
    is_intra: number;
    IdrPicFlag: number;
    bottom_field_flag: number;
    is_reference: number;
    complementary_field_pair: number;
  }) {
    const s = StdVideoDecodeH264PictureInfoFlags.alloc();
    if (data.field_pic_flag !== undefined) s.field_pic_flag = data.field_pic_flag;
    if (data.is_intra !== undefined) s.is_intra = data.is_intra;
    if (data.IdrPicFlag !== undefined) s.IdrPicFlag = data.IdrPicFlag;
    if (data.bottom_field_flag !== undefined) s.bottom_field_flag = data.bottom_field_flag;
    if (data.is_reference !== undefined) s.is_reference = data.is_reference;
    if (data.complementary_field_pair !== undefined) s.complementary_field_pair = data.complementary_field_pair;
    return s;
  }
  
  get field_pic_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set field_pic_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get is_intra() {
    return this.#view.getUint32(4, LE);
  }
  
  set is_intra(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get IdrPicFlag() {
    return this.#view.getUint32(8, LE);
  }
  
  set IdrPicFlag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bottom_field_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set bottom_field_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get is_reference() {
    return this.#view.getUint32(16, LE);
  }
  
  set is_reference(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get complementary_field_pair() {
    return this.#view.getUint32(20, LE);
  }
  
  set complementary_field_pair(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

/** requires tag is for PicOrderCnt, which needs the enum type */
export class StdVideoDecodeH264PictureInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH264PictureInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH264PictureInfo(new Uint8Array(StdVideoDecodeH264PictureInfo.size));
  }
  
  static create(data: {
    flags: StdVideoDecodeH264PictureInfoFlags;
    seq_parameter_set_id: number;
    pic_parameter_set_id: number;
    reserved1: number;
    reserved2: number;
    frame_num: number;
    idr_pic_id: number;
    PicOrderCnt: number;
  }) {
    const s = StdVideoDecodeH264PictureInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.seq_parameter_set_id !== undefined) s.seq_parameter_set_id = data.seq_parameter_set_id;
    if (data.pic_parameter_set_id !== undefined) s.pic_parameter_set_id = data.pic_parameter_set_id;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.frame_num !== undefined) s.frame_num = data.frame_num;
    if (data.idr_pic_id !== undefined) s.idr_pic_id = data.idr_pic_id;
    if (data.PicOrderCnt !== undefined) s.PicOrderCnt = data.PicOrderCnt;
    return s;
  }
  
  get flags() {
    return new StdVideoDecodeH264PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH264PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH264PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(24);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(25);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(26);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(27);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(27, Number(value));
  }
  
  get frame_num() {
    return this.#view.getUint16(28, LE);
  }
  
  set frame_num(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
  
  get idr_pic_id() {
    return this.#view.getUint16(30, LE);
  }
  
  set idr_pic_id(value: number) {
    this.#view.setUint16(30, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(32, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
}

export class StdVideoDecodeH264ReferenceInfoFlags implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH264ReferenceInfoFlags(new Uint8Array(StdVideoDecodeH264ReferenceInfoFlags.size));
  }
  
  static create(data: {
    top_field_flag: number;
    bottom_field_flag: number;
    used_for_long_term_reference: number;
    is_non_existing: number;
  }) {
    const s = StdVideoDecodeH264ReferenceInfoFlags.alloc();
    if (data.top_field_flag !== undefined) s.top_field_flag = data.top_field_flag;
    if (data.bottom_field_flag !== undefined) s.bottom_field_flag = data.bottom_field_flag;
    if (data.used_for_long_term_reference !== undefined) s.used_for_long_term_reference = data.used_for_long_term_reference;
    if (data.is_non_existing !== undefined) s.is_non_existing = data.is_non_existing;
    return s;
  }
  
  get top_field_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set top_field_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get bottom_field_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set bottom_field_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(8, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get is_non_existing() {
    return this.#view.getUint32(12, LE);
  }
  
  set is_non_existing(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class StdVideoDecodeH264ReferenceInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH264ReferenceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH264ReferenceInfo(new Uint8Array(StdVideoDecodeH264ReferenceInfo.size));
  }
  
  static create(data: {
    flags: StdVideoDecodeH264ReferenceInfoFlags;
    FrameNum: number;
    reserved: number;
    PicOrderCnt: number;
  }) {
    const s = StdVideoDecodeH264ReferenceInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.FrameNum !== undefined) s.FrameNum = data.FrameNum;
    if (data.reserved !== undefined) s.reserved = data.reserved;
    if (data.PicOrderCnt !== undefined) s.PicOrderCnt = data.PicOrderCnt;
    return s;
  }
  
  get flags() {
    return new StdVideoDecodeH264ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH264ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH264ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get FrameNum() {
    return this.#view.getUint16(16, LE);
  }
  
  set FrameNum(value: number) {
    this.#view.setUint16(16, Number(value), LE);
  }
  
  get reserved() {
    return this.#view.getUint16(18, LE);
  }
  
  set reserved(value: number) {
    this.#view.setUint16(18, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(20, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(20, Number(value), LE);
  }
}

export class StdVideoEncodeH264WeightTableFlags implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264WeightTableFlags(new Uint8Array(StdVideoEncodeH264WeightTableFlags.size));
  }
  
  static create(data: {
    luma_weight_l0_flag: number;
    chroma_weight_l0_flag: number;
    luma_weight_l1_flag: number;
    chroma_weight_l1_flag: number;
  }) {
    const s = StdVideoEncodeH264WeightTableFlags.alloc();
    if (data.luma_weight_l0_flag !== undefined) s.luma_weight_l0_flag = data.luma_weight_l0_flag;
    if (data.chroma_weight_l0_flag !== undefined) s.chroma_weight_l0_flag = data.chroma_weight_l0_flag;
    if (data.luma_weight_l1_flag !== undefined) s.luma_weight_l1_flag = data.luma_weight_l1_flag;
    if (data.chroma_weight_l1_flag !== undefined) s.chroma_weight_l1_flag = data.chroma_weight_l1_flag;
    return s;
  }
  
  get luma_weight_l0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set luma_weight_l0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get chroma_weight_l0_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set chroma_weight_l0_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get luma_weight_l1_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set luma_weight_l1_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get chroma_weight_l1_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set chroma_weight_l1_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class StdVideoEncodeH264WeightTable implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264WeightTable.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264WeightTable(new Uint8Array(StdVideoEncodeH264WeightTable.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH264WeightTableFlags;
    luma_log2_weight_denom: number;
    chroma_log2_weight_denom: number;
    luma_weight_l0: number;
    luma_offset_l0: number;
    chroma_weight_l0: number;
    chroma_offset_l0: number;
    luma_weight_l1: number;
    luma_offset_l1: number;
    chroma_weight_l1: number;
    chroma_offset_l1: number;
  }) {
    const s = StdVideoEncodeH264WeightTable.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.luma_log2_weight_denom !== undefined) s.luma_log2_weight_denom = data.luma_log2_weight_denom;
    if (data.chroma_log2_weight_denom !== undefined) s.chroma_log2_weight_denom = data.chroma_log2_weight_denom;
    if (data.luma_weight_l0 !== undefined) s.luma_weight_l0 = data.luma_weight_l0;
    if (data.luma_offset_l0 !== undefined) s.luma_offset_l0 = data.luma_offset_l0;
    if (data.chroma_weight_l0 !== undefined) s.chroma_weight_l0 = data.chroma_weight_l0;
    if (data.chroma_offset_l0 !== undefined) s.chroma_offset_l0 = data.chroma_offset_l0;
    if (data.luma_weight_l1 !== undefined) s.luma_weight_l1 = data.luma_weight_l1;
    if (data.luma_offset_l1 !== undefined) s.luma_offset_l1 = data.luma_offset_l1;
    if (data.chroma_weight_l1 !== undefined) s.chroma_weight_l1 = data.chroma_weight_l1;
    if (data.chroma_offset_l1 !== undefined) s.chroma_offset_l1 = data.chroma_offset_l1;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH264WeightTableFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264WeightTableFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264WeightTableFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get luma_log2_weight_denom() {
    return this.#view.getUint8(16);
  }
  
  set luma_log2_weight_denom(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get chroma_log2_weight_denom() {
    return this.#view.getUint8(17);
  }
  
  set chroma_log2_weight_denom(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get luma_weight_l0() {
    return this.#view.getInt8(18);
  }
  
  set luma_weight_l0(value: number) {
    this.#view.setInt8(18, Number(value));
  }
  
  get luma_offset_l0() {
    return this.#view.getInt8(19);
  }
  
  set luma_offset_l0(value: number) {
    this.#view.setInt8(19, Number(value));
  }
  
  get chroma_weight_l0() {
    return this.#view.getInt8(20);
  }
  
  set chroma_weight_l0(value: number) {
    this.#view.setInt8(20, Number(value));
  }
  
  get chroma_offset_l0() {
    return this.#view.getInt8(21);
  }
  
  set chroma_offset_l0(value: number) {
    this.#view.setInt8(21, Number(value));
  }
  
  get luma_weight_l1() {
    return this.#view.getInt8(22);
  }
  
  set luma_weight_l1(value: number) {
    this.#view.setInt8(22, Number(value));
  }
  
  get luma_offset_l1() {
    return this.#view.getInt8(23);
  }
  
  set luma_offset_l1(value: number) {
    this.#view.setInt8(23, Number(value));
  }
  
  get chroma_weight_l1() {
    return this.#view.getInt8(24);
  }
  
  set chroma_weight_l1(value: number) {
    this.#view.setInt8(24, Number(value));
  }
  
  get chroma_offset_l1() {
    return this.#view.getInt8(25);
  }
  
  set chroma_offset_l1(value: number) {
    this.#view.setInt8(25, Number(value));
  }
}

export class StdVideoEncodeH264SliceHeaderFlags implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264SliceHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264SliceHeaderFlags(new Uint8Array(StdVideoEncodeH264SliceHeaderFlags.size));
  }
  
  static create(data: {
    direct_spatial_mv_pred_flag: number;
    num_ref_idx_active_override_flag: number;
    no_output_of_prior_pics_flag: number;
    adaptive_ref_pic_marking_mode_flag: number;
    no_prior_references_available_flag: number;
  }) {
    const s = StdVideoEncodeH264SliceHeaderFlags.alloc();
    if (data.direct_spatial_mv_pred_flag !== undefined) s.direct_spatial_mv_pred_flag = data.direct_spatial_mv_pred_flag;
    if (data.num_ref_idx_active_override_flag !== undefined) s.num_ref_idx_active_override_flag = data.num_ref_idx_active_override_flag;
    if (data.no_output_of_prior_pics_flag !== undefined) s.no_output_of_prior_pics_flag = data.no_output_of_prior_pics_flag;
    if (data.adaptive_ref_pic_marking_mode_flag !== undefined) s.adaptive_ref_pic_marking_mode_flag = data.adaptive_ref_pic_marking_mode_flag;
    if (data.no_prior_references_available_flag !== undefined) s.no_prior_references_available_flag = data.no_prior_references_available_flag;
    return s;
  }
  
  get direct_spatial_mv_pred_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set direct_spatial_mv_pred_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get num_ref_idx_active_override_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set num_ref_idx_active_override_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get no_output_of_prior_pics_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set no_output_of_prior_pics_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get adaptive_ref_pic_marking_mode_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set adaptive_ref_pic_marking_mode_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get no_prior_references_available_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set no_prior_references_available_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class StdVideoEncodeH264PictureInfoFlags implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264PictureInfoFlags(new Uint8Array(StdVideoEncodeH264PictureInfoFlags.size));
  }
  
  static create(data: {
    idr_flag: number;
    is_reference_flag: number;
    used_for_long_term_reference: number;
  }) {
    const s = StdVideoEncodeH264PictureInfoFlags.alloc();
    if (data.idr_flag !== undefined) s.idr_flag = data.idr_flag;
    if (data.is_reference_flag !== undefined) s.is_reference_flag = data.is_reference_flag;
    if (data.used_for_long_term_reference !== undefined) s.used_for_long_term_reference = data.used_for_long_term_reference;
    return s;
  }
  
  get idr_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set idr_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get is_reference_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set is_reference_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(8, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class StdVideoEncodeH264ReferenceInfoFlags implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264ReferenceInfoFlags(new Uint8Array(StdVideoEncodeH264ReferenceInfoFlags.size));
  }
  
  static create(data: {
    used_for_long_term_reference: number;
  }) {
    const s = StdVideoEncodeH264ReferenceInfoFlags.alloc();
    if (data.used_for_long_term_reference !== undefined) s.used_for_long_term_reference = data.used_for_long_term_reference;
    return s;
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export class StdVideoEncodeH264RefMgmtFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264RefMgmtFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264RefMgmtFlags(new Uint8Array(StdVideoEncodeH264RefMgmtFlags.size));
  }
  
  static create(data: {
    ref_pic_list_modification_l0_flag: number;
    ref_pic_list_modification_l1_flag: number;
  }) {
    const s = StdVideoEncodeH264RefMgmtFlags.alloc();
    if (data.ref_pic_list_modification_l0_flag !== undefined) s.ref_pic_list_modification_l0_flag = data.ref_pic_list_modification_l0_flag;
    if (data.ref_pic_list_modification_l1_flag !== undefined) s.ref_pic_list_modification_l1_flag = data.ref_pic_list_modification_l1_flag;
    return s;
  }
  
  get ref_pic_list_modification_l0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set ref_pic_list_modification_l0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get ref_pic_list_modification_l1_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set ref_pic_list_modification_l1_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoEncodeH264RefListModEntry implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264RefListModEntry.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264RefListModEntry(new Uint8Array(StdVideoEncodeH264RefListModEntry.size));
  }
  
  static create(data: {
    modification_of_pic_nums_idc: StdVideoH264ModificationOfPicNumsIdc;
    abs_diff_pic_num_minus1: number;
    long_term_pic_num: number;
  }) {
    const s = StdVideoEncodeH264RefListModEntry.alloc();
    if (data.modification_of_pic_nums_idc !== undefined) s.modification_of_pic_nums_idc = data.modification_of_pic_nums_idc;
    if (data.abs_diff_pic_num_minus1 !== undefined) s.abs_diff_pic_num_minus1 = data.abs_diff_pic_num_minus1;
    if (data.long_term_pic_num !== undefined) s.long_term_pic_num = data.long_term_pic_num;
    return s;
  }
  
  get modification_of_pic_nums_idc() {
    return this.#view.getUint32(0, LE);
  }
  
  set modification_of_pic_nums_idc(value: StdVideoH264ModificationOfPicNumsIdc) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get abs_diff_pic_num_minus1() {
    return this.#view.getUint16(4, LE);
  }
  
  set abs_diff_pic_num_minus1(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(6, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export class StdVideoEncodeH264RefPicMarkingEntry implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264RefPicMarkingEntry.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264RefPicMarkingEntry(new Uint8Array(StdVideoEncodeH264RefPicMarkingEntry.size));
  }
  
  static create(data: {
    operation: StdVideoH264MemMgmtControlOp;
    difference_of_pic_nums_minus1: number;
    long_term_pic_num: number;
    long_term_frame_idx: number;
    max_long_term_frame_idx_plus1: number;
  }) {
    const s = StdVideoEncodeH264RefPicMarkingEntry.alloc();
    if (data.operation !== undefined) s.operation = data.operation;
    if (data.difference_of_pic_nums_minus1 !== undefined) s.difference_of_pic_nums_minus1 = data.difference_of_pic_nums_minus1;
    if (data.long_term_pic_num !== undefined) s.long_term_pic_num = data.long_term_pic_num;
    if (data.long_term_frame_idx !== undefined) s.long_term_frame_idx = data.long_term_frame_idx;
    if (data.max_long_term_frame_idx_plus1 !== undefined) s.max_long_term_frame_idx_plus1 = data.max_long_term_frame_idx_plus1;
    return s;
  }
  
  get operation() {
    return this.#view.getUint32(0, LE);
  }
  
  set operation(value: StdVideoH264MemMgmtControlOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get difference_of_pic_nums_minus1() {
    return this.#view.getUint16(4, LE);
  }
  
  set difference_of_pic_nums_minus1(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(6, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
  
  get long_term_frame_idx() {
    return this.#view.getUint16(8, LE);
  }
  
  set long_term_frame_idx(value: number) {
    this.#view.setUint16(8, Number(value), LE);
  }
  
  get max_long_term_frame_idx_plus1() {
    return this.#view.getUint16(10, LE);
  }
  
  set max_long_term_frame_idx_plus1(value: number) {
    this.#view.setUint16(10, Number(value), LE);
  }
}

export class StdVideoEncodeH264RefMemMgmtCtrlOperations implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264RefMemMgmtCtrlOperations.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264RefMemMgmtCtrlOperations(new Uint8Array(StdVideoEncodeH264RefMemMgmtCtrlOperations.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH264RefMgmtFlags;
    refList0ModOpCount: number;
    pRefList0ModOperations: Deno.PointerValue;
    refList1ModOpCount: number;
    pRefList1ModOperations: Deno.PointerValue;
    refPicMarkingOpCount: number;
    pRefPicMarkingOperations: Deno.PointerValue;
  }) {
    const s = StdVideoEncodeH264RefMemMgmtCtrlOperations.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.refList0ModOpCount !== undefined) s.refList0ModOpCount = data.refList0ModOpCount;
    if (data.pRefList0ModOperations !== undefined) s.pRefList0ModOperations = data.pRefList0ModOperations;
    if (data.refList1ModOpCount !== undefined) s.refList1ModOpCount = data.refList1ModOpCount;
    if (data.pRefList1ModOperations !== undefined) s.pRefList1ModOperations = data.pRefList1ModOperations;
    if (data.refPicMarkingOpCount !== undefined) s.refPicMarkingOpCount = data.refPicMarkingOpCount;
    if (data.pRefPicMarkingOperations !== undefined) s.pRefPicMarkingOperations = data.pRefPicMarkingOperations;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH264RefMgmtFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264RefMgmtFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264RefMgmtFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264RefMgmtFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get refList0ModOpCount() {
    return this.#view.getUint8(8);
  }
  
  set refList0ModOpCount(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get pRefList0ModOperations() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pRefList0ModOperations(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get refList1ModOpCount() {
    return this.#view.getUint8(24);
  }
  
  set refList1ModOpCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pRefList1ModOperations() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pRefList1ModOperations(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get refPicMarkingOpCount() {
    return this.#view.getUint8(40);
  }
  
  set refPicMarkingOpCount(value: number) {
    this.#view.setUint8(40, Number(value));
  }
  
  get pRefPicMarkingOperations() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRefPicMarkingOperations(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class StdVideoEncodeH264PictureInfo implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264PictureInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264PictureInfo(new Uint8Array(StdVideoEncodeH264PictureInfo.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH264PictureInfoFlags;
    seq_parameter_set_id: number;
    pic_parameter_set_id: number;
    pictureType: StdVideoH264PictureType;
    frame_num: number;
    PicOrderCnt: number;
  }) {
    const s = StdVideoEncodeH264PictureInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.seq_parameter_set_id !== undefined) s.seq_parameter_set_id = data.seq_parameter_set_id;
    if (data.pic_parameter_set_id !== undefined) s.pic_parameter_set_id = data.pic_parameter_set_id;
    if (data.pictureType !== undefined) s.pictureType = data.pictureType;
    if (data.frame_num !== undefined) s.frame_num = data.frame_num;
    if (data.PicOrderCnt !== undefined) s.PicOrderCnt = data.PicOrderCnt;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH264PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(12);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(12, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(13);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(13, Number(value));
  }
  
  get pictureType() {
    return this.#view.getUint32(16, LE);
  }
  
  set pictureType(value: StdVideoH264PictureType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get frame_num() {
    return this.#view.getUint32(20, LE);
  }
  
  set frame_num(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(24, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(24, Number(value), LE);
  }
}

export class StdVideoEncodeH264ReferenceInfo implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264ReferenceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264ReferenceInfo(new Uint8Array(StdVideoEncodeH264ReferenceInfo.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH264ReferenceInfoFlags;
    FrameNum: number;
    PicOrderCnt: number;
    long_term_pic_num: number;
    long_term_frame_idx: number;
  }) {
    const s = StdVideoEncodeH264ReferenceInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.FrameNum !== undefined) s.FrameNum = data.FrameNum;
    if (data.PicOrderCnt !== undefined) s.PicOrderCnt = data.PicOrderCnt;
    if (data.long_term_pic_num !== undefined) s.long_term_pic_num = data.long_term_pic_num;
    if (data.long_term_frame_idx !== undefined) s.long_term_frame_idx = data.long_term_frame_idx;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH264ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get FrameNum() {
    return this.#view.getUint32(4, LE);
  }
  
  set FrameNum(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(12, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(12, Number(value), LE);
  }
  
  get long_term_frame_idx() {
    return this.#view.getUint16(14, LE);
  }
  
  set long_term_frame_idx(value: number) {
    this.#view.setUint16(14, Number(value), LE);
  }
}

export class StdVideoEncodeH264SliceHeader implements IVkStructure {
  static size = 60;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH264SliceHeader.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH264SliceHeader(new Uint8Array(StdVideoEncodeH264SliceHeader.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH264SliceHeaderFlags;
    first_mb_in_slice: number;
    slice_type: StdVideoH264SliceType;
    idr_pic_id: number;
    num_ref_idx_l0_active_minus1: number;
    num_ref_idx_l1_active_minus1: number;
    cabac_init_idc: StdVideoH264CabacInitIdc;
    disable_deblocking_filter_idc: StdVideoH264DisableDeblockingFilterIdc;
    slice_alpha_c0_offset_div2: number;
    slice_beta_offset_div2: number;
    pWeightTable: Deno.PointerValue;
  }) {
    const s = StdVideoEncodeH264SliceHeader.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.first_mb_in_slice !== undefined) s.first_mb_in_slice = data.first_mb_in_slice;
    if (data.slice_type !== undefined) s.slice_type = data.slice_type;
    if (data.idr_pic_id !== undefined) s.idr_pic_id = data.idr_pic_id;
    if (data.num_ref_idx_l0_active_minus1 !== undefined) s.num_ref_idx_l0_active_minus1 = data.num_ref_idx_l0_active_minus1;
    if (data.num_ref_idx_l1_active_minus1 !== undefined) s.num_ref_idx_l1_active_minus1 = data.num_ref_idx_l1_active_minus1;
    if (data.cabac_init_idc !== undefined) s.cabac_init_idc = data.cabac_init_idc;
    if (data.disable_deblocking_filter_idc !== undefined) s.disable_deblocking_filter_idc = data.disable_deblocking_filter_idc;
    if (data.slice_alpha_c0_offset_div2 !== undefined) s.slice_alpha_c0_offset_div2 = data.slice_alpha_c0_offset_div2;
    if (data.slice_beta_offset_div2 !== undefined) s.slice_beta_offset_div2 = data.slice_beta_offset_div2;
    if (data.pWeightTable !== undefined) s.pWeightTable = data.pWeightTable;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH264SliceHeaderFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264SliceHeaderFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264SliceHeaderFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264SliceHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get first_mb_in_slice() {
    return this.#view.getUint32(20, LE);
  }
  
  set first_mb_in_slice(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get slice_type() {
    return this.#view.getUint32(24, LE);
  }
  
  set slice_type(value: StdVideoH264SliceType) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get idr_pic_id() {
    return this.#view.getUint16(28, LE);
  }
  
  set idr_pic_id(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
  
  get num_ref_idx_l0_active_minus1() {
    return this.#view.getUint8(30);
  }
  
  set num_ref_idx_l0_active_minus1(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get num_ref_idx_l1_active_minus1() {
    return this.#view.getUint8(31);
  }
  
  set num_ref_idx_l1_active_minus1(value: number) {
    this.#view.setUint8(31, Number(value));
  }
  
  get cabac_init_idc() {
    return this.#view.getUint32(32, LE);
  }
  
  set cabac_init_idc(value: StdVideoH264CabacInitIdc) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get disable_deblocking_filter_idc() {
    return this.#view.getUint32(36, LE);
  }
  
  set disable_deblocking_filter_idc(value: StdVideoH264DisableDeblockingFilterIdc) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get slice_alpha_c0_offset_div2() {
    return this.#view.getInt8(40);
  }
  
  set slice_alpha_c0_offset_div2(value: number) {
    this.#view.setInt8(40, Number(value));
  }
  
  get slice_beta_offset_div2() {
    return this.#view.getInt8(41);
  }
  
  set slice_beta_offset_div2(value: number) {
    this.#view.setInt8(41, Number(value));
  }
  
  get pWeightTable() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pWeightTable(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class StdVideoH265ProfileTierLevelFlags implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265ProfileTierLevelFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265ProfileTierLevelFlags(new Uint8Array(StdVideoH265ProfileTierLevelFlags.size));
  }
  
  static create(data: {
    general_tier_flag: number;
    general_progressive_source_flag: number;
    general_interlaced_source_flag: number;
    general_non_packed_constraint_flag: number;
    general_frame_only_constraint_flag: number;
  }) {
    const s = StdVideoH265ProfileTierLevelFlags.alloc();
    if (data.general_tier_flag !== undefined) s.general_tier_flag = data.general_tier_flag;
    if (data.general_progressive_source_flag !== undefined) s.general_progressive_source_flag = data.general_progressive_source_flag;
    if (data.general_interlaced_source_flag !== undefined) s.general_interlaced_source_flag = data.general_interlaced_source_flag;
    if (data.general_non_packed_constraint_flag !== undefined) s.general_non_packed_constraint_flag = data.general_non_packed_constraint_flag;
    if (data.general_frame_only_constraint_flag !== undefined) s.general_frame_only_constraint_flag = data.general_frame_only_constraint_flag;
    return s;
  }
  
  get general_tier_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set general_tier_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get general_progressive_source_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set general_progressive_source_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get general_interlaced_source_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set general_interlaced_source_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get general_non_packed_constraint_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set general_non_packed_constraint_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get general_frame_only_constraint_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set general_frame_only_constraint_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

/** profile_tier_level */
export class StdVideoH265ProfileTierLevel implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265ProfileTierLevel.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265ProfileTierLevel(new Uint8Array(StdVideoH265ProfileTierLevel.size));
  }
  
  static create(data: {
    flags: StdVideoH265ProfileTierLevelFlags;
    general_profile_idc: StdVideoH265ProfileIdc;
    general_level_idc: StdVideoH265LevelIdc;
  }) {
    const s = StdVideoH265ProfileTierLevel.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.general_profile_idc !== undefined) s.general_profile_idc = data.general_profile_idc;
    if (data.general_level_idc !== undefined) s.general_level_idc = data.general_level_idc;
    return s;
  }
  
  get flags() {
    return new StdVideoH265ProfileTierLevelFlags(this.#data.subarray(0, 0 + StdVideoH265ProfileTierLevelFlags.size));
  }
  
  set flags(value: StdVideoH265ProfileTierLevelFlags) {
    if (value[BUFFER].byteLength < StdVideoH265ProfileTierLevelFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get general_profile_idc() {
    return this.#view.getUint32(20, LE);
  }
  
  set general_profile_idc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get general_level_idc() {
    return this.#view.getUint32(24, LE);
  }
  
  set general_level_idc(value: StdVideoH265LevelIdc) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

/** sps_ or vps_ parameters, based on if the StdVideoH265DecPicBufMgr is used within the StdVideoH265SequenceParameterSet or StdVideoH265VideoParameterSet */
export class StdVideoH265DecPicBufMgr implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265DecPicBufMgr.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265DecPicBufMgr(new Uint8Array(StdVideoH265DecPicBufMgr.size));
  }
  
  static create(data: {
    max_latency_increase_plus1: number;
    max_dec_pic_buffering_minus1: number;
    max_num_reorder_pics: number;
  }) {
    const s = StdVideoH265DecPicBufMgr.alloc();
    if (data.max_latency_increase_plus1 !== undefined) s.max_latency_increase_plus1 = data.max_latency_increase_plus1;
    if (data.max_dec_pic_buffering_minus1 !== undefined) s.max_dec_pic_buffering_minus1 = data.max_dec_pic_buffering_minus1;
    if (data.max_num_reorder_pics !== undefined) s.max_num_reorder_pics = data.max_num_reorder_pics;
    return s;
  }
  
  get max_latency_increase_plus1() {
    return this.#view.getUint32(0, LE);
  }
  
  set max_latency_increase_plus1(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get max_dec_pic_buffering_minus1() {
    return this.#view.getUint8(4);
  }
  
  set max_dec_pic_buffering_minus1(value: number) {
    this.#view.setUint8(4, Number(value));
  }
  
  get max_num_reorder_pics() {
    return this.#view.getUint8(5);
  }
  
  set max_num_reorder_pics(value: number) {
    this.#view.setUint8(5, Number(value));
  }
}

/** sub_layer_hrd_parameters */
export class StdVideoH265SubLayerHrdParameters implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265SubLayerHrdParameters.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265SubLayerHrdParameters(new Uint8Array(StdVideoH265SubLayerHrdParameters.size));
  }
  
  static create(data: {
    bit_rate_value_minus1: number;
    cpb_size_value_minus1: number;
    cpb_size_du_value_minus1: number;
    bit_rate_du_value_minus1: number;
    cbr_flag: number;
  }) {
    const s = StdVideoH265SubLayerHrdParameters.alloc();
    if (data.bit_rate_value_minus1 !== undefined) s.bit_rate_value_minus1 = data.bit_rate_value_minus1;
    if (data.cpb_size_value_minus1 !== undefined) s.cpb_size_value_minus1 = data.cpb_size_value_minus1;
    if (data.cpb_size_du_value_minus1 !== undefined) s.cpb_size_du_value_minus1 = data.cpb_size_du_value_minus1;
    if (data.bit_rate_du_value_minus1 !== undefined) s.bit_rate_du_value_minus1 = data.bit_rate_du_value_minus1;
    if (data.cbr_flag !== undefined) s.cbr_flag = data.cbr_flag;
    return s;
  }
  
  get bit_rate_value_minus1() {
    return this.#view.getUint32(0, LE);
  }
  
  set bit_rate_value_minus1(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get cpb_size_value_minus1() {
    return this.#view.getUint32(4, LE);
  }
  
  set cpb_size_value_minus1(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get cpb_size_du_value_minus1() {
    return this.#view.getUint32(8, LE);
  }
  
  set cpb_size_du_value_minus1(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bit_rate_du_value_minus1() {
    return this.#view.getUint32(12, LE);
  }
  
  set bit_rate_du_value_minus1(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get cbr_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set cbr_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class StdVideoH265HrdFlags implements IVkStructure {
  static size = 28;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265HrdFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265HrdFlags(new Uint8Array(StdVideoH265HrdFlags.size));
  }
  
  static create(data: {
    nal_hrd_parameters_present_flag: number;
    vcl_hrd_parameters_present_flag: number;
    sub_pic_hrd_params_present_flag: number;
    sub_pic_cpb_params_in_pic_timing_sei_flag: number;
    fixed_pic_rate_general_flag: number;
    fixed_pic_rate_within_cvs_flag: number;
    low_delay_hrd_flag: number;
  }) {
    const s = StdVideoH265HrdFlags.alloc();
    if (data.nal_hrd_parameters_present_flag !== undefined) s.nal_hrd_parameters_present_flag = data.nal_hrd_parameters_present_flag;
    if (data.vcl_hrd_parameters_present_flag !== undefined) s.vcl_hrd_parameters_present_flag = data.vcl_hrd_parameters_present_flag;
    if (data.sub_pic_hrd_params_present_flag !== undefined) s.sub_pic_hrd_params_present_flag = data.sub_pic_hrd_params_present_flag;
    if (data.sub_pic_cpb_params_in_pic_timing_sei_flag !== undefined) s.sub_pic_cpb_params_in_pic_timing_sei_flag = data.sub_pic_cpb_params_in_pic_timing_sei_flag;
    if (data.fixed_pic_rate_general_flag !== undefined) s.fixed_pic_rate_general_flag = data.fixed_pic_rate_general_flag;
    if (data.fixed_pic_rate_within_cvs_flag !== undefined) s.fixed_pic_rate_within_cvs_flag = data.fixed_pic_rate_within_cvs_flag;
    if (data.low_delay_hrd_flag !== undefined) s.low_delay_hrd_flag = data.low_delay_hrd_flag;
    return s;
  }
  
  get nal_hrd_parameters_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set nal_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vcl_hrd_parameters_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set vcl_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sub_pic_hrd_params_present_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set sub_pic_hrd_params_present_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get sub_pic_cpb_params_in_pic_timing_sei_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set sub_pic_cpb_params_in_pic_timing_sei_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get fixed_pic_rate_general_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set fixed_pic_rate_general_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fixed_pic_rate_within_cvs_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set fixed_pic_rate_within_cvs_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get low_delay_hrd_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set low_delay_hrd_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class StdVideoH265HrdParameters implements IVkStructure {
  static size = 84;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265HrdParameters.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265HrdParameters(new Uint8Array(StdVideoH265HrdParameters.size));
  }
  
  static create(data: {
    flags: StdVideoH265HrdFlags;
    tick_divisor_minus2: number;
    du_cpb_removal_delay_increment_length_minus1: number;
    dpb_output_delay_du_length_minus1: number;
    bit_rate_scale: number;
    cpb_size_scale: number;
    cpb_size_du_scale: number;
    initial_cpb_removal_delay_length_minus1: number;
    au_cpb_removal_delay_length_minus1: number;
    dpb_output_delay_length_minus1: number;
    cpb_cnt_minus1: number;
    elemental_duration_in_tc_minus1: number;
    reserved: number;
    pSubLayerHrdParametersNal: Deno.PointerValue;
    pSubLayerHrdParametersVcl: Deno.PointerValue;
  }) {
    const s = StdVideoH265HrdParameters.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.tick_divisor_minus2 !== undefined) s.tick_divisor_minus2 = data.tick_divisor_minus2;
    if (data.du_cpb_removal_delay_increment_length_minus1 !== undefined) s.du_cpb_removal_delay_increment_length_minus1 = data.du_cpb_removal_delay_increment_length_minus1;
    if (data.dpb_output_delay_du_length_minus1 !== undefined) s.dpb_output_delay_du_length_minus1 = data.dpb_output_delay_du_length_minus1;
    if (data.bit_rate_scale !== undefined) s.bit_rate_scale = data.bit_rate_scale;
    if (data.cpb_size_scale !== undefined) s.cpb_size_scale = data.cpb_size_scale;
    if (data.cpb_size_du_scale !== undefined) s.cpb_size_du_scale = data.cpb_size_du_scale;
    if (data.initial_cpb_removal_delay_length_minus1 !== undefined) s.initial_cpb_removal_delay_length_minus1 = data.initial_cpb_removal_delay_length_minus1;
    if (data.au_cpb_removal_delay_length_minus1 !== undefined) s.au_cpb_removal_delay_length_minus1 = data.au_cpb_removal_delay_length_minus1;
    if (data.dpb_output_delay_length_minus1 !== undefined) s.dpb_output_delay_length_minus1 = data.dpb_output_delay_length_minus1;
    if (data.cpb_cnt_minus1 !== undefined) s.cpb_cnt_minus1 = data.cpb_cnt_minus1;
    if (data.elemental_duration_in_tc_minus1 !== undefined) s.elemental_duration_in_tc_minus1 = data.elemental_duration_in_tc_minus1;
    if (data.reserved !== undefined) s.reserved = data.reserved;
    if (data.pSubLayerHrdParametersNal !== undefined) s.pSubLayerHrdParametersNal = data.pSubLayerHrdParametersNal;
    if (data.pSubLayerHrdParametersVcl !== undefined) s.pSubLayerHrdParametersVcl = data.pSubLayerHrdParametersVcl;
    return s;
  }
  
  get flags() {
    return new StdVideoH265HrdFlags(this.#data.subarray(0, 0 + StdVideoH265HrdFlags.size));
  }
  
  set flags(value: StdVideoH265HrdFlags) {
    if (value[BUFFER].byteLength < StdVideoH265HrdFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get tick_divisor_minus2() {
    return this.#view.getUint8(28);
  }
  
  set tick_divisor_minus2(value: number) {
    this.#view.setUint8(28, Number(value));
  }
  
  get du_cpb_removal_delay_increment_length_minus1() {
    return this.#view.getUint8(29);
  }
  
  set du_cpb_removal_delay_increment_length_minus1(value: number) {
    this.#view.setUint8(29, Number(value));
  }
  
  get dpb_output_delay_du_length_minus1() {
    return this.#view.getUint8(30);
  }
  
  set dpb_output_delay_du_length_minus1(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get bit_rate_scale() {
    return this.#view.getUint8(31);
  }
  
  set bit_rate_scale(value: number) {
    this.#view.setUint8(31, Number(value));
  }
  
  get cpb_size_scale() {
    return this.#view.getUint8(32);
  }
  
  set cpb_size_scale(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get cpb_size_du_scale() {
    return this.#view.getUint8(33);
  }
  
  set cpb_size_du_scale(value: number) {
    this.#view.setUint8(33, Number(value));
  }
  
  get initial_cpb_removal_delay_length_minus1() {
    return this.#view.getUint8(34);
  }
  
  set initial_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint8(34, Number(value));
  }
  
  get au_cpb_removal_delay_length_minus1() {
    return this.#view.getUint8(35);
  }
  
  set au_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint8(35, Number(value));
  }
  
  get dpb_output_delay_length_minus1() {
    return this.#view.getUint8(36);
  }
  
  set dpb_output_delay_length_minus1(value: number) {
    this.#view.setUint8(36, Number(value));
  }
  
  get cpb_cnt_minus1() {
    return this.#view.getUint8(37);
  }
  
  set cpb_cnt_minus1(value: number) {
    this.#view.setUint8(37, Number(value));
  }
  
  get elemental_duration_in_tc_minus1() {
    return this.#view.getUint16(38, LE);
  }
  
  set elemental_duration_in_tc_minus1(value: number) {
    this.#view.setUint16(38, Number(value), LE);
  }
  
  get reserved() {
    return this.#view.getUint16(40, LE);
  }
  
  set reserved(value: number) {
    this.#view.setUint16(40, Number(value), LE);
  }
  
  get pSubLayerHrdParametersNal() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pSubLayerHrdParametersNal(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pSubLayerHrdParametersVcl() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pSubLayerHrdParametersVcl(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class StdVideoH265VpsFlags implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265VpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265VpsFlags(new Uint8Array(StdVideoH265VpsFlags.size));
  }
  
  static create(data: {
    vps_temporal_id_nesting_flag: number;
    vps_sub_layer_ordering_info_present_flag: number;
    vps_timing_info_present_flag: number;
    vps_poc_proportional_to_timing_flag: number;
  }) {
    const s = StdVideoH265VpsFlags.alloc();
    if (data.vps_temporal_id_nesting_flag !== undefined) s.vps_temporal_id_nesting_flag = data.vps_temporal_id_nesting_flag;
    if (data.vps_sub_layer_ordering_info_present_flag !== undefined) s.vps_sub_layer_ordering_info_present_flag = data.vps_sub_layer_ordering_info_present_flag;
    if (data.vps_timing_info_present_flag !== undefined) s.vps_timing_info_present_flag = data.vps_timing_info_present_flag;
    if (data.vps_poc_proportional_to_timing_flag !== undefined) s.vps_poc_proportional_to_timing_flag = data.vps_poc_proportional_to_timing_flag;
    return s;
  }
  
  get vps_temporal_id_nesting_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set vps_temporal_id_nesting_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vps_sub_layer_ordering_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set vps_sub_layer_ordering_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vps_timing_info_present_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set vps_timing_info_present_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get vps_poc_proportional_to_timing_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set vps_poc_proportional_to_timing_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class StdVideoH265VideoParameterSet implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265VideoParameterSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265VideoParameterSet(new Uint8Array(StdVideoH265VideoParameterSet.size));
  }
  
  static create(data: {
    flags: StdVideoH265VpsFlags;
    vps_video_parameter_set_id: number;
    vps_max_sub_layers_minus1: number;
    reserved1: number;
    reserved2: number;
    vps_num_units_in_tick: number;
    vps_time_scale: number;
    vps_num_ticks_poc_diff_one_minus1: number;
    reserved3: number;
    pDecPicBufMgr: Deno.PointerValue;
    pHrdParameters: Deno.PointerValue;
    pProfileTierLevel: Deno.PointerValue;
  }) {
    const s = StdVideoH265VideoParameterSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.vps_video_parameter_set_id !== undefined) s.vps_video_parameter_set_id = data.vps_video_parameter_set_id;
    if (data.vps_max_sub_layers_minus1 !== undefined) s.vps_max_sub_layers_minus1 = data.vps_max_sub_layers_minus1;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.vps_num_units_in_tick !== undefined) s.vps_num_units_in_tick = data.vps_num_units_in_tick;
    if (data.vps_time_scale !== undefined) s.vps_time_scale = data.vps_time_scale;
    if (data.vps_num_ticks_poc_diff_one_minus1 !== undefined) s.vps_num_ticks_poc_diff_one_minus1 = data.vps_num_ticks_poc_diff_one_minus1;
    if (data.reserved3 !== undefined) s.reserved3 = data.reserved3;
    if (data.pDecPicBufMgr !== undefined) s.pDecPicBufMgr = data.pDecPicBufMgr;
    if (data.pHrdParameters !== undefined) s.pHrdParameters = data.pHrdParameters;
    if (data.pProfileTierLevel !== undefined) s.pProfileTierLevel = data.pProfileTierLevel;
    return s;
  }
  
  get flags() {
    return new StdVideoH265VpsFlags(this.#data.subarray(0, 0 + StdVideoH265VpsFlags.size));
  }
  
  set flags(value: StdVideoH265VpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265VpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get vps_video_parameter_set_id() {
    return this.#view.getUint8(16);
  }
  
  set vps_video_parameter_set_id(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get vps_max_sub_layers_minus1() {
    return this.#view.getUint8(17);
  }
  
  set vps_max_sub_layers_minus1(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(18);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(19);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(19, Number(value));
  }
  
  get vps_num_units_in_tick() {
    return this.#view.getUint32(20, LE);
  }
  
  set vps_num_units_in_tick(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vps_time_scale() {
    return this.#view.getUint32(24, LE);
  }
  
  set vps_time_scale(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get vps_num_ticks_poc_diff_one_minus1() {
    return this.#view.getUint32(28, LE);
  }
  
  set vps_num_ticks_poc_diff_one_minus1(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get reserved3() {
    return this.#view.getUint32(32, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pDecPicBufMgr() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pDecPicBufMgr(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pHrdParameters(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pProfileTierLevel() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pProfileTierLevel(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class StdVideoH265ScalingLists implements IVkStructure {
  static size = 6;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265ScalingLists.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265ScalingLists(new Uint8Array(StdVideoH265ScalingLists.size));
  }
  
  static create(data: {
    ScalingList4x4: number;
    ScalingList8x8: number;
    ScalingList16x16: number;
    ScalingList32x32: number;
    ScalingListDCCoef16x16: number;
    ScalingListDCCoef32x32: number;
  }) {
    const s = StdVideoH265ScalingLists.alloc();
    if (data.ScalingList4x4 !== undefined) s.ScalingList4x4 = data.ScalingList4x4;
    if (data.ScalingList8x8 !== undefined) s.ScalingList8x8 = data.ScalingList8x8;
    if (data.ScalingList16x16 !== undefined) s.ScalingList16x16 = data.ScalingList16x16;
    if (data.ScalingList32x32 !== undefined) s.ScalingList32x32 = data.ScalingList32x32;
    if (data.ScalingListDCCoef16x16 !== undefined) s.ScalingListDCCoef16x16 = data.ScalingListDCCoef16x16;
    if (data.ScalingListDCCoef32x32 !== undefined) s.ScalingListDCCoef32x32 = data.ScalingListDCCoef32x32;
    return s;
  }
  
  get ScalingList4x4() {
    return this.#view.getUint8(0);
  }
  
  set ScalingList4x4(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get ScalingList8x8() {
    return this.#view.getUint8(1);
  }
  
  set ScalingList8x8(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get ScalingList16x16() {
    return this.#view.getUint8(2);
  }
  
  set ScalingList16x16(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get ScalingList32x32() {
    return this.#view.getUint8(3);
  }
  
  set ScalingList32x32(value: number) {
    this.#view.setUint8(3, Number(value));
  }
  
  get ScalingListDCCoef16x16() {
    return this.#view.getUint8(4);
  }
  
  set ScalingListDCCoef16x16(value: number) {
    this.#view.setUint8(4, Number(value));
  }
  
  get ScalingListDCCoef32x32() {
    return this.#view.getUint8(5);
  }
  
  set ScalingListDCCoef32x32(value: number) {
    this.#view.setUint8(5, Number(value));
  }
}

export class StdVideoH265ShortTermRefPicSetFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265ShortTermRefPicSetFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265ShortTermRefPicSetFlags(new Uint8Array(StdVideoH265ShortTermRefPicSetFlags.size));
  }
  
  static create(data: {
    inter_ref_pic_set_prediction_flag: number;
    delta_rps_sign: number;
  }) {
    const s = StdVideoH265ShortTermRefPicSetFlags.alloc();
    if (data.inter_ref_pic_set_prediction_flag !== undefined) s.inter_ref_pic_set_prediction_flag = data.inter_ref_pic_set_prediction_flag;
    if (data.delta_rps_sign !== undefined) s.delta_rps_sign = data.delta_rps_sign;
    return s;
  }
  
  get inter_ref_pic_set_prediction_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set inter_ref_pic_set_prediction_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get delta_rps_sign() {
    return this.#view.getUint32(4, LE);
  }
  
  set delta_rps_sign(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoH265ShortTermRefPicSet implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265ShortTermRefPicSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265ShortTermRefPicSet(new Uint8Array(StdVideoH265ShortTermRefPicSet.size));
  }
  
  static create(data: {
    flags: StdVideoH265ShortTermRefPicSetFlags;
    delta_idx_minus1: number;
    use_delta_flag: number;
    abs_delta_rps_minus1: number;
    used_by_curr_pic_flag: number;
    used_by_curr_pic_s0_flag: number;
    used_by_curr_pic_s1_flag: number;
    reserved1: number;
    reserved2: number;
    reserved3: number;
    num_negative_pics: number;
    num_positive_pics: number;
    delta_poc_s0_minus1: number;
    delta_poc_s1_minus1: number;
  }) {
    const s = StdVideoH265ShortTermRefPicSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.delta_idx_minus1 !== undefined) s.delta_idx_minus1 = data.delta_idx_minus1;
    if (data.use_delta_flag !== undefined) s.use_delta_flag = data.use_delta_flag;
    if (data.abs_delta_rps_minus1 !== undefined) s.abs_delta_rps_minus1 = data.abs_delta_rps_minus1;
    if (data.used_by_curr_pic_flag !== undefined) s.used_by_curr_pic_flag = data.used_by_curr_pic_flag;
    if (data.used_by_curr_pic_s0_flag !== undefined) s.used_by_curr_pic_s0_flag = data.used_by_curr_pic_s0_flag;
    if (data.used_by_curr_pic_s1_flag !== undefined) s.used_by_curr_pic_s1_flag = data.used_by_curr_pic_s1_flag;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.reserved3 !== undefined) s.reserved3 = data.reserved3;
    if (data.num_negative_pics !== undefined) s.num_negative_pics = data.num_negative_pics;
    if (data.num_positive_pics !== undefined) s.num_positive_pics = data.num_positive_pics;
    if (data.delta_poc_s0_minus1 !== undefined) s.delta_poc_s0_minus1 = data.delta_poc_s0_minus1;
    if (data.delta_poc_s1_minus1 !== undefined) s.delta_poc_s1_minus1 = data.delta_poc_s1_minus1;
    return s;
  }
  
  get flags() {
    return new StdVideoH265ShortTermRefPicSetFlags(this.#data.subarray(0, 0 + StdVideoH265ShortTermRefPicSetFlags.size));
  }
  
  set flags(value: StdVideoH265ShortTermRefPicSetFlags) {
    if (value[BUFFER].byteLength < StdVideoH265ShortTermRefPicSetFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get delta_idx_minus1() {
    return this.#view.getUint32(8, LE);
  }
  
  set delta_idx_minus1(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get use_delta_flag() {
    return this.#view.getUint16(12, LE);
  }
  
  set use_delta_flag(value: number) {
    this.#view.setUint16(12, Number(value), LE);
  }
  
  get abs_delta_rps_minus1() {
    return this.#view.getUint16(14, LE);
  }
  
  set abs_delta_rps_minus1(value: number) {
    this.#view.setUint16(14, Number(value), LE);
  }
  
  get used_by_curr_pic_flag() {
    return this.#view.getUint16(16, LE);
  }
  
  set used_by_curr_pic_flag(value: number) {
    this.#view.setUint16(16, Number(value), LE);
  }
  
  get used_by_curr_pic_s0_flag() {
    return this.#view.getUint16(18, LE);
  }
  
  set used_by_curr_pic_s0_flag(value: number) {
    this.#view.setUint16(18, Number(value), LE);
  }
  
  get used_by_curr_pic_s1_flag() {
    return this.#view.getUint16(20, LE);
  }
  
  set used_by_curr_pic_s1_flag(value: number) {
    this.#view.setUint16(20, Number(value), LE);
  }
  
  get reserved1() {
    return this.#view.getUint16(22, LE);
  }
  
  set reserved1(value: number) {
    this.#view.setUint16(22, Number(value), LE);
  }
  
  get reserved2() {
    return this.#view.getUint8(24);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get reserved3() {
    return this.#view.getUint8(25);
  }
  
  set reserved3(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get num_negative_pics() {
    return this.#view.getUint8(26);
  }
  
  set num_negative_pics(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get num_positive_pics() {
    return this.#view.getUint8(27);
  }
  
  set num_positive_pics(value: number) {
    this.#view.setUint8(27, Number(value));
  }
  
  get delta_poc_s0_minus1() {
    return this.#view.getUint16(28, LE);
  }
  
  set delta_poc_s0_minus1(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
  
  get delta_poc_s1_minus1() {
    return this.#view.getUint16(30, LE);
  }
  
  set delta_poc_s1_minus1(value: number) {
    this.#view.setUint16(30, Number(value), LE);
  }
}

export class StdVideoH265LongTermRefPicsSps implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265LongTermRefPicsSps.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265LongTermRefPicsSps(new Uint8Array(StdVideoH265LongTermRefPicsSps.size));
  }
  
  static create(data: {
    used_by_curr_pic_lt_sps_flag: number;
    lt_ref_pic_poc_lsb_sps: number;
  }) {
    const s = StdVideoH265LongTermRefPicsSps.alloc();
    if (data.used_by_curr_pic_lt_sps_flag !== undefined) s.used_by_curr_pic_lt_sps_flag = data.used_by_curr_pic_lt_sps_flag;
    if (data.lt_ref_pic_poc_lsb_sps !== undefined) s.lt_ref_pic_poc_lsb_sps = data.lt_ref_pic_poc_lsb_sps;
    return s;
  }
  
  get used_by_curr_pic_lt_sps_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_by_curr_pic_lt_sps_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get lt_ref_pic_poc_lsb_sps() {
    return this.#view.getUint32(4, LE);
  }
  
  set lt_ref_pic_poc_lsb_sps(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoH265SpsVuiFlags implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265SpsVuiFlags(new Uint8Array(StdVideoH265SpsVuiFlags.size));
  }
  
  static create(data: {
    aspect_ratio_info_present_flag: number;
    overscan_info_present_flag: number;
    overscan_appropriate_flag: number;
    video_signal_type_present_flag: number;
    video_full_range_flag: number;
    colour_description_present_flag: number;
    chroma_loc_info_present_flag: number;
    neutral_chroma_indication_flag: number;
    field_seq_flag: number;
    frame_field_info_present_flag: number;
    default_display_window_flag: number;
    vui_timing_info_present_flag: number;
    vui_poc_proportional_to_timing_flag: number;
    vui_hrd_parameters_present_flag: number;
    bitstream_restriction_flag: number;
    tiles_fixed_structure_flag: number;
    motion_vectors_over_pic_boundaries_flag: number;
    restricted_ref_pic_lists_flag: number;
  }) {
    const s = StdVideoH265SpsVuiFlags.alloc();
    if (data.aspect_ratio_info_present_flag !== undefined) s.aspect_ratio_info_present_flag = data.aspect_ratio_info_present_flag;
    if (data.overscan_info_present_flag !== undefined) s.overscan_info_present_flag = data.overscan_info_present_flag;
    if (data.overscan_appropriate_flag !== undefined) s.overscan_appropriate_flag = data.overscan_appropriate_flag;
    if (data.video_signal_type_present_flag !== undefined) s.video_signal_type_present_flag = data.video_signal_type_present_flag;
    if (data.video_full_range_flag !== undefined) s.video_full_range_flag = data.video_full_range_flag;
    if (data.colour_description_present_flag !== undefined) s.colour_description_present_flag = data.colour_description_present_flag;
    if (data.chroma_loc_info_present_flag !== undefined) s.chroma_loc_info_present_flag = data.chroma_loc_info_present_flag;
    if (data.neutral_chroma_indication_flag !== undefined) s.neutral_chroma_indication_flag = data.neutral_chroma_indication_flag;
    if (data.field_seq_flag !== undefined) s.field_seq_flag = data.field_seq_flag;
    if (data.frame_field_info_present_flag !== undefined) s.frame_field_info_present_flag = data.frame_field_info_present_flag;
    if (data.default_display_window_flag !== undefined) s.default_display_window_flag = data.default_display_window_flag;
    if (data.vui_timing_info_present_flag !== undefined) s.vui_timing_info_present_flag = data.vui_timing_info_present_flag;
    if (data.vui_poc_proportional_to_timing_flag !== undefined) s.vui_poc_proportional_to_timing_flag = data.vui_poc_proportional_to_timing_flag;
    if (data.vui_hrd_parameters_present_flag !== undefined) s.vui_hrd_parameters_present_flag = data.vui_hrd_parameters_present_flag;
    if (data.bitstream_restriction_flag !== undefined) s.bitstream_restriction_flag = data.bitstream_restriction_flag;
    if (data.tiles_fixed_structure_flag !== undefined) s.tiles_fixed_structure_flag = data.tiles_fixed_structure_flag;
    if (data.motion_vectors_over_pic_boundaries_flag !== undefined) s.motion_vectors_over_pic_boundaries_flag = data.motion_vectors_over_pic_boundaries_flag;
    if (data.restricted_ref_pic_lists_flag !== undefined) s.restricted_ref_pic_lists_flag = data.restricted_ref_pic_lists_flag;
    return s;
  }
  
  get aspect_ratio_info_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspect_ratio_info_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get overscan_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set overscan_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get overscan_appropriate_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set overscan_appropriate_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get video_signal_type_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set video_signal_type_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get video_full_range_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set video_full_range_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get colour_description_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set colour_description_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get chroma_loc_info_present_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set chroma_loc_info_present_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get neutral_chroma_indication_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set neutral_chroma_indication_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get field_seq_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set field_seq_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get frame_field_info_present_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set frame_field_info_present_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get default_display_window_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set default_display_window_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get vui_timing_info_present_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set vui_timing_info_present_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get vui_poc_proportional_to_timing_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set vui_poc_proportional_to_timing_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get vui_hrd_parameters_present_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set vui_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get bitstream_restriction_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set bitstream_restriction_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get tiles_fixed_structure_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set tiles_fixed_structure_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get motion_vectors_over_pic_boundaries_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set motion_vectors_over_pic_boundaries_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get restricted_ref_pic_lists_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set restricted_ref_pic_lists_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export class StdVideoH265SequenceParameterSetVui implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265SequenceParameterSetVui.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265SequenceParameterSetVui(new Uint8Array(StdVideoH265SequenceParameterSetVui.size));
  }
  
  static create(data: {
    flags: StdVideoH265SpsVuiFlags;
    aspect_ratio_idc: StdVideoH265AspectRatioIdc;
    sar_width: number;
    sar_height: number;
    video_format: number;
    colour_primaries: number;
    transfer_characteristics: number;
    matrix_coeffs: number;
    chroma_sample_loc_type_top_field: number;
    chroma_sample_loc_type_bottom_field: number;
    reserved1: number;
    reserved2: number;
    def_disp_win_left_offset: number;
    def_disp_win_right_offset: number;
    def_disp_win_top_offset: number;
    def_disp_win_bottom_offset: number;
    vui_num_units_in_tick: number;
    vui_time_scale: number;
    vui_num_ticks_poc_diff_one_minus1: number;
    min_spatial_segmentation_idc: number;
    reserved3: number;
    max_bytes_per_pic_denom: number;
    max_bits_per_min_cu_denom: number;
    log2_max_mv_length_horizontal: number;
    log2_max_mv_length_vertical: number;
    pHrdParameters: Deno.PointerValue;
  }) {
    const s = StdVideoH265SequenceParameterSetVui.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.aspect_ratio_idc !== undefined) s.aspect_ratio_idc = data.aspect_ratio_idc;
    if (data.sar_width !== undefined) s.sar_width = data.sar_width;
    if (data.sar_height !== undefined) s.sar_height = data.sar_height;
    if (data.video_format !== undefined) s.video_format = data.video_format;
    if (data.colour_primaries !== undefined) s.colour_primaries = data.colour_primaries;
    if (data.transfer_characteristics !== undefined) s.transfer_characteristics = data.transfer_characteristics;
    if (data.matrix_coeffs !== undefined) s.matrix_coeffs = data.matrix_coeffs;
    if (data.chroma_sample_loc_type_top_field !== undefined) s.chroma_sample_loc_type_top_field = data.chroma_sample_loc_type_top_field;
    if (data.chroma_sample_loc_type_bottom_field !== undefined) s.chroma_sample_loc_type_bottom_field = data.chroma_sample_loc_type_bottom_field;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.def_disp_win_left_offset !== undefined) s.def_disp_win_left_offset = data.def_disp_win_left_offset;
    if (data.def_disp_win_right_offset !== undefined) s.def_disp_win_right_offset = data.def_disp_win_right_offset;
    if (data.def_disp_win_top_offset !== undefined) s.def_disp_win_top_offset = data.def_disp_win_top_offset;
    if (data.def_disp_win_bottom_offset !== undefined) s.def_disp_win_bottom_offset = data.def_disp_win_bottom_offset;
    if (data.vui_num_units_in_tick !== undefined) s.vui_num_units_in_tick = data.vui_num_units_in_tick;
    if (data.vui_time_scale !== undefined) s.vui_time_scale = data.vui_time_scale;
    if (data.vui_num_ticks_poc_diff_one_minus1 !== undefined) s.vui_num_ticks_poc_diff_one_minus1 = data.vui_num_ticks_poc_diff_one_minus1;
    if (data.min_spatial_segmentation_idc !== undefined) s.min_spatial_segmentation_idc = data.min_spatial_segmentation_idc;
    if (data.reserved3 !== undefined) s.reserved3 = data.reserved3;
    if (data.max_bytes_per_pic_denom !== undefined) s.max_bytes_per_pic_denom = data.max_bytes_per_pic_denom;
    if (data.max_bits_per_min_cu_denom !== undefined) s.max_bits_per_min_cu_denom = data.max_bits_per_min_cu_denom;
    if (data.log2_max_mv_length_horizontal !== undefined) s.log2_max_mv_length_horizontal = data.log2_max_mv_length_horizontal;
    if (data.log2_max_mv_length_vertical !== undefined) s.log2_max_mv_length_vertical = data.log2_max_mv_length_vertical;
    if (data.pHrdParameters !== undefined) s.pHrdParameters = data.pHrdParameters;
    return s;
  }
  
  get flags() {
    return new StdVideoH265SpsVuiFlags(this.#data.subarray(0, 0 + StdVideoH265SpsVuiFlags.size));
  }
  
  set flags(value: StdVideoH265SpsVuiFlags) {
    if (value[BUFFER].byteLength < StdVideoH265SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aspect_ratio_idc() {
    return this.#view.getUint32(72, LE);
  }
  
  set aspect_ratio_idc(value: StdVideoH265AspectRatioIdc) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get sar_width() {
    return this.#view.getUint16(76, LE);
  }
  
  set sar_width(value: number) {
    this.#view.setUint16(76, Number(value), LE);
  }
  
  get sar_height() {
    return this.#view.getUint16(78, LE);
  }
  
  set sar_height(value: number) {
    this.#view.setUint16(78, Number(value), LE);
  }
  
  get video_format() {
    return this.#view.getUint8(80);
  }
  
  set video_format(value: number) {
    this.#view.setUint8(80, Number(value));
  }
  
  get colour_primaries() {
    return this.#view.getUint8(81);
  }
  
  set colour_primaries(value: number) {
    this.#view.setUint8(81, Number(value));
  }
  
  get transfer_characteristics() {
    return this.#view.getUint8(82);
  }
  
  set transfer_characteristics(value: number) {
    this.#view.setUint8(82, Number(value));
  }
  
  get matrix_coeffs() {
    return this.#view.getUint8(83);
  }
  
  set matrix_coeffs(value: number) {
    this.#view.setUint8(83, Number(value));
  }
  
  get chroma_sample_loc_type_top_field() {
    return this.#view.getUint8(84);
  }
  
  set chroma_sample_loc_type_top_field(value: number) {
    this.#view.setUint8(84, Number(value));
  }
  
  get chroma_sample_loc_type_bottom_field() {
    return this.#view.getUint8(85);
  }
  
  set chroma_sample_loc_type_bottom_field(value: number) {
    this.#view.setUint8(85, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(86);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(86, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(87);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(87, Number(value));
  }
  
  get def_disp_win_left_offset() {
    return this.#view.getUint16(88, LE);
  }
  
  set def_disp_win_left_offset(value: number) {
    this.#view.setUint16(88, Number(value), LE);
  }
  
  get def_disp_win_right_offset() {
    return this.#view.getUint16(90, LE);
  }
  
  set def_disp_win_right_offset(value: number) {
    this.#view.setUint16(90, Number(value), LE);
  }
  
  get def_disp_win_top_offset() {
    return this.#view.getUint16(92, LE);
  }
  
  set def_disp_win_top_offset(value: number) {
    this.#view.setUint16(92, Number(value), LE);
  }
  
  get def_disp_win_bottom_offset() {
    return this.#view.getUint16(94, LE);
  }
  
  set def_disp_win_bottom_offset(value: number) {
    this.#view.setUint16(94, Number(value), LE);
  }
  
  get vui_num_units_in_tick() {
    return this.#view.getUint32(96, LE);
  }
  
  set vui_num_units_in_tick(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get vui_time_scale() {
    return this.#view.getUint32(100, LE);
  }
  
  set vui_time_scale(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get vui_num_ticks_poc_diff_one_minus1() {
    return this.#view.getUint32(104, LE);
  }
  
  set vui_num_ticks_poc_diff_one_minus1(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get min_spatial_segmentation_idc() {
    return this.#view.getUint16(108, LE);
  }
  
  set min_spatial_segmentation_idc(value: number) {
    this.#view.setUint16(108, Number(value), LE);
  }
  
  get reserved3() {
    return this.#view.getUint16(110, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint16(110, Number(value), LE);
  }
  
  get max_bytes_per_pic_denom() {
    return this.#view.getUint8(112);
  }
  
  set max_bytes_per_pic_denom(value: number) {
    this.#view.setUint8(112, Number(value));
  }
  
  get max_bits_per_min_cu_denom() {
    return this.#view.getUint8(113);
  }
  
  set max_bits_per_min_cu_denom(value: number) {
    this.#view.setUint8(113, Number(value));
  }
  
  get log2_max_mv_length_horizontal() {
    return this.#view.getUint8(114);
  }
  
  set log2_max_mv_length_horizontal(value: number) {
    this.#view.setUint8(114, Number(value));
  }
  
  get log2_max_mv_length_vertical() {
    return this.#view.getUint8(115);
  }
  
  set log2_max_mv_length_vertical(value: number) {
    this.#view.setUint8(115, Number(value));
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(120, LE);
  }
  
  set pHrdParameters(value: Deno.PointerValue) {
    this.#view.setBigUint64(120, BigInt(value), LE);
  }
}

export class StdVideoH265PredictorPaletteEntries implements IVkStructure {
  static size = 2;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265PredictorPaletteEntries.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265PredictorPaletteEntries(new Uint8Array(StdVideoH265PredictorPaletteEntries.size));
  }
  
  static create(data: {
    PredictorPaletteEntries: number;
  }) {
    const s = StdVideoH265PredictorPaletteEntries.alloc();
    if (data.PredictorPaletteEntries !== undefined) s.PredictorPaletteEntries = data.PredictorPaletteEntries;
    return s;
  }
  
  get PredictorPaletteEntries() {
    return this.#view.getUint16(0, LE);
  }
  
  set PredictorPaletteEntries(value: number) {
    this.#view.setUint16(0, Number(value), LE);
  }
}

export class StdVideoH265SpsFlags implements IVkStructure {
  static size = 120;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265SpsFlags(new Uint8Array(StdVideoH265SpsFlags.size));
  }
  
  static create(data: {
    sps_temporal_id_nesting_flag: number;
    separate_colour_plane_flag: number;
    conformance_window_flag: number;
    sps_sub_layer_ordering_info_present_flag: number;
    scaling_list_enabled_flag: number;
    sps_scaling_list_data_present_flag: number;
    amp_enabled_flag: number;
    sample_adaptive_offset_enabled_flag: number;
    pcm_enabled_flag: number;
    pcm_loop_filter_disabled_flag: number;
    long_term_ref_pics_present_flag: number;
    sps_temporal_mvp_enabled_flag: number;
    strong_intra_smoothing_enabled_flag: number;
    vui_parameters_present_flag: number;
    sps_extension_present_flag: number;
    sps_range_extension_flag: number;
    transform_skip_rotation_enabled_flag: number;
    transform_skip_context_enabled_flag: number;
    implicit_rdpcm_enabled_flag: number;
    explicit_rdpcm_enabled_flag: number;
    extended_precision_processing_flag: number;
    intra_smoothing_disabled_flag: number;
    high_precision_offsets_enabled_flag: number;
    persistent_rice_adaptation_enabled_flag: number;
    cabac_bypass_alignment_enabled_flag: number;
    sps_scc_extension_flag: number;
    sps_curr_pic_ref_enabled_flag: number;
    palette_mode_enabled_flag: number;
    sps_palette_predictor_initializers_present_flag: number;
    intra_boundary_filtering_disabled_flag: number;
  }) {
    const s = StdVideoH265SpsFlags.alloc();
    if (data.sps_temporal_id_nesting_flag !== undefined) s.sps_temporal_id_nesting_flag = data.sps_temporal_id_nesting_flag;
    if (data.separate_colour_plane_flag !== undefined) s.separate_colour_plane_flag = data.separate_colour_plane_flag;
    if (data.conformance_window_flag !== undefined) s.conformance_window_flag = data.conformance_window_flag;
    if (data.sps_sub_layer_ordering_info_present_flag !== undefined) s.sps_sub_layer_ordering_info_present_flag = data.sps_sub_layer_ordering_info_present_flag;
    if (data.scaling_list_enabled_flag !== undefined) s.scaling_list_enabled_flag = data.scaling_list_enabled_flag;
    if (data.sps_scaling_list_data_present_flag !== undefined) s.sps_scaling_list_data_present_flag = data.sps_scaling_list_data_present_flag;
    if (data.amp_enabled_flag !== undefined) s.amp_enabled_flag = data.amp_enabled_flag;
    if (data.sample_adaptive_offset_enabled_flag !== undefined) s.sample_adaptive_offset_enabled_flag = data.sample_adaptive_offset_enabled_flag;
    if (data.pcm_enabled_flag !== undefined) s.pcm_enabled_flag = data.pcm_enabled_flag;
    if (data.pcm_loop_filter_disabled_flag !== undefined) s.pcm_loop_filter_disabled_flag = data.pcm_loop_filter_disabled_flag;
    if (data.long_term_ref_pics_present_flag !== undefined) s.long_term_ref_pics_present_flag = data.long_term_ref_pics_present_flag;
    if (data.sps_temporal_mvp_enabled_flag !== undefined) s.sps_temporal_mvp_enabled_flag = data.sps_temporal_mvp_enabled_flag;
    if (data.strong_intra_smoothing_enabled_flag !== undefined) s.strong_intra_smoothing_enabled_flag = data.strong_intra_smoothing_enabled_flag;
    if (data.vui_parameters_present_flag !== undefined) s.vui_parameters_present_flag = data.vui_parameters_present_flag;
    if (data.sps_extension_present_flag !== undefined) s.sps_extension_present_flag = data.sps_extension_present_flag;
    if (data.sps_range_extension_flag !== undefined) s.sps_range_extension_flag = data.sps_range_extension_flag;
    if (data.transform_skip_rotation_enabled_flag !== undefined) s.transform_skip_rotation_enabled_flag = data.transform_skip_rotation_enabled_flag;
    if (data.transform_skip_context_enabled_flag !== undefined) s.transform_skip_context_enabled_flag = data.transform_skip_context_enabled_flag;
    if (data.implicit_rdpcm_enabled_flag !== undefined) s.implicit_rdpcm_enabled_flag = data.implicit_rdpcm_enabled_flag;
    if (data.explicit_rdpcm_enabled_flag !== undefined) s.explicit_rdpcm_enabled_flag = data.explicit_rdpcm_enabled_flag;
    if (data.extended_precision_processing_flag !== undefined) s.extended_precision_processing_flag = data.extended_precision_processing_flag;
    if (data.intra_smoothing_disabled_flag !== undefined) s.intra_smoothing_disabled_flag = data.intra_smoothing_disabled_flag;
    if (data.high_precision_offsets_enabled_flag !== undefined) s.high_precision_offsets_enabled_flag = data.high_precision_offsets_enabled_flag;
    if (data.persistent_rice_adaptation_enabled_flag !== undefined) s.persistent_rice_adaptation_enabled_flag = data.persistent_rice_adaptation_enabled_flag;
    if (data.cabac_bypass_alignment_enabled_flag !== undefined) s.cabac_bypass_alignment_enabled_flag = data.cabac_bypass_alignment_enabled_flag;
    if (data.sps_scc_extension_flag !== undefined) s.sps_scc_extension_flag = data.sps_scc_extension_flag;
    if (data.sps_curr_pic_ref_enabled_flag !== undefined) s.sps_curr_pic_ref_enabled_flag = data.sps_curr_pic_ref_enabled_flag;
    if (data.palette_mode_enabled_flag !== undefined) s.palette_mode_enabled_flag = data.palette_mode_enabled_flag;
    if (data.sps_palette_predictor_initializers_present_flag !== undefined) s.sps_palette_predictor_initializers_present_flag = data.sps_palette_predictor_initializers_present_flag;
    if (data.intra_boundary_filtering_disabled_flag !== undefined) s.intra_boundary_filtering_disabled_flag = data.intra_boundary_filtering_disabled_flag;
    return s;
  }
  
  get sps_temporal_id_nesting_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set sps_temporal_id_nesting_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get separate_colour_plane_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set separate_colour_plane_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get conformance_window_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set conformance_window_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get sps_sub_layer_ordering_info_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set sps_sub_layer_ordering_info_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get scaling_list_enabled_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set scaling_list_enabled_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sps_scaling_list_data_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set sps_scaling_list_data_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get amp_enabled_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set amp_enabled_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sample_adaptive_offset_enabled_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set sample_adaptive_offset_enabled_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pcm_enabled_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set pcm_enabled_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pcm_loop_filter_disabled_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set pcm_loop_filter_disabled_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get long_term_ref_pics_present_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set long_term_ref_pics_present_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get sps_temporal_mvp_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set sps_temporal_mvp_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get strong_intra_smoothing_enabled_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set strong_intra_smoothing_enabled_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get vui_parameters_present_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set vui_parameters_present_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get sps_extension_present_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set sps_extension_present_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sps_range_extension_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set sps_range_extension_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get transform_skip_rotation_enabled_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set transform_skip_rotation_enabled_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get transform_skip_context_enabled_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set transform_skip_context_enabled_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get implicit_rdpcm_enabled_flag() {
    return this.#view.getUint32(72, LE);
  }
  
  set implicit_rdpcm_enabled_flag(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get explicit_rdpcm_enabled_flag() {
    return this.#view.getUint32(76, LE);
  }
  
  set explicit_rdpcm_enabled_flag(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get extended_precision_processing_flag() {
    return this.#view.getUint32(80, LE);
  }
  
  set extended_precision_processing_flag(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get intra_smoothing_disabled_flag() {
    return this.#view.getUint32(84, LE);
  }
  
  set intra_smoothing_disabled_flag(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get high_precision_offsets_enabled_flag() {
    return this.#view.getUint32(88, LE);
  }
  
  set high_precision_offsets_enabled_flag(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get persistent_rice_adaptation_enabled_flag() {
    return this.#view.getUint32(92, LE);
  }
  
  set persistent_rice_adaptation_enabled_flag(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get cabac_bypass_alignment_enabled_flag() {
    return this.#view.getUint32(96, LE);
  }
  
  set cabac_bypass_alignment_enabled_flag(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get sps_scc_extension_flag() {
    return this.#view.getUint32(100, LE);
  }
  
  set sps_scc_extension_flag(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get sps_curr_pic_ref_enabled_flag() {
    return this.#view.getUint32(104, LE);
  }
  
  set sps_curr_pic_ref_enabled_flag(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get palette_mode_enabled_flag() {
    return this.#view.getUint32(108, LE);
  }
  
  set palette_mode_enabled_flag(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get sps_palette_predictor_initializers_present_flag() {
    return this.#view.getUint32(112, LE);
  }
  
  set sps_palette_predictor_initializers_present_flag(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get intra_boundary_filtering_disabled_flag() {
    return this.#view.getUint32(116, LE);
  }
  
  set intra_boundary_filtering_disabled_flag(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
}

export class StdVideoH265SequenceParameterSet implements IVkStructure {
  static size = 240;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265SequenceParameterSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265SequenceParameterSet(new Uint8Array(StdVideoH265SequenceParameterSet.size));
  }
  
  static create(data: {
    flags: StdVideoH265SpsFlags;
    chroma_format_idc: StdVideoH265ChromaFormatIdc;
    pic_width_in_luma_samples: number;
    pic_height_in_luma_samples: number;
    sps_video_parameter_set_id: number;
    sps_max_sub_layers_minus1: number;
    sps_seq_parameter_set_id: number;
    bit_depth_luma_minus8: number;
    bit_depth_chroma_minus8: number;
    log2_max_pic_order_cnt_lsb_minus4: number;
    log2_min_luma_coding_block_size_minus3: number;
    log2_diff_max_min_luma_coding_block_size: number;
    log2_min_luma_transform_block_size_minus2: number;
    log2_diff_max_min_luma_transform_block_size: number;
    max_transform_hierarchy_depth_inter: number;
    max_transform_hierarchy_depth_intra: number;
    num_short_term_ref_pic_sets: number;
    num_long_term_ref_pics_sps: number;
    pcm_sample_bit_depth_luma_minus1: number;
    pcm_sample_bit_depth_chroma_minus1: number;
    log2_min_pcm_luma_coding_block_size_minus3: number;
    log2_diff_max_min_pcm_luma_coding_block_size: number;
    reserved1: number;
    reserved2: number;
    palette_max_size: number;
    delta_palette_max_predictor_size: number;
    motion_vector_resolution_control_idc: number;
    sps_num_palette_predictor_initializers_minus1: number;
    conf_win_left_offset: number;
    conf_win_right_offset: number;
    conf_win_top_offset: number;
    conf_win_bottom_offset: number;
    pProfileTierLevel: Deno.PointerValue;
    pDecPicBufMgr: Deno.PointerValue;
    pScalingLists: Deno.PointerValue;
    pShortTermRefPicSet: Deno.PointerValue;
    pLongTermRefPicsSps: Deno.PointerValue;
    pSequenceParameterSetVui: Deno.PointerValue;
    pPredictorPaletteEntries: Deno.PointerValue;
  }) {
    const s = StdVideoH265SequenceParameterSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.chroma_format_idc !== undefined) s.chroma_format_idc = data.chroma_format_idc;
    if (data.pic_width_in_luma_samples !== undefined) s.pic_width_in_luma_samples = data.pic_width_in_luma_samples;
    if (data.pic_height_in_luma_samples !== undefined) s.pic_height_in_luma_samples = data.pic_height_in_luma_samples;
    if (data.sps_video_parameter_set_id !== undefined) s.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
    if (data.sps_max_sub_layers_minus1 !== undefined) s.sps_max_sub_layers_minus1 = data.sps_max_sub_layers_minus1;
    if (data.sps_seq_parameter_set_id !== undefined) s.sps_seq_parameter_set_id = data.sps_seq_parameter_set_id;
    if (data.bit_depth_luma_minus8 !== undefined) s.bit_depth_luma_minus8 = data.bit_depth_luma_minus8;
    if (data.bit_depth_chroma_minus8 !== undefined) s.bit_depth_chroma_minus8 = data.bit_depth_chroma_minus8;
    if (data.log2_max_pic_order_cnt_lsb_minus4 !== undefined) s.log2_max_pic_order_cnt_lsb_minus4 = data.log2_max_pic_order_cnt_lsb_minus4;
    if (data.log2_min_luma_coding_block_size_minus3 !== undefined) s.log2_min_luma_coding_block_size_minus3 = data.log2_min_luma_coding_block_size_minus3;
    if (data.log2_diff_max_min_luma_coding_block_size !== undefined) s.log2_diff_max_min_luma_coding_block_size = data.log2_diff_max_min_luma_coding_block_size;
    if (data.log2_min_luma_transform_block_size_minus2 !== undefined) s.log2_min_luma_transform_block_size_minus2 = data.log2_min_luma_transform_block_size_minus2;
    if (data.log2_diff_max_min_luma_transform_block_size !== undefined) s.log2_diff_max_min_luma_transform_block_size = data.log2_diff_max_min_luma_transform_block_size;
    if (data.max_transform_hierarchy_depth_inter !== undefined) s.max_transform_hierarchy_depth_inter = data.max_transform_hierarchy_depth_inter;
    if (data.max_transform_hierarchy_depth_intra !== undefined) s.max_transform_hierarchy_depth_intra = data.max_transform_hierarchy_depth_intra;
    if (data.num_short_term_ref_pic_sets !== undefined) s.num_short_term_ref_pic_sets = data.num_short_term_ref_pic_sets;
    if (data.num_long_term_ref_pics_sps !== undefined) s.num_long_term_ref_pics_sps = data.num_long_term_ref_pics_sps;
    if (data.pcm_sample_bit_depth_luma_minus1 !== undefined) s.pcm_sample_bit_depth_luma_minus1 = data.pcm_sample_bit_depth_luma_minus1;
    if (data.pcm_sample_bit_depth_chroma_minus1 !== undefined) s.pcm_sample_bit_depth_chroma_minus1 = data.pcm_sample_bit_depth_chroma_minus1;
    if (data.log2_min_pcm_luma_coding_block_size_minus3 !== undefined) s.log2_min_pcm_luma_coding_block_size_minus3 = data.log2_min_pcm_luma_coding_block_size_minus3;
    if (data.log2_diff_max_min_pcm_luma_coding_block_size !== undefined) s.log2_diff_max_min_pcm_luma_coding_block_size = data.log2_diff_max_min_pcm_luma_coding_block_size;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.palette_max_size !== undefined) s.palette_max_size = data.palette_max_size;
    if (data.delta_palette_max_predictor_size !== undefined) s.delta_palette_max_predictor_size = data.delta_palette_max_predictor_size;
    if (data.motion_vector_resolution_control_idc !== undefined) s.motion_vector_resolution_control_idc = data.motion_vector_resolution_control_idc;
    if (data.sps_num_palette_predictor_initializers_minus1 !== undefined) s.sps_num_palette_predictor_initializers_minus1 = data.sps_num_palette_predictor_initializers_minus1;
    if (data.conf_win_left_offset !== undefined) s.conf_win_left_offset = data.conf_win_left_offset;
    if (data.conf_win_right_offset !== undefined) s.conf_win_right_offset = data.conf_win_right_offset;
    if (data.conf_win_top_offset !== undefined) s.conf_win_top_offset = data.conf_win_top_offset;
    if (data.conf_win_bottom_offset !== undefined) s.conf_win_bottom_offset = data.conf_win_bottom_offset;
    if (data.pProfileTierLevel !== undefined) s.pProfileTierLevel = data.pProfileTierLevel;
    if (data.pDecPicBufMgr !== undefined) s.pDecPicBufMgr = data.pDecPicBufMgr;
    if (data.pScalingLists !== undefined) s.pScalingLists = data.pScalingLists;
    if (data.pShortTermRefPicSet !== undefined) s.pShortTermRefPicSet = data.pShortTermRefPicSet;
    if (data.pLongTermRefPicsSps !== undefined) s.pLongTermRefPicsSps = data.pLongTermRefPicsSps;
    if (data.pSequenceParameterSetVui !== undefined) s.pSequenceParameterSetVui = data.pSequenceParameterSetVui;
    if (data.pPredictorPaletteEntries !== undefined) s.pPredictorPaletteEntries = data.pPredictorPaletteEntries;
    return s;
  }
  
  get flags() {
    return new StdVideoH265SpsFlags(this.#data.subarray(0, 0 + StdVideoH265SpsFlags.size));
  }
  
  set flags(value: StdVideoH265SpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get chroma_format_idc() {
    return this.#view.getUint32(120, LE);
  }
  
  set chroma_format_idc(value: StdVideoH265ChromaFormatIdc) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get pic_width_in_luma_samples() {
    return this.#view.getUint32(124, LE);
  }
  
  set pic_width_in_luma_samples(value: number) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get pic_height_in_luma_samples() {
    return this.#view.getUint32(128, LE);
  }
  
  set pic_height_in_luma_samples(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(132);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(132, Number(value));
  }
  
  get sps_max_sub_layers_minus1() {
    return this.#view.getUint8(133);
  }
  
  set sps_max_sub_layers_minus1(value: number) {
    this.#view.setUint8(133, Number(value));
  }
  
  get sps_seq_parameter_set_id() {
    return this.#view.getUint8(134);
  }
  
  set sps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(134, Number(value));
  }
  
  get bit_depth_luma_minus8() {
    return this.#view.getUint8(135);
  }
  
  set bit_depth_luma_minus8(value: number) {
    this.#view.setUint8(135, Number(value));
  }
  
  get bit_depth_chroma_minus8() {
    return this.#view.getUint8(136);
  }
  
  set bit_depth_chroma_minus8(value: number) {
    this.#view.setUint8(136, Number(value));
  }
  
  get log2_max_pic_order_cnt_lsb_minus4() {
    return this.#view.getUint8(137);
  }
  
  set log2_max_pic_order_cnt_lsb_minus4(value: number) {
    this.#view.setUint8(137, Number(value));
  }
  
  get log2_min_luma_coding_block_size_minus3() {
    return this.#view.getUint8(138);
  }
  
  set log2_min_luma_coding_block_size_minus3(value: number) {
    this.#view.setUint8(138, Number(value));
  }
  
  get log2_diff_max_min_luma_coding_block_size() {
    return this.#view.getUint8(139);
  }
  
  set log2_diff_max_min_luma_coding_block_size(value: number) {
    this.#view.setUint8(139, Number(value));
  }
  
  get log2_min_luma_transform_block_size_minus2() {
    return this.#view.getUint8(140);
  }
  
  set log2_min_luma_transform_block_size_minus2(value: number) {
    this.#view.setUint8(140, Number(value));
  }
  
  get log2_diff_max_min_luma_transform_block_size() {
    return this.#view.getUint8(141);
  }
  
  set log2_diff_max_min_luma_transform_block_size(value: number) {
    this.#view.setUint8(141, Number(value));
  }
  
  get max_transform_hierarchy_depth_inter() {
    return this.#view.getUint8(142);
  }
  
  set max_transform_hierarchy_depth_inter(value: number) {
    this.#view.setUint8(142, Number(value));
  }
  
  get max_transform_hierarchy_depth_intra() {
    return this.#view.getUint8(143);
  }
  
  set max_transform_hierarchy_depth_intra(value: number) {
    this.#view.setUint8(143, Number(value));
  }
  
  get num_short_term_ref_pic_sets() {
    return this.#view.getUint8(144);
  }
  
  set num_short_term_ref_pic_sets(value: number) {
    this.#view.setUint8(144, Number(value));
  }
  
  get num_long_term_ref_pics_sps() {
    return this.#view.getUint8(145);
  }
  
  set num_long_term_ref_pics_sps(value: number) {
    this.#view.setUint8(145, Number(value));
  }
  
  get pcm_sample_bit_depth_luma_minus1() {
    return this.#view.getUint8(146);
  }
  
  set pcm_sample_bit_depth_luma_minus1(value: number) {
    this.#view.setUint8(146, Number(value));
  }
  
  get pcm_sample_bit_depth_chroma_minus1() {
    return this.#view.getUint8(147);
  }
  
  set pcm_sample_bit_depth_chroma_minus1(value: number) {
    this.#view.setUint8(147, Number(value));
  }
  
  get log2_min_pcm_luma_coding_block_size_minus3() {
    return this.#view.getUint8(148);
  }
  
  set log2_min_pcm_luma_coding_block_size_minus3(value: number) {
    this.#view.setUint8(148, Number(value));
  }
  
  get log2_diff_max_min_pcm_luma_coding_block_size() {
    return this.#view.getUint8(149);
  }
  
  set log2_diff_max_min_pcm_luma_coding_block_size(value: number) {
    this.#view.setUint8(149, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(150);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(150, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(151);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(151, Number(value));
  }
  
  get palette_max_size() {
    return this.#view.getUint8(152);
  }
  
  set palette_max_size(value: number) {
    this.#view.setUint8(152, Number(value));
  }
  
  get delta_palette_max_predictor_size() {
    return this.#view.getUint8(153);
  }
  
  set delta_palette_max_predictor_size(value: number) {
    this.#view.setUint8(153, Number(value));
  }
  
  get motion_vector_resolution_control_idc() {
    return this.#view.getUint8(154);
  }
  
  set motion_vector_resolution_control_idc(value: number) {
    this.#view.setUint8(154, Number(value));
  }
  
  get sps_num_palette_predictor_initializers_minus1() {
    return this.#view.getUint8(155);
  }
  
  set sps_num_palette_predictor_initializers_minus1(value: number) {
    this.#view.setUint8(155, Number(value));
  }
  
  get conf_win_left_offset() {
    return this.#view.getUint32(156, LE);
  }
  
  set conf_win_left_offset(value: number) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get conf_win_right_offset() {
    return this.#view.getUint32(160, LE);
  }
  
  set conf_win_right_offset(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get conf_win_top_offset() {
    return this.#view.getUint32(164, LE);
  }
  
  set conf_win_top_offset(value: number) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get conf_win_bottom_offset() {
    return this.#view.getUint32(168, LE);
  }
  
  set conf_win_bottom_offset(value: number) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get pProfileTierLevel() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set pProfileTierLevel(value: Deno.PointerValue) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
  
  get pDecPicBufMgr() {
    return this.#view.getBigUint64(184, LE);
  }
  
  set pDecPicBufMgr(value: Deno.PointerValue) {
    this.#view.setBigUint64(184, BigInt(value), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set pScalingLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(192, BigInt(value), LE);
  }
  
  get pShortTermRefPicSet() {
    return this.#view.getBigUint64(200, LE);
  }
  
  set pShortTermRefPicSet(value: Deno.PointerValue) {
    this.#view.setBigUint64(200, BigInt(value), LE);
  }
  
  get pLongTermRefPicsSps() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set pLongTermRefPicsSps(value: Deno.PointerValue) {
    this.#view.setBigUint64(208, BigInt(value), LE);
  }
  
  get pSequenceParameterSetVui() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set pSequenceParameterSetVui(value: Deno.PointerValue) {
    this.#view.setBigUint64(216, BigInt(value), LE);
  }
  
  get pPredictorPaletteEntries() {
    return this.#view.getBigUint64(224, LE);
  }
  
  set pPredictorPaletteEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(224, BigInt(value), LE);
  }
}

export class StdVideoH265PpsFlags implements IVkStructure {
  static size = 124;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265PpsFlags(new Uint8Array(StdVideoH265PpsFlags.size));
  }
  
  static create(data: {
    dependent_slice_segments_enabled_flag: number;
    output_flag_present_flag: number;
    sign_data_hiding_enabled_flag: number;
    cabac_init_present_flag: number;
    constrained_intra_pred_flag: number;
    transform_skip_enabled_flag: number;
    cu_qp_delta_enabled_flag: number;
    pps_slice_chroma_qp_offsets_present_flag: number;
    weighted_pred_flag: number;
    weighted_bipred_flag: number;
    transquant_bypass_enabled_flag: number;
    tiles_enabled_flag: number;
    entropy_coding_sync_enabled_flag: number;
    uniform_spacing_flag: number;
    loop_filter_across_tiles_enabled_flag: number;
    pps_loop_filter_across_slices_enabled_flag: number;
    deblocking_filter_control_present_flag: number;
    deblocking_filter_override_enabled_flag: number;
    pps_deblocking_filter_disabled_flag: number;
    pps_scaling_list_data_present_flag: number;
    lists_modification_present_flag: number;
    slice_segment_header_extension_present_flag: number;
    pps_extension_present_flag: number;
    cross_component_prediction_enabled_flag: number;
    chroma_qp_offset_list_enabled_flag: number;
    pps_curr_pic_ref_enabled_flag: number;
    residual_adaptive_colour_transform_enabled_flag: number;
    pps_slice_act_qp_offsets_present_flag: number;
    pps_palette_predictor_initializers_present_flag: number;
    monochrome_palette_flag: number;
    pps_range_extension_flag: number;
  }) {
    const s = StdVideoH265PpsFlags.alloc();
    if (data.dependent_slice_segments_enabled_flag !== undefined) s.dependent_slice_segments_enabled_flag = data.dependent_slice_segments_enabled_flag;
    if (data.output_flag_present_flag !== undefined) s.output_flag_present_flag = data.output_flag_present_flag;
    if (data.sign_data_hiding_enabled_flag !== undefined) s.sign_data_hiding_enabled_flag = data.sign_data_hiding_enabled_flag;
    if (data.cabac_init_present_flag !== undefined) s.cabac_init_present_flag = data.cabac_init_present_flag;
    if (data.constrained_intra_pred_flag !== undefined) s.constrained_intra_pred_flag = data.constrained_intra_pred_flag;
    if (data.transform_skip_enabled_flag !== undefined) s.transform_skip_enabled_flag = data.transform_skip_enabled_flag;
    if (data.cu_qp_delta_enabled_flag !== undefined) s.cu_qp_delta_enabled_flag = data.cu_qp_delta_enabled_flag;
    if (data.pps_slice_chroma_qp_offsets_present_flag !== undefined) s.pps_slice_chroma_qp_offsets_present_flag = data.pps_slice_chroma_qp_offsets_present_flag;
    if (data.weighted_pred_flag !== undefined) s.weighted_pred_flag = data.weighted_pred_flag;
    if (data.weighted_bipred_flag !== undefined) s.weighted_bipred_flag = data.weighted_bipred_flag;
    if (data.transquant_bypass_enabled_flag !== undefined) s.transquant_bypass_enabled_flag = data.transquant_bypass_enabled_flag;
    if (data.tiles_enabled_flag !== undefined) s.tiles_enabled_flag = data.tiles_enabled_flag;
    if (data.entropy_coding_sync_enabled_flag !== undefined) s.entropy_coding_sync_enabled_flag = data.entropy_coding_sync_enabled_flag;
    if (data.uniform_spacing_flag !== undefined) s.uniform_spacing_flag = data.uniform_spacing_flag;
    if (data.loop_filter_across_tiles_enabled_flag !== undefined) s.loop_filter_across_tiles_enabled_flag = data.loop_filter_across_tiles_enabled_flag;
    if (data.pps_loop_filter_across_slices_enabled_flag !== undefined) s.pps_loop_filter_across_slices_enabled_flag = data.pps_loop_filter_across_slices_enabled_flag;
    if (data.deblocking_filter_control_present_flag !== undefined) s.deblocking_filter_control_present_flag = data.deblocking_filter_control_present_flag;
    if (data.deblocking_filter_override_enabled_flag !== undefined) s.deblocking_filter_override_enabled_flag = data.deblocking_filter_override_enabled_flag;
    if (data.pps_deblocking_filter_disabled_flag !== undefined) s.pps_deblocking_filter_disabled_flag = data.pps_deblocking_filter_disabled_flag;
    if (data.pps_scaling_list_data_present_flag !== undefined) s.pps_scaling_list_data_present_flag = data.pps_scaling_list_data_present_flag;
    if (data.lists_modification_present_flag !== undefined) s.lists_modification_present_flag = data.lists_modification_present_flag;
    if (data.slice_segment_header_extension_present_flag !== undefined) s.slice_segment_header_extension_present_flag = data.slice_segment_header_extension_present_flag;
    if (data.pps_extension_present_flag !== undefined) s.pps_extension_present_flag = data.pps_extension_present_flag;
    if (data.cross_component_prediction_enabled_flag !== undefined) s.cross_component_prediction_enabled_flag = data.cross_component_prediction_enabled_flag;
    if (data.chroma_qp_offset_list_enabled_flag !== undefined) s.chroma_qp_offset_list_enabled_flag = data.chroma_qp_offset_list_enabled_flag;
    if (data.pps_curr_pic_ref_enabled_flag !== undefined) s.pps_curr_pic_ref_enabled_flag = data.pps_curr_pic_ref_enabled_flag;
    if (data.residual_adaptive_colour_transform_enabled_flag !== undefined) s.residual_adaptive_colour_transform_enabled_flag = data.residual_adaptive_colour_transform_enabled_flag;
    if (data.pps_slice_act_qp_offsets_present_flag !== undefined) s.pps_slice_act_qp_offsets_present_flag = data.pps_slice_act_qp_offsets_present_flag;
    if (data.pps_palette_predictor_initializers_present_flag !== undefined) s.pps_palette_predictor_initializers_present_flag = data.pps_palette_predictor_initializers_present_flag;
    if (data.monochrome_palette_flag !== undefined) s.monochrome_palette_flag = data.monochrome_palette_flag;
    if (data.pps_range_extension_flag !== undefined) s.pps_range_extension_flag = data.pps_range_extension_flag;
    return s;
  }
  
  get dependent_slice_segments_enabled_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set dependent_slice_segments_enabled_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get output_flag_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set output_flag_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sign_data_hiding_enabled_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set sign_data_hiding_enabled_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get cabac_init_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set cabac_init_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get constrained_intra_pred_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set constrained_intra_pred_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transform_skip_enabled_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set transform_skip_enabled_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get cu_qp_delta_enabled_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set cu_qp_delta_enabled_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pps_slice_chroma_qp_offsets_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set pps_slice_chroma_qp_offsets_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get weighted_pred_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set weighted_pred_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get weighted_bipred_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set weighted_bipred_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get transquant_bypass_enabled_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set transquant_bypass_enabled_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get tiles_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set tiles_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get entropy_coding_sync_enabled_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set entropy_coding_sync_enabled_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get uniform_spacing_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set uniform_spacing_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get loop_filter_across_tiles_enabled_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set loop_filter_across_tiles_enabled_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pps_loop_filter_across_slices_enabled_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set pps_loop_filter_across_slices_enabled_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get deblocking_filter_control_present_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set deblocking_filter_control_present_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get deblocking_filter_override_enabled_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set deblocking_filter_override_enabled_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get pps_deblocking_filter_disabled_flag() {
    return this.#view.getUint32(72, LE);
  }
  
  set pps_deblocking_filter_disabled_flag(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pps_scaling_list_data_present_flag() {
    return this.#view.getUint32(76, LE);
  }
  
  set pps_scaling_list_data_present_flag(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get lists_modification_present_flag() {
    return this.#view.getUint32(80, LE);
  }
  
  set lists_modification_present_flag(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get slice_segment_header_extension_present_flag() {
    return this.#view.getUint32(84, LE);
  }
  
  set slice_segment_header_extension_present_flag(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get pps_extension_present_flag() {
    return this.#view.getUint32(88, LE);
  }
  
  set pps_extension_present_flag(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get cross_component_prediction_enabled_flag() {
    return this.#view.getUint32(92, LE);
  }
  
  set cross_component_prediction_enabled_flag(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get chroma_qp_offset_list_enabled_flag() {
    return this.#view.getUint32(96, LE);
  }
  
  set chroma_qp_offset_list_enabled_flag(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get pps_curr_pic_ref_enabled_flag() {
    return this.#view.getUint32(100, LE);
  }
  
  set pps_curr_pic_ref_enabled_flag(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get residual_adaptive_colour_transform_enabled_flag() {
    return this.#view.getUint32(104, LE);
  }
  
  set residual_adaptive_colour_transform_enabled_flag(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pps_slice_act_qp_offsets_present_flag() {
    return this.#view.getUint32(108, LE);
  }
  
  set pps_slice_act_qp_offsets_present_flag(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get pps_palette_predictor_initializers_present_flag() {
    return this.#view.getUint32(112, LE);
  }
  
  set pps_palette_predictor_initializers_present_flag(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get monochrome_palette_flag() {
    return this.#view.getUint32(116, LE);
  }
  
  set monochrome_palette_flag(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get pps_range_extension_flag() {
    return this.#view.getUint32(120, LE);
  }
  
  set pps_range_extension_flag(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
}

export class StdVideoH265PictureParameterSet implements IVkStructure {
  static size = 248;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoH265PictureParameterSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoH265PictureParameterSet(new Uint8Array(StdVideoH265PictureParameterSet.size));
  }
  
  static create(data: {
    flags: StdVideoH265PpsFlags;
    pps_pic_parameter_set_id: number;
    pps_seq_parameter_set_id: number;
    sps_video_parameter_set_id: number;
    num_extra_slice_header_bits: number;
    num_ref_idx_l0_default_active_minus1: number;
    num_ref_idx_l1_default_active_minus1: number;
    init_qp_minus26: number;
    diff_cu_qp_delta_depth: number;
    pps_cb_qp_offset: number;
    pps_cr_qp_offset: number;
    pps_beta_offset_div2: number;
    pps_tc_offset_div2: number;
    log2_parallel_merge_level_minus2: number;
    log2_max_transform_skip_block_size_minus2: number;
    diff_cu_chroma_qp_offset_depth: number;
    chroma_qp_offset_list_len_minus1: number;
    cb_qp_offset_list: number;
    cr_qp_offset_list: number;
    log2_sao_offset_scale_luma: number;
    log2_sao_offset_scale_chroma: number;
    pps_act_y_qp_offset_plus5: number;
    pps_act_cb_qp_offset_plus5: number;
    pps_act_cr_qp_offset_plus3: number;
    pps_num_palette_predictor_initializers: number;
    luma_bit_depth_entry_minus8: number;
    chroma_bit_depth_entry_minus8: number;
    num_tile_columns_minus1: number;
    num_tile_rows_minus1: number;
    reserved1: number;
    reserved2: number;
    column_width_minus1: number;
    row_height_minus1: number;
    reserved3: number;
    pScalingLists: Deno.PointerValue;
    pPredictorPaletteEntries: Deno.PointerValue;
  }) {
    const s = StdVideoH265PictureParameterSet.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pps_pic_parameter_set_id !== undefined) s.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
    if (data.pps_seq_parameter_set_id !== undefined) s.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
    if (data.sps_video_parameter_set_id !== undefined) s.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
    if (data.num_extra_slice_header_bits !== undefined) s.num_extra_slice_header_bits = data.num_extra_slice_header_bits;
    if (data.num_ref_idx_l0_default_active_minus1 !== undefined) s.num_ref_idx_l0_default_active_minus1 = data.num_ref_idx_l0_default_active_minus1;
    if (data.num_ref_idx_l1_default_active_minus1 !== undefined) s.num_ref_idx_l1_default_active_minus1 = data.num_ref_idx_l1_default_active_minus1;
    if (data.init_qp_minus26 !== undefined) s.init_qp_minus26 = data.init_qp_minus26;
    if (data.diff_cu_qp_delta_depth !== undefined) s.diff_cu_qp_delta_depth = data.diff_cu_qp_delta_depth;
    if (data.pps_cb_qp_offset !== undefined) s.pps_cb_qp_offset = data.pps_cb_qp_offset;
    if (data.pps_cr_qp_offset !== undefined) s.pps_cr_qp_offset = data.pps_cr_qp_offset;
    if (data.pps_beta_offset_div2 !== undefined) s.pps_beta_offset_div2 = data.pps_beta_offset_div2;
    if (data.pps_tc_offset_div2 !== undefined) s.pps_tc_offset_div2 = data.pps_tc_offset_div2;
    if (data.log2_parallel_merge_level_minus2 !== undefined) s.log2_parallel_merge_level_minus2 = data.log2_parallel_merge_level_minus2;
    if (data.log2_max_transform_skip_block_size_minus2 !== undefined) s.log2_max_transform_skip_block_size_minus2 = data.log2_max_transform_skip_block_size_minus2;
    if (data.diff_cu_chroma_qp_offset_depth !== undefined) s.diff_cu_chroma_qp_offset_depth = data.diff_cu_chroma_qp_offset_depth;
    if (data.chroma_qp_offset_list_len_minus1 !== undefined) s.chroma_qp_offset_list_len_minus1 = data.chroma_qp_offset_list_len_minus1;
    if (data.cb_qp_offset_list !== undefined) s.cb_qp_offset_list = data.cb_qp_offset_list;
    if (data.cr_qp_offset_list !== undefined) s.cr_qp_offset_list = data.cr_qp_offset_list;
    if (data.log2_sao_offset_scale_luma !== undefined) s.log2_sao_offset_scale_luma = data.log2_sao_offset_scale_luma;
    if (data.log2_sao_offset_scale_chroma !== undefined) s.log2_sao_offset_scale_chroma = data.log2_sao_offset_scale_chroma;
    if (data.pps_act_y_qp_offset_plus5 !== undefined) s.pps_act_y_qp_offset_plus5 = data.pps_act_y_qp_offset_plus5;
    if (data.pps_act_cb_qp_offset_plus5 !== undefined) s.pps_act_cb_qp_offset_plus5 = data.pps_act_cb_qp_offset_plus5;
    if (data.pps_act_cr_qp_offset_plus3 !== undefined) s.pps_act_cr_qp_offset_plus3 = data.pps_act_cr_qp_offset_plus3;
    if (data.pps_num_palette_predictor_initializers !== undefined) s.pps_num_palette_predictor_initializers = data.pps_num_palette_predictor_initializers;
    if (data.luma_bit_depth_entry_minus8 !== undefined) s.luma_bit_depth_entry_minus8 = data.luma_bit_depth_entry_minus8;
    if (data.chroma_bit_depth_entry_minus8 !== undefined) s.chroma_bit_depth_entry_minus8 = data.chroma_bit_depth_entry_minus8;
    if (data.num_tile_columns_minus1 !== undefined) s.num_tile_columns_minus1 = data.num_tile_columns_minus1;
    if (data.num_tile_rows_minus1 !== undefined) s.num_tile_rows_minus1 = data.num_tile_rows_minus1;
    if (data.reserved1 !== undefined) s.reserved1 = data.reserved1;
    if (data.reserved2 !== undefined) s.reserved2 = data.reserved2;
    if (data.column_width_minus1 !== undefined) s.column_width_minus1 = data.column_width_minus1;
    if (data.row_height_minus1 !== undefined) s.row_height_minus1 = data.row_height_minus1;
    if (data.reserved3 !== undefined) s.reserved3 = data.reserved3;
    if (data.pScalingLists !== undefined) s.pScalingLists = data.pScalingLists;
    if (data.pPredictorPaletteEntries !== undefined) s.pPredictorPaletteEntries = data.pPredictorPaletteEntries;
    return s;
  }
  
  get flags() {
    return new StdVideoH265PpsFlags(this.#data.subarray(0, 0 + StdVideoH265PpsFlags.size));
  }
  
  set flags(value: StdVideoH265PpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(124);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(124, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(125);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(125, Number(value));
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(126);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(126, Number(value));
  }
  
  get num_extra_slice_header_bits() {
    return this.#view.getUint8(127);
  }
  
  set num_extra_slice_header_bits(value: number) {
    this.#view.setUint8(127, Number(value));
  }
  
  get num_ref_idx_l0_default_active_minus1() {
    return this.#view.getUint8(128);
  }
  
  set num_ref_idx_l0_default_active_minus1(value: number) {
    this.#view.setUint8(128, Number(value));
  }
  
  get num_ref_idx_l1_default_active_minus1() {
    return this.#view.getUint8(129);
  }
  
  set num_ref_idx_l1_default_active_minus1(value: number) {
    this.#view.setUint8(129, Number(value));
  }
  
  get init_qp_minus26() {
    return this.#view.getInt8(130);
  }
  
  set init_qp_minus26(value: number) {
    this.#view.setInt8(130, Number(value));
  }
  
  get diff_cu_qp_delta_depth() {
    return this.#view.getUint8(131);
  }
  
  set diff_cu_qp_delta_depth(value: number) {
    this.#view.setUint8(131, Number(value));
  }
  
  get pps_cb_qp_offset() {
    return this.#view.getInt8(132);
  }
  
  set pps_cb_qp_offset(value: number) {
    this.#view.setInt8(132, Number(value));
  }
  
  get pps_cr_qp_offset() {
    return this.#view.getInt8(133);
  }
  
  set pps_cr_qp_offset(value: number) {
    this.#view.setInt8(133, Number(value));
  }
  
  get pps_beta_offset_div2() {
    return this.#view.getInt8(134);
  }
  
  set pps_beta_offset_div2(value: number) {
    this.#view.setInt8(134, Number(value));
  }
  
  get pps_tc_offset_div2() {
    return this.#view.getInt8(135);
  }
  
  set pps_tc_offset_div2(value: number) {
    this.#view.setInt8(135, Number(value));
  }
  
  get log2_parallel_merge_level_minus2() {
    return this.#view.getUint8(136);
  }
  
  set log2_parallel_merge_level_minus2(value: number) {
    this.#view.setUint8(136, Number(value));
  }
  
  get log2_max_transform_skip_block_size_minus2() {
    return this.#view.getUint8(137);
  }
  
  set log2_max_transform_skip_block_size_minus2(value: number) {
    this.#view.setUint8(137, Number(value));
  }
  
  get diff_cu_chroma_qp_offset_depth() {
    return this.#view.getUint8(138);
  }
  
  set diff_cu_chroma_qp_offset_depth(value: number) {
    this.#view.setUint8(138, Number(value));
  }
  
  get chroma_qp_offset_list_len_minus1() {
    return this.#view.getUint8(139);
  }
  
  set chroma_qp_offset_list_len_minus1(value: number) {
    this.#view.setUint8(139, Number(value));
  }
  
  get cb_qp_offset_list() {
    return this.#view.getInt8(140);
  }
  
  set cb_qp_offset_list(value: number) {
    this.#view.setInt8(140, Number(value));
  }
  
  get cr_qp_offset_list() {
    return this.#view.getInt8(141);
  }
  
  set cr_qp_offset_list(value: number) {
    this.#view.setInt8(141, Number(value));
  }
  
  get log2_sao_offset_scale_luma() {
    return this.#view.getUint8(142);
  }
  
  set log2_sao_offset_scale_luma(value: number) {
    this.#view.setUint8(142, Number(value));
  }
  
  get log2_sao_offset_scale_chroma() {
    return this.#view.getUint8(143);
  }
  
  set log2_sao_offset_scale_chroma(value: number) {
    this.#view.setUint8(143, Number(value));
  }
  
  get pps_act_y_qp_offset_plus5() {
    return this.#view.getInt8(144);
  }
  
  set pps_act_y_qp_offset_plus5(value: number) {
    this.#view.setInt8(144, Number(value));
  }
  
  get pps_act_cb_qp_offset_plus5() {
    return this.#view.getInt8(145);
  }
  
  set pps_act_cb_qp_offset_plus5(value: number) {
    this.#view.setInt8(145, Number(value));
  }
  
  get pps_act_cr_qp_offset_plus3() {
    return this.#view.getInt8(146);
  }
  
  set pps_act_cr_qp_offset_plus3(value: number) {
    this.#view.setInt8(146, Number(value));
  }
  
  get pps_num_palette_predictor_initializers() {
    return this.#view.getUint8(147);
  }
  
  set pps_num_palette_predictor_initializers(value: number) {
    this.#view.setUint8(147, Number(value));
  }
  
  get luma_bit_depth_entry_minus8() {
    return this.#view.getUint8(148);
  }
  
  set luma_bit_depth_entry_minus8(value: number) {
    this.#view.setUint8(148, Number(value));
  }
  
  get chroma_bit_depth_entry_minus8() {
    return this.#view.getUint8(149);
  }
  
  set chroma_bit_depth_entry_minus8(value: number) {
    this.#view.setUint8(149, Number(value));
  }
  
  get num_tile_columns_minus1() {
    return this.#view.getUint8(150);
  }
  
  set num_tile_columns_minus1(value: number) {
    this.#view.setUint8(150, Number(value));
  }
  
  get num_tile_rows_minus1() {
    return this.#view.getUint8(151);
  }
  
  set num_tile_rows_minus1(value: number) {
    this.#view.setUint8(151, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(152);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(152, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(153);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(153, Number(value));
  }
  
  get column_width_minus1() {
    return this.#view.getUint16(154, LE);
  }
  
  set column_width_minus1(value: number) {
    this.#view.setUint16(154, Number(value), LE);
  }
  
  get row_height_minus1() {
    return this.#view.getUint16(156, LE);
  }
  
  set row_height_minus1(value: number) {
    this.#view.setUint16(156, Number(value), LE);
  }
  
  get reserved3() {
    return this.#view.getUint32(160, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(168, LE);
  }
  
  set pScalingLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(168, BigInt(value), LE);
  }
  
  get pPredictorPaletteEntries() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set pPredictorPaletteEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
}

export class StdVideoDecodeH265PictureInfoFlags implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH265PictureInfoFlags(new Uint8Array(StdVideoDecodeH265PictureInfoFlags.size));
  }
  
  static create(data: {
    IrapPicFlag: number;
    IdrPicFlag: number;
    IsReference: number;
    short_term_ref_pic_set_sps_flag: number;
  }) {
    const s = StdVideoDecodeH265PictureInfoFlags.alloc();
    if (data.IrapPicFlag !== undefined) s.IrapPicFlag = data.IrapPicFlag;
    if (data.IdrPicFlag !== undefined) s.IdrPicFlag = data.IdrPicFlag;
    if (data.IsReference !== undefined) s.IsReference = data.IsReference;
    if (data.short_term_ref_pic_set_sps_flag !== undefined) s.short_term_ref_pic_set_sps_flag = data.short_term_ref_pic_set_sps_flag;
    return s;
  }
  
  get IrapPicFlag() {
    return this.#view.getUint32(0, LE);
  }
  
  set IrapPicFlag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get IdrPicFlag() {
    return this.#view.getUint32(4, LE);
  }
  
  set IdrPicFlag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get IsReference() {
    return this.#view.getUint32(8, LE);
  }
  
  set IsReference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get short_term_ref_pic_set_sps_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set short_term_ref_pic_set_sps_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class StdVideoDecodeH265PictureInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH265PictureInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH265PictureInfo(new Uint8Array(StdVideoDecodeH265PictureInfo.size));
  }
  
  static create(data: {
    flags: StdVideoDecodeH265PictureInfoFlags;
    sps_video_parameter_set_id: number;
    pps_seq_parameter_set_id: number;
    pps_pic_parameter_set_id: number;
    NumDeltaPocsOfRefRpsIdx: number;
    PicOrderCntVal: number;
    NumBitsForSTRefPicSetInSlice: number;
    reserved: number;
    RefPicSetStCurrBefore: number;
    RefPicSetStCurrAfter: number;
    RefPicSetLtCurr: number;
  }) {
    const s = StdVideoDecodeH265PictureInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.sps_video_parameter_set_id !== undefined) s.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
    if (data.pps_seq_parameter_set_id !== undefined) s.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
    if (data.pps_pic_parameter_set_id !== undefined) s.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
    if (data.NumDeltaPocsOfRefRpsIdx !== undefined) s.NumDeltaPocsOfRefRpsIdx = data.NumDeltaPocsOfRefRpsIdx;
    if (data.PicOrderCntVal !== undefined) s.PicOrderCntVal = data.PicOrderCntVal;
    if (data.NumBitsForSTRefPicSetInSlice !== undefined) s.NumBitsForSTRefPicSetInSlice = data.NumBitsForSTRefPicSetInSlice;
    if (data.reserved !== undefined) s.reserved = data.reserved;
    if (data.RefPicSetStCurrBefore !== undefined) s.RefPicSetStCurrBefore = data.RefPicSetStCurrBefore;
    if (data.RefPicSetStCurrAfter !== undefined) s.RefPicSetStCurrAfter = data.RefPicSetStCurrAfter;
    if (data.RefPicSetLtCurr !== undefined) s.RefPicSetLtCurr = data.RefPicSetLtCurr;
    return s;
  }
  
  get flags() {
    return new StdVideoDecodeH265PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH265PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH265PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(16);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(17);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(18);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get NumDeltaPocsOfRefRpsIdx() {
    return this.#view.getUint8(19);
  }
  
  set NumDeltaPocsOfRefRpsIdx(value: number) {
    this.#view.setUint8(19, Number(value));
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(20, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(20, Number(value), LE);
  }
  
  get NumBitsForSTRefPicSetInSlice() {
    return this.#view.getUint16(24, LE);
  }
  
  set NumBitsForSTRefPicSetInSlice(value: number) {
    this.#view.setUint16(24, Number(value), LE);
  }
  
  get reserved() {
    return this.#view.getUint16(26, LE);
  }
  
  set reserved(value: number) {
    this.#view.setUint16(26, Number(value), LE);
  }
  
  get RefPicSetStCurrBefore() {
    return this.#view.getUint8(28);
  }
  
  set RefPicSetStCurrBefore(value: number) {
    this.#view.setUint8(28, Number(value));
  }
  
  get RefPicSetStCurrAfter() {
    return this.#view.getUint8(29);
  }
  
  set RefPicSetStCurrAfter(value: number) {
    this.#view.setUint8(29, Number(value));
  }
  
  get RefPicSetLtCurr() {
    return this.#view.getUint8(30);
  }
  
  set RefPicSetLtCurr(value: number) {
    this.#view.setUint8(30, Number(value));
  }
}

export class StdVideoDecodeH265ReferenceInfoFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH265ReferenceInfoFlags(new Uint8Array(StdVideoDecodeH265ReferenceInfoFlags.size));
  }
  
  static create(data: {
    used_for_long_term_reference: number;
    unused_for_reference: number;
  }) {
    const s = StdVideoDecodeH265ReferenceInfoFlags.alloc();
    if (data.used_for_long_term_reference !== undefined) s.used_for_long_term_reference = data.used_for_long_term_reference;
    if (data.unused_for_reference !== undefined) s.unused_for_reference = data.unused_for_reference;
    return s;
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get unused_for_reference() {
    return this.#view.getUint32(4, LE);
  }
  
  set unused_for_reference(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoDecodeH265ReferenceInfo implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoDecodeH265ReferenceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoDecodeH265ReferenceInfo(new Uint8Array(StdVideoDecodeH265ReferenceInfo.size));
  }
  
  static create(data: {
    flags: StdVideoDecodeH265ReferenceInfoFlags;
    PicOrderCntVal: number;
  }) {
    const s = StdVideoDecodeH265ReferenceInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.PicOrderCntVal !== undefined) s.PicOrderCntVal = data.PicOrderCntVal;
    return s;
  }
  
  get flags() {
    return new StdVideoDecodeH265ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH265ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH265ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export class StdVideoEncodeH265WeightTableFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265WeightTableFlags(new Uint8Array(StdVideoEncodeH265WeightTableFlags.size));
  }
  
  static create(data: {
    luma_weight_l0_flag: number;
    chroma_weight_l0_flag: number;
    luma_weight_l1_flag: number;
    chroma_weight_l1_flag: number;
  }) {
    const s = StdVideoEncodeH265WeightTableFlags.alloc();
    if (data.luma_weight_l0_flag !== undefined) s.luma_weight_l0_flag = data.luma_weight_l0_flag;
    if (data.chroma_weight_l0_flag !== undefined) s.chroma_weight_l0_flag = data.chroma_weight_l0_flag;
    if (data.luma_weight_l1_flag !== undefined) s.luma_weight_l1_flag = data.luma_weight_l1_flag;
    if (data.chroma_weight_l1_flag !== undefined) s.chroma_weight_l1_flag = data.chroma_weight_l1_flag;
    return s;
  }
  
  get luma_weight_l0_flag() {
    return this.#view.getUint16(0, LE);
  }
  
  set luma_weight_l0_flag(value: number) {
    this.#view.setUint16(0, Number(value), LE);
  }
  
  get chroma_weight_l0_flag() {
    return this.#view.getUint16(2, LE);
  }
  
  set chroma_weight_l0_flag(value: number) {
    this.#view.setUint16(2, Number(value), LE);
  }
  
  get luma_weight_l1_flag() {
    return this.#view.getUint16(4, LE);
  }
  
  set luma_weight_l1_flag(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get chroma_weight_l1_flag() {
    return this.#view.getUint16(6, LE);
  }
  
  set chroma_weight_l1_flag(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export class StdVideoEncodeH265WeightTable implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265WeightTable.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265WeightTable(new Uint8Array(StdVideoEncodeH265WeightTable.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH265WeightTableFlags;
    luma_log2_weight_denom: number;
    delta_chroma_log2_weight_denom: number;
    delta_luma_weight_l0: number;
    luma_offset_l0: number;
    delta_chroma_weight_l0: number;
    delta_chroma_offset_l0: number;
    delta_luma_weight_l1: number;
    luma_offset_l1: number;
    delta_chroma_weight_l1: number;
    delta_chroma_offset_l1: number;
  }) {
    const s = StdVideoEncodeH265WeightTable.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.luma_log2_weight_denom !== undefined) s.luma_log2_weight_denom = data.luma_log2_weight_denom;
    if (data.delta_chroma_log2_weight_denom !== undefined) s.delta_chroma_log2_weight_denom = data.delta_chroma_log2_weight_denom;
    if (data.delta_luma_weight_l0 !== undefined) s.delta_luma_weight_l0 = data.delta_luma_weight_l0;
    if (data.luma_offset_l0 !== undefined) s.luma_offset_l0 = data.luma_offset_l0;
    if (data.delta_chroma_weight_l0 !== undefined) s.delta_chroma_weight_l0 = data.delta_chroma_weight_l0;
    if (data.delta_chroma_offset_l0 !== undefined) s.delta_chroma_offset_l0 = data.delta_chroma_offset_l0;
    if (data.delta_luma_weight_l1 !== undefined) s.delta_luma_weight_l1 = data.delta_luma_weight_l1;
    if (data.luma_offset_l1 !== undefined) s.luma_offset_l1 = data.luma_offset_l1;
    if (data.delta_chroma_weight_l1 !== undefined) s.delta_chroma_weight_l1 = data.delta_chroma_weight_l1;
    if (data.delta_chroma_offset_l1 !== undefined) s.delta_chroma_offset_l1 = data.delta_chroma_offset_l1;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH265WeightTableFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265WeightTableFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265WeightTableFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get luma_log2_weight_denom() {
    return this.#view.getUint8(8);
  }
  
  set luma_log2_weight_denom(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get delta_chroma_log2_weight_denom() {
    return this.#view.getInt8(9);
  }
  
  set delta_chroma_log2_weight_denom(value: number) {
    this.#view.setInt8(9, Number(value));
  }
  
  get delta_luma_weight_l0() {
    return this.#view.getInt8(10);
  }
  
  set delta_luma_weight_l0(value: number) {
    this.#view.setInt8(10, Number(value));
  }
  
  get luma_offset_l0() {
    return this.#view.getInt8(11);
  }
  
  set luma_offset_l0(value: number) {
    this.#view.setInt8(11, Number(value));
  }
  
  get delta_chroma_weight_l0() {
    return this.#view.getInt8(12);
  }
  
  set delta_chroma_weight_l0(value: number) {
    this.#view.setInt8(12, Number(value));
  }
  
  get delta_chroma_offset_l0() {
    return this.#view.getInt8(13);
  }
  
  set delta_chroma_offset_l0(value: number) {
    this.#view.setInt8(13, Number(value));
  }
  
  get delta_luma_weight_l1() {
    return this.#view.getInt8(14);
  }
  
  set delta_luma_weight_l1(value: number) {
    this.#view.setInt8(14, Number(value));
  }
  
  get luma_offset_l1() {
    return this.#view.getInt8(15);
  }
  
  set luma_offset_l1(value: number) {
    this.#view.setInt8(15, Number(value));
  }
  
  get delta_chroma_weight_l1() {
    return this.#view.getInt8(16);
  }
  
  set delta_chroma_weight_l1(value: number) {
    this.#view.setInt8(16, Number(value));
  }
  
  get delta_chroma_offset_l1() {
    return this.#view.getInt8(17);
  }
  
  set delta_chroma_offset_l1(value: number) {
    this.#view.setInt8(17, Number(value));
  }
}

export class StdVideoEncodeH265SliceSegmentLongTermRefPics implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265SliceSegmentLongTermRefPics.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265SliceSegmentLongTermRefPics(new Uint8Array(StdVideoEncodeH265SliceSegmentLongTermRefPics.size));
  }
  
  static create(data: {
    num_long_term_sps: number;
    num_long_term_pics: number;
    lt_idx_sps: number;
    poc_lsb_lt: number;
    used_by_curr_pic_lt_flag: number;
    delta_poc_msb_present_flag: number;
    delta_poc_msb_cycle_lt: number;
  }) {
    const s = StdVideoEncodeH265SliceSegmentLongTermRefPics.alloc();
    if (data.num_long_term_sps !== undefined) s.num_long_term_sps = data.num_long_term_sps;
    if (data.num_long_term_pics !== undefined) s.num_long_term_pics = data.num_long_term_pics;
    if (data.lt_idx_sps !== undefined) s.lt_idx_sps = data.lt_idx_sps;
    if (data.poc_lsb_lt !== undefined) s.poc_lsb_lt = data.poc_lsb_lt;
    if (data.used_by_curr_pic_lt_flag !== undefined) s.used_by_curr_pic_lt_flag = data.used_by_curr_pic_lt_flag;
    if (data.delta_poc_msb_present_flag !== undefined) s.delta_poc_msb_present_flag = data.delta_poc_msb_present_flag;
    if (data.delta_poc_msb_cycle_lt !== undefined) s.delta_poc_msb_cycle_lt = data.delta_poc_msb_cycle_lt;
    return s;
  }
  
  get num_long_term_sps() {
    return this.#view.getUint8(0);
  }
  
  set num_long_term_sps(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get num_long_term_pics() {
    return this.#view.getUint8(1);
  }
  
  set num_long_term_pics(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get lt_idx_sps() {
    return this.#view.getUint8(2);
  }
  
  set lt_idx_sps(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get poc_lsb_lt() {
    return this.#view.getUint8(3);
  }
  
  set poc_lsb_lt(value: number) {
    this.#view.setUint8(3, Number(value));
  }
  
  get used_by_curr_pic_lt_flag() {
    return this.#view.getUint16(4, LE);
  }
  
  set used_by_curr_pic_lt_flag(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get delta_poc_msb_present_flag() {
    return this.#view.getUint8(6);
  }
  
  set delta_poc_msb_present_flag(value: number) {
    this.#view.setUint8(6, Number(value));
  }
  
  get delta_poc_msb_cycle_lt() {
    return this.#view.getUint8(7);
  }
  
  set delta_poc_msb_cycle_lt(value: number) {
    this.#view.setUint8(7, Number(value));
  }
}

export class StdVideoEncodeH265SliceSegmentHeaderFlags implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265SliceSegmentHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265SliceSegmentHeaderFlags(new Uint8Array(StdVideoEncodeH265SliceSegmentHeaderFlags.size));
  }
  
  static create(data: {
    first_slice_segment_in_pic_flag: number;
    no_output_of_prior_pics_flag: number;
    dependent_slice_segment_flag: number;
    pic_output_flag: number;
    short_term_ref_pic_set_sps_flag: number;
    slice_temporal_mvp_enable_flag: number;
    slice_sao_luma_flag: number;
    slice_sao_chroma_flag: number;
    num_ref_idx_active_override_flag: number;
    mvd_l1_zero_flag: number;
    cabac_init_flag: number;
    cu_chroma_qp_offset_enabled_flag: number;
    deblocking_filter_override_flag: number;
    slice_deblocking_filter_disabled_flag: number;
    collocated_from_l0_flag: number;
    slice_loop_filter_across_slices_enabled_flag: number;
  }) {
    const s = StdVideoEncodeH265SliceSegmentHeaderFlags.alloc();
    if (data.first_slice_segment_in_pic_flag !== undefined) s.first_slice_segment_in_pic_flag = data.first_slice_segment_in_pic_flag;
    if (data.no_output_of_prior_pics_flag !== undefined) s.no_output_of_prior_pics_flag = data.no_output_of_prior_pics_flag;
    if (data.dependent_slice_segment_flag !== undefined) s.dependent_slice_segment_flag = data.dependent_slice_segment_flag;
    if (data.pic_output_flag !== undefined) s.pic_output_flag = data.pic_output_flag;
    if (data.short_term_ref_pic_set_sps_flag !== undefined) s.short_term_ref_pic_set_sps_flag = data.short_term_ref_pic_set_sps_flag;
    if (data.slice_temporal_mvp_enable_flag !== undefined) s.slice_temporal_mvp_enable_flag = data.slice_temporal_mvp_enable_flag;
    if (data.slice_sao_luma_flag !== undefined) s.slice_sao_luma_flag = data.slice_sao_luma_flag;
    if (data.slice_sao_chroma_flag !== undefined) s.slice_sao_chroma_flag = data.slice_sao_chroma_flag;
    if (data.num_ref_idx_active_override_flag !== undefined) s.num_ref_idx_active_override_flag = data.num_ref_idx_active_override_flag;
    if (data.mvd_l1_zero_flag !== undefined) s.mvd_l1_zero_flag = data.mvd_l1_zero_flag;
    if (data.cabac_init_flag !== undefined) s.cabac_init_flag = data.cabac_init_flag;
    if (data.cu_chroma_qp_offset_enabled_flag !== undefined) s.cu_chroma_qp_offset_enabled_flag = data.cu_chroma_qp_offset_enabled_flag;
    if (data.deblocking_filter_override_flag !== undefined) s.deblocking_filter_override_flag = data.deblocking_filter_override_flag;
    if (data.slice_deblocking_filter_disabled_flag !== undefined) s.slice_deblocking_filter_disabled_flag = data.slice_deblocking_filter_disabled_flag;
    if (data.collocated_from_l0_flag !== undefined) s.collocated_from_l0_flag = data.collocated_from_l0_flag;
    if (data.slice_loop_filter_across_slices_enabled_flag !== undefined) s.slice_loop_filter_across_slices_enabled_flag = data.slice_loop_filter_across_slices_enabled_flag;
    return s;
  }
  
  get first_slice_segment_in_pic_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set first_slice_segment_in_pic_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get no_output_of_prior_pics_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set no_output_of_prior_pics_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dependent_slice_segment_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set dependent_slice_segment_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pic_output_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set pic_output_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get short_term_ref_pic_set_sps_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set short_term_ref_pic_set_sps_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get slice_temporal_mvp_enable_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set slice_temporal_mvp_enable_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get slice_sao_luma_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set slice_sao_luma_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get slice_sao_chroma_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set slice_sao_chroma_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get num_ref_idx_active_override_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set num_ref_idx_active_override_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get mvd_l1_zero_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set mvd_l1_zero_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get cabac_init_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set cabac_init_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get cu_chroma_qp_offset_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set cu_chroma_qp_offset_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get deblocking_filter_override_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set deblocking_filter_override_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get slice_deblocking_filter_disabled_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set slice_deblocking_filter_disabled_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get collocated_from_l0_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set collocated_from_l0_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get slice_loop_filter_across_slices_enabled_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set slice_loop_filter_across_slices_enabled_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class StdVideoEncodeH265SliceSegmentHeader implements IVkStructure {
  static size = 128;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265SliceSegmentHeader.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265SliceSegmentHeader(new Uint8Array(StdVideoEncodeH265SliceSegmentHeader.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH265SliceSegmentHeaderFlags;
    slice_type: StdVideoH265SliceType;
    slice_segment_address: number;
    short_term_ref_pic_set_idx: number;
    collocated_ref_idx: number;
    num_ref_idx_l0_active_minus1: number;
    num_ref_idx_l1_active_minus1: number;
    MaxNumMergeCand: number;
    slice_cb_qp_offset: number;
    slice_cr_qp_offset: number;
    slice_beta_offset_div2: number;
    slice_tc_offset_div2: number;
    slice_act_y_qp_offset: number;
    slice_act_cb_qp_offset: number;
    slice_act_cr_qp_offset: number;
    pShortTermRefPicSet: Deno.PointerValue;
    pLongTermRefPics: Deno.PointerValue;
    pWeightTable: Deno.PointerValue;
  }) {
    const s = StdVideoEncodeH265SliceSegmentHeader.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.slice_type !== undefined) s.slice_type = data.slice_type;
    if (data.slice_segment_address !== undefined) s.slice_segment_address = data.slice_segment_address;
    if (data.short_term_ref_pic_set_idx !== undefined) s.short_term_ref_pic_set_idx = data.short_term_ref_pic_set_idx;
    if (data.collocated_ref_idx !== undefined) s.collocated_ref_idx = data.collocated_ref_idx;
    if (data.num_ref_idx_l0_active_minus1 !== undefined) s.num_ref_idx_l0_active_minus1 = data.num_ref_idx_l0_active_minus1;
    if (data.num_ref_idx_l1_active_minus1 !== undefined) s.num_ref_idx_l1_active_minus1 = data.num_ref_idx_l1_active_minus1;
    if (data.MaxNumMergeCand !== undefined) s.MaxNumMergeCand = data.MaxNumMergeCand;
    if (data.slice_cb_qp_offset !== undefined) s.slice_cb_qp_offset = data.slice_cb_qp_offset;
    if (data.slice_cr_qp_offset !== undefined) s.slice_cr_qp_offset = data.slice_cr_qp_offset;
    if (data.slice_beta_offset_div2 !== undefined) s.slice_beta_offset_div2 = data.slice_beta_offset_div2;
    if (data.slice_tc_offset_div2 !== undefined) s.slice_tc_offset_div2 = data.slice_tc_offset_div2;
    if (data.slice_act_y_qp_offset !== undefined) s.slice_act_y_qp_offset = data.slice_act_y_qp_offset;
    if (data.slice_act_cb_qp_offset !== undefined) s.slice_act_cb_qp_offset = data.slice_act_cb_qp_offset;
    if (data.slice_act_cr_qp_offset !== undefined) s.slice_act_cr_qp_offset = data.slice_act_cr_qp_offset;
    if (data.pShortTermRefPicSet !== undefined) s.pShortTermRefPicSet = data.pShortTermRefPicSet;
    if (data.pLongTermRefPics !== undefined) s.pLongTermRefPics = data.pLongTermRefPics;
    if (data.pWeightTable !== undefined) s.pWeightTable = data.pWeightTable;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH265SliceSegmentHeaderFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265SliceSegmentHeaderFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265SliceSegmentHeaderFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265SliceSegmentHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get slice_type() {
    return this.#view.getUint32(64, LE);
  }
  
  set slice_type(value: StdVideoH265SliceType) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get slice_segment_address() {
    return this.#view.getUint32(68, LE);
  }
  
  set slice_segment_address(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get short_term_ref_pic_set_idx() {
    return this.#view.getUint8(72);
  }
  
  set short_term_ref_pic_set_idx(value: number) {
    this.#view.setUint8(72, Number(value));
  }
  
  get collocated_ref_idx() {
    return this.#view.getUint8(73);
  }
  
  set collocated_ref_idx(value: number) {
    this.#view.setUint8(73, Number(value));
  }
  
  get num_ref_idx_l0_active_minus1() {
    return this.#view.getUint8(74);
  }
  
  set num_ref_idx_l0_active_minus1(value: number) {
    this.#view.setUint8(74, Number(value));
  }
  
  get num_ref_idx_l1_active_minus1() {
    return this.#view.getUint8(75);
  }
  
  set num_ref_idx_l1_active_minus1(value: number) {
    this.#view.setUint8(75, Number(value));
  }
  
  get MaxNumMergeCand() {
    return this.#view.getUint8(76);
  }
  
  set MaxNumMergeCand(value: number) {
    this.#view.setUint8(76, Number(value));
  }
  
  get slice_cb_qp_offset() {
    return this.#view.getInt8(77);
  }
  
  set slice_cb_qp_offset(value: number) {
    this.#view.setInt8(77, Number(value));
  }
  
  get slice_cr_qp_offset() {
    return this.#view.getInt8(78);
  }
  
  set slice_cr_qp_offset(value: number) {
    this.#view.setInt8(78, Number(value));
  }
  
  get slice_beta_offset_div2() {
    return this.#view.getInt8(79);
  }
  
  set slice_beta_offset_div2(value: number) {
    this.#view.setInt8(79, Number(value));
  }
  
  get slice_tc_offset_div2() {
    return this.#view.getInt8(80);
  }
  
  set slice_tc_offset_div2(value: number) {
    this.#view.setInt8(80, Number(value));
  }
  
  get slice_act_y_qp_offset() {
    return this.#view.getInt8(81);
  }
  
  set slice_act_y_qp_offset(value: number) {
    this.#view.setInt8(81, Number(value));
  }
  
  get slice_act_cb_qp_offset() {
    return this.#view.getInt8(82);
  }
  
  set slice_act_cb_qp_offset(value: number) {
    this.#view.setInt8(82, Number(value));
  }
  
  get slice_act_cr_qp_offset() {
    return this.#view.getInt8(83);
  }
  
  set slice_act_cr_qp_offset(value: number) {
    this.#view.setInt8(83, Number(value));
  }
  
  get pShortTermRefPicSet() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pShortTermRefPicSet(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get pLongTermRefPics() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pLongTermRefPics(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get pWeightTable() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set pWeightTable(value: Deno.PointerValue) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
}

export class StdVideoEncodeH265ReferenceModificationFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265ReferenceModificationFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265ReferenceModificationFlags(new Uint8Array(StdVideoEncodeH265ReferenceModificationFlags.size));
  }
  
  static create(data: {
    ref_pic_list_modification_flag_l0: number;
    ref_pic_list_modification_flag_l1: number;
  }) {
    const s = StdVideoEncodeH265ReferenceModificationFlags.alloc();
    if (data.ref_pic_list_modification_flag_l0 !== undefined) s.ref_pic_list_modification_flag_l0 = data.ref_pic_list_modification_flag_l0;
    if (data.ref_pic_list_modification_flag_l1 !== undefined) s.ref_pic_list_modification_flag_l1 = data.ref_pic_list_modification_flag_l1;
    return s;
  }
  
  get ref_pic_list_modification_flag_l0() {
    return this.#view.getUint32(0, LE);
  }
  
  set ref_pic_list_modification_flag_l0(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get ref_pic_list_modification_flag_l1() {
    return this.#view.getUint32(4, LE);
  }
  
  set ref_pic_list_modification_flag_l1(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoEncodeH265ReferenceModifications implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265ReferenceModifications.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265ReferenceModifications(new Uint8Array(StdVideoEncodeH265ReferenceModifications.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH265ReferenceModificationFlags;
    referenceList0ModificationsCount: number;
    pReferenceList0Modifications: Deno.PointerValue;
    referenceList1ModificationsCount: number;
    pReferenceList1Modifications: Deno.PointerValue;
  }) {
    const s = StdVideoEncodeH265ReferenceModifications.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.referenceList0ModificationsCount !== undefined) s.referenceList0ModificationsCount = data.referenceList0ModificationsCount;
    if (data.pReferenceList0Modifications !== undefined) s.pReferenceList0Modifications = data.pReferenceList0Modifications;
    if (data.referenceList1ModificationsCount !== undefined) s.referenceList1ModificationsCount = data.referenceList1ModificationsCount;
    if (data.pReferenceList1Modifications !== undefined) s.pReferenceList1Modifications = data.pReferenceList1Modifications;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH265ReferenceModificationFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265ReferenceModificationFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265ReferenceModificationFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265ReferenceModificationFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get referenceList0ModificationsCount() {
    return this.#view.getUint8(8);
  }
  
  set referenceList0ModificationsCount(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get pReferenceList0Modifications() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceList0Modifications(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get referenceList1ModificationsCount() {
    return this.#view.getUint8(24);
  }
  
  set referenceList1ModificationsCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pReferenceList1Modifications() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pReferenceList1Modifications(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class StdVideoEncodeH265PictureInfoFlags implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265PictureInfoFlags(new Uint8Array(StdVideoEncodeH265PictureInfoFlags.size));
  }
  
  static create(data: {
    is_reference_flag: number;
    IrapPicFlag: number;
    long_term_flag: number;
    discardable_flag: number;
    cross_layer_bla_flag: number;
  }) {
    const s = StdVideoEncodeH265PictureInfoFlags.alloc();
    if (data.is_reference_flag !== undefined) s.is_reference_flag = data.is_reference_flag;
    if (data.IrapPicFlag !== undefined) s.IrapPicFlag = data.IrapPicFlag;
    if (data.long_term_flag !== undefined) s.long_term_flag = data.long_term_flag;
    if (data.discardable_flag !== undefined) s.discardable_flag = data.discardable_flag;
    if (data.cross_layer_bla_flag !== undefined) s.cross_layer_bla_flag = data.cross_layer_bla_flag;
    return s;
  }
  
  get is_reference_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set is_reference_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get IrapPicFlag() {
    return this.#view.getUint32(4, LE);
  }
  
  set IrapPicFlag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get long_term_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set long_term_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get discardable_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set discardable_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get cross_layer_bla_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set cross_layer_bla_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class StdVideoEncodeH265PictureInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265PictureInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265PictureInfo(new Uint8Array(StdVideoEncodeH265PictureInfo.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH265PictureInfoFlags;
    PictureType: StdVideoH265PictureType;
    sps_video_parameter_set_id: number;
    pps_seq_parameter_set_id: number;
    pps_pic_parameter_set_id: number;
    PicOrderCntVal: number;
    TemporalId: number;
  }) {
    const s = StdVideoEncodeH265PictureInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.PictureType !== undefined) s.PictureType = data.PictureType;
    if (data.sps_video_parameter_set_id !== undefined) s.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
    if (data.pps_seq_parameter_set_id !== undefined) s.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
    if (data.pps_pic_parameter_set_id !== undefined) s.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
    if (data.PicOrderCntVal !== undefined) s.PicOrderCntVal = data.PicOrderCntVal;
    if (data.TemporalId !== undefined) s.TemporalId = data.TemporalId;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH265PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PictureType() {
    return this.#view.getUint32(20, LE);
  }
  
  set PictureType(value: StdVideoH265PictureType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(24);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(25);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(26);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(28, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(28, Number(value), LE);
  }
  
  get TemporalId() {
    return this.#view.getUint8(32);
  }
  
  set TemporalId(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export class StdVideoEncodeH265ReferenceInfoFlags implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265ReferenceInfoFlags(new Uint8Array(StdVideoEncodeH265ReferenceInfoFlags.size));
  }
  
  static create(data: {
    used_for_long_term_reference: number;
    unused_for_reference: number;
  }) {
    const s = StdVideoEncodeH265ReferenceInfoFlags.alloc();
    if (data.used_for_long_term_reference !== undefined) s.used_for_long_term_reference = data.used_for_long_term_reference;
    if (data.unused_for_reference !== undefined) s.unused_for_reference = data.unused_for_reference;
    return s;
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get unused_for_reference() {
    return this.#view.getUint32(4, LE);
  }
  
  set unused_for_reference(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class StdVideoEncodeH265ReferenceInfo implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < StdVideoEncodeH265ReferenceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new StdVideoEncodeH265ReferenceInfo(new Uint8Array(StdVideoEncodeH265ReferenceInfo.size));
  }
  
  static create(data: {
    flags: StdVideoEncodeH265ReferenceInfoFlags;
    PicOrderCntVal: number;
    TemporalId: number;
  }) {
    const s = StdVideoEncodeH265ReferenceInfo.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.PicOrderCntVal !== undefined) s.PicOrderCntVal = data.PicOrderCntVal;
    if (data.TemporalId !== undefined) s.TemporalId = data.TemporalId;
    return s;
  }
  
  get flags() {
    return new StdVideoEncodeH265ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
  
  get TemporalId() {
    return this.#view.getUint8(12);
  }
  
  set TemporalId(value: number) {
    this.#view.setUint8(12, Number(value));
  }
}

export class VkBaseOutStructure implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBaseOutStructure.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBaseOutStructure(new Uint8Array(VkBaseOutStructure.size));
  }
  
  static create(data: {
    sType: VkStructureType;
    pNext?: Deno.PointerValue;
  }) {
    const s = VkBaseOutStructure.alloc();
    if (data.sType !== undefined) s.sType = data.sType;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkBaseInStructure implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBaseInStructure.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBaseInStructure(new Uint8Array(VkBaseInStructure.size));
  }
  
  static create(data: {
    sType: VkStructureType;
    pNext?: Deno.PointerValue;
  }) {
    const s = VkBaseInStructure.alloc();
    if (data.sType !== undefined) s.sType = data.sType;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkOffset2D implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOffset2D(new Uint8Array(VkOffset2D.size));
  }
  
  static create(data: {
    x: number;
    y: number;
  }) {
    const s = VkOffset2D.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    return s;
  }
  
  get x() {
    return this.#view.getInt32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getInt32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
}

export class VkOffset3D implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOffset3D(new Uint8Array(VkOffset3D.size));
  }
  
  static create(data: {
    x: number;
    y: number;
    z: number;
  }) {
    const s = VkOffset3D.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    if (data.z !== undefined) s.z = data.z;
    return s;
  }
  
  get x() {
    return this.#view.getInt32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getInt32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getInt32(8, LE);
  }
  
  set z(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export class VkExtent2D implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExtent2D(new Uint8Array(VkExtent2D.size));
  }
  
  static create(data: {
    width: number;
    height: number;
  }) {
    const s = VkExtent2D.alloc();
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    return s;
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkExtent3D implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExtent3D(new Uint8Array(VkExtent3D.size));
  }
  
  static create(data: {
    width: number;
    height: number;
    depth: number;
  }) {
    const s = VkExtent3D.alloc();
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.depth !== undefined) s.depth = data.depth;
    return s;
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(8, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkViewport implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkViewport.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkViewport(new Uint8Array(VkViewport.size));
  }
  
  static create(data: {
    x: number;
    y: number;
    width: number;
    height: number;
    minDepth: number;
    maxDepth: number;
  }) {
    const s = VkViewport.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.minDepth !== undefined) s.minDepth = data.minDepth;
    if (data.maxDepth !== undefined) s.maxDepth = data.maxDepth;
    return s;
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get width() {
    return this.#view.getFloat32(8, LE);
  }
  
  set width(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get height() {
    return this.#view.getFloat32(12, LE);
  }
  
  set height(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get minDepth() {
    return this.#view.getFloat32(16, LE);
  }
  
  set minDepth(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxDepth() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxDepth(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
}

export class VkRect2D implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRect2D(new Uint8Array(VkRect2D.size));
  }
  
  static create(data: {
    offset: VkOffset2D;
    extent: VkExtent2D;
  }) {
    const s = VkRect2D.alloc();
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.extent !== undefined) s.extent = data.extent;
    return s;
  }
  
  get offset() {
    return new VkOffset2D(this.#data.subarray(0, 0 + VkOffset2D.size));
  }
  
  set offset(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get extent() {
    return new VkExtent2D(this.#data.subarray(8, 8 + VkExtent2D.size));
  }
  
  set extent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
}

export class VkClearRect implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkClearRect.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkClearRect(new Uint8Array(VkClearRect.size));
  }
  
  static create(data: {
    rect: VkRect2D;
    baseArrayLayer: number;
    layerCount: number;
  }) {
    const s = VkClearRect.alloc();
    if (data.rect !== undefined) s.rect = data.rect;
    if (data.baseArrayLayer !== undefined) s.baseArrayLayer = data.baseArrayLayer;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    return s;
  }
  
  get rect() {
    return new VkRect2D(this.#data.subarray(0, 0 + VkRect2D.size));
  }
  
  set rect(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(16, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkComponentMapping implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkComponentMapping(new Uint8Array(VkComponentMapping.size));
  }
  
  static create(data: {
    r: VkComponentSwizzle;
    g: VkComponentSwizzle;
    b: VkComponentSwizzle;
    a: VkComponentSwizzle;
  }) {
    const s = VkComponentMapping.alloc();
    if (data.r !== undefined) s.r = data.r;
    if (data.g !== undefined) s.g = data.g;
    if (data.b !== undefined) s.b = data.b;
    if (data.a !== undefined) s.a = data.a;
    return s;
  }
  
  get r() {
    return this.#view.getUint32(0, LE);
  }
  
  set r(value: VkComponentSwizzle) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get g() {
    return this.#view.getUint32(4, LE);
  }
  
  set g(value: VkComponentSwizzle) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get b() {
    return this.#view.getUint32(8, LE);
  }
  
  set b(value: VkComponentSwizzle) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get a() {
    return this.#view.getUint32(12, LE);
  }
  
  set a(value: VkComponentSwizzle) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkPhysicalDeviceProperties implements IVkStructure {
  static size = 1416;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProperties(new Uint8Array(VkPhysicalDeviceProperties.size));
  }
  
  static create(data: {
    apiVersion: number;
    driverVersion: number;
    vendorID: number;
    deviceID: number;
    deviceType: VkPhysicalDeviceType;
    deviceName: number;
    pipelineCacheUUID: number;
    limits: VkPhysicalDeviceLimits;
    sparseProperties: VkPhysicalDeviceSparseProperties;
  }) {
    const s = VkPhysicalDeviceProperties.alloc();
    if (data.apiVersion !== undefined) s.apiVersion = data.apiVersion;
    if (data.driverVersion !== undefined) s.driverVersion = data.driverVersion;
    if (data.vendorID !== undefined) s.vendorID = data.vendorID;
    if (data.deviceID !== undefined) s.deviceID = data.deviceID;
    if (data.deviceType !== undefined) s.deviceType = data.deviceType;
    if (data.deviceName !== undefined) s.deviceName = data.deviceName;
    if (data.pipelineCacheUUID !== undefined) s.pipelineCacheUUID = data.pipelineCacheUUID;
    if (data.limits !== undefined) s.limits = data.limits;
    if (data.sparseProperties !== undefined) s.sparseProperties = data.sparseProperties;
    return s;
  }
  
  get apiVersion() {
    return this.#view.getUint32(0, LE);
  }
  
  set apiVersion(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get driverVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set driverVersion(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get deviceType() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceType(value: VkPhysicalDeviceType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceName() {
    return this.#view.getUint8(20);
  }
  
  set deviceName(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get pipelineCacheUUID() {
    return this.#view.getUint8(21);
  }
  
  set pipelineCacheUUID(value: number) {
    this.#view.setUint8(21, Number(value));
  }
  
  get limits() {
    return new VkPhysicalDeviceLimits(this.#data.subarray(472, 472 + VkPhysicalDeviceLimits.size));
  }
  
  set limits(value: VkPhysicalDeviceLimits) {
    if (value[BUFFER].byteLength < VkPhysicalDeviceLimits.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 472);
  }
  
  get sparseProperties() {
    return new VkPhysicalDeviceSparseProperties(this.#data.subarray(960, 960 + VkPhysicalDeviceSparseProperties.size));
  }
  
  set sparseProperties(value: VkPhysicalDeviceSparseProperties) {
    if (value[BUFFER].byteLength < VkPhysicalDeviceSparseProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 960);
  }
}

export class VkExtensionProperties implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExtensionProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExtensionProperties(new Uint8Array(VkExtensionProperties.size));
  }
  
  static create(data: {
    extensionName: number;
    specVersion: number;
  }) {
    const s = VkExtensionProperties.alloc();
    if (data.extensionName !== undefined) s.extensionName = data.extensionName;
    if (data.specVersion !== undefined) s.specVersion = data.specVersion;
    return s;
  }
  
  get extensionName() {
    return this.#view.getUint8(0);
  }
  
  set extensionName(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get specVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set specVersion(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkLayerProperties implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkLayerProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkLayerProperties(new Uint8Array(VkLayerProperties.size));
  }
  
  static create(data: {
    layerName: number;
    specVersion: number;
    implementationVersion: number;
    description: number;
  }) {
    const s = VkLayerProperties.alloc();
    if (data.layerName !== undefined) s.layerName = data.layerName;
    if (data.specVersion !== undefined) s.specVersion = data.specVersion;
    if (data.implementationVersion !== undefined) s.implementationVersion = data.implementationVersion;
    if (data.description !== undefined) s.description = data.description;
    return s;
  }
  
  get layerName() {
    return this.#view.getUint8(0);
  }
  
  set layerName(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get specVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set specVersion(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get implementationVersion() {
    return this.#view.getUint32(8, LE);
  }
  
  set implementationVersion(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get description() {
    return this.#view.getUint8(12);
  }
  
  set description(value: number) {
    this.#view.setUint8(12, Number(value));
  }
}

export class VkApplicationInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkApplicationInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkApplicationInfo(new Uint8Array(VkApplicationInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pApplicationName?: Deno.PointerValue;
    applicationVersion: number;
    pEngineName?: Deno.PointerValue;
    engineVersion: number;
    apiVersion: number;
  }) {
    const s = VkApplicationInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pApplicationName !== undefined) s.pApplicationName = data.pApplicationName;
    if (data.applicationVersion !== undefined) s.applicationVersion = data.applicationVersion;
    if (data.pEngineName !== undefined) s.pEngineName = data.pEngineName;
    if (data.engineVersion !== undefined) s.engineVersion = data.engineVersion;
    if (data.apiVersion !== undefined) s.apiVersion = data.apiVersion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pApplicationName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pApplicationName(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get applicationVersion() {
    return this.#view.getUint32(24, LE);
  }
  
  set applicationVersion(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pEngineName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pEngineName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get engineVersion() {
    return this.#view.getUint32(40, LE);
  }
  
  set engineVersion(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get apiVersion() {
    return this.#view.getUint32(44, LE);
  }
  
  set apiVersion(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export class VkAllocationCallbacks implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAllocationCallbacks.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAllocationCallbacks(new Uint8Array(VkAllocationCallbacks.size));
  }
  
  static create(data: {
    pUserData?: Deno.PointerValue;
    pfnAllocation: Deno.PointerValue;
    pfnReallocation: Deno.PointerValue;
    pfnFree: Deno.PointerValue;
    pfnInternalAllocation?: Deno.PointerValue;
    pfnInternalFree?: Deno.PointerValue;
  }) {
    const s = VkAllocationCallbacks.alloc();
    if (data.pUserData !== undefined) s.pUserData = data.pUserData;
    if (data.pfnAllocation !== undefined) s.pfnAllocation = data.pfnAllocation;
    if (data.pfnReallocation !== undefined) s.pfnReallocation = data.pfnReallocation;
    if (data.pfnFree !== undefined) s.pfnFree = data.pfnFree;
    if (data.pfnInternalAllocation !== undefined) s.pfnInternalAllocation = data.pfnInternalAllocation;
    if (data.pfnInternalFree !== undefined) s.pfnInternalFree = data.pfnInternalFree;
    return s;
  }
  
  get pUserData() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set pUserData(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get pfnAllocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnAllocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnReallocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnReallocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnFree() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnFree(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnInternalAllocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnInternalAllocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnInternalFree() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnInternalFree(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
}

export class VkDeviceQueueCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceQueueCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceQueueCreateInfo(new Uint8Array(VkDeviceQueueCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDeviceQueueCreateFlags;
    queueFamilyIndex: number;
    queueCount: number;
    pQueuePriorities: Deno.PointerValue;
  }) {
    const s = VkDeviceQueueCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.queueFamilyIndex !== undefined) s.queueFamilyIndex = data.queueFamilyIndex;
    if (data.queueCount !== undefined) s.queueCount = data.queueCount;
    if (data.pQueuePriorities !== undefined) s.pQueuePriorities = data.pQueuePriorities;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceQueueCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queueCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set queueCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pQueuePriorities() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pQueuePriorities(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDeviceCreateInfo implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceCreateInfo(new Uint8Array(VkDeviceCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDeviceCreateFlags;
    queueCreateInfoCount: number;
    pQueueCreateInfos: Deno.PointerValue;
    enabledLayerCount?: number;
    ppEnabledLayerNames: Deno.PointerValue;
    enabledExtensionCount?: number;
    ppEnabledExtensionNames: Deno.PointerValue;
    pEnabledFeatures?: Deno.PointerValue;
  }) {
    const s = VkDeviceCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.queueCreateInfoCount !== undefined) s.queueCreateInfoCount = data.queueCreateInfoCount;
    if (data.pQueueCreateInfos !== undefined) s.pQueueCreateInfos = data.pQueueCreateInfos;
    if (data.enabledLayerCount !== undefined) s.enabledLayerCount = data.enabledLayerCount;
    if (data.ppEnabledLayerNames !== undefined) s.ppEnabledLayerNames = data.ppEnabledLayerNames;
    if (data.enabledExtensionCount !== undefined) s.enabledExtensionCount = data.enabledExtensionCount;
    if (data.ppEnabledExtensionNames !== undefined) s.ppEnabledExtensionNames = data.ppEnabledExtensionNames;
    if (data.pEnabledFeatures !== undefined) s.pEnabledFeatures = data.pEnabledFeatures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueCreateInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueCreateInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pQueueCreateInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pQueueCreateInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get enabledLayerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set enabledLayerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get ppEnabledLayerNames() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set ppEnabledLayerNames(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get enabledExtensionCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set enabledExtensionCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get ppEnabledExtensionNames() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppEnabledExtensionNames(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pEnabledFeatures() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pEnabledFeatures(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkInstanceCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkInstanceCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkInstanceCreateInfo(new Uint8Array(VkInstanceCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkInstanceCreateFlags;
    pApplicationInfo?: Deno.PointerValue;
    enabledLayerCount?: number;
    ppEnabledLayerNames: Deno.PointerValue;
    enabledExtensionCount?: number;
    ppEnabledExtensionNames: Deno.PointerValue;
  }) {
    const s = VkInstanceCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pApplicationInfo !== undefined) s.pApplicationInfo = data.pApplicationInfo;
    if (data.enabledLayerCount !== undefined) s.enabledLayerCount = data.enabledLayerCount;
    if (data.ppEnabledLayerNames !== undefined) s.ppEnabledLayerNames = data.ppEnabledLayerNames;
    if (data.enabledExtensionCount !== undefined) s.enabledExtensionCount = data.enabledExtensionCount;
    if (data.ppEnabledExtensionNames !== undefined) s.ppEnabledExtensionNames = data.ppEnabledExtensionNames;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkInstanceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pApplicationInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pApplicationInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get enabledLayerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set enabledLayerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get ppEnabledLayerNames() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set ppEnabledLayerNames(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get enabledExtensionCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set enabledExtensionCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get ppEnabledExtensionNames() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppEnabledExtensionNames(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkQueueFamilyProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyProperties(new Uint8Array(VkQueueFamilyProperties.size));
  }
  
  static create(data: {
    queueFlags?: VkQueueFlags;
    queueCount: number;
    timestampValidBits: number;
    minImageTransferGranularity: VkExtent3D;
  }) {
    const s = VkQueueFamilyProperties.alloc();
    if (data.queueFlags !== undefined) s.queueFlags = data.queueFlags;
    if (data.queueCount !== undefined) s.queueCount = data.queueCount;
    if (data.timestampValidBits !== undefined) s.timestampValidBits = data.timestampValidBits;
    if (data.minImageTransferGranularity !== undefined) s.minImageTransferGranularity = data.minImageTransferGranularity;
    return s;
  }
  
  get queueFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set queueFlags(value: VkQueueFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get queueCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set queueCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get timestampValidBits() {
    return this.#view.getUint32(8, LE);
  }
  
  set timestampValidBits(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get minImageTransferGranularity() {
    return new VkExtent3D(this.#data.subarray(12, 12 + VkExtent3D.size));
  }
  
  set minImageTransferGranularity(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
}

export class VkPhysicalDeviceMemoryProperties implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryProperties(new Uint8Array(VkPhysicalDeviceMemoryProperties.size));
  }
  
  static create(data: {
    memoryTypeCount: number;
    memoryTypes: VkMemoryType;
    memoryHeapCount: number;
    memoryHeaps: VkMemoryHeap;
  }) {
    const s = VkPhysicalDeviceMemoryProperties.alloc();
    if (data.memoryTypeCount !== undefined) s.memoryTypeCount = data.memoryTypeCount;
    if (data.memoryTypes !== undefined) s.memoryTypes = data.memoryTypes;
    if (data.memoryHeapCount !== undefined) s.memoryHeapCount = data.memoryHeapCount;
    if (data.memoryHeaps !== undefined) s.memoryHeaps = data.memoryHeaps;
    return s;
  }
  
  get memoryTypeCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set memoryTypeCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get memoryTypes() {
    return new VkMemoryType(this.#data.subarray(8, 8 + VkMemoryType.size));
  }
  
  set memoryTypes(value: VkMemoryType) {
    if (value[BUFFER].byteLength < VkMemoryType.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get memoryHeapCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryHeapCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryHeaps() {
    return new VkMemoryHeap(this.#data.subarray(32, 32 + VkMemoryHeap.size));
  }
  
  set memoryHeaps(value: VkMemoryHeap) {
    if (value[BUFFER].byteLength < VkMemoryHeap.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkMemoryAllocateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryAllocateInfo(new Uint8Array(VkMemoryAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    allocationSize: VkDeviceSize;
    memoryTypeIndex: number;
  }) {
    const s = VkMemoryAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.allocationSize !== undefined) s.allocationSize = data.allocationSize;
    if (data.memoryTypeIndex !== undefined) s.memoryTypeIndex = data.memoryTypeIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get allocationSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set allocationSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memoryTypeIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set memoryTypeIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkMemoryRequirements implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryRequirements(new Uint8Array(VkMemoryRequirements.size));
  }
  
  static create(data: {
    size: VkDeviceSize;
    alignment: VkDeviceSize;
    memoryTypeBits: number;
  }) {
    const s = VkMemoryRequirements.alloc();
    if (data.size !== undefined) s.size = data.size;
    if (data.alignment !== undefined) s.alignment = data.alignment;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get size() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get alignment() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set alignment(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSparseImageFormatProperties implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageFormatProperties(new Uint8Array(VkSparseImageFormatProperties.size));
  }
  
  static create(data: {
    aspectMask?: VkImageAspectFlags;
    imageGranularity: VkExtent3D;
    flags?: VkSparseImageFormatFlags;
  }) {
    const s = VkSparseImageFormatProperties.alloc();
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    if (data.imageGranularity !== undefined) s.imageGranularity = data.imageGranularity;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get imageGranularity() {
    return new VkExtent3D(this.#data.subarray(12, 12 + VkExtent3D.size));
  }
  
  set imageGranularity(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkSparseImageFormatFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkSparseImageMemoryRequirements implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageMemoryRequirements(new Uint8Array(VkSparseImageMemoryRequirements.size));
  }
  
  static create(data: {
    formatProperties: VkSparseImageFormatProperties;
    imageMipTailFirstLod: number;
    imageMipTailSize: VkDeviceSize;
    imageMipTailOffset: VkDeviceSize;
    imageMipTailStride: VkDeviceSize;
  }) {
    const s = VkSparseImageMemoryRequirements.alloc();
    if (data.formatProperties !== undefined) s.formatProperties = data.formatProperties;
    if (data.imageMipTailFirstLod !== undefined) s.imageMipTailFirstLod = data.imageMipTailFirstLod;
    if (data.imageMipTailSize !== undefined) s.imageMipTailSize = data.imageMipTailSize;
    if (data.imageMipTailOffset !== undefined) s.imageMipTailOffset = data.imageMipTailOffset;
    if (data.imageMipTailStride !== undefined) s.imageMipTailStride = data.imageMipTailStride;
    return s;
  }
  
  get formatProperties() {
    return new VkSparseImageFormatProperties(this.#data.subarray(0, 0 + VkSparseImageFormatProperties.size));
  }
  
  set formatProperties(value: VkSparseImageFormatProperties) {
    if (value[BUFFER].byteLength < VkSparseImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get imageMipTailFirstLod() {
    return this.#view.getUint32(36, LE);
  }
  
  set imageMipTailFirstLod(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get imageMipTailSize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set imageMipTailSize(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get imageMipTailOffset() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set imageMipTailOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get imageMipTailStride() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set imageMipTailStride(value: VkDeviceSize) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkMemoryType implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryType.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryType(new Uint8Array(VkMemoryType.size));
  }
  
  static create(data: {
    propertyFlags?: VkMemoryPropertyFlags;
    heapIndex: number;
  }) {
    const s = VkMemoryType.alloc();
    if (data.propertyFlags !== undefined) s.propertyFlags = data.propertyFlags;
    if (data.heapIndex !== undefined) s.heapIndex = data.heapIndex;
    return s;
  }
  
  get propertyFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set propertyFlags(value: VkMemoryPropertyFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get heapIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set heapIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkMemoryHeap implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryHeap.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryHeap(new Uint8Array(VkMemoryHeap.size));
  }
  
  static create(data: {
    size: VkDeviceSize;
    flags?: VkMemoryHeapFlags;
  }) {
    const s = VkMemoryHeap.alloc();
    if (data.size !== undefined) s.size = data.size;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get size() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(8, LE);
  }
  
  set flags(value: VkMemoryHeapFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkMappedMemoryRange implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMappedMemoryRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMappedMemoryRange(new Uint8Array(VkMappedMemoryRange.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    offset: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkMappedMemoryRange.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkFormatProperties implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFormatProperties(new Uint8Array(VkFormatProperties.size));
  }
  
  static create(data: {
    linearTilingFeatures?: VkFormatFeatureFlags;
    optimalTilingFeatures?: VkFormatFeatureFlags;
    bufferFeatures?: VkFormatFeatureFlags;
  }) {
    const s = VkFormatProperties.alloc();
    if (data.linearTilingFeatures !== undefined) s.linearTilingFeatures = data.linearTilingFeatures;
    if (data.optimalTilingFeatures !== undefined) s.optimalTilingFeatures = data.optimalTilingFeatures;
    if (data.bufferFeatures !== undefined) s.bufferFeatures = data.bufferFeatures;
    return s;
  }
  
  get linearTilingFeatures() {
    return this.#view.getUint32(0, LE);
  }
  
  set linearTilingFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get optimalTilingFeatures() {
    return this.#view.getUint32(4, LE);
  }
  
  set optimalTilingFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get bufferFeatures() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkImageFormatProperties implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageFormatProperties(new Uint8Array(VkImageFormatProperties.size));
  }
  
  static create(data: {
    maxExtent: VkExtent3D;
    maxMipLevels: number;
    maxArrayLayers: number;
    sampleCounts?: VkSampleCountFlags;
    maxResourceSize: VkDeviceSize;
  }) {
    const s = VkImageFormatProperties.alloc();
    if (data.maxExtent !== undefined) s.maxExtent = data.maxExtent;
    if (data.maxMipLevels !== undefined) s.maxMipLevels = data.maxMipLevels;
    if (data.maxArrayLayers !== undefined) s.maxArrayLayers = data.maxArrayLayers;
    if (data.sampleCounts !== undefined) s.sampleCounts = data.sampleCounts;
    if (data.maxResourceSize !== undefined) s.maxResourceSize = data.maxResourceSize;
    return s;
  }
  
  get maxExtent() {
    return new VkExtent3D(this.#data.subarray(0, 0 + VkExtent3D.size));
  }
  
  set maxExtent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get maxMipLevels() {
    return this.#view.getUint32(12, LE);
  }
  
  set maxMipLevels(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get maxArrayLayers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxArrayLayers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleCounts() {
    return this.#view.getUint32(20, LE);
  }
  
  set sampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxResourceSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxResourceSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorBufferInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorBufferInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorBufferInfo(new Uint8Array(VkDescriptorBufferInfo.size));
  }
  
  static create(data: {
    buffer?: VkBuffer;
    offset: VkDeviceSize;
    range: VkDeviceSize;
  }) {
    const s = VkDescriptorBufferInfo.alloc();
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.range !== undefined) s.range = data.range;
    return s;
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set range(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDescriptorImageInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorImageInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorImageInfo(new Uint8Array(VkDescriptorImageInfo.size));
  }
  
  static create(data: {
    sampler: VkSampler;
    imageView: VkImageView;
    imageLayout: VkImageLayout;
  }) {
    const s = VkDescriptorImageInfo.alloc();
    if (data.sampler !== undefined) s.sampler = data.sampler;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.imageLayout !== undefined) s.imageLayout = data.imageLayout;
    return s;
  }
  
  get sampler() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set sampler(value: VkSampler) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageLayout(value: VkImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkWriteDescriptorSet implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWriteDescriptorSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWriteDescriptorSet(new Uint8Array(VkWriteDescriptorSet.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dstSet: VkDescriptorSet;
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number;
    descriptorType: VkDescriptorType;
    pImageInfo: Deno.PointerValue;
    pBufferInfo: Deno.PointerValue;
    pTexelBufferView: Deno.PointerValue;
  }) {
    const s = VkWriteDescriptorSet.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dstSet !== undefined) s.dstSet = data.dstSet;
    if (data.dstBinding !== undefined) s.dstBinding = data.dstBinding;
    if (data.dstArrayElement !== undefined) s.dstArrayElement = data.dstArrayElement;
    if (data.descriptorCount !== undefined) s.descriptorCount = data.descriptorCount;
    if (data.descriptorType !== undefined) s.descriptorType = data.descriptorType;
    if (data.pImageInfo !== undefined) s.pImageInfo = data.pImageInfo;
    if (data.pBufferInfo !== undefined) s.pBufferInfo = data.pBufferInfo;
    if (data.pTexelBufferView !== undefined) s.pTexelBufferView = data.pTexelBufferView;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dstSet() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dstSet(value: VkDescriptorSet) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dstBinding() {
    return this.#view.getUint32(24, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(36, LE);
  }
  
  set descriptorType(value: VkDescriptorType) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pImageInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pImageInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pBufferInfo() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pBufferInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pTexelBufferView() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pTexelBufferView(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkCopyDescriptorSet implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyDescriptorSet.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyDescriptorSet(new Uint8Array(VkCopyDescriptorSet.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcSet: VkDescriptorSet;
    srcBinding: number;
    srcArrayElement: number;
    dstSet: VkDescriptorSet;
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number;
  }) {
    const s = VkCopyDescriptorSet.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcSet !== undefined) s.srcSet = data.srcSet;
    if (data.srcBinding !== undefined) s.srcBinding = data.srcBinding;
    if (data.srcArrayElement !== undefined) s.srcArrayElement = data.srcArrayElement;
    if (data.dstSet !== undefined) s.dstSet = data.dstSet;
    if (data.dstBinding !== undefined) s.dstBinding = data.dstBinding;
    if (data.dstArrayElement !== undefined) s.dstArrayElement = data.dstArrayElement;
    if (data.descriptorCount !== undefined) s.descriptorCount = data.descriptorCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcSet() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcSet(value: VkDescriptorSet) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcBinding() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcBinding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get srcArrayElement() {
    return this.#view.getUint32(28, LE);
  }
  
  set srcArrayElement(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get dstSet() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstSet(value: VkDescriptorSet) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstBinding() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(44, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkBufferCreateInfo implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCreateInfo(new Uint8Array(VkBufferCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkBufferCreateFlags;
    size: VkDeviceSize;
    usage: VkBufferUsageFlags;
    sharingMode: VkSharingMode;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: Deno.PointerValue;
  }) {
    const s = VkBufferCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.size !== undefined) s.size = data.size;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.sharingMode !== undefined) s.sharingMode = data.sharingMode;
    if (data.queueFamilyIndexCount !== undefined) s.queueFamilyIndexCount = data.queueFamilyIndexCount;
    if (data.pQueueFamilyIndices !== undefined) s.pQueueFamilyIndices = data.pQueueFamilyIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkBufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(32, LE);
  }
  
  set usage(value: VkBufferUsageFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(36, LE);
  }
  
  set sharingMode(value: VkSharingMode) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pQueueFamilyIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkBufferViewCreateInfo implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferViewCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferViewCreateInfo(new Uint8Array(VkBufferViewCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkBufferViewCreateFlags;
    buffer: VkBuffer;
    format: VkFormat;
    offset: VkDeviceSize;
    range: VkDeviceSize;
  }) {
    const s = VkBufferViewCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.format !== undefined) s.format = data.format;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.range !== undefined) s.range = data.range;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkBufferViewCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(32, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set range(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkImageSubresource implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSubresource.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSubresource(new Uint8Array(VkImageSubresource.size));
  }
  
  static create(data: {
    aspectMask: VkImageAspectFlags;
    mipLevel: number;
    arrayLayer: number;
  }) {
    const s = VkImageSubresource.alloc();
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    if (data.mipLevel !== undefined) s.mipLevel = data.mipLevel;
    if (data.arrayLayer !== undefined) s.arrayLayer = data.arrayLayer;
    return s;
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get mipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set mipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get arrayLayer() {
    return this.#view.getUint32(8, LE);
  }
  
  set arrayLayer(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkImageSubresourceLayers implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSubresourceLayers(new Uint8Array(VkImageSubresourceLayers.size));
  }
  
  static create(data: {
    aspectMask: VkImageAspectFlags;
    mipLevel: number;
    baseArrayLayer: number;
    layerCount: number;
  }) {
    const s = VkImageSubresourceLayers.alloc();
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    if (data.mipLevel !== undefined) s.mipLevel = data.mipLevel;
    if (data.baseArrayLayer !== undefined) s.baseArrayLayer = data.baseArrayLayer;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    return s;
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get mipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set mipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(8, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(12, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkImageSubresourceRange implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSubresourceRange(new Uint8Array(VkImageSubresourceRange.size));
  }
  
  static create(data: {
    aspectMask: VkImageAspectFlags;
    baseMipLevel: number;
    levelCount: number;
    baseArrayLayer: number;
    layerCount: number;
  }) {
    const s = VkImageSubresourceRange.alloc();
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    if (data.baseMipLevel !== undefined) s.baseMipLevel = data.baseMipLevel;
    if (data.levelCount !== undefined) s.levelCount = data.levelCount;
    if (data.baseArrayLayer !== undefined) s.baseArrayLayer = data.baseArrayLayer;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    return s;
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get baseMipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set baseMipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get levelCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set levelCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(12, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryBarrier implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryBarrier.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryBarrier(new Uint8Array(VkMemoryBarrier.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcAccessMask?: VkAccessFlags;
    dstAccessMask?: VkAccessFlags;
  }) {
    const s = VkMemoryBarrier.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkBufferMemoryBarrier implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferMemoryBarrier.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferMemoryBarrier(new Uint8Array(VkBufferMemoryBarrier.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcAccessMask: VkAccessFlags;
    dstAccessMask: VkAccessFlags;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkBufferMemoryBarrier.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.srcQueueFamilyIndex !== undefined) s.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
    if (data.dstQueueFamilyIndex !== undefined) s.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkImageMemoryBarrier implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageMemoryBarrier.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageMemoryBarrier(new Uint8Array(VkImageMemoryBarrier.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcAccessMask: VkAccessFlags;
    dstAccessMask: VkAccessFlags;
    oldLayout: VkImageLayout;
    newLayout: VkImageLayout;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    image: VkImage;
    subresourceRange: VkImageSubresourceRange;
  }) {
    const s = VkImageMemoryBarrier.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.oldLayout !== undefined) s.oldLayout = data.oldLayout;
    if (data.newLayout !== undefined) s.newLayout = data.newLayout;
    if (data.srcQueueFamilyIndex !== undefined) s.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
    if (data.dstQueueFamilyIndex !== undefined) s.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
    if (data.image !== undefined) s.image = data.image;
    if (data.subresourceRange !== undefined) s.subresourceRange = data.subresourceRange;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get oldLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set oldLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get newLayout() {
    return this.#view.getUint32(28, LE);
  }
  
  set newLayout(value: VkImageLayout) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(32, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(36, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get subresourceRange() {
    return new VkImageSubresourceRange(this.#data.subarray(60, 60 + VkImageSubresourceRange.size));
  }
  
  set subresourceRange(value: VkImageSubresourceRange) {
    if (value[BUFFER].byteLength < VkImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
}

export class VkImageCreateInfo implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCreateInfo(new Uint8Array(VkImageCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkImageCreateFlags;
    imageType: VkImageType;
    format: VkFormat;
    extent: VkExtent3D;
    mipLevels: number;
    arrayLayers: number;
    samples: VkSampleCountFlagBits;
    tiling: VkImageTiling;
    usage: VkImageUsageFlags;
    sharingMode: VkSharingMode;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: Deno.PointerValue;
    initialLayout: VkImageLayout;
  }) {
    const s = VkImageCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.imageType !== undefined) s.imageType = data.imageType;
    if (data.format !== undefined) s.format = data.format;
    if (data.extent !== undefined) s.extent = data.extent;
    if (data.mipLevels !== undefined) s.mipLevels = data.mipLevels;
    if (data.arrayLayers !== undefined) s.arrayLayers = data.arrayLayers;
    if (data.samples !== undefined) s.samples = data.samples;
    if (data.tiling !== undefined) s.tiling = data.tiling;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.sharingMode !== undefined) s.sharingMode = data.sharingMode;
    if (data.queueFamilyIndexCount !== undefined) s.queueFamilyIndexCount = data.queueFamilyIndexCount;
    if (data.pQueueFamilyIndices !== undefined) s.pQueueFamilyIndices = data.pQueueFamilyIndices;
    if (data.initialLayout !== undefined) s.initialLayout = data.initialLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkImageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imageType() {
    return this.#view.getUint32(20, LE);
  }
  
  set imageType(value: VkImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(24, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(36, 36 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get mipLevels() {
    return this.#view.getUint32(48, LE);
  }
  
  set mipLevels(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get arrayLayers() {
    return this.#view.getUint32(52, LE);
  }
  
  set arrayLayers(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(56, LE);
  }
  
  set samples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(60, LE);
  }
  
  set tiling(value: VkImageTiling) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(64, LE);
  }
  
  set usage(value: VkImageUsageFlags) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(68, LE);
  }
  
  set sharingMode(value: VkSharingMode) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pQueueFamilyIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(88, LE);
  }
  
  set initialLayout(value: VkImageLayout) {
    this.#view.setUint32(88, Number(value), LE);
  }
}

export class VkSubresourceLayout implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubresourceLayout.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubresourceLayout(new Uint8Array(VkSubresourceLayout.size));
  }
  
  static create(data: {
    offset: VkDeviceSize;
    size: VkDeviceSize;
    rowPitch: VkDeviceSize;
    arrayPitch: VkDeviceSize;
    depthPitch: VkDeviceSize;
  }) {
    const s = VkSubresourceLayout.alloc();
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    if (data.rowPitch !== undefined) s.rowPitch = data.rowPitch;
    if (data.arrayPitch !== undefined) s.arrayPitch = data.arrayPitch;
    if (data.depthPitch !== undefined) s.depthPitch = data.depthPitch;
    return s;
  }
  
  get offset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rowPitch() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set rowPitch(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get arrayPitch() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set arrayPitch(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get depthPitch() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set depthPitch(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageViewCreateInfo implements IVkStructure {
  static size = 100;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewCreateInfo(new Uint8Array(VkImageViewCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkImageViewCreateFlags;
    image: VkImage;
    viewType: VkImageViewType;
    format: VkFormat;
    components: VkComponentMapping;
    subresourceRange: VkImageSubresourceRange;
  }) {
    const s = VkImageViewCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.image !== undefined) s.image = data.image;
    if (data.viewType !== undefined) s.viewType = data.viewType;
    if (data.format !== undefined) s.format = data.format;
    if (data.components !== undefined) s.components = data.components;
    if (data.subresourceRange !== undefined) s.subresourceRange = data.subresourceRange;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkImageViewCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get viewType() {
    return this.#view.getUint32(32, LE);
  }
  
  set viewType(value: VkImageViewType) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(36, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get components() {
    return new VkComponentMapping(this.#data.subarray(48, 48 + VkComponentMapping.size));
  }
  
  set components(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get subresourceRange() {
    return new VkImageSubresourceRange(this.#data.subarray(80, 80 + VkImageSubresourceRange.size));
  }
  
  set subresourceRange(value: VkImageSubresourceRange) {
    if (value[BUFFER].byteLength < VkImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 80);
  }
}

export class VkBufferCopy implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCopy.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCopy(new Uint8Array(VkBufferCopy.size));
  }
  
  static create(data: {
    srcOffset: VkDeviceSize;
    dstOffset: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkBufferCopy.alloc();
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get srcOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstOffset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSparseMemoryBind implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseMemoryBind.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseMemoryBind(new Uint8Array(VkSparseMemoryBind.size));
  }
  
  static create(data: {
    resourceOffset: VkDeviceSize;
    size: VkDeviceSize;
    memory?: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
    flags?: VkSparseMemoryBindFlags;
  }) {
    const s = VkSparseMemoryBind.alloc();
    if (data.resourceOffset !== undefined) s.resourceOffset = data.resourceOffset;
    if (data.size !== undefined) s.size = data.size;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get resourceOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set resourceOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: VkSparseMemoryBindFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkSparseImageMemoryBind implements IVkStructure {
  static size = 60;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageMemoryBind.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageMemoryBind(new Uint8Array(VkSparseImageMemoryBind.size));
  }
  
  static create(data: {
    subresource: VkImageSubresource;
    offset: VkOffset3D;
    extent: VkExtent3D;
    memory?: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
    flags?: VkSparseMemoryBindFlags;
  }) {
    const s = VkSparseImageMemoryBind.alloc();
    if (data.subresource !== undefined) s.subresource = data.subresource;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.extent !== undefined) s.extent = data.extent;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get subresource() {
    return new VkImageSubresource(this.#data.subarray(0, 0 + VkImageSubresource.size));
  }
  
  set subresource(value: VkImageSubresource) {
    if (value[BUFFER].byteLength < VkImageSubresource.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get offset() {
    return new VkOffset3D(this.#data.subarray(12, 12 + VkOffset3D.size));
  }
  
  set offset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(24, 24 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get memory() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(56, LE);
  }
  
  set flags(value: VkSparseMemoryBindFlags) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkSparseBufferMemoryBindInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseBufferMemoryBindInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseBufferMemoryBindInfo(new Uint8Array(VkSparseBufferMemoryBindInfo.size));
  }
  
  static create(data: {
    buffer: VkBuffer;
    bindCount: number;
    pBinds: Deno.PointerValue;
  }) {
    const s = VkSparseBufferMemoryBindInfo.alloc();
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.bindCount !== undefined) s.bindCount = data.bindCount;
    if (data.pBinds !== undefined) s.pBinds = data.pBinds;
    return s;
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSparseImageOpaqueMemoryBindInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageOpaqueMemoryBindInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageOpaqueMemoryBindInfo(new Uint8Array(VkSparseImageOpaqueMemoryBindInfo.size));
  }
  
  static create(data: {
    image: VkImage;
    bindCount: number;
    pBinds: Deno.PointerValue;
  }) {
    const s = VkSparseImageOpaqueMemoryBindInfo.alloc();
    if (data.image !== undefined) s.image = data.image;
    if (data.bindCount !== undefined) s.bindCount = data.bindCount;
    if (data.pBinds !== undefined) s.pBinds = data.pBinds;
    return s;
  }
  
  get image() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSparseImageMemoryBindInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageMemoryBindInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageMemoryBindInfo(new Uint8Array(VkSparseImageMemoryBindInfo.size));
  }
  
  static create(data: {
    image: VkImage;
    bindCount: number;
    pBinds: Deno.PointerValue;
  }) {
    const s = VkSparseImageMemoryBindInfo.alloc();
    if (data.image !== undefined) s.image = data.image;
    if (data.bindCount !== undefined) s.bindCount = data.bindCount;
    if (data.pBinds !== undefined) s.pBinds = data.pBinds;
    return s;
  }
  
  get image() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkBindSparseInfo implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindSparseInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindSparseInfo(new Uint8Array(VkBindSparseInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreCount?: number;
    pWaitSemaphores: Deno.PointerValue;
    bufferBindCount?: number;
    pBufferBinds: Deno.PointerValue;
    imageOpaqueBindCount?: number;
    pImageOpaqueBinds: Deno.PointerValue;
    imageBindCount?: number;
    pImageBinds: Deno.PointerValue;
    signalSemaphoreCount?: number;
    pSignalSemaphores: Deno.PointerValue;
  }) {
    const s = VkBindSparseInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreCount !== undefined) s.waitSemaphoreCount = data.waitSemaphoreCount;
    if (data.pWaitSemaphores !== undefined) s.pWaitSemaphores = data.pWaitSemaphores;
    if (data.bufferBindCount !== undefined) s.bufferBindCount = data.bufferBindCount;
    if (data.pBufferBinds !== undefined) s.pBufferBinds = data.pBufferBinds;
    if (data.imageOpaqueBindCount !== undefined) s.imageOpaqueBindCount = data.imageOpaqueBindCount;
    if (data.pImageOpaqueBinds !== undefined) s.pImageOpaqueBinds = data.pImageOpaqueBinds;
    if (data.imageBindCount !== undefined) s.imageBindCount = data.imageBindCount;
    if (data.pImageBinds !== undefined) s.pImageBinds = data.pImageBinds;
    if (data.signalSemaphoreCount !== undefined) s.signalSemaphoreCount = data.signalSemaphoreCount;
    if (data.pSignalSemaphores !== undefined) s.pSignalSemaphores = data.pSignalSemaphores;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferBindCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set bufferBindCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pBufferBinds() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pBufferBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get imageOpaqueBindCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageOpaqueBindCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pImageOpaqueBinds() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pImageOpaqueBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get imageBindCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set imageBindCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pImageBinds() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pImageBinds(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(80, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get pSignalSemaphores() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pSignalSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export class VkImageCopy implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCopy.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCopy(new Uint8Array(VkImageCopy.size));
  }
  
  static create(data: {
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D;
    extent: VkExtent3D;
  }) {
    const s = VkImageCopy.alloc();
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.extent !== undefined) s.extent = data.extent;
    return s;
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(0, 0 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffset() {
    return new VkOffset3D(this.#data.subarray(24, 24 + VkOffset3D.size));
  }
  
  set srcOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffset() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(84, 84 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 84);
  }
}

export class VkImageBlit implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageBlit.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageBlit(new Uint8Array(VkImageBlit.size));
  }
  
  static create(data: {
    srcSubresource: VkImageSubresourceLayers;
    srcOffsets: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffsets: VkOffset3D;
  }) {
    const s = VkImageBlit.alloc();
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffsets !== undefined) s.srcOffsets = data.srcOffsets;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffsets !== undefined) s.dstOffsets = data.dstOffsets;
    return s;
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(0, 0 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffsets() {
    return new VkOffset3D(this.#data.subarray(24, 24 + VkOffset3D.size));
  }
  
  set srcOffsets(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffsets() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffsets(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export class VkBufferImageCopy implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferImageCopy.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferImageCopy(new Uint8Array(VkBufferImageCopy.size));
  }
  
  static create(data: {
    bufferOffset: VkDeviceSize;
    bufferRowLength: number;
    bufferImageHeight: number;
    imageSubresource: VkImageSubresourceLayers;
    imageOffset: VkOffset3D;
    imageExtent: VkExtent3D;
  }) {
    const s = VkBufferImageCopy.alloc();
    if (data.bufferOffset !== undefined) s.bufferOffset = data.bufferOffset;
    if (data.bufferRowLength !== undefined) s.bufferRowLength = data.bufferRowLength;
    if (data.bufferImageHeight !== undefined) s.bufferImageHeight = data.bufferImageHeight;
    if (data.imageSubresource !== undefined) s.imageSubresource = data.imageSubresource;
    if (data.imageOffset !== undefined) s.imageOffset = data.imageOffset;
    if (data.imageExtent !== undefined) s.imageExtent = data.imageExtent;
    return s;
  }
  
  get bufferOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(12, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get imageSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(16, 16 + VkImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get imageOffset() {
    return new VkOffset3D(this.#data.subarray(36, 36 + VkOffset3D.size));
  }
  
  set imageOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get imageExtent() {
    return new VkExtent3D(this.#data.subarray(48, 48 + VkExtent3D.size));
  }
  
  set imageExtent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkCopyMemoryIndirectCommandNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMemoryIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMemoryIndirectCommandNV(new Uint8Array(VkCopyMemoryIndirectCommandNV.size));
  }
  
  static create(data: {
    srcAddress: VkDeviceAddress;
    dstAddress: VkDeviceAddress;
    size: VkDeviceSize;
  }) {
    const s = VkCopyMemoryIndirectCommandNV.alloc();
    if (data.srcAddress !== undefined) s.srcAddress = data.srcAddress;
    if (data.dstAddress !== undefined) s.dstAddress = data.dstAddress;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkCopyMemoryToImageIndirectCommandNV implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMemoryToImageIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMemoryToImageIndirectCommandNV(new Uint8Array(VkCopyMemoryToImageIndirectCommandNV.size));
  }
  
  static create(data: {
    srcAddress: VkDeviceAddress;
    bufferRowLength: number;
    bufferImageHeight: number;
    imageSubresource: VkImageSubresourceLayers;
    imageOffset: VkOffset3D;
    imageExtent: VkExtent3D;
  }) {
    const s = VkCopyMemoryToImageIndirectCommandNV.alloc();
    if (data.srcAddress !== undefined) s.srcAddress = data.srcAddress;
    if (data.bufferRowLength !== undefined) s.bufferRowLength = data.bufferRowLength;
    if (data.bufferImageHeight !== undefined) s.bufferImageHeight = data.bufferImageHeight;
    if (data.imageSubresource !== undefined) s.imageSubresource = data.imageSubresource;
    if (data.imageOffset !== undefined) s.imageOffset = data.imageOffset;
    if (data.imageExtent !== undefined) s.imageExtent = data.imageExtent;
    return s;
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(12, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get imageSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(16, 16 + VkImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get imageOffset() {
    return new VkOffset3D(this.#data.subarray(36, 36 + VkOffset3D.size));
  }
  
  set imageOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get imageExtent() {
    return new VkExtent3D(this.#data.subarray(48, 48 + VkExtent3D.size));
  }
  
  set imageExtent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkImageResolve implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageResolve.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageResolve(new Uint8Array(VkImageResolve.size));
  }
  
  static create(data: {
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D;
    extent: VkExtent3D;
  }) {
    const s = VkImageResolve.alloc();
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.extent !== undefined) s.extent = data.extent;
    return s;
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(0, 0 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffset() {
    return new VkOffset3D(this.#data.subarray(24, 24 + VkOffset3D.size));
  }
  
  set srcOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffset() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(84, 84 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 84);
  }
}

export class VkShaderModuleCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShaderModuleCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShaderModuleCreateInfo(new Uint8Array(VkShaderModuleCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkShaderModuleCreateFlags;
    codeSize: Deno.PointerValue;
    pCode: Deno.PointerValue;
  }) {
    const s = VkShaderModuleCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.codeSize !== undefined) s.codeSize = data.codeSize;
    if (data.pCode !== undefined) s.pCode = data.pCode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkShaderModuleCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get codeSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set codeSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pCode() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pCode(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDescriptorSetLayoutBinding implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetLayoutBinding.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetLayoutBinding(new Uint8Array(VkDescriptorSetLayoutBinding.size));
  }
  
  static create(data: {
    binding: number;
    descriptorType: VkDescriptorType;
    descriptorCount?: number;
    stageFlags: VkShaderStageFlags;
    pImmutableSamplers?: Deno.PointerValue;
  }) {
    const s = VkDescriptorSetLayoutBinding.alloc();
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.descriptorType !== undefined) s.descriptorType = data.descriptorType;
    if (data.descriptorCount !== undefined) s.descriptorCount = data.descriptorCount;
    if (data.stageFlags !== undefined) s.stageFlags = data.stageFlags;
    if (data.pImmutableSamplers !== undefined) s.pImmutableSamplers = data.pImmutableSamplers;
    return s;
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(4, LE);
  }
  
  set descriptorType(value: VkDescriptorType) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get stageFlags() {
    return this.#view.getUint32(12, LE);
  }
  
  set stageFlags(value: VkShaderStageFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get pImmutableSamplers() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pImmutableSamplers(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDescriptorSetLayoutCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetLayoutCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetLayoutCreateInfo(new Uint8Array(VkDescriptorSetLayoutCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDescriptorSetLayoutCreateFlags;
    bindingCount?: number;
    pBindings: Deno.PointerValue;
  }) {
    const s = VkDescriptorSetLayoutCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.bindingCount !== undefined) s.bindingCount = data.bindingCount;
    if (data.pBindings !== undefined) s.pBindings = data.pBindings;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDescriptorSetLayoutCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bindingCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set bindingCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pBindings() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pBindings(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorPoolSize implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorPoolSize.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorPoolSize(new Uint8Array(VkDescriptorPoolSize.size));
  }
  
  static create(data: {
    type: VkDescriptorType;
    descriptorCount: number;
  }) {
    const s = VkDescriptorPoolSize.alloc();
    if (data.type !== undefined) s.type = data.type;
    if (data.descriptorCount !== undefined) s.descriptorCount = data.descriptorCount;
    return s;
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: VkDescriptorType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkDescriptorPoolCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorPoolCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorPoolCreateInfo(new Uint8Array(VkDescriptorPoolCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDescriptorPoolCreateFlags;
    maxSets: number;
    poolSizeCount?: number;
    pPoolSizes: Deno.PointerValue;
  }) {
    const s = VkDescriptorPoolCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.maxSets !== undefined) s.maxSets = data.maxSets;
    if (data.poolSizeCount !== undefined) s.poolSizeCount = data.poolSizeCount;
    if (data.pPoolSizes !== undefined) s.pPoolSizes = data.pPoolSizes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDescriptorPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSets() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSets(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get poolSizeCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set poolSizeCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPoolSizes() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPoolSizes(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDescriptorSetAllocateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetAllocateInfo(new Uint8Array(VkDescriptorSetAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorPool: VkDescriptorPool;
    descriptorSetCount: number;
    pSetLayouts: Deno.PointerValue;
  }) {
    const s = VkDescriptorSetAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorPool !== undefined) s.descriptorPool = data.descriptorPool;
    if (data.descriptorSetCount !== undefined) s.descriptorSetCount = data.descriptorSetCount;
    if (data.pSetLayouts !== undefined) s.pSetLayouts = data.pSetLayouts;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorPool() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorPool(value: VkDescriptorPool) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get descriptorSetCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorSetCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSetLayouts() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSetLayouts(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkSpecializationMapEntry implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSpecializationMapEntry.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSpecializationMapEntry(new Uint8Array(VkSpecializationMapEntry.size));
  }
  
  static create(data: {
    constantID: number;
    offset: number;
    size: Deno.PointerValue;
  }) {
    const s = VkSpecializationMapEntry.alloc();
    if (data.constantID !== undefined) s.constantID = data.constantID;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get constantID() {
    return this.#view.getUint32(0, LE);
  }
  
  set constantID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(4, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkSpecializationInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSpecializationInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSpecializationInfo(new Uint8Array(VkSpecializationInfo.size));
  }
  
  static create(data: {
    mapEntryCount?: number;
    pMapEntries: Deno.PointerValue;
    dataSize?: Deno.PointerValue;
    pData: Deno.PointerValue;
  }) {
    const s = VkSpecializationInfo.alloc();
    if (data.mapEntryCount !== undefined) s.mapEntryCount = data.mapEntryCount;
    if (data.pMapEntries !== undefined) s.pMapEntries = data.pMapEntries;
    if (data.dataSize !== undefined) s.dataSize = data.dataSize;
    if (data.pData !== undefined) s.pData = data.pData;
    return s;
  }
  
  get mapEntryCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set mapEntryCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pMapEntries() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pMapEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPipelineShaderStageCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineShaderStageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineShaderStageCreateInfo(new Uint8Array(VkPipelineShaderStageCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineShaderStageCreateFlags;
    stage: VkShaderStageFlagBits;
    module?: VkShaderModule;
    pName: Deno.PointerValue;
    pSpecializationInfo?: Deno.PointerValue;
  }) {
    const s = VkPipelineShaderStageCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.stage !== undefined) s.stage = data.stage;
    if (data.module !== undefined) s.module = data.module;
    if (data.pName !== undefined) s.pName = data.pName;
    if (data.pSpecializationInfo !== undefined) s.pSpecializationInfo = data.pSpecializationInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineShaderStageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stage() {
    return this.#view.getUint32(20, LE);
  }
  
  set stage(value: VkShaderStageFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get module() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set module(value: VkShaderModule) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pSpecializationInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSpecializationInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkComputePipelineCreateInfo implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkComputePipelineCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkComputePipelineCreateInfo(new Uint8Array(VkComputePipelineCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCreateFlags;
    stage: VkPipelineShaderStageCreateInfo;
    layout: VkPipelineLayout;
    basePipelineHandle?: VkPipeline;
    basePipelineIndex: number;
  }) {
    const s = VkComputePipelineCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.stage !== undefined) s.stage = data.stage;
    if (data.layout !== undefined) s.layout = data.layout;
    if (data.basePipelineHandle !== undefined) s.basePipelineHandle = data.basePipelineHandle;
    if (data.basePipelineIndex !== undefined) s.basePipelineIndex = data.basePipelineIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stage() {
    return new VkPipelineShaderStageCreateInfo(this.#data.subarray(48, 48 + VkPipelineShaderStageCreateInfo.size));
  }
  
  set stage(value: VkPipelineShaderStageCreateInfo) {
    if (value[BUFFER].byteLength < VkPipelineShaderStageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get layout() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set layout(value: VkPipelineLayout) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set basePipelineHandle(value: VkPipeline) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(112, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(112, Number(value), LE);
  }
}

export class VkVertexInputBindingDescription implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVertexInputBindingDescription.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVertexInputBindingDescription(new Uint8Array(VkVertexInputBindingDescription.size));
  }
  
  static create(data: {
    binding: number;
    stride: number;
    inputRate: VkVertexInputRate;
  }) {
    const s = VkVertexInputBindingDescription.alloc();
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.stride !== undefined) s.stride = data.stride;
    if (data.inputRate !== undefined) s.inputRate = data.inputRate;
    return s;
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(4, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get inputRate() {
    return this.#view.getUint32(8, LE);
  }
  
  set inputRate(value: VkVertexInputRate) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkVertexInputAttributeDescription implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVertexInputAttributeDescription.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVertexInputAttributeDescription(new Uint8Array(VkVertexInputAttributeDescription.size));
  }
  
  static create(data: {
    location: number;
    binding: number;
    format: VkFormat;
    offset: number;
  }) {
    const s = VkVertexInputAttributeDescription.alloc();
    if (data.location !== undefined) s.location = data.location;
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.format !== undefined) s.format = data.format;
    if (data.offset !== undefined) s.offset = data.offset;
    return s;
  }
  
  get location() {
    return this.#view.getUint32(0, LE);
  }
  
  set location(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(4, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(8, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(12, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkPipelineVertexInputStateCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineVertexInputStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineVertexInputStateCreateInfo(new Uint8Array(VkPipelineVertexInputStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount?: number;
    pVertexBindingDescriptions: Deno.PointerValue;
    vertexAttributeDescriptionCount?: number;
    pVertexAttributeDescriptions: Deno.PointerValue;
  }) {
    const s = VkPipelineVertexInputStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.vertexBindingDescriptionCount !== undefined) s.vertexBindingDescriptionCount = data.vertexBindingDescriptionCount;
    if (data.pVertexBindingDescriptions !== undefined) s.pVertexBindingDescriptions = data.pVertexBindingDescriptions;
    if (data.vertexAttributeDescriptionCount !== undefined) s.vertexAttributeDescriptionCount = data.vertexAttributeDescriptionCount;
    if (data.pVertexAttributeDescriptions !== undefined) s.pVertexAttributeDescriptions = data.pVertexAttributeDescriptions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineVertexInputStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexBindingDescriptionCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set vertexBindingDescriptionCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pVertexBindingDescriptions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVertexBindingDescriptions(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get vertexAttributeDescriptionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexAttributeDescriptionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pVertexAttributeDescriptions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pVertexAttributeDescriptions(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkPipelineInputAssemblyStateCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineInputAssemblyStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineInputAssemblyStateCreateInfo(new Uint8Array(VkPipelineInputAssemblyStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineInputAssemblyStateCreateFlags;
    topology: VkPrimitiveTopology;
    primitiveRestartEnable: VkBool32;
  }) {
    const s = VkPipelineInputAssemblyStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.topology !== undefined) s.topology = data.topology;
    if (data.primitiveRestartEnable !== undefined) s.primitiveRestartEnable = data.primitiveRestartEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineInputAssemblyStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get topology() {
    return this.#view.getUint32(20, LE);
  }
  
  set topology(value: VkPrimitiveTopology) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primitiveRestartEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set primitiveRestartEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPipelineTessellationStateCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineTessellationStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineTessellationStateCreateInfo(new Uint8Array(VkPipelineTessellationStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineTessellationStateCreateFlags;
    patchControlPoints: number;
  }) {
    const s = VkPipelineTessellationStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.patchControlPoints !== undefined) s.patchControlPoints = data.patchControlPoints;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineTessellationStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get patchControlPoints() {
    return this.#view.getUint32(20, LE);
  }
  
  set patchControlPoints(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPipelineViewportStateCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportStateCreateInfo(new Uint8Array(VkPipelineViewportStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineViewportStateCreateFlags;
    viewportCount?: number;
    pViewports?: Deno.PointerValue;
    scissorCount?: number;
    pScissors?: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.viewportCount !== undefined) s.viewportCount = data.viewportCount;
    if (data.pViewports !== undefined) s.pViewports = data.pViewports;
    if (data.scissorCount !== undefined) s.scissorCount = data.scissorCount;
    if (data.pScissors !== undefined) s.pScissors = data.pScissors;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineViewportStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewports() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewports(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get scissorCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set scissorCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pScissors() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pScissors(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkPipelineRasterizationStateCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationStateCreateInfo(new Uint8Array(VkPipelineRasterizationStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineRasterizationStateCreateFlags;
    depthClampEnable: VkBool32;
    rasterizerDiscardEnable: VkBool32;
    polygonMode: VkPolygonMode;
    cullMode?: VkCullModeFlags;
    frontFace: VkFrontFace;
    depthBiasEnable: VkBool32;
    depthBiasConstantFactor: number;
    depthBiasClamp: number;
    depthBiasSlopeFactor: number;
    lineWidth: number;
  }) {
    const s = VkPipelineRasterizationStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.depthClampEnable !== undefined) s.depthClampEnable = data.depthClampEnable;
    if (data.rasterizerDiscardEnable !== undefined) s.rasterizerDiscardEnable = data.rasterizerDiscardEnable;
    if (data.polygonMode !== undefined) s.polygonMode = data.polygonMode;
    if (data.cullMode !== undefined) s.cullMode = data.cullMode;
    if (data.frontFace !== undefined) s.frontFace = data.frontFace;
    if (data.depthBiasEnable !== undefined) s.depthBiasEnable = data.depthBiasEnable;
    if (data.depthBiasConstantFactor !== undefined) s.depthBiasConstantFactor = data.depthBiasConstantFactor;
    if (data.depthBiasClamp !== undefined) s.depthBiasClamp = data.depthBiasClamp;
    if (data.depthBiasSlopeFactor !== undefined) s.depthBiasSlopeFactor = data.depthBiasSlopeFactor;
    if (data.lineWidth !== undefined) s.lineWidth = data.lineWidth;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineRasterizationStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthClampEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthClampEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rasterizerDiscardEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set rasterizerDiscardEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get polygonMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set polygonMode(value: VkPolygonMode) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get cullMode() {
    return this.#view.getUint32(32, LE);
  }
  
  set cullMode(value: VkCullModeFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get frontFace() {
    return this.#view.getUint32(36, LE);
  }
  
  set frontFace(value: VkFrontFace) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get depthBiasEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set depthBiasEnable(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get depthBiasConstantFactor() {
    return this.#view.getFloat32(44, LE);
  }
  
  set depthBiasConstantFactor(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get depthBiasClamp() {
    return this.#view.getFloat32(48, LE);
  }
  
  set depthBiasClamp(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get depthBiasSlopeFactor() {
    return this.#view.getFloat32(52, LE);
  }
  
  set depthBiasSlopeFactor(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get lineWidth() {
    return this.#view.getFloat32(56, LE);
  }
  
  set lineWidth(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
}

export class VkPipelineMultisampleStateCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineMultisampleStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineMultisampleStateCreateInfo(new Uint8Array(VkPipelineMultisampleStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineMultisampleStateCreateFlags;
    rasterizationSamples: VkSampleCountFlagBits;
    sampleShadingEnable: VkBool32;
    minSampleShading: number;
    pSampleMask?: Deno.PointerValue;
    alphaToCoverageEnable: VkBool32;
    alphaToOneEnable: VkBool32;
  }) {
    const s = VkPipelineMultisampleStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.rasterizationSamples !== undefined) s.rasterizationSamples = data.rasterizationSamples;
    if (data.sampleShadingEnable !== undefined) s.sampleShadingEnable = data.sampleShadingEnable;
    if (data.minSampleShading !== undefined) s.minSampleShading = data.minSampleShading;
    if (data.pSampleMask !== undefined) s.pSampleMask = data.pSampleMask;
    if (data.alphaToCoverageEnable !== undefined) s.alphaToCoverageEnable = data.alphaToCoverageEnable;
    if (data.alphaToOneEnable !== undefined) s.alphaToOneEnable = data.alphaToOneEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineMultisampleStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sampleShadingEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set sampleShadingEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get minSampleShading() {
    return this.#view.getFloat32(28, LE);
  }
  
  set minSampleShading(value: number) {
    this.#view.setFloat32(28, Number(value), LE);
  }
  
  get pSampleMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSampleMask(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get alphaToCoverageEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set alphaToCoverageEnable(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get alphaToOneEnable() {
    return this.#view.getUint32(44, LE);
  }
  
  set alphaToOneEnable(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export class VkPipelineColorBlendAttachmentState implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineColorBlendAttachmentState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineColorBlendAttachmentState(new Uint8Array(VkPipelineColorBlendAttachmentState.size));
  }
  
  static create(data: {
    blendEnable: VkBool32;
    srcColorBlendFactor: VkBlendFactor;
    dstColorBlendFactor: VkBlendFactor;
    colorBlendOp: VkBlendOp;
    srcAlphaBlendFactor: VkBlendFactor;
    dstAlphaBlendFactor: VkBlendFactor;
    alphaBlendOp: VkBlendOp;
    colorWriteMask?: VkColorComponentFlags;
  }) {
    const s = VkPipelineColorBlendAttachmentState.alloc();
    if (data.blendEnable !== undefined) s.blendEnable = data.blendEnable;
    if (data.srcColorBlendFactor !== undefined) s.srcColorBlendFactor = data.srcColorBlendFactor;
    if (data.dstColorBlendFactor !== undefined) s.dstColorBlendFactor = data.dstColorBlendFactor;
    if (data.colorBlendOp !== undefined) s.colorBlendOp = data.colorBlendOp;
    if (data.srcAlphaBlendFactor !== undefined) s.srcAlphaBlendFactor = data.srcAlphaBlendFactor;
    if (data.dstAlphaBlendFactor !== undefined) s.dstAlphaBlendFactor = data.dstAlphaBlendFactor;
    if (data.alphaBlendOp !== undefined) s.alphaBlendOp = data.alphaBlendOp;
    if (data.colorWriteMask !== undefined) s.colorWriteMask = data.colorWriteMask;
    return s;
  }
  
  get blendEnable() {
    return this.#view.getUint32(0, LE);
  }
  
  set blendEnable(value: VkBool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get srcColorBlendFactor() {
    return this.#view.getUint32(4, LE);
  }
  
  set srcColorBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dstColorBlendFactor() {
    return this.#view.getUint32(8, LE);
  }
  
  set dstColorBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get colorBlendOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set colorBlendOp(value: VkBlendOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get srcAlphaBlendFactor() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAlphaBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAlphaBlendFactor() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAlphaBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get alphaBlendOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set alphaBlendOp(value: VkBlendOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get colorWriteMask() {
    return this.#view.getUint32(28, LE);
  }
  
  set colorWriteMask(value: VkColorComponentFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPipelineColorBlendStateCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineColorBlendStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineColorBlendStateCreateInfo(new Uint8Array(VkPipelineColorBlendStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineColorBlendStateCreateFlags;
    logicOpEnable: VkBool32;
    logicOp: VkLogicOp;
    attachmentCount?: number;
    pAttachments?: Deno.PointerValue;
    blendConstants: number;
  }) {
    const s = VkPipelineColorBlendStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.logicOpEnable !== undefined) s.logicOpEnable = data.logicOpEnable;
    if (data.logicOp !== undefined) s.logicOp = data.logicOp;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pAttachments !== undefined) s.pAttachments = data.pAttachments;
    if (data.blendConstants !== undefined) s.blendConstants = data.blendConstants;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineColorBlendStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get logicOpEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set logicOpEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get logicOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set logicOp(value: VkLogicOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get blendConstants() {
    return this.#view.getFloat32(40, LE);
  }
  
  set blendConstants(value: number) {
    this.#view.setFloat32(40, Number(value), LE);
  }
}

export class VkPipelineDynamicStateCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineDynamicStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineDynamicStateCreateInfo(new Uint8Array(VkPipelineDynamicStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineDynamicStateCreateFlags;
    dynamicStateCount?: number;
    pDynamicStates: Deno.PointerValue;
  }) {
    const s = VkPipelineDynamicStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.dynamicStateCount !== undefined) s.dynamicStateCount = data.dynamicStateCount;
    if (data.pDynamicStates !== undefined) s.pDynamicStates = data.pDynamicStates;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineDynamicStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dynamicStateCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set dynamicStateCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDynamicStates() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDynamicStates(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkStencilOpState implements IVkStructure {
  static size = 28;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkStencilOpState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkStencilOpState(new Uint8Array(VkStencilOpState.size));
  }
  
  static create(data: {
    failOp: VkStencilOp;
    passOp: VkStencilOp;
    depthFailOp: VkStencilOp;
    compareOp: VkCompareOp;
    compareMask: number;
    writeMask: number;
    reference: number;
  }) {
    const s = VkStencilOpState.alloc();
    if (data.failOp !== undefined) s.failOp = data.failOp;
    if (data.passOp !== undefined) s.passOp = data.passOp;
    if (data.depthFailOp !== undefined) s.depthFailOp = data.depthFailOp;
    if (data.compareOp !== undefined) s.compareOp = data.compareOp;
    if (data.compareMask !== undefined) s.compareMask = data.compareMask;
    if (data.writeMask !== undefined) s.writeMask = data.writeMask;
    if (data.reference !== undefined) s.reference = data.reference;
    return s;
  }
  
  get failOp() {
    return this.#view.getUint32(0, LE);
  }
  
  set failOp(value: VkStencilOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get passOp() {
    return this.#view.getUint32(4, LE);
  }
  
  set passOp(value: VkStencilOp) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depthFailOp() {
    return this.#view.getUint32(8, LE);
  }
  
  set depthFailOp(value: VkStencilOp) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get compareOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set compareOp(value: VkCompareOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get compareMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set compareMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get writeMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set writeMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get reference() {
    return this.#view.getUint32(24, LE);
  }
  
  set reference(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPipelineDepthStencilStateCreateInfo implements IVkStructure {
  static size = 140;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineDepthStencilStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineDepthStencilStateCreateInfo(new Uint8Array(VkPipelineDepthStencilStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineDepthStencilStateCreateFlags;
    depthTestEnable: VkBool32;
    depthWriteEnable: VkBool32;
    depthCompareOp: VkCompareOp;
    depthBoundsTestEnable: VkBool32;
    stencilTestEnable: VkBool32;
    front: VkStencilOpState;
    back: VkStencilOpState;
    minDepthBounds: number;
    maxDepthBounds: number;
  }) {
    const s = VkPipelineDepthStencilStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.depthTestEnable !== undefined) s.depthTestEnable = data.depthTestEnable;
    if (data.depthWriteEnable !== undefined) s.depthWriteEnable = data.depthWriteEnable;
    if (data.depthCompareOp !== undefined) s.depthCompareOp = data.depthCompareOp;
    if (data.depthBoundsTestEnable !== undefined) s.depthBoundsTestEnable = data.depthBoundsTestEnable;
    if (data.stencilTestEnable !== undefined) s.stencilTestEnable = data.stencilTestEnable;
    if (data.front !== undefined) s.front = data.front;
    if (data.back !== undefined) s.back = data.back;
    if (data.minDepthBounds !== undefined) s.minDepthBounds = data.minDepthBounds;
    if (data.maxDepthBounds !== undefined) s.maxDepthBounds = data.maxDepthBounds;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineDepthStencilStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthTestEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthTestEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get depthWriteEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set depthWriteEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get depthCompareOp() {
    return this.#view.getUint32(28, LE);
  }
  
  set depthCompareOp(value: VkCompareOp) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get depthBoundsTestEnable() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthBoundsTestEnable(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilTestEnable() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilTestEnable(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get front() {
    return new VkStencilOpState(this.#data.subarray(56, 56 + VkStencilOpState.size));
  }
  
  set front(value: VkStencilOpState) {
    if (value[BUFFER].byteLength < VkStencilOpState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get back() {
    return new VkStencilOpState(this.#data.subarray(84, 84 + VkStencilOpState.size));
  }
  
  set back(value: VkStencilOpState) {
    if (value[BUFFER].byteLength < VkStencilOpState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 84);
  }
  
  get minDepthBounds() {
    return this.#view.getFloat32(112, LE);
  }
  
  set minDepthBounds(value: number) {
    this.#view.setFloat32(112, Number(value), LE);
  }
  
  get maxDepthBounds() {
    return this.#view.getFloat32(116, LE);
  }
  
  set maxDepthBounds(value: number) {
    this.#view.setFloat32(116, Number(value), LE);
  }
}

export class VkGraphicsPipelineCreateInfo implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGraphicsPipelineCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGraphicsPipelineCreateInfo(new Uint8Array(VkGraphicsPipelineCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCreateFlags;
    stageCount?: number;
    pStages?: Deno.PointerValue;
    pVertexInputState?: Deno.PointerValue;
    pInputAssemblyState?: Deno.PointerValue;
    pTessellationState?: Deno.PointerValue;
    pViewportState?: Deno.PointerValue;
    pRasterizationState?: Deno.PointerValue;
    pMultisampleState?: Deno.PointerValue;
    pDepthStencilState?: Deno.PointerValue;
    pColorBlendState?: Deno.PointerValue;
    pDynamicState?: Deno.PointerValue;
    layout?: VkPipelineLayout;
    renderPass?: VkRenderPass;
    subpass: number;
    basePipelineHandle?: VkPipeline;
    basePipelineIndex: number;
  }) {
    const s = VkGraphicsPipelineCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.stageCount !== undefined) s.stageCount = data.stageCount;
    if (data.pStages !== undefined) s.pStages = data.pStages;
    if (data.pVertexInputState !== undefined) s.pVertexInputState = data.pVertexInputState;
    if (data.pInputAssemblyState !== undefined) s.pInputAssemblyState = data.pInputAssemblyState;
    if (data.pTessellationState !== undefined) s.pTessellationState = data.pTessellationState;
    if (data.pViewportState !== undefined) s.pViewportState = data.pViewportState;
    if (data.pRasterizationState !== undefined) s.pRasterizationState = data.pRasterizationState;
    if (data.pMultisampleState !== undefined) s.pMultisampleState = data.pMultisampleState;
    if (data.pDepthStencilState !== undefined) s.pDepthStencilState = data.pDepthStencilState;
    if (data.pColorBlendState !== undefined) s.pColorBlendState = data.pColorBlendState;
    if (data.pDynamicState !== undefined) s.pDynamicState = data.pDynamicState;
    if (data.layout !== undefined) s.layout = data.layout;
    if (data.renderPass !== undefined) s.renderPass = data.renderPass;
    if (data.subpass !== undefined) s.subpass = data.subpass;
    if (data.basePipelineHandle !== undefined) s.basePipelineHandle = data.basePipelineHandle;
    if (data.basePipelineIndex !== undefined) s.basePipelineIndex = data.basePipelineIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pVertexInputState() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pVertexInputState(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pInputAssemblyState() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pInputAssemblyState(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pTessellationState() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTessellationState(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pViewportState() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pViewportState(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pRasterizationState() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pRasterizationState(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get pMultisampleState() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pMultisampleState(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get pDepthStencilState() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pDepthStencilState(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get pColorBlendState() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pColorBlendState(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get pDynamicState() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pDynamicState(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set layout(value: VkPipelineLayout) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set renderPass(value: VkRenderPass) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(120, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set basePipelineHandle(value: VkPipeline) {
    this.#view.setBigUint64(128, BigInt(value), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(136, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(136, Number(value), LE);
  }
}

export class VkPipelineCacheCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCacheCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCacheCreateInfo(new Uint8Array(VkPipelineCacheCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCacheCreateFlags;
    initialDataSize?: Deno.PointerValue;
    pInitialData: Deno.PointerValue;
  }) {
    const s = VkPipelineCacheCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.initialDataSize !== undefined) s.initialDataSize = data.initialDataSize;
    if (data.pInitialData !== undefined) s.pInitialData = data.pInitialData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCacheCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialDataSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pInitialData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInitialData(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPipelineCacheHeaderVersionOne implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCacheHeaderVersionOne.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCacheHeaderVersionOne(new Uint8Array(VkPipelineCacheHeaderVersionOne.size));
  }
  
  static create(data: {
    headerSize: number;
    headerVersion: VkPipelineCacheHeaderVersion;
    vendorID: number;
    deviceID: number;
    pipelineCacheUUID: number;
  }) {
    const s = VkPipelineCacheHeaderVersionOne.alloc();
    if (data.headerSize !== undefined) s.headerSize = data.headerSize;
    if (data.headerVersion !== undefined) s.headerVersion = data.headerVersion;
    if (data.vendorID !== undefined) s.vendorID = data.vendorID;
    if (data.deviceID !== undefined) s.deviceID = data.deviceID;
    if (data.pipelineCacheUUID !== undefined) s.pipelineCacheUUID = data.pipelineCacheUUID;
    return s;
  }
  
  get headerSize() {
    return this.#view.getUint32(0, LE);
  }
  
  set headerSize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get headerVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set headerVersion(value: VkPipelineCacheHeaderVersion) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get pipelineCacheUUID() {
    return this.#view.getUint8(16);
  }
  
  set pipelineCacheUUID(value: number) {
    this.#view.setUint8(16, Number(value));
  }
}

export class VkPushConstantRange implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPushConstantRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPushConstantRange(new Uint8Array(VkPushConstantRange.size));
  }
  
  static create(data: {
    stageFlags: VkShaderStageFlags;
    offset: number;
    size: number;
  }) {
    const s = VkPushConstantRange.alloc();
    if (data.stageFlags !== undefined) s.stageFlags = data.stageFlags;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get stageFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set stageFlags(value: VkShaderStageFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(4, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkPipelineLayoutCreateInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineLayoutCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineLayoutCreateInfo(new Uint8Array(VkPipelineLayoutCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineLayoutCreateFlags;
    setLayoutCount?: number;
    pSetLayouts?: Deno.PointerValue;
    pushConstantRangeCount?: number;
    pPushConstantRanges: Deno.PointerValue;
  }) {
    const s = VkPipelineLayoutCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.setLayoutCount !== undefined) s.setLayoutCount = data.setLayoutCount;
    if (data.pSetLayouts !== undefined) s.pSetLayouts = data.pSetLayouts;
    if (data.pushConstantRangeCount !== undefined) s.pushConstantRangeCount = data.pushConstantRangeCount;
    if (data.pPushConstantRanges !== undefined) s.pPushConstantRanges = data.pPushConstantRanges;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineLayoutCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get setLayoutCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set setLayoutCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pSetLayouts() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pSetLayouts(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pushConstantRangeCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set pushConstantRangeCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPushConstantRanges() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPushConstantRanges(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkSamplerCreateInfo implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerCreateInfo(new Uint8Array(VkSamplerCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSamplerCreateFlags;
    magFilter: VkFilter;
    minFilter: VkFilter;
    mipmapMode: VkSamplerMipmapMode;
    addressModeU: VkSamplerAddressMode;
    addressModeV: VkSamplerAddressMode;
    addressModeW: VkSamplerAddressMode;
    mipLodBias: number;
    anisotropyEnable: VkBool32;
    maxAnisotropy: number;
    compareEnable: VkBool32;
    compareOp: VkCompareOp;
    minLod: number;
    maxLod: number;
    borderColor: VkBorderColor;
    unnormalizedCoordinates: VkBool32;
  }) {
    const s = VkSamplerCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.magFilter !== undefined) s.magFilter = data.magFilter;
    if (data.minFilter !== undefined) s.minFilter = data.minFilter;
    if (data.mipmapMode !== undefined) s.mipmapMode = data.mipmapMode;
    if (data.addressModeU !== undefined) s.addressModeU = data.addressModeU;
    if (data.addressModeV !== undefined) s.addressModeV = data.addressModeV;
    if (data.addressModeW !== undefined) s.addressModeW = data.addressModeW;
    if (data.mipLodBias !== undefined) s.mipLodBias = data.mipLodBias;
    if (data.anisotropyEnable !== undefined) s.anisotropyEnable = data.anisotropyEnable;
    if (data.maxAnisotropy !== undefined) s.maxAnisotropy = data.maxAnisotropy;
    if (data.compareEnable !== undefined) s.compareEnable = data.compareEnable;
    if (data.compareOp !== undefined) s.compareOp = data.compareOp;
    if (data.minLod !== undefined) s.minLod = data.minLod;
    if (data.maxLod !== undefined) s.maxLod = data.maxLod;
    if (data.borderColor !== undefined) s.borderColor = data.borderColor;
    if (data.unnormalizedCoordinates !== undefined) s.unnormalizedCoordinates = data.unnormalizedCoordinates;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSamplerCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get magFilter() {
    return this.#view.getUint32(20, LE);
  }
  
  set magFilter(value: VkFilter) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get minFilter() {
    return this.#view.getUint32(24, LE);
  }
  
  set minFilter(value: VkFilter) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get mipmapMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set mipmapMode(value: VkSamplerMipmapMode) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get addressModeU() {
    return this.#view.getUint32(32, LE);
  }
  
  set addressModeU(value: VkSamplerAddressMode) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get addressModeV() {
    return this.#view.getUint32(36, LE);
  }
  
  set addressModeV(value: VkSamplerAddressMode) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get addressModeW() {
    return this.#view.getUint32(40, LE);
  }
  
  set addressModeW(value: VkSamplerAddressMode) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get mipLodBias() {
    return this.#view.getFloat32(44, LE);
  }
  
  set mipLodBias(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get anisotropyEnable() {
    return this.#view.getUint32(48, LE);
  }
  
  set anisotropyEnable(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxAnisotropy() {
    return this.#view.getFloat32(52, LE);
  }
  
  set maxAnisotropy(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get compareEnable() {
    return this.#view.getUint32(56, LE);
  }
  
  set compareEnable(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get compareOp() {
    return this.#view.getUint32(60, LE);
  }
  
  set compareOp(value: VkCompareOp) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get minLod() {
    return this.#view.getFloat32(64, LE);
  }
  
  set minLod(value: number) {
    this.#view.setFloat32(64, Number(value), LE);
  }
  
  get maxLod() {
    return this.#view.getFloat32(68, LE);
  }
  
  set maxLod(value: number) {
    this.#view.setFloat32(68, Number(value), LE);
  }
  
  get borderColor() {
    return this.#view.getUint32(72, LE);
  }
  
  set borderColor(value: VkBorderColor) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get unnormalizedCoordinates() {
    return this.#view.getUint32(76, LE);
  }
  
  set unnormalizedCoordinates(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
}

export class VkCommandPoolCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandPoolCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandPoolCreateInfo(new Uint8Array(VkCommandPoolCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkCommandPoolCreateFlags;
    queueFamilyIndex: number;
  }) {
    const s = VkCommandPoolCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.queueFamilyIndex !== undefined) s.queueFamilyIndex = data.queueFamilyIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkCommandPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkCommandBufferAllocateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferAllocateInfo(new Uint8Array(VkCommandBufferAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    commandPool: VkCommandPool;
    level: VkCommandBufferLevel;
    commandBufferCount: number;
  }) {
    const s = VkCommandBufferAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.commandPool !== undefined) s.commandPool = data.commandPool;
    if (data.level !== undefined) s.level = data.level;
    if (data.commandBufferCount !== undefined) s.commandBufferCount = data.commandBufferCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get commandPool() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set commandPool(value: VkCommandPool) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get level() {
    return this.#view.getUint32(24, LE);
  }
  
  set level(value: VkCommandBufferLevel) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkCommandBufferInheritanceInfo implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferInheritanceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferInheritanceInfo(new Uint8Array(VkCommandBufferInheritanceInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    renderPass?: VkRenderPass;
    subpass: number;
    framebuffer?: VkFramebuffer;
    occlusionQueryEnable: VkBool32;
    queryFlags?: VkQueryControlFlags;
    pipelineStatistics?: VkQueryPipelineStatisticFlags;
  }) {
    const s = VkCommandBufferInheritanceInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.renderPass !== undefined) s.renderPass = data.renderPass;
    if (data.subpass !== undefined) s.subpass = data.subpass;
    if (data.framebuffer !== undefined) s.framebuffer = data.framebuffer;
    if (data.occlusionQueryEnable !== undefined) s.occlusionQueryEnable = data.occlusionQueryEnable;
    if (data.queryFlags !== undefined) s.queryFlags = data.queryFlags;
    if (data.pipelineStatistics !== undefined) s.pipelineStatistics = data.pipelineStatistics;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: VkRenderPass) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(24, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get framebuffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set framebuffer(value: VkFramebuffer) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get occlusionQueryEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set occlusionQueryEnable(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get queryFlags() {
    return this.#view.getUint32(44, LE);
  }
  
  set queryFlags(value: VkQueryControlFlags) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pipelineStatistics() {
    return this.#view.getUint32(48, LE);
  }
  
  set pipelineStatistics(value: VkQueryPipelineStatisticFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkCommandBufferBeginInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferBeginInfo(new Uint8Array(VkCommandBufferBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkCommandBufferUsageFlags;
    pInheritanceInfo?: Deno.PointerValue;
  }) {
    const s = VkCommandBufferBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pInheritanceInfo !== undefined) s.pInheritanceInfo = data.pInheritanceInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkCommandBufferUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pInheritanceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pInheritanceInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkRenderPassBeginInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassBeginInfo(new Uint8Array(VkRenderPassBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    renderPass: VkRenderPass;
    framebuffer: VkFramebuffer;
    renderArea: VkRect2D;
    clearValueCount?: number;
    pClearValues: Deno.PointerValue;
  }) {
    const s = VkRenderPassBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.renderPass !== undefined) s.renderPass = data.renderPass;
    if (data.framebuffer !== undefined) s.framebuffer = data.framebuffer;
    if (data.renderArea !== undefined) s.renderArea = data.renderArea;
    if (data.clearValueCount !== undefined) s.clearValueCount = data.clearValueCount;
    if (data.pClearValues !== undefined) s.pClearValues = data.pClearValues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: VkRenderPass) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get framebuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set framebuffer(value: VkFramebuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get renderArea() {
    return new VkRect2D(this.#data.subarray(32, 32 + VkRect2D.size));
  }
  
  set renderArea(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get clearValueCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set clearValueCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pClearValues() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pClearValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkClearDepthStencilValue implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkClearDepthStencilValue.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkClearDepthStencilValue(new Uint8Array(VkClearDepthStencilValue.size));
  }
  
  static create(data: {
    depth: number;
    stencil: number;
  }) {
    const s = VkClearDepthStencilValue.alloc();
    if (data.depth !== undefined) s.depth = data.depth;
    if (data.stencil !== undefined) s.stencil = data.stencil;
    return s;
  }
  
  get depth() {
    return this.#view.getFloat32(0, LE);
  }
  
  set depth(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get stencil() {
    return this.#view.getUint32(4, LE);
  }
  
  set stencil(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkClearAttachment implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkClearAttachment.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkClearAttachment(new Uint8Array(VkClearAttachment.size));
  }
  
  static create(data: {
    aspectMask: VkImageAspectFlags;
    colorAttachment: number;
    clearValue: VkClearValue;
  }) {
    const s = VkClearAttachment.alloc();
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    if (data.colorAttachment !== undefined) s.colorAttachment = data.colorAttachment;
    if (data.clearValue !== undefined) s.clearValue = data.clearValue;
    return s;
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get colorAttachment() {
    return this.#view.getUint32(4, LE);
  }
  
  set colorAttachment(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get clearValue() {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
  
  set clearValue(value: VkClearValue) {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
}

export class VkAttachmentDescription implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentDescription.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentDescription(new Uint8Array(VkAttachmentDescription.size));
  }
  
  static create(data: {
    flags?: VkAttachmentDescriptionFlags;
    format: VkFormat;
    samples: VkSampleCountFlagBits;
    loadOp: VkAttachmentLoadOp;
    storeOp: VkAttachmentStoreOp;
    stencilLoadOp: VkAttachmentLoadOp;
    stencilStoreOp: VkAttachmentStoreOp;
    initialLayout: VkImageLayout;
    finalLayout: VkImageLayout;
  }) {
    const s = VkAttachmentDescription.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.format !== undefined) s.format = data.format;
    if (data.samples !== undefined) s.samples = data.samples;
    if (data.loadOp !== undefined) s.loadOp = data.loadOp;
    if (data.storeOp !== undefined) s.storeOp = data.storeOp;
    if (data.stencilLoadOp !== undefined) s.stencilLoadOp = data.stencilLoadOp;
    if (data.stencilStoreOp !== undefined) s.stencilStoreOp = data.stencilStoreOp;
    if (data.initialLayout !== undefined) s.initialLayout = data.initialLayout;
    if (data.finalLayout !== undefined) s.finalLayout = data.finalLayout;
    return s;
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: VkAttachmentDescriptionFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(4, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(8, LE);
  }
  
  set samples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set loadOp(value: VkAttachmentLoadOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(16, LE);
  }
  
  set storeOp(value: VkAttachmentStoreOp) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilLoadOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilLoadOp(value: VkAttachmentLoadOp) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get stencilStoreOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set stencilStoreOp(value: VkAttachmentStoreOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(28, LE);
  }
  
  set initialLayout(value: VkImageLayout) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get finalLayout() {
    return this.#view.getUint32(32, LE);
  }
  
  set finalLayout(value: VkImageLayout) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkAttachmentReference implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentReference.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentReference(new Uint8Array(VkAttachmentReference.size));
  }
  
  static create(data: {
    attachment: number;
    layout: VkImageLayout;
  }) {
    const s = VkAttachmentReference.alloc();
    if (data.attachment !== undefined) s.attachment = data.attachment;
    if (data.layout !== undefined) s.layout = data.layout;
    return s;
  }
  
  get attachment() {
    return this.#view.getUint32(0, LE);
  }
  
  set attachment(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getUint32(4, LE);
  }
  
  set layout(value: VkImageLayout) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkSubpassDescription implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassDescription.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassDescription(new Uint8Array(VkSubpassDescription.size));
  }
  
  static create(data: {
    flags?: VkSubpassDescriptionFlags;
    pipelineBindPoint: VkPipelineBindPoint;
    inputAttachmentCount?: number;
    pInputAttachments: Deno.PointerValue;
    colorAttachmentCount?: number;
    pColorAttachments: Deno.PointerValue;
    pResolveAttachments?: Deno.PointerValue;
    pDepthStencilAttachment?: Deno.PointerValue;
    preserveAttachmentCount?: number;
    pPreserveAttachments: Deno.PointerValue;
  }) {
    const s = VkSubpassDescription.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.inputAttachmentCount !== undefined) s.inputAttachmentCount = data.inputAttachmentCount;
    if (data.pInputAttachments !== undefined) s.pInputAttachments = data.pInputAttachments;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachments !== undefined) s.pColorAttachments = data.pColorAttachments;
    if (data.pResolveAttachments !== undefined) s.pResolveAttachments = data.pResolveAttachments;
    if (data.pDepthStencilAttachment !== undefined) s.pDepthStencilAttachment = data.pDepthStencilAttachment;
    if (data.preserveAttachmentCount !== undefined) s.preserveAttachmentCount = data.preserveAttachmentCount;
    if (data.pPreserveAttachments !== undefined) s.pPreserveAttachments = data.pPreserveAttachments;
    return s;
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: VkSubpassDescriptionFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(4, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get inputAttachmentCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set inputAttachmentCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pInputAttachments() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pInputAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pColorAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pResolveAttachments() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pResolveAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pDepthStencilAttachment() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pDepthStencilAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get preserveAttachmentCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set preserveAttachmentCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pPreserveAttachments() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pPreserveAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkSubpassDependency implements IVkStructure {
  static size = 28;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassDependency.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassDependency(new Uint8Array(VkSubpassDependency.size));
  }
  
  static create(data: {
    srcSubpass: number;
    dstSubpass: number;
    srcStageMask?: VkPipelineStageFlags;
    dstStageMask?: VkPipelineStageFlags;
    srcAccessMask?: VkAccessFlags;
    dstAccessMask?: VkAccessFlags;
    dependencyFlags?: VkDependencyFlags;
  }) {
    const s = VkSubpassDependency.alloc();
    if (data.srcSubpass !== undefined) s.srcSubpass = data.srcSubpass;
    if (data.dstSubpass !== undefined) s.dstSubpass = data.dstSubpass;
    if (data.srcStageMask !== undefined) s.srcStageMask = data.srcStageMask;
    if (data.dstStageMask !== undefined) s.dstStageMask = data.dstStageMask;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.dependencyFlags !== undefined) s.dependencyFlags = data.dependencyFlags;
    return s;
  }
  
  get srcSubpass() {
    return this.#view.getUint32(0, LE);
  }
  
  set srcSubpass(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstSubpass() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstSubpass(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getUint32(8, LE);
  }
  
  set srcStageMask(value: VkPipelineStageFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getUint32(12, LE);
  }
  
  set dstStageMask(value: VkPipelineStageFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set dependencyFlags(value: VkDependencyFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkRenderPassCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassCreateInfo(new Uint8Array(VkRenderPassCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkRenderPassCreateFlags;
    attachmentCount?: number;
    pAttachments: Deno.PointerValue;
    subpassCount: number;
    pSubpasses: Deno.PointerValue;
    dependencyCount?: number;
    pDependencies: Deno.PointerValue;
  }) {
    const s = VkRenderPassCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pAttachments !== undefined) s.pAttachments = data.pAttachments;
    if (data.subpassCount !== undefined) s.subpassCount = data.subpassCount;
    if (data.pSubpasses !== undefined) s.pSubpasses = data.pSubpasses;
    if (data.dependencyCount !== undefined) s.dependencyCount = data.dependencyCount;
    if (data.pDependencies !== undefined) s.pDependencies = data.pDependencies;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkRenderPassCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSubpasses() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSubpasses(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pDependencies() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pDependencies(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkEventCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkEventCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkEventCreateInfo(new Uint8Array(VkEventCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkEventCreateFlags;
  }) {
    const s = VkEventCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkEventCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkFenceCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFenceCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFenceCreateInfo(new Uint8Array(VkFenceCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkFenceCreateFlags;
  }) {
    const s = VkFenceCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkFenceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFeatures implements IVkStructure {
  static size = 220;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFeatures(new Uint8Array(VkPhysicalDeviceFeatures.size));
  }
  
  static create(data: {
    robustBufferAccess: VkBool32;
    fullDrawIndexUint32: VkBool32;
    imageCubeArray: VkBool32;
    independentBlend: VkBool32;
    geometryShader: VkBool32;
    tessellationShader: VkBool32;
    sampleRateShading: VkBool32;
    dualSrcBlend: VkBool32;
    logicOp: VkBool32;
    multiDrawIndirect: VkBool32;
    drawIndirectFirstInstance: VkBool32;
    depthClamp: VkBool32;
    depthBiasClamp: VkBool32;
    fillModeNonSolid: VkBool32;
    depthBounds: VkBool32;
    wideLines: VkBool32;
    largePoints: VkBool32;
    alphaToOne: VkBool32;
    multiViewport: VkBool32;
    samplerAnisotropy: VkBool32;
    textureCompressionETC2: VkBool32;
    textureCompressionASTC_LDR: VkBool32;
    textureCompressionBC: VkBool32;
    occlusionQueryPrecise: VkBool32;
    pipelineStatisticsQuery: VkBool32;
    vertexPipelineStoresAndAtomics: VkBool32;
    fragmentStoresAndAtomics: VkBool32;
    shaderTessellationAndGeometryPointSize: VkBool32;
    shaderImageGatherExtended: VkBool32;
    shaderStorageImageExtendedFormats: VkBool32;
    shaderStorageImageMultisample: VkBool32;
    shaderStorageImageReadWithoutFormat: VkBool32;
    shaderStorageImageWriteWithoutFormat: VkBool32;
    shaderUniformBufferArrayDynamicIndexing: VkBool32;
    shaderSampledImageArrayDynamicIndexing: VkBool32;
    shaderStorageBufferArrayDynamicIndexing: VkBool32;
    shaderStorageImageArrayDynamicIndexing: VkBool32;
    shaderClipDistance: VkBool32;
    shaderCullDistance: VkBool32;
    shaderFloat64: VkBool32;
    shaderInt64: VkBool32;
    shaderInt16: VkBool32;
    shaderResourceResidency: VkBool32;
    shaderResourceMinLod: VkBool32;
    sparseBinding: VkBool32;
    sparseResidencyBuffer: VkBool32;
    sparseResidencyImage2D: VkBool32;
    sparseResidencyImage3D: VkBool32;
    sparseResidency2Samples: VkBool32;
    sparseResidency4Samples: VkBool32;
    sparseResidency8Samples: VkBool32;
    sparseResidency16Samples: VkBool32;
    sparseResidencyAliased: VkBool32;
    variableMultisampleRate: VkBool32;
    inheritedQueries: VkBool32;
  }) {
    const s = VkPhysicalDeviceFeatures.alloc();
    if (data.robustBufferAccess !== undefined) s.robustBufferAccess = data.robustBufferAccess;
    if (data.fullDrawIndexUint32 !== undefined) s.fullDrawIndexUint32 = data.fullDrawIndexUint32;
    if (data.imageCubeArray !== undefined) s.imageCubeArray = data.imageCubeArray;
    if (data.independentBlend !== undefined) s.independentBlend = data.independentBlend;
    if (data.geometryShader !== undefined) s.geometryShader = data.geometryShader;
    if (data.tessellationShader !== undefined) s.tessellationShader = data.tessellationShader;
    if (data.sampleRateShading !== undefined) s.sampleRateShading = data.sampleRateShading;
    if (data.dualSrcBlend !== undefined) s.dualSrcBlend = data.dualSrcBlend;
    if (data.logicOp !== undefined) s.logicOp = data.logicOp;
    if (data.multiDrawIndirect !== undefined) s.multiDrawIndirect = data.multiDrawIndirect;
    if (data.drawIndirectFirstInstance !== undefined) s.drawIndirectFirstInstance = data.drawIndirectFirstInstance;
    if (data.depthClamp !== undefined) s.depthClamp = data.depthClamp;
    if (data.depthBiasClamp !== undefined) s.depthBiasClamp = data.depthBiasClamp;
    if (data.fillModeNonSolid !== undefined) s.fillModeNonSolid = data.fillModeNonSolid;
    if (data.depthBounds !== undefined) s.depthBounds = data.depthBounds;
    if (data.wideLines !== undefined) s.wideLines = data.wideLines;
    if (data.largePoints !== undefined) s.largePoints = data.largePoints;
    if (data.alphaToOne !== undefined) s.alphaToOne = data.alphaToOne;
    if (data.multiViewport !== undefined) s.multiViewport = data.multiViewport;
    if (data.samplerAnisotropy !== undefined) s.samplerAnisotropy = data.samplerAnisotropy;
    if (data.textureCompressionETC2 !== undefined) s.textureCompressionETC2 = data.textureCompressionETC2;
    if (data.textureCompressionASTC_LDR !== undefined) s.textureCompressionASTC_LDR = data.textureCompressionASTC_LDR;
    if (data.textureCompressionBC !== undefined) s.textureCompressionBC = data.textureCompressionBC;
    if (data.occlusionQueryPrecise !== undefined) s.occlusionQueryPrecise = data.occlusionQueryPrecise;
    if (data.pipelineStatisticsQuery !== undefined) s.pipelineStatisticsQuery = data.pipelineStatisticsQuery;
    if (data.vertexPipelineStoresAndAtomics !== undefined) s.vertexPipelineStoresAndAtomics = data.vertexPipelineStoresAndAtomics;
    if (data.fragmentStoresAndAtomics !== undefined) s.fragmentStoresAndAtomics = data.fragmentStoresAndAtomics;
    if (data.shaderTessellationAndGeometryPointSize !== undefined) s.shaderTessellationAndGeometryPointSize = data.shaderTessellationAndGeometryPointSize;
    if (data.shaderImageGatherExtended !== undefined) s.shaderImageGatherExtended = data.shaderImageGatherExtended;
    if (data.shaderStorageImageExtendedFormats !== undefined) s.shaderStorageImageExtendedFormats = data.shaderStorageImageExtendedFormats;
    if (data.shaderStorageImageMultisample !== undefined) s.shaderStorageImageMultisample = data.shaderStorageImageMultisample;
    if (data.shaderStorageImageReadWithoutFormat !== undefined) s.shaderStorageImageReadWithoutFormat = data.shaderStorageImageReadWithoutFormat;
    if (data.shaderStorageImageWriteWithoutFormat !== undefined) s.shaderStorageImageWriteWithoutFormat = data.shaderStorageImageWriteWithoutFormat;
    if (data.shaderUniformBufferArrayDynamicIndexing !== undefined) s.shaderUniformBufferArrayDynamicIndexing = data.shaderUniformBufferArrayDynamicIndexing;
    if (data.shaderSampledImageArrayDynamicIndexing !== undefined) s.shaderSampledImageArrayDynamicIndexing = data.shaderSampledImageArrayDynamicIndexing;
    if (data.shaderStorageBufferArrayDynamicIndexing !== undefined) s.shaderStorageBufferArrayDynamicIndexing = data.shaderStorageBufferArrayDynamicIndexing;
    if (data.shaderStorageImageArrayDynamicIndexing !== undefined) s.shaderStorageImageArrayDynamicIndexing = data.shaderStorageImageArrayDynamicIndexing;
    if (data.shaderClipDistance !== undefined) s.shaderClipDistance = data.shaderClipDistance;
    if (data.shaderCullDistance !== undefined) s.shaderCullDistance = data.shaderCullDistance;
    if (data.shaderFloat64 !== undefined) s.shaderFloat64 = data.shaderFloat64;
    if (data.shaderInt64 !== undefined) s.shaderInt64 = data.shaderInt64;
    if (data.shaderInt16 !== undefined) s.shaderInt16 = data.shaderInt16;
    if (data.shaderResourceResidency !== undefined) s.shaderResourceResidency = data.shaderResourceResidency;
    if (data.shaderResourceMinLod !== undefined) s.shaderResourceMinLod = data.shaderResourceMinLod;
    if (data.sparseBinding !== undefined) s.sparseBinding = data.sparseBinding;
    if (data.sparseResidencyBuffer !== undefined) s.sparseResidencyBuffer = data.sparseResidencyBuffer;
    if (data.sparseResidencyImage2D !== undefined) s.sparseResidencyImage2D = data.sparseResidencyImage2D;
    if (data.sparseResidencyImage3D !== undefined) s.sparseResidencyImage3D = data.sparseResidencyImage3D;
    if (data.sparseResidency2Samples !== undefined) s.sparseResidency2Samples = data.sparseResidency2Samples;
    if (data.sparseResidency4Samples !== undefined) s.sparseResidency4Samples = data.sparseResidency4Samples;
    if (data.sparseResidency8Samples !== undefined) s.sparseResidency8Samples = data.sparseResidency8Samples;
    if (data.sparseResidency16Samples !== undefined) s.sparseResidency16Samples = data.sparseResidency16Samples;
    if (data.sparseResidencyAliased !== undefined) s.sparseResidencyAliased = data.sparseResidencyAliased;
    if (data.variableMultisampleRate !== undefined) s.variableMultisampleRate = data.variableMultisampleRate;
    if (data.inheritedQueries !== undefined) s.inheritedQueries = data.inheritedQueries;
    return s;
  }
  
  get robustBufferAccess() {
    return this.#view.getUint32(0, LE);
  }
  
  set robustBufferAccess(value: VkBool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get fullDrawIndexUint32() {
    return this.#view.getUint32(4, LE);
  }
  
  set fullDrawIndexUint32(value: VkBool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get imageCubeArray() {
    return this.#view.getUint32(8, LE);
  }
  
  set imageCubeArray(value: VkBool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get independentBlend() {
    return this.#view.getUint32(12, LE);
  }
  
  set independentBlend(value: VkBool32) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get geometryShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryShader(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get tessellationShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set tessellationShader(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sampleRateShading() {
    return this.#view.getUint32(24, LE);
  }
  
  set sampleRateShading(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dualSrcBlend() {
    return this.#view.getUint32(28, LE);
  }
  
  set dualSrcBlend(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get logicOp() {
    return this.#view.getUint32(32, LE);
  }
  
  set logicOp(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multiDrawIndirect() {
    return this.#view.getUint32(36, LE);
  }
  
  set multiDrawIndirect(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get drawIndirectFirstInstance() {
    return this.#view.getUint32(40, LE);
  }
  
  set drawIndirectFirstInstance(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get depthClamp() {
    return this.#view.getUint32(44, LE);
  }
  
  set depthClamp(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get depthBiasClamp() {
    return this.#view.getUint32(48, LE);
  }
  
  set depthBiasClamp(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get fillModeNonSolid() {
    return this.#view.getUint32(52, LE);
  }
  
  set fillModeNonSolid(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get depthBounds() {
    return this.#view.getUint32(56, LE);
  }
  
  set depthBounds(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get wideLines() {
    return this.#view.getUint32(60, LE);
  }
  
  set wideLines(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get largePoints() {
    return this.#view.getUint32(64, LE);
  }
  
  set largePoints(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get alphaToOne() {
    return this.#view.getUint32(68, LE);
  }
  
  set alphaToOne(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get multiViewport() {
    return this.#view.getUint32(72, LE);
  }
  
  set multiViewport(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get samplerAnisotropy() {
    return this.#view.getUint32(76, LE);
  }
  
  set samplerAnisotropy(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get textureCompressionETC2() {
    return this.#view.getUint32(80, LE);
  }
  
  set textureCompressionETC2(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get textureCompressionASTC_LDR() {
    return this.#view.getUint32(84, LE);
  }
  
  set textureCompressionASTC_LDR(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get textureCompressionBC() {
    return this.#view.getUint32(88, LE);
  }
  
  set textureCompressionBC(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get occlusionQueryPrecise() {
    return this.#view.getUint32(92, LE);
  }
  
  set occlusionQueryPrecise(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get pipelineStatisticsQuery() {
    return this.#view.getUint32(96, LE);
  }
  
  set pipelineStatisticsQuery(value: VkBool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get vertexPipelineStoresAndAtomics() {
    return this.#view.getUint32(100, LE);
  }
  
  set vertexPipelineStoresAndAtomics(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get fragmentStoresAndAtomics() {
    return this.#view.getUint32(104, LE);
  }
  
  set fragmentStoresAndAtomics(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get shaderTessellationAndGeometryPointSize() {
    return this.#view.getUint32(108, LE);
  }
  
  set shaderTessellationAndGeometryPointSize(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get shaderImageGatherExtended() {
    return this.#view.getUint32(112, LE);
  }
  
  set shaderImageGatherExtended(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get shaderStorageImageExtendedFormats() {
    return this.#view.getUint32(116, LE);
  }
  
  set shaderStorageImageExtendedFormats(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get shaderStorageImageMultisample() {
    return this.#view.getUint32(120, LE);
  }
  
  set shaderStorageImageMultisample(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get shaderStorageImageReadWithoutFormat() {
    return this.#view.getUint32(124, LE);
  }
  
  set shaderStorageImageReadWithoutFormat(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get shaderStorageImageWriteWithoutFormat() {
    return this.#view.getUint32(128, LE);
  }
  
  set shaderStorageImageWriteWithoutFormat(value: VkBool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get shaderUniformBufferArrayDynamicIndexing() {
    return this.#view.getUint32(132, LE);
  }
  
  set shaderUniformBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get shaderSampledImageArrayDynamicIndexing() {
    return this.#view.getUint32(136, LE);
  }
  
  set shaderSampledImageArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get shaderStorageBufferArrayDynamicIndexing() {
    return this.#view.getUint32(140, LE);
  }
  
  set shaderStorageBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get shaderStorageImageArrayDynamicIndexing() {
    return this.#view.getUint32(144, LE);
  }
  
  set shaderStorageImageArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get shaderClipDistance() {
    return this.#view.getUint32(148, LE);
  }
  
  set shaderClipDistance(value: VkBool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get shaderCullDistance() {
    return this.#view.getUint32(152, LE);
  }
  
  set shaderCullDistance(value: VkBool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get shaderFloat64() {
    return this.#view.getUint32(156, LE);
  }
  
  set shaderFloat64(value: VkBool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get shaderInt64() {
    return this.#view.getUint32(160, LE);
  }
  
  set shaderInt64(value: VkBool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get shaderInt16() {
    return this.#view.getUint32(164, LE);
  }
  
  set shaderInt16(value: VkBool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get shaderResourceResidency() {
    return this.#view.getUint32(168, LE);
  }
  
  set shaderResourceResidency(value: VkBool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get shaderResourceMinLod() {
    return this.#view.getUint32(172, LE);
  }
  
  set shaderResourceMinLod(value: VkBool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get sparseBinding() {
    return this.#view.getUint32(176, LE);
  }
  
  set sparseBinding(value: VkBool32) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get sparseResidencyBuffer() {
    return this.#view.getUint32(180, LE);
  }
  
  set sparseResidencyBuffer(value: VkBool32) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get sparseResidencyImage2D() {
    return this.#view.getUint32(184, LE);
  }
  
  set sparseResidencyImage2D(value: VkBool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get sparseResidencyImage3D() {
    return this.#view.getUint32(188, LE);
  }
  
  set sparseResidencyImage3D(value: VkBool32) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get sparseResidency2Samples() {
    return this.#view.getUint32(192, LE);
  }
  
  set sparseResidency2Samples(value: VkBool32) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get sparseResidency4Samples() {
    return this.#view.getUint32(196, LE);
  }
  
  set sparseResidency4Samples(value: VkBool32) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get sparseResidency8Samples() {
    return this.#view.getUint32(200, LE);
  }
  
  set sparseResidency8Samples(value: VkBool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get sparseResidency16Samples() {
    return this.#view.getUint32(204, LE);
  }
  
  set sparseResidency16Samples(value: VkBool32) {
    this.#view.setUint32(204, Number(value), LE);
  }
  
  get sparseResidencyAliased() {
    return this.#view.getUint32(208, LE);
  }
  
  set sparseResidencyAliased(value: VkBool32) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get variableMultisampleRate() {
    return this.#view.getUint32(212, LE);
  }
  
  set variableMultisampleRate(value: VkBool32) {
    this.#view.setUint32(212, Number(value), LE);
  }
  
  get inheritedQueries() {
    return this.#view.getUint32(216, LE);
  }
  
  set inheritedQueries(value: VkBool32) {
    this.#view.setUint32(216, Number(value), LE);
  }
}

export class VkPhysicalDeviceSparseProperties implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSparseProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSparseProperties(new Uint8Array(VkPhysicalDeviceSparseProperties.size));
  }
  
  static create(data: {
    residencyStandard2DBlockShape: VkBool32;
    residencyStandard2DMultisampleBlockShape: VkBool32;
    residencyStandard3DBlockShape: VkBool32;
    residencyAlignedMipSize: VkBool32;
    residencyNonResidentStrict: VkBool32;
  }) {
    const s = VkPhysicalDeviceSparseProperties.alloc();
    if (data.residencyStandard2DBlockShape !== undefined) s.residencyStandard2DBlockShape = data.residencyStandard2DBlockShape;
    if (data.residencyStandard2DMultisampleBlockShape !== undefined) s.residencyStandard2DMultisampleBlockShape = data.residencyStandard2DMultisampleBlockShape;
    if (data.residencyStandard3DBlockShape !== undefined) s.residencyStandard3DBlockShape = data.residencyStandard3DBlockShape;
    if (data.residencyAlignedMipSize !== undefined) s.residencyAlignedMipSize = data.residencyAlignedMipSize;
    if (data.residencyNonResidentStrict !== undefined) s.residencyNonResidentStrict = data.residencyNonResidentStrict;
    return s;
  }
  
  get residencyStandard2DBlockShape() {
    return this.#view.getUint32(0, LE);
  }
  
  set residencyStandard2DBlockShape(value: VkBool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get residencyStandard2DMultisampleBlockShape() {
    return this.#view.getUint32(4, LE);
  }
  
  set residencyStandard2DMultisampleBlockShape(value: VkBool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get residencyStandard3DBlockShape() {
    return this.#view.getUint32(8, LE);
  }
  
  set residencyStandard3DBlockShape(value: VkBool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get residencyAlignedMipSize() {
    return this.#view.getUint32(12, LE);
  }
  
  set residencyAlignedMipSize(value: VkBool32) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get residencyNonResidentStrict() {
    return this.#view.getUint32(16, LE);
  }
  
  set residencyNonResidentStrict(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceLimits implements IVkStructure {
  static size = 472;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceLimits.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceLimits(new Uint8Array(VkPhysicalDeviceLimits.size));
  }
  
  static create(data: {
    maxImageDimension1D: number;
    maxImageDimension2D: number;
    maxImageDimension3D: number;
    maxImageDimensionCube: number;
    maxImageArrayLayers: number;
    maxTexelBufferElements: number;
    maxUniformBufferRange: number;
    maxStorageBufferRange: number;
    maxPushConstantsSize: number;
    maxMemoryAllocationCount: number;
    maxSamplerAllocationCount: number;
    bufferImageGranularity: VkDeviceSize;
    sparseAddressSpaceSize: VkDeviceSize;
    maxBoundDescriptorSets: number;
    maxPerStageDescriptorSamplers: number;
    maxPerStageDescriptorUniformBuffers: number;
    maxPerStageDescriptorStorageBuffers: number;
    maxPerStageDescriptorSampledImages: number;
    maxPerStageDescriptorStorageImages: number;
    maxPerStageDescriptorInputAttachments: number;
    maxPerStageResources: number;
    maxDescriptorSetSamplers: number;
    maxDescriptorSetUniformBuffers: number;
    maxDescriptorSetUniformBuffersDynamic: number;
    maxDescriptorSetStorageBuffers: number;
    maxDescriptorSetStorageBuffersDynamic: number;
    maxDescriptorSetSampledImages: number;
    maxDescriptorSetStorageImages: number;
    maxDescriptorSetInputAttachments: number;
    maxVertexInputAttributes: number;
    maxVertexInputBindings: number;
    maxVertexInputAttributeOffset: number;
    maxVertexInputBindingStride: number;
    maxVertexOutputComponents: number;
    maxTessellationGenerationLevel: number;
    maxTessellationPatchSize: number;
    maxTessellationControlPerVertexInputComponents: number;
    maxTessellationControlPerVertexOutputComponents: number;
    maxTessellationControlPerPatchOutputComponents: number;
    maxTessellationControlTotalOutputComponents: number;
    maxTessellationEvaluationInputComponents: number;
    maxTessellationEvaluationOutputComponents: number;
    maxGeometryShaderInvocations: number;
    maxGeometryInputComponents: number;
    maxGeometryOutputComponents: number;
    maxGeometryOutputVertices: number;
    maxGeometryTotalOutputComponents: number;
    maxFragmentInputComponents: number;
    maxFragmentOutputAttachments: number;
    maxFragmentDualSrcAttachments: number;
    maxFragmentCombinedOutputResources: number;
    maxComputeSharedMemorySize: number;
    maxComputeWorkGroupCount: number;
    maxComputeWorkGroupInvocations: number;
    maxComputeWorkGroupSize: number;
    subPixelPrecisionBits: number;
    subTexelPrecisionBits: number;
    mipmapPrecisionBits: number;
    maxDrawIndexedIndexValue: number;
    maxDrawIndirectCount: number;
    maxSamplerLodBias: number;
    maxSamplerAnisotropy: number;
    maxViewports: number;
    maxViewportDimensions: number;
    viewportBoundsRange: number;
    viewportSubPixelBits: number;
    minMemoryMapAlignment: Deno.PointerValue;
    minTexelBufferOffsetAlignment: VkDeviceSize;
    minUniformBufferOffsetAlignment: VkDeviceSize;
    minStorageBufferOffsetAlignment: VkDeviceSize;
    minTexelOffset: number;
    maxTexelOffset: number;
    minTexelGatherOffset: number;
    maxTexelGatherOffset: number;
    minInterpolationOffset: number;
    maxInterpolationOffset: number;
    subPixelInterpolationOffsetBits: number;
    maxFramebufferWidth: number;
    maxFramebufferHeight: number;
    maxFramebufferLayers: number;
    framebufferColorSampleCounts?: VkSampleCountFlags;
    framebufferDepthSampleCounts?: VkSampleCountFlags;
    framebufferStencilSampleCounts?: VkSampleCountFlags;
    framebufferNoAttachmentsSampleCounts?: VkSampleCountFlags;
    maxColorAttachments: number;
    sampledImageColorSampleCounts?: VkSampleCountFlags;
    sampledImageIntegerSampleCounts?: VkSampleCountFlags;
    sampledImageDepthSampleCounts?: VkSampleCountFlags;
    sampledImageStencilSampleCounts?: VkSampleCountFlags;
    storageImageSampleCounts?: VkSampleCountFlags;
    maxSampleMaskWords: number;
    timestampComputeAndGraphics: VkBool32;
    timestampPeriod: number;
    maxClipDistances: number;
    maxCullDistances: number;
    maxCombinedClipAndCullDistances: number;
    discreteQueuePriorities: number;
    pointSizeRange: number;
    lineWidthRange: number;
    pointSizeGranularity: number;
    lineWidthGranularity: number;
    strictLines: VkBool32;
    standardSampleLocations: VkBool32;
    optimalBufferCopyOffsetAlignment: VkDeviceSize;
    optimalBufferCopyRowPitchAlignment: VkDeviceSize;
    nonCoherentAtomSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceLimits.alloc();
    if (data.maxImageDimension1D !== undefined) s.maxImageDimension1D = data.maxImageDimension1D;
    if (data.maxImageDimension2D !== undefined) s.maxImageDimension2D = data.maxImageDimension2D;
    if (data.maxImageDimension3D !== undefined) s.maxImageDimension3D = data.maxImageDimension3D;
    if (data.maxImageDimensionCube !== undefined) s.maxImageDimensionCube = data.maxImageDimensionCube;
    if (data.maxImageArrayLayers !== undefined) s.maxImageArrayLayers = data.maxImageArrayLayers;
    if (data.maxTexelBufferElements !== undefined) s.maxTexelBufferElements = data.maxTexelBufferElements;
    if (data.maxUniformBufferRange !== undefined) s.maxUniformBufferRange = data.maxUniformBufferRange;
    if (data.maxStorageBufferRange !== undefined) s.maxStorageBufferRange = data.maxStorageBufferRange;
    if (data.maxPushConstantsSize !== undefined) s.maxPushConstantsSize = data.maxPushConstantsSize;
    if (data.maxMemoryAllocationCount !== undefined) s.maxMemoryAllocationCount = data.maxMemoryAllocationCount;
    if (data.maxSamplerAllocationCount !== undefined) s.maxSamplerAllocationCount = data.maxSamplerAllocationCount;
    if (data.bufferImageGranularity !== undefined) s.bufferImageGranularity = data.bufferImageGranularity;
    if (data.sparseAddressSpaceSize !== undefined) s.sparseAddressSpaceSize = data.sparseAddressSpaceSize;
    if (data.maxBoundDescriptorSets !== undefined) s.maxBoundDescriptorSets = data.maxBoundDescriptorSets;
    if (data.maxPerStageDescriptorSamplers !== undefined) s.maxPerStageDescriptorSamplers = data.maxPerStageDescriptorSamplers;
    if (data.maxPerStageDescriptorUniformBuffers !== undefined) s.maxPerStageDescriptorUniformBuffers = data.maxPerStageDescriptorUniformBuffers;
    if (data.maxPerStageDescriptorStorageBuffers !== undefined) s.maxPerStageDescriptorStorageBuffers = data.maxPerStageDescriptorStorageBuffers;
    if (data.maxPerStageDescriptorSampledImages !== undefined) s.maxPerStageDescriptorSampledImages = data.maxPerStageDescriptorSampledImages;
    if (data.maxPerStageDescriptorStorageImages !== undefined) s.maxPerStageDescriptorStorageImages = data.maxPerStageDescriptorStorageImages;
    if (data.maxPerStageDescriptorInputAttachments !== undefined) s.maxPerStageDescriptorInputAttachments = data.maxPerStageDescriptorInputAttachments;
    if (data.maxPerStageResources !== undefined) s.maxPerStageResources = data.maxPerStageResources;
    if (data.maxDescriptorSetSamplers !== undefined) s.maxDescriptorSetSamplers = data.maxDescriptorSetSamplers;
    if (data.maxDescriptorSetUniformBuffers !== undefined) s.maxDescriptorSetUniformBuffers = data.maxDescriptorSetUniformBuffers;
    if (data.maxDescriptorSetUniformBuffersDynamic !== undefined) s.maxDescriptorSetUniformBuffersDynamic = data.maxDescriptorSetUniformBuffersDynamic;
    if (data.maxDescriptorSetStorageBuffers !== undefined) s.maxDescriptorSetStorageBuffers = data.maxDescriptorSetStorageBuffers;
    if (data.maxDescriptorSetStorageBuffersDynamic !== undefined) s.maxDescriptorSetStorageBuffersDynamic = data.maxDescriptorSetStorageBuffersDynamic;
    if (data.maxDescriptorSetSampledImages !== undefined) s.maxDescriptorSetSampledImages = data.maxDescriptorSetSampledImages;
    if (data.maxDescriptorSetStorageImages !== undefined) s.maxDescriptorSetStorageImages = data.maxDescriptorSetStorageImages;
    if (data.maxDescriptorSetInputAttachments !== undefined) s.maxDescriptorSetInputAttachments = data.maxDescriptorSetInputAttachments;
    if (data.maxVertexInputAttributes !== undefined) s.maxVertexInputAttributes = data.maxVertexInputAttributes;
    if (data.maxVertexInputBindings !== undefined) s.maxVertexInputBindings = data.maxVertexInputBindings;
    if (data.maxVertexInputAttributeOffset !== undefined) s.maxVertexInputAttributeOffset = data.maxVertexInputAttributeOffset;
    if (data.maxVertexInputBindingStride !== undefined) s.maxVertexInputBindingStride = data.maxVertexInputBindingStride;
    if (data.maxVertexOutputComponents !== undefined) s.maxVertexOutputComponents = data.maxVertexOutputComponents;
    if (data.maxTessellationGenerationLevel !== undefined) s.maxTessellationGenerationLevel = data.maxTessellationGenerationLevel;
    if (data.maxTessellationPatchSize !== undefined) s.maxTessellationPatchSize = data.maxTessellationPatchSize;
    if (data.maxTessellationControlPerVertexInputComponents !== undefined) s.maxTessellationControlPerVertexInputComponents = data.maxTessellationControlPerVertexInputComponents;
    if (data.maxTessellationControlPerVertexOutputComponents !== undefined) s.maxTessellationControlPerVertexOutputComponents = data.maxTessellationControlPerVertexOutputComponents;
    if (data.maxTessellationControlPerPatchOutputComponents !== undefined) s.maxTessellationControlPerPatchOutputComponents = data.maxTessellationControlPerPatchOutputComponents;
    if (data.maxTessellationControlTotalOutputComponents !== undefined) s.maxTessellationControlTotalOutputComponents = data.maxTessellationControlTotalOutputComponents;
    if (data.maxTessellationEvaluationInputComponents !== undefined) s.maxTessellationEvaluationInputComponents = data.maxTessellationEvaluationInputComponents;
    if (data.maxTessellationEvaluationOutputComponents !== undefined) s.maxTessellationEvaluationOutputComponents = data.maxTessellationEvaluationOutputComponents;
    if (data.maxGeometryShaderInvocations !== undefined) s.maxGeometryShaderInvocations = data.maxGeometryShaderInvocations;
    if (data.maxGeometryInputComponents !== undefined) s.maxGeometryInputComponents = data.maxGeometryInputComponents;
    if (data.maxGeometryOutputComponents !== undefined) s.maxGeometryOutputComponents = data.maxGeometryOutputComponents;
    if (data.maxGeometryOutputVertices !== undefined) s.maxGeometryOutputVertices = data.maxGeometryOutputVertices;
    if (data.maxGeometryTotalOutputComponents !== undefined) s.maxGeometryTotalOutputComponents = data.maxGeometryTotalOutputComponents;
    if (data.maxFragmentInputComponents !== undefined) s.maxFragmentInputComponents = data.maxFragmentInputComponents;
    if (data.maxFragmentOutputAttachments !== undefined) s.maxFragmentOutputAttachments = data.maxFragmentOutputAttachments;
    if (data.maxFragmentDualSrcAttachments !== undefined) s.maxFragmentDualSrcAttachments = data.maxFragmentDualSrcAttachments;
    if (data.maxFragmentCombinedOutputResources !== undefined) s.maxFragmentCombinedOutputResources = data.maxFragmentCombinedOutputResources;
    if (data.maxComputeSharedMemorySize !== undefined) s.maxComputeSharedMemorySize = data.maxComputeSharedMemorySize;
    if (data.maxComputeWorkGroupCount !== undefined) s.maxComputeWorkGroupCount = data.maxComputeWorkGroupCount;
    if (data.maxComputeWorkGroupInvocations !== undefined) s.maxComputeWorkGroupInvocations = data.maxComputeWorkGroupInvocations;
    if (data.maxComputeWorkGroupSize !== undefined) s.maxComputeWorkGroupSize = data.maxComputeWorkGroupSize;
    if (data.subPixelPrecisionBits !== undefined) s.subPixelPrecisionBits = data.subPixelPrecisionBits;
    if (data.subTexelPrecisionBits !== undefined) s.subTexelPrecisionBits = data.subTexelPrecisionBits;
    if (data.mipmapPrecisionBits !== undefined) s.mipmapPrecisionBits = data.mipmapPrecisionBits;
    if (data.maxDrawIndexedIndexValue !== undefined) s.maxDrawIndexedIndexValue = data.maxDrawIndexedIndexValue;
    if (data.maxDrawIndirectCount !== undefined) s.maxDrawIndirectCount = data.maxDrawIndirectCount;
    if (data.maxSamplerLodBias !== undefined) s.maxSamplerLodBias = data.maxSamplerLodBias;
    if (data.maxSamplerAnisotropy !== undefined) s.maxSamplerAnisotropy = data.maxSamplerAnisotropy;
    if (data.maxViewports !== undefined) s.maxViewports = data.maxViewports;
    if (data.maxViewportDimensions !== undefined) s.maxViewportDimensions = data.maxViewportDimensions;
    if (data.viewportBoundsRange !== undefined) s.viewportBoundsRange = data.viewportBoundsRange;
    if (data.viewportSubPixelBits !== undefined) s.viewportSubPixelBits = data.viewportSubPixelBits;
    if (data.minMemoryMapAlignment !== undefined) s.minMemoryMapAlignment = data.minMemoryMapAlignment;
    if (data.minTexelBufferOffsetAlignment !== undefined) s.minTexelBufferOffsetAlignment = data.minTexelBufferOffsetAlignment;
    if (data.minUniformBufferOffsetAlignment !== undefined) s.minUniformBufferOffsetAlignment = data.minUniformBufferOffsetAlignment;
    if (data.minStorageBufferOffsetAlignment !== undefined) s.minStorageBufferOffsetAlignment = data.minStorageBufferOffsetAlignment;
    if (data.minTexelOffset !== undefined) s.minTexelOffset = data.minTexelOffset;
    if (data.maxTexelOffset !== undefined) s.maxTexelOffset = data.maxTexelOffset;
    if (data.minTexelGatherOffset !== undefined) s.minTexelGatherOffset = data.minTexelGatherOffset;
    if (data.maxTexelGatherOffset !== undefined) s.maxTexelGatherOffset = data.maxTexelGatherOffset;
    if (data.minInterpolationOffset !== undefined) s.minInterpolationOffset = data.minInterpolationOffset;
    if (data.maxInterpolationOffset !== undefined) s.maxInterpolationOffset = data.maxInterpolationOffset;
    if (data.subPixelInterpolationOffsetBits !== undefined) s.subPixelInterpolationOffsetBits = data.subPixelInterpolationOffsetBits;
    if (data.maxFramebufferWidth !== undefined) s.maxFramebufferWidth = data.maxFramebufferWidth;
    if (data.maxFramebufferHeight !== undefined) s.maxFramebufferHeight = data.maxFramebufferHeight;
    if (data.maxFramebufferLayers !== undefined) s.maxFramebufferLayers = data.maxFramebufferLayers;
    if (data.framebufferColorSampleCounts !== undefined) s.framebufferColorSampleCounts = data.framebufferColorSampleCounts;
    if (data.framebufferDepthSampleCounts !== undefined) s.framebufferDepthSampleCounts = data.framebufferDepthSampleCounts;
    if (data.framebufferStencilSampleCounts !== undefined) s.framebufferStencilSampleCounts = data.framebufferStencilSampleCounts;
    if (data.framebufferNoAttachmentsSampleCounts !== undefined) s.framebufferNoAttachmentsSampleCounts = data.framebufferNoAttachmentsSampleCounts;
    if (data.maxColorAttachments !== undefined) s.maxColorAttachments = data.maxColorAttachments;
    if (data.sampledImageColorSampleCounts !== undefined) s.sampledImageColorSampleCounts = data.sampledImageColorSampleCounts;
    if (data.sampledImageIntegerSampleCounts !== undefined) s.sampledImageIntegerSampleCounts = data.sampledImageIntegerSampleCounts;
    if (data.sampledImageDepthSampleCounts !== undefined) s.sampledImageDepthSampleCounts = data.sampledImageDepthSampleCounts;
    if (data.sampledImageStencilSampleCounts !== undefined) s.sampledImageStencilSampleCounts = data.sampledImageStencilSampleCounts;
    if (data.storageImageSampleCounts !== undefined) s.storageImageSampleCounts = data.storageImageSampleCounts;
    if (data.maxSampleMaskWords !== undefined) s.maxSampleMaskWords = data.maxSampleMaskWords;
    if (data.timestampComputeAndGraphics !== undefined) s.timestampComputeAndGraphics = data.timestampComputeAndGraphics;
    if (data.timestampPeriod !== undefined) s.timestampPeriod = data.timestampPeriod;
    if (data.maxClipDistances !== undefined) s.maxClipDistances = data.maxClipDistances;
    if (data.maxCullDistances !== undefined) s.maxCullDistances = data.maxCullDistances;
    if (data.maxCombinedClipAndCullDistances !== undefined) s.maxCombinedClipAndCullDistances = data.maxCombinedClipAndCullDistances;
    if (data.discreteQueuePriorities !== undefined) s.discreteQueuePriorities = data.discreteQueuePriorities;
    if (data.pointSizeRange !== undefined) s.pointSizeRange = data.pointSizeRange;
    if (data.lineWidthRange !== undefined) s.lineWidthRange = data.lineWidthRange;
    if (data.pointSizeGranularity !== undefined) s.pointSizeGranularity = data.pointSizeGranularity;
    if (data.lineWidthGranularity !== undefined) s.lineWidthGranularity = data.lineWidthGranularity;
    if (data.strictLines !== undefined) s.strictLines = data.strictLines;
    if (data.standardSampleLocations !== undefined) s.standardSampleLocations = data.standardSampleLocations;
    if (data.optimalBufferCopyOffsetAlignment !== undefined) s.optimalBufferCopyOffsetAlignment = data.optimalBufferCopyOffsetAlignment;
    if (data.optimalBufferCopyRowPitchAlignment !== undefined) s.optimalBufferCopyRowPitchAlignment = data.optimalBufferCopyRowPitchAlignment;
    if (data.nonCoherentAtomSize !== undefined) s.nonCoherentAtomSize = data.nonCoherentAtomSize;
    return s;
  }
  
  get maxImageDimension1D() {
    return this.#view.getUint32(0, LE);
  }
  
  set maxImageDimension1D(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get maxImageDimension2D() {
    return this.#view.getUint32(4, LE);
  }
  
  set maxImageDimension2D(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get maxImageDimension3D() {
    return this.#view.getUint32(8, LE);
  }
  
  set maxImageDimension3D(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get maxImageDimensionCube() {
    return this.#view.getUint32(12, LE);
  }
  
  set maxImageDimensionCube(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTexelBufferElements() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTexelBufferElements(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxUniformBufferRange() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxUniformBufferRange(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxStorageBufferRange() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxStorageBufferRange(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxPushConstantsSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxPushConstantsSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxMemoryAllocationCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxMemoryAllocationCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxSamplerAllocationCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxSamplerAllocationCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get bufferImageGranularity() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set bufferImageGranularity(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get sparseAddressSpaceSize() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set sparseAddressSpaceSize(value: VkDeviceSize) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get maxBoundDescriptorSets() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxBoundDescriptorSets(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxPerStageDescriptorSamplers() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxPerStageDescriptorSamplers(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxPerStageDescriptorUniformBuffers() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxPerStageDescriptorUniformBuffers(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get maxPerStageDescriptorStorageBuffers() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxPerStageDescriptorStorageBuffers(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxPerStageDescriptorSampledImages() {
    return this.#view.getUint32(80, LE);
  }
  
  set maxPerStageDescriptorSampledImages(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxPerStageDescriptorStorageImages() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxPerStageDescriptorStorageImages(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxPerStageDescriptorInputAttachments() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxPerStageDescriptorInputAttachments(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get maxPerStageResources() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxPerStageResources(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxDescriptorSetSamplers() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxDescriptorSetSamplers(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxDescriptorSetUniformBuffers() {
    return this.#view.getUint32(100, LE);
  }
  
  set maxDescriptorSetUniformBuffers(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxDescriptorSetUniformBuffersDynamic() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxDescriptorSetUniformBuffersDynamic(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get maxDescriptorSetStorageBuffers() {
    return this.#view.getUint32(108, LE);
  }
  
  set maxDescriptorSetStorageBuffers(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get maxDescriptorSetStorageBuffersDynamic() {
    return this.#view.getUint32(112, LE);
  }
  
  set maxDescriptorSetStorageBuffersDynamic(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get maxDescriptorSetSampledImages() {
    return this.#view.getUint32(116, LE);
  }
  
  set maxDescriptorSetSampledImages(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get maxDescriptorSetStorageImages() {
    return this.#view.getUint32(120, LE);
  }
  
  set maxDescriptorSetStorageImages(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get maxDescriptorSetInputAttachments() {
    return this.#view.getUint32(124, LE);
  }
  
  set maxDescriptorSetInputAttachments(value: number) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get maxVertexInputAttributes() {
    return this.#view.getUint32(128, LE);
  }
  
  set maxVertexInputAttributes(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get maxVertexInputBindings() {
    return this.#view.getUint32(132, LE);
  }
  
  set maxVertexInputBindings(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get maxVertexInputAttributeOffset() {
    return this.#view.getUint32(136, LE);
  }
  
  set maxVertexInputAttributeOffset(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get maxVertexInputBindingStride() {
    return this.#view.getUint32(140, LE);
  }
  
  set maxVertexInputBindingStride(value: number) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get maxVertexOutputComponents() {
    return this.#view.getUint32(144, LE);
  }
  
  set maxVertexOutputComponents(value: number) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get maxTessellationGenerationLevel() {
    return this.#view.getUint32(148, LE);
  }
  
  set maxTessellationGenerationLevel(value: number) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get maxTessellationPatchSize() {
    return this.#view.getUint32(152, LE);
  }
  
  set maxTessellationPatchSize(value: number) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get maxTessellationControlPerVertexInputComponents() {
    return this.#view.getUint32(156, LE);
  }
  
  set maxTessellationControlPerVertexInputComponents(value: number) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get maxTessellationControlPerVertexOutputComponents() {
    return this.#view.getUint32(160, LE);
  }
  
  set maxTessellationControlPerVertexOutputComponents(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get maxTessellationControlPerPatchOutputComponents() {
    return this.#view.getUint32(164, LE);
  }
  
  set maxTessellationControlPerPatchOutputComponents(value: number) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get maxTessellationControlTotalOutputComponents() {
    return this.#view.getUint32(168, LE);
  }
  
  set maxTessellationControlTotalOutputComponents(value: number) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get maxTessellationEvaluationInputComponents() {
    return this.#view.getUint32(172, LE);
  }
  
  set maxTessellationEvaluationInputComponents(value: number) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get maxTessellationEvaluationOutputComponents() {
    return this.#view.getUint32(176, LE);
  }
  
  set maxTessellationEvaluationOutputComponents(value: number) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get maxGeometryShaderInvocations() {
    return this.#view.getUint32(180, LE);
  }
  
  set maxGeometryShaderInvocations(value: number) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get maxGeometryInputComponents() {
    return this.#view.getUint32(184, LE);
  }
  
  set maxGeometryInputComponents(value: number) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get maxGeometryOutputComponents() {
    return this.#view.getUint32(188, LE);
  }
  
  set maxGeometryOutputComponents(value: number) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get maxGeometryOutputVertices() {
    return this.#view.getUint32(192, LE);
  }
  
  set maxGeometryOutputVertices(value: number) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get maxGeometryTotalOutputComponents() {
    return this.#view.getUint32(196, LE);
  }
  
  set maxGeometryTotalOutputComponents(value: number) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get maxFragmentInputComponents() {
    return this.#view.getUint32(200, LE);
  }
  
  set maxFragmentInputComponents(value: number) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get maxFragmentOutputAttachments() {
    return this.#view.getUint32(204, LE);
  }
  
  set maxFragmentOutputAttachments(value: number) {
    this.#view.setUint32(204, Number(value), LE);
  }
  
  get maxFragmentDualSrcAttachments() {
    return this.#view.getUint32(208, LE);
  }
  
  set maxFragmentDualSrcAttachments(value: number) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get maxFragmentCombinedOutputResources() {
    return this.#view.getUint32(212, LE);
  }
  
  set maxFragmentCombinedOutputResources(value: number) {
    this.#view.setUint32(212, Number(value), LE);
  }
  
  get maxComputeSharedMemorySize() {
    return this.#view.getUint32(216, LE);
  }
  
  set maxComputeSharedMemorySize(value: number) {
    this.#view.setUint32(216, Number(value), LE);
  }
  
  get maxComputeWorkGroupCount() {
    return this.#view.getUint32(220, LE);
  }
  
  set maxComputeWorkGroupCount(value: number) {
    this.#view.setUint32(220, Number(value), LE);
  }
  
  get maxComputeWorkGroupInvocations() {
    return this.#view.getUint32(224, LE);
  }
  
  set maxComputeWorkGroupInvocations(value: number) {
    this.#view.setUint32(224, Number(value), LE);
  }
  
  get maxComputeWorkGroupSize() {
    return this.#view.getUint32(228, LE);
  }
  
  set maxComputeWorkGroupSize(value: number) {
    this.#view.setUint32(228, Number(value), LE);
  }
  
  get subPixelPrecisionBits() {
    return this.#view.getUint32(232, LE);
  }
  
  set subPixelPrecisionBits(value: number) {
    this.#view.setUint32(232, Number(value), LE);
  }
  
  get subTexelPrecisionBits() {
    return this.#view.getUint32(236, LE);
  }
  
  set subTexelPrecisionBits(value: number) {
    this.#view.setUint32(236, Number(value), LE);
  }
  
  get mipmapPrecisionBits() {
    return this.#view.getUint32(240, LE);
  }
  
  set mipmapPrecisionBits(value: number) {
    this.#view.setUint32(240, Number(value), LE);
  }
  
  get maxDrawIndexedIndexValue() {
    return this.#view.getUint32(244, LE);
  }
  
  set maxDrawIndexedIndexValue(value: number) {
    this.#view.setUint32(244, Number(value), LE);
  }
  
  get maxDrawIndirectCount() {
    return this.#view.getUint32(248, LE);
  }
  
  set maxDrawIndirectCount(value: number) {
    this.#view.setUint32(248, Number(value), LE);
  }
  
  get maxSamplerLodBias() {
    return this.#view.getFloat32(252, LE);
  }
  
  set maxSamplerLodBias(value: number) {
    this.#view.setFloat32(252, Number(value), LE);
  }
  
  get maxSamplerAnisotropy() {
    return this.#view.getFloat32(256, LE);
  }
  
  set maxSamplerAnisotropy(value: number) {
    this.#view.setFloat32(256, Number(value), LE);
  }
  
  get maxViewports() {
    return this.#view.getUint32(260, LE);
  }
  
  set maxViewports(value: number) {
    this.#view.setUint32(260, Number(value), LE);
  }
  
  get maxViewportDimensions() {
    return this.#view.getUint32(264, LE);
  }
  
  set maxViewportDimensions(value: number) {
    this.#view.setUint32(264, Number(value), LE);
  }
  
  get viewportBoundsRange() {
    return this.#view.getFloat32(268, LE);
  }
  
  set viewportBoundsRange(value: number) {
    this.#view.setFloat32(268, Number(value), LE);
  }
  
  get viewportSubPixelBits() {
    return this.#view.getUint32(272, LE);
  }
  
  set viewportSubPixelBits(value: number) {
    this.#view.setUint32(272, Number(value), LE);
  }
  
  get minMemoryMapAlignment() {
    return this.#view.getBigUint64(280, LE);
  }
  
  set minMemoryMapAlignment(value: Deno.PointerValue) {
    this.#view.setBigUint64(280, BigInt(value), LE);
  }
  
  get minTexelBufferOffsetAlignment() {
    return this.#view.getBigUint64(288, LE);
  }
  
  set minTexelBufferOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(288, BigInt(value), LE);
  }
  
  get minUniformBufferOffsetAlignment() {
    return this.#view.getBigUint64(296, LE);
  }
  
  set minUniformBufferOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(296, BigInt(value), LE);
  }
  
  get minStorageBufferOffsetAlignment() {
    return this.#view.getBigUint64(304, LE);
  }
  
  set minStorageBufferOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(304, BigInt(value), LE);
  }
  
  get minTexelOffset() {
    return this.#view.getInt32(312, LE);
  }
  
  set minTexelOffset(value: number) {
    this.#view.setInt32(312, Number(value), LE);
  }
  
  get maxTexelOffset() {
    return this.#view.getUint32(316, LE);
  }
  
  set maxTexelOffset(value: number) {
    this.#view.setUint32(316, Number(value), LE);
  }
  
  get minTexelGatherOffset() {
    return this.#view.getInt32(320, LE);
  }
  
  set minTexelGatherOffset(value: number) {
    this.#view.setInt32(320, Number(value), LE);
  }
  
  get maxTexelGatherOffset() {
    return this.#view.getUint32(324, LE);
  }
  
  set maxTexelGatherOffset(value: number) {
    this.#view.setUint32(324, Number(value), LE);
  }
  
  get minInterpolationOffset() {
    return this.#view.getFloat32(328, LE);
  }
  
  set minInterpolationOffset(value: number) {
    this.#view.setFloat32(328, Number(value), LE);
  }
  
  get maxInterpolationOffset() {
    return this.#view.getFloat32(332, LE);
  }
  
  set maxInterpolationOffset(value: number) {
    this.#view.setFloat32(332, Number(value), LE);
  }
  
  get subPixelInterpolationOffsetBits() {
    return this.#view.getUint32(336, LE);
  }
  
  set subPixelInterpolationOffsetBits(value: number) {
    this.#view.setUint32(336, Number(value), LE);
  }
  
  get maxFramebufferWidth() {
    return this.#view.getUint32(340, LE);
  }
  
  set maxFramebufferWidth(value: number) {
    this.#view.setUint32(340, Number(value), LE);
  }
  
  get maxFramebufferHeight() {
    return this.#view.getUint32(344, LE);
  }
  
  set maxFramebufferHeight(value: number) {
    this.#view.setUint32(344, Number(value), LE);
  }
  
  get maxFramebufferLayers() {
    return this.#view.getUint32(348, LE);
  }
  
  set maxFramebufferLayers(value: number) {
    this.#view.setUint32(348, Number(value), LE);
  }
  
  get framebufferColorSampleCounts() {
    return this.#view.getUint32(352, LE);
  }
  
  set framebufferColorSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(352, Number(value), LE);
  }
  
  get framebufferDepthSampleCounts() {
    return this.#view.getUint32(356, LE);
  }
  
  set framebufferDepthSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(356, Number(value), LE);
  }
  
  get framebufferStencilSampleCounts() {
    return this.#view.getUint32(360, LE);
  }
  
  set framebufferStencilSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(360, Number(value), LE);
  }
  
  get framebufferNoAttachmentsSampleCounts() {
    return this.#view.getUint32(364, LE);
  }
  
  set framebufferNoAttachmentsSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(364, Number(value), LE);
  }
  
  get maxColorAttachments() {
    return this.#view.getUint32(368, LE);
  }
  
  set maxColorAttachments(value: number) {
    this.#view.setUint32(368, Number(value), LE);
  }
  
  get sampledImageColorSampleCounts() {
    return this.#view.getUint32(372, LE);
  }
  
  set sampledImageColorSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(372, Number(value), LE);
  }
  
  get sampledImageIntegerSampleCounts() {
    return this.#view.getUint32(376, LE);
  }
  
  set sampledImageIntegerSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(376, Number(value), LE);
  }
  
  get sampledImageDepthSampleCounts() {
    return this.#view.getUint32(380, LE);
  }
  
  set sampledImageDepthSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(380, Number(value), LE);
  }
  
  get sampledImageStencilSampleCounts() {
    return this.#view.getUint32(384, LE);
  }
  
  set sampledImageStencilSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(384, Number(value), LE);
  }
  
  get storageImageSampleCounts() {
    return this.#view.getUint32(388, LE);
  }
  
  set storageImageSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(388, Number(value), LE);
  }
  
  get maxSampleMaskWords() {
    return this.#view.getUint32(392, LE);
  }
  
  set maxSampleMaskWords(value: number) {
    this.#view.setUint32(392, Number(value), LE);
  }
  
  get timestampComputeAndGraphics() {
    return this.#view.getUint32(396, LE);
  }
  
  set timestampComputeAndGraphics(value: VkBool32) {
    this.#view.setUint32(396, Number(value), LE);
  }
  
  get timestampPeriod() {
    return this.#view.getFloat32(400, LE);
  }
  
  set timestampPeriod(value: number) {
    this.#view.setFloat32(400, Number(value), LE);
  }
  
  get maxClipDistances() {
    return this.#view.getUint32(404, LE);
  }
  
  set maxClipDistances(value: number) {
    this.#view.setUint32(404, Number(value), LE);
  }
  
  get maxCullDistances() {
    return this.#view.getUint32(408, LE);
  }
  
  set maxCullDistances(value: number) {
    this.#view.setUint32(408, Number(value), LE);
  }
  
  get maxCombinedClipAndCullDistances() {
    return this.#view.getUint32(412, LE);
  }
  
  set maxCombinedClipAndCullDistances(value: number) {
    this.#view.setUint32(412, Number(value), LE);
  }
  
  get discreteQueuePriorities() {
    return this.#view.getUint32(416, LE);
  }
  
  set discreteQueuePriorities(value: number) {
    this.#view.setUint32(416, Number(value), LE);
  }
  
  get pointSizeRange() {
    return this.#view.getFloat32(420, LE);
  }
  
  set pointSizeRange(value: number) {
    this.#view.setFloat32(420, Number(value), LE);
  }
  
  get lineWidthRange() {
    return this.#view.getFloat32(424, LE);
  }
  
  set lineWidthRange(value: number) {
    this.#view.setFloat32(424, Number(value), LE);
  }
  
  get pointSizeGranularity() {
    return this.#view.getFloat32(428, LE);
  }
  
  set pointSizeGranularity(value: number) {
    this.#view.setFloat32(428, Number(value), LE);
  }
  
  get lineWidthGranularity() {
    return this.#view.getFloat32(432, LE);
  }
  
  set lineWidthGranularity(value: number) {
    this.#view.setFloat32(432, Number(value), LE);
  }
  
  get strictLines() {
    return this.#view.getUint32(436, LE);
  }
  
  set strictLines(value: VkBool32) {
    this.#view.setUint32(436, Number(value), LE);
  }
  
  get standardSampleLocations() {
    return this.#view.getUint32(440, LE);
  }
  
  set standardSampleLocations(value: VkBool32) {
    this.#view.setUint32(440, Number(value), LE);
  }
  
  get optimalBufferCopyOffsetAlignment() {
    return this.#view.getBigUint64(448, LE);
  }
  
  set optimalBufferCopyOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(448, BigInt(value), LE);
  }
  
  get optimalBufferCopyRowPitchAlignment() {
    return this.#view.getBigUint64(456, LE);
  }
  
  set optimalBufferCopyRowPitchAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(456, BigInt(value), LE);
  }
  
  get nonCoherentAtomSize() {
    return this.#view.getBigUint64(464, LE);
  }
  
  set nonCoherentAtomSize(value: VkDeviceSize) {
    this.#view.setBigUint64(464, BigInt(value), LE);
  }
}

export class VkSemaphoreCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreCreateInfo(new Uint8Array(VkSemaphoreCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSemaphoreCreateFlags;
  }) {
    const s = VkSemaphoreCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSemaphoreCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkQueryPoolCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueryPoolCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueryPoolCreateInfo(new Uint8Array(VkQueryPoolCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkQueryPoolCreateFlags;
    queryType: VkQueryType;
    queryCount: number;
    pipelineStatistics?: VkQueryPipelineStatisticFlags;
  }) {
    const s = VkQueryPoolCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.queryType !== undefined) s.queryType = data.queryType;
    if (data.queryCount !== undefined) s.queryCount = data.queryCount;
    if (data.pipelineStatistics !== undefined) s.pipelineStatistics = data.pipelineStatistics;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkQueryPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queryType() {
    return this.#view.getUint32(20, LE);
  }
  
  set queryType(value: VkQueryType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set queryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pipelineStatistics() {
    return this.#view.getUint32(28, LE);
  }
  
  set pipelineStatistics(value: VkQueryPipelineStatisticFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkFramebufferCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFramebufferCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFramebufferCreateInfo(new Uint8Array(VkFramebufferCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkFramebufferCreateFlags;
    renderPass: VkRenderPass;
    attachmentCount?: number;
    pAttachments: Deno.PointerValue;
    width: number;
    height: number;
    layers: number;
  }) {
    const s = VkFramebufferCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.renderPass !== undefined) s.renderPass = data.renderPass;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pAttachments !== undefined) s.pAttachments = data.pAttachments;
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.layers !== undefined) s.layers = data.layers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkFramebufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set renderPass(value: VkRenderPass) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(48, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(52, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get layers() {
    return this.#view.getUint32(56, LE);
  }
  
  set layers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkDrawIndirectCommand implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrawIndirectCommand.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrawIndirectCommand(new Uint8Array(VkDrawIndirectCommand.size));
  }
  
  static create(data: {
    vertexCount: number;
    instanceCount: number;
    firstVertex: number;
    firstInstance: number;
  }) {
    const s = VkDrawIndirectCommand.alloc();
    if (data.vertexCount !== undefined) s.vertexCount = data.vertexCount;
    if (data.instanceCount !== undefined) s.instanceCount = data.instanceCount;
    if (data.firstVertex !== undefined) s.firstVertex = data.firstVertex;
    if (data.firstInstance !== undefined) s.firstInstance = data.firstInstance;
    return s;
  }
  
  get vertexCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstVertex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get firstInstance() {
    return this.#view.getUint32(12, LE);
  }
  
  set firstInstance(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkDrawIndexedIndirectCommand implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrawIndexedIndirectCommand.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrawIndexedIndirectCommand(new Uint8Array(VkDrawIndexedIndirectCommand.size));
  }
  
  static create(data: {
    indexCount: number;
    instanceCount: number;
    firstIndex: number;
    vertexOffset: number;
    firstInstance: number;
  }) {
    const s = VkDrawIndexedIndirectCommand.alloc();
    if (data.indexCount !== undefined) s.indexCount = data.indexCount;
    if (data.instanceCount !== undefined) s.instanceCount = data.instanceCount;
    if (data.firstIndex !== undefined) s.firstIndex = data.firstIndex;
    if (data.vertexOffset !== undefined) s.vertexOffset = data.vertexOffset;
    if (data.firstInstance !== undefined) s.firstInstance = data.firstInstance;
    return s;
  }
  
  get indexCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get vertexOffset() {
    return this.#view.getInt32(12, LE);
  }
  
  set vertexOffset(value: number) {
    this.#view.setInt32(12, Number(value), LE);
  }
  
  get firstInstance() {
    return this.#view.getUint32(16, LE);
  }
  
  set firstInstance(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDispatchIndirectCommand implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDispatchIndirectCommand.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDispatchIndirectCommand(new Uint8Array(VkDispatchIndirectCommand.size));
  }
  
  static create(data: {
    x: number;
    y: number;
    z: number;
  }) {
    const s = VkDispatchIndirectCommand.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    if (data.z !== undefined) s.z = data.z;
    return s;
  }
  
  get x() {
    return this.#view.getUint32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getUint32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getUint32(8, LE);
  }
  
  set z(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkMultiDrawInfoEXT implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMultiDrawInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMultiDrawInfoEXT(new Uint8Array(VkMultiDrawInfoEXT.size));
  }
  
  static create(data: {
    firstVertex: number;
    vertexCount: number;
  }) {
    const s = VkMultiDrawInfoEXT.alloc();
    if (data.firstVertex !== undefined) s.firstVertex = data.firstVertex;
    if (data.vertexCount !== undefined) s.vertexCount = data.vertexCount;
    return s;
  }
  
  get firstVertex() {
    return this.#view.getUint32(0, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vertexCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkMultiDrawIndexedInfoEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMultiDrawIndexedInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMultiDrawIndexedInfoEXT(new Uint8Array(VkMultiDrawIndexedInfoEXT.size));
  }
  
  static create(data: {
    firstIndex: number;
    indexCount: number;
    vertexOffset: number;
  }) {
    const s = VkMultiDrawIndexedInfoEXT.alloc();
    if (data.firstIndex !== undefined) s.firstIndex = data.firstIndex;
    if (data.indexCount !== undefined) s.indexCount = data.indexCount;
    if (data.vertexOffset !== undefined) s.vertexOffset = data.vertexOffset;
    return s;
  }
  
  get firstIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set firstIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get indexCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vertexOffset() {
    return this.#view.getInt32(8, LE);
  }
  
  set vertexOffset(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export class VkSubmitInfo implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubmitInfo(new Uint8Array(VkSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreCount?: number;
    pWaitSemaphores: Deno.PointerValue;
    pWaitDstStageMask?: Deno.PointerValue;
    commandBufferCount?: number;
    pCommandBuffers: Deno.PointerValue;
    signalSemaphoreCount?: number;
    pSignalSemaphores: Deno.PointerValue;
  }) {
    const s = VkSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreCount !== undefined) s.waitSemaphoreCount = data.waitSemaphoreCount;
    if (data.pWaitSemaphores !== undefined) s.pWaitSemaphores = data.pWaitSemaphores;
    if (data.pWaitDstStageMask !== undefined) s.pWaitDstStageMask = data.pWaitDstStageMask;
    if (data.commandBufferCount !== undefined) s.commandBufferCount = data.commandBufferCount;
    if (data.pCommandBuffers !== undefined) s.pCommandBuffers = data.pCommandBuffers;
    if (data.signalSemaphoreCount !== undefined) s.signalSemaphoreCount = data.signalSemaphoreCount;
    if (data.pSignalSemaphores !== undefined) s.pSignalSemaphores = data.pSignalSemaphores;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pWaitDstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pWaitDstStageMask(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pCommandBuffers() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pCommandBuffers(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pSignalSemaphores() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pSignalSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkDisplayPropertiesKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPropertiesKHR(new Uint8Array(VkDisplayPropertiesKHR.size));
  }
  
  static create(data: {
    display: VkDisplayKHR;
    displayName: Deno.PointerValue;
    physicalDimensions: VkExtent2D;
    physicalResolution: VkExtent2D;
    supportedTransforms?: VkSurfaceTransformFlagsKHR;
    planeReorderPossible: VkBool32;
    persistentContent: VkBool32;
  }) {
    const s = VkDisplayPropertiesKHR.alloc();
    if (data.display !== undefined) s.display = data.display;
    if (data.displayName !== undefined) s.displayName = data.displayName;
    if (data.physicalDimensions !== undefined) s.physicalDimensions = data.physicalDimensions;
    if (data.physicalResolution !== undefined) s.physicalResolution = data.physicalResolution;
    if (data.supportedTransforms !== undefined) s.supportedTransforms = data.supportedTransforms;
    if (data.planeReorderPossible !== undefined) s.planeReorderPossible = data.planeReorderPossible;
    if (data.persistentContent !== undefined) s.persistentContent = data.persistentContent;
    return s;
  }
  
  get display() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set display(value: VkDisplayKHR) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get displayName() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set displayName(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get physicalDimensions() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set physicalDimensions(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get physicalResolution() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set physicalResolution(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(32, LE);
  }
  
  set supportedTransforms(value: VkSurfaceTransformFlagsKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get planeReorderPossible() {
    return this.#view.getUint32(36, LE);
  }
  
  set planeReorderPossible(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get persistentContent() {
    return this.#view.getUint32(40, LE);
  }
  
  set persistentContent(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkDisplayPlanePropertiesKHR implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPlanePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPlanePropertiesKHR(new Uint8Array(VkDisplayPlanePropertiesKHR.size));
  }
  
  static create(data: {
    currentDisplay: VkDisplayKHR;
    currentStackIndex: number;
  }) {
    const s = VkDisplayPlanePropertiesKHR.alloc();
    if (data.currentDisplay !== undefined) s.currentDisplay = data.currentDisplay;
    if (data.currentStackIndex !== undefined) s.currentStackIndex = data.currentStackIndex;
    return s;
  }
  
  get currentDisplay() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set currentDisplay(value: VkDisplayKHR) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get currentStackIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set currentStackIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkDisplayModeParametersKHR implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayModeParametersKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayModeParametersKHR(new Uint8Array(VkDisplayModeParametersKHR.size));
  }
  
  static create(data: {
    visibleRegion: VkExtent2D;
    refreshRate: number;
  }) {
    const s = VkDisplayModeParametersKHR.alloc();
    if (data.visibleRegion !== undefined) s.visibleRegion = data.visibleRegion;
    if (data.refreshRate !== undefined) s.refreshRate = data.refreshRate;
    return s;
  }
  
  get visibleRegion() {
    return new VkExtent2D(this.#data.subarray(0, 0 + VkExtent2D.size));
  }
  
  set visibleRegion(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get refreshRate() {
    return this.#view.getUint32(8, LE);
  }
  
  set refreshRate(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkDisplayModePropertiesKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayModePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayModePropertiesKHR(new Uint8Array(VkDisplayModePropertiesKHR.size));
  }
  
  static create(data: {
    displayMode: VkDisplayModeKHR;
    parameters: VkDisplayModeParametersKHR;
  }) {
    const s = VkDisplayModePropertiesKHR.alloc();
    if (data.displayMode !== undefined) s.displayMode = data.displayMode;
    if (data.parameters !== undefined) s.parameters = data.parameters;
    return s;
  }
  
  get displayMode() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set displayMode(value: VkDisplayModeKHR) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get parameters() {
    return new VkDisplayModeParametersKHR(this.#data.subarray(16, 16 + VkDisplayModeParametersKHR.size));
  }
  
  set parameters(value: VkDisplayModeParametersKHR) {
    if (value[BUFFER].byteLength < VkDisplayModeParametersKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkDisplayModeCreateInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayModeCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayModeCreateInfoKHR(new Uint8Array(VkDisplayModeCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDisplayModeCreateFlagsKHR;
    parameters: VkDisplayModeParametersKHR;
  }) {
    const s = VkDisplayModeCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.parameters !== undefined) s.parameters = data.parameters;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDisplayModeCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get parameters() {
    return new VkDisplayModeParametersKHR(this.#data.subarray(32, 32 + VkDisplayModeParametersKHR.size));
  }
  
  set parameters(value: VkDisplayModeParametersKHR) {
    if (value[BUFFER].byteLength < VkDisplayModeParametersKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkDisplayPlaneCapabilitiesKHR implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPlaneCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPlaneCapabilitiesKHR(new Uint8Array(VkDisplayPlaneCapabilitiesKHR.size));
  }
  
  static create(data: {
    supportedAlpha?: VkDisplayPlaneAlphaFlagsKHR;
    minSrcPosition: VkOffset2D;
    maxSrcPosition: VkOffset2D;
    minSrcExtent: VkExtent2D;
    maxSrcExtent: VkExtent2D;
    minDstPosition: VkOffset2D;
    maxDstPosition: VkOffset2D;
    minDstExtent: VkExtent2D;
    maxDstExtent: VkExtent2D;
  }) {
    const s = VkDisplayPlaneCapabilitiesKHR.alloc();
    if (data.supportedAlpha !== undefined) s.supportedAlpha = data.supportedAlpha;
    if (data.minSrcPosition !== undefined) s.minSrcPosition = data.minSrcPosition;
    if (data.maxSrcPosition !== undefined) s.maxSrcPosition = data.maxSrcPosition;
    if (data.minSrcExtent !== undefined) s.minSrcExtent = data.minSrcExtent;
    if (data.maxSrcExtent !== undefined) s.maxSrcExtent = data.maxSrcExtent;
    if (data.minDstPosition !== undefined) s.minDstPosition = data.minDstPosition;
    if (data.maxDstPosition !== undefined) s.maxDstPosition = data.maxDstPosition;
    if (data.minDstExtent !== undefined) s.minDstExtent = data.minDstExtent;
    if (data.maxDstExtent !== undefined) s.maxDstExtent = data.maxDstExtent;
    return s;
  }
  
  get supportedAlpha() {
    return this.#view.getUint32(0, LE);
  }
  
  set supportedAlpha(value: VkDisplayPlaneAlphaFlagsKHR) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get minSrcPosition() {
    return new VkOffset2D(this.#data.subarray(8, 8 + VkOffset2D.size));
  }
  
  set minSrcPosition(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get maxSrcPosition() {
    return new VkOffset2D(this.#data.subarray(16, 16 + VkOffset2D.size));
  }
  
  set maxSrcPosition(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get minSrcExtent() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set minSrcExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxSrcExtent() {
    return new VkExtent2D(this.#data.subarray(32, 32 + VkExtent2D.size));
  }
  
  set maxSrcExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get minDstPosition() {
    return new VkOffset2D(this.#data.subarray(40, 40 + VkOffset2D.size));
  }
  
  set minDstPosition(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get maxDstPosition() {
    return new VkOffset2D(this.#data.subarray(48, 48 + VkOffset2D.size));
  }
  
  set maxDstPosition(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get minDstExtent() {
    return new VkExtent2D(this.#data.subarray(56, 56 + VkExtent2D.size));
  }
  
  set minDstExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get maxDstExtent() {
    return new VkExtent2D(this.#data.subarray(64, 64 + VkExtent2D.size));
  }
  
  set maxDstExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 64);
  }
}

export class VkDisplaySurfaceCreateInfoKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplaySurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplaySurfaceCreateInfoKHR(new Uint8Array(VkDisplaySurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDisplaySurfaceCreateFlagsKHR;
    displayMode: VkDisplayModeKHR;
    planeIndex: number;
    planeStackIndex: number;
    transform: VkSurfaceTransformFlagBitsKHR;
    globalAlpha: number;
    alphaMode: VkDisplayPlaneAlphaFlagBitsKHR;
    imageExtent: VkExtent2D;
  }) {
    const s = VkDisplaySurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.displayMode !== undefined) s.displayMode = data.displayMode;
    if (data.planeIndex !== undefined) s.planeIndex = data.planeIndex;
    if (data.planeStackIndex !== undefined) s.planeStackIndex = data.planeStackIndex;
    if (data.transform !== undefined) s.transform = data.transform;
    if (data.globalAlpha !== undefined) s.globalAlpha = data.globalAlpha;
    if (data.alphaMode !== undefined) s.alphaMode = data.alphaMode;
    if (data.imageExtent !== undefined) s.imageExtent = data.imageExtent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDisplaySurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get displayMode() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set displayMode(value: VkDisplayModeKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get planeIndex() {
    return this.#view.getUint32(32, LE);
  }
  
  set planeIndex(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get planeStackIndex() {
    return this.#view.getUint32(36, LE);
  }
  
  set planeStackIndex(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get transform() {
    return this.#view.getUint32(40, LE);
  }
  
  set transform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get globalAlpha() {
    return this.#view.getFloat32(44, LE);
  }
  
  set globalAlpha(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get alphaMode() {
    return this.#view.getUint32(48, LE);
  }
  
  set alphaMode(value: VkDisplayPlaneAlphaFlagBitsKHR) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get imageExtent() {
    return new VkExtent2D(this.#data.subarray(56, 56 + VkExtent2D.size));
  }
  
  set imageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
}

export class VkDisplayPresentInfoKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPresentInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPresentInfoKHR(new Uint8Array(VkDisplayPresentInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcRect: VkRect2D;
    dstRect: VkRect2D;
    persistent: VkBool32;
  }) {
    const s = VkDisplayPresentInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcRect !== undefined) s.srcRect = data.srcRect;
    if (data.dstRect !== undefined) s.dstRect = data.dstRect;
    if (data.persistent !== undefined) s.persistent = data.persistent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcRect() {
    return new VkRect2D(this.#data.subarray(16, 16 + VkRect2D.size));
  }
  
  set srcRect(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get dstRect() {
    return new VkRect2D(this.#data.subarray(32, 32 + VkRect2D.size));
  }
  
  set dstRect(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get persistent() {
    return this.#view.getUint32(48, LE);
  }
  
  set persistent(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkSurfaceCapabilitiesKHR implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceCapabilitiesKHR(new Uint8Array(VkSurfaceCapabilitiesKHR.size));
  }
  
  static create(data: {
    minImageCount: number;
    maxImageCount: number;
    currentExtent: VkExtent2D;
    minImageExtent: VkExtent2D;
    maxImageExtent: VkExtent2D;
    maxImageArrayLayers: number;
    supportedTransforms: VkSurfaceTransformFlagsKHR;
    currentTransform: VkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR;
    supportedUsageFlags: VkImageUsageFlags;
  }) {
    const s = VkSurfaceCapabilitiesKHR.alloc();
    if (data.minImageCount !== undefined) s.minImageCount = data.minImageCount;
    if (data.maxImageCount !== undefined) s.maxImageCount = data.maxImageCount;
    if (data.currentExtent !== undefined) s.currentExtent = data.currentExtent;
    if (data.minImageExtent !== undefined) s.minImageExtent = data.minImageExtent;
    if (data.maxImageExtent !== undefined) s.maxImageExtent = data.maxImageExtent;
    if (data.maxImageArrayLayers !== undefined) s.maxImageArrayLayers = data.maxImageArrayLayers;
    if (data.supportedTransforms !== undefined) s.supportedTransforms = data.supportedTransforms;
    if (data.currentTransform !== undefined) s.currentTransform = data.currentTransform;
    if (data.supportedCompositeAlpha !== undefined) s.supportedCompositeAlpha = data.supportedCompositeAlpha;
    if (data.supportedUsageFlags !== undefined) s.supportedUsageFlags = data.supportedUsageFlags;
    return s;
  }
  
  get minImageCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get maxImageCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set maxImageCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get currentExtent() {
    return new VkExtent2D(this.#data.subarray(8, 8 + VkExtent2D.size));
  }
  
  set currentExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get minImageExtent() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set minImageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxImageExtent() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set maxImageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(36, LE);
  }
  
  set supportedTransforms(value: VkSurfaceTransformFlagsKHR) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get currentTransform() {
    return this.#view.getUint32(40, LE);
  }
  
  set currentTransform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get supportedCompositeAlpha() {
    return this.#view.getUint32(44, LE);
  }
  
  set supportedCompositeAlpha(value: VkCompositeAlphaFlagsKHR) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get supportedUsageFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set supportedUsageFlags(value: VkImageUsageFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkAndroidSurfaceCreateInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAndroidSurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAndroidSurfaceCreateInfoKHR(new Uint8Array(VkAndroidSurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkAndroidSurfaceCreateFlagsKHR;
    window: Deno.PointerValue;
  }) {
    const s = VkAndroidSurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.window !== undefined) s.window = data.window;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkAndroidSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkViSurfaceCreateInfoNN implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkViSurfaceCreateInfoNN.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkViSurfaceCreateInfoNN(new Uint8Array(VkViSurfaceCreateInfoNN.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkViSurfaceCreateFlagsNN;
    window: Deno.PointerValue;
  }) {
    const s = VkViSurfaceCreateInfoNN.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.window !== undefined) s.window = data.window;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkViSurfaceCreateFlagsNN) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkWaylandSurfaceCreateInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWaylandSurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWaylandSurfaceCreateInfoKHR(new Uint8Array(VkWaylandSurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkWaylandSurfaceCreateFlagsKHR;
    display: Deno.PointerValue;
    surface: Deno.PointerValue;
  }) {
    const s = VkWaylandSurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.display !== undefined) s.display = data.display;
    if (data.surface !== undefined) s.surface = data.surface;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkWaylandSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get display() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set display(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set surface(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkWin32SurfaceCreateInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWin32SurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWin32SurfaceCreateInfoKHR(new Uint8Array(VkWin32SurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkWin32SurfaceCreateFlagsKHR;
    hinstance: Deno.PointerValue;
    hwnd: Deno.PointerValue;
  }) {
    const s = VkWin32SurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.hinstance !== undefined) s.hinstance = data.hinstance;
    if (data.hwnd !== undefined) s.hwnd = data.hwnd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkWin32SurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get hinstance() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set hinstance(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get hwnd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set hwnd(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkXlibSurfaceCreateInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkXlibSurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkXlibSurfaceCreateInfoKHR(new Uint8Array(VkXlibSurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkXlibSurfaceCreateFlagsKHR;
    dpy: Deno.PointerValue;
    window: Deno.PointerValue;
  }) {
    const s = VkXlibSurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.dpy !== undefined) s.dpy = data.dpy;
    if (data.window !== undefined) s.window = data.window;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkXlibSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dpy() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dpy(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkXcbSurfaceCreateInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkXcbSurfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkXcbSurfaceCreateInfoKHR(new Uint8Array(VkXcbSurfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkXcbSurfaceCreateFlagsKHR;
    connection: Deno.PointerValue;
    window: Deno.PointerValue;
  }) {
    const s = VkXcbSurfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.connection !== undefined) s.connection = data.connection;
    if (data.window !== undefined) s.window = data.window;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkXcbSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get connection() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set connection(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDirectFBSurfaceCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDirectFBSurfaceCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDirectFBSurfaceCreateInfoEXT(new Uint8Array(VkDirectFBSurfaceCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDirectFBSurfaceCreateFlagsEXT;
    dfb: Deno.PointerValue;
    surface: Deno.PointerValue;
  }) {
    const s = VkDirectFBSurfaceCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.dfb !== undefined) s.dfb = data.dfb;
    if (data.surface !== undefined) s.surface = data.surface;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDirectFBSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dfb() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dfb(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set surface(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImagePipeSurfaceCreateInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImagePipeSurfaceCreateInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImagePipeSurfaceCreateInfoFUCHSIA(new Uint8Array(VkImagePipeSurfaceCreateInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkImagePipeSurfaceCreateFlagsFUCHSIA;
    imagePipeHandle: Deno.PointerValue;
  }) {
    const s = VkImagePipeSurfaceCreateInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.imagePipeHandle !== undefined) s.imagePipeHandle = data.imagePipeHandle;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkImagePipeSurfaceCreateFlagsFUCHSIA) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imagePipeHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set imagePipeHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkStreamDescriptorSurfaceCreateInfoGGP implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkStreamDescriptorSurfaceCreateInfoGGP.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkStreamDescriptorSurfaceCreateInfoGGP(new Uint8Array(VkStreamDescriptorSurfaceCreateInfoGGP.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkStreamDescriptorSurfaceCreateFlagsGGP;
    streamDescriptor: Deno.PointerValue;
  }) {
    const s = VkStreamDescriptorSurfaceCreateInfoGGP.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.streamDescriptor !== undefined) s.streamDescriptor = data.streamDescriptor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkStreamDescriptorSurfaceCreateFlagsGGP) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get streamDescriptor() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set streamDescriptor(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkScreenSurfaceCreateInfoQNX implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkScreenSurfaceCreateInfoQNX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkScreenSurfaceCreateInfoQNX(new Uint8Array(VkScreenSurfaceCreateInfoQNX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkScreenSurfaceCreateFlagsQNX;
    context: Deno.PointerValue;
    window: Deno.PointerValue;
  }) {
    const s = VkScreenSurfaceCreateInfoQNX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.context !== undefined) s.context = data.context;
    if (data.window !== undefined) s.window = data.window;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkScreenSurfaceCreateFlagsQNX) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get context() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set context(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkSurfaceFormatKHR implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceFormatKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceFormatKHR(new Uint8Array(VkSurfaceFormatKHR.size));
  }
  
  static create(data: {
    format: VkFormat;
    colorSpace: VkColorSpaceKHR;
  }) {
    const s = VkSurfaceFormatKHR.alloc();
    if (data.format !== undefined) s.format = data.format;
    if (data.colorSpace !== undefined) s.colorSpace = data.colorSpace;
    return s;
  }
  
  get format() {
    return this.#view.getUint32(0, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get colorSpace() {
    return this.#view.getUint32(4, LE);
  }
  
  set colorSpace(value: VkColorSpaceKHR) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkSwapchainCreateInfoKHR implements IVkStructure {
  static size = 104;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSwapchainCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSwapchainCreateInfoKHR(new Uint8Array(VkSwapchainCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSwapchainCreateFlagsKHR;
    surface: VkSurfaceKHR;
    minImageCount: number;
    imageFormat: VkFormat;
    imageColorSpace: VkColorSpaceKHR;
    imageExtent: VkExtent2D;
    imageArrayLayers: number;
    imageUsage: VkImageUsageFlags;
    imageSharingMode: VkSharingMode;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: Deno.PointerValue;
    preTransform: VkSurfaceTransformFlagBitsKHR;
    compositeAlpha: VkCompositeAlphaFlagBitsKHR;
    presentMode: VkPresentModeKHR;
    clipped: VkBool32;
    oldSwapchain?: VkSwapchainKHR;
  }) {
    const s = VkSwapchainCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.surface !== undefined) s.surface = data.surface;
    if (data.minImageCount !== undefined) s.minImageCount = data.minImageCount;
    if (data.imageFormat !== undefined) s.imageFormat = data.imageFormat;
    if (data.imageColorSpace !== undefined) s.imageColorSpace = data.imageColorSpace;
    if (data.imageExtent !== undefined) s.imageExtent = data.imageExtent;
    if (data.imageArrayLayers !== undefined) s.imageArrayLayers = data.imageArrayLayers;
    if (data.imageUsage !== undefined) s.imageUsage = data.imageUsage;
    if (data.imageSharingMode !== undefined) s.imageSharingMode = data.imageSharingMode;
    if (data.queueFamilyIndexCount !== undefined) s.queueFamilyIndexCount = data.queueFamilyIndexCount;
    if (data.pQueueFamilyIndices !== undefined) s.pQueueFamilyIndices = data.pQueueFamilyIndices;
    if (data.preTransform !== undefined) s.preTransform = data.preTransform;
    if (data.compositeAlpha !== undefined) s.compositeAlpha = data.compositeAlpha;
    if (data.presentMode !== undefined) s.presentMode = data.presentMode;
    if (data.clipped !== undefined) s.clipped = data.clipped;
    if (data.oldSwapchain !== undefined) s.oldSwapchain = data.oldSwapchain;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSwapchainCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set surface(value: VkSurfaceKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get minImageCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get imageFormat() {
    return this.#view.getUint32(36, LE);
  }
  
  set imageFormat(value: VkFormat) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get imageColorSpace() {
    return this.#view.getUint32(40, LE);
  }
  
  set imageColorSpace(value: VkColorSpaceKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get imageExtent() {
    return new VkExtent2D(this.#data.subarray(48, 48 + VkExtent2D.size));
  }
  
  set imageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get imageArrayLayers() {
    return this.#view.getUint32(56, LE);
  }
  
  set imageArrayLayers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get imageUsage() {
    return this.#view.getUint32(60, LE);
  }
  
  set imageUsage(value: VkImageUsageFlags) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get imageSharingMode() {
    return this.#view.getUint32(64, LE);
  }
  
  set imageSharingMode(value: VkSharingMode) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(68, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pQueueFamilyIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get preTransform() {
    return this.#view.getUint32(80, LE);
  }
  
  set preTransform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get compositeAlpha() {
    return this.#view.getUint32(84, LE);
  }
  
  set compositeAlpha(value: VkCompositeAlphaFlagBitsKHR) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get presentMode() {
    return this.#view.getUint32(88, LE);
  }
  
  set presentMode(value: VkPresentModeKHR) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get clipped() {
    return this.#view.getUint32(92, LE);
  }
  
  set clipped(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get oldSwapchain() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set oldSwapchain(value: VkSwapchainKHR) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
}

export class VkPresentInfoKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentInfoKHR(new Uint8Array(VkPresentInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreCount?: number;
    pWaitSemaphores: Deno.PointerValue;
    swapchainCount: number;
    pSwapchains: Deno.PointerValue;
    pImageIndices: Deno.PointerValue;
    pResults?: Deno.PointerValue;
  }) {
    const s = VkPresentInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreCount !== undefined) s.waitSemaphoreCount = data.waitSemaphoreCount;
    if (data.pWaitSemaphores !== undefined) s.pWaitSemaphores = data.pWaitSemaphores;
    if (data.swapchainCount !== undefined) s.swapchainCount = data.swapchainCount;
    if (data.pSwapchains !== undefined) s.pSwapchains = data.pSwapchains;
    if (data.pImageIndices !== undefined) s.pImageIndices = data.pImageIndices;
    if (data.pResults !== undefined) s.pResults = data.pResults;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSwapchains() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSwapchains(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pImageIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pImageIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pResults() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pResults(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkDebugReportCallbackCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugReportCallbackCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugReportCallbackCreateInfoEXT(new Uint8Array(VkDebugReportCallbackCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDebugReportFlagsEXT;
    pfnCallback: Deno.PointerValue;
    pUserData?: Deno.PointerValue;
  }) {
    const s = VkDebugReportCallbackCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pfnCallback !== undefined) s.pfnCallback = data.pfnCallback;
    if (data.pUserData !== undefined) s.pUserData = data.pUserData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDebugReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pfnCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pUserData(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkValidationFlagsEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkValidationFlagsEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkValidationFlagsEXT(new Uint8Array(VkValidationFlagsEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    disabledValidationCheckCount: number;
    pDisabledValidationChecks: Deno.PointerValue;
  }) {
    const s = VkValidationFlagsEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.disabledValidationCheckCount !== undefined) s.disabledValidationCheckCount = data.disabledValidationCheckCount;
    if (data.pDisabledValidationChecks !== undefined) s.pDisabledValidationChecks = data.pDisabledValidationChecks;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get disabledValidationCheckCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set disabledValidationCheckCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDisabledValidationChecks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDisabledValidationChecks(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkValidationFeaturesEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkValidationFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkValidationFeaturesEXT(new Uint8Array(VkValidationFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    enabledValidationFeatureCount?: number;
    pEnabledValidationFeatures: Deno.PointerValue;
    disabledValidationFeatureCount?: number;
    pDisabledValidationFeatures: Deno.PointerValue;
  }) {
    const s = VkValidationFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.enabledValidationFeatureCount !== undefined) s.enabledValidationFeatureCount = data.enabledValidationFeatureCount;
    if (data.pEnabledValidationFeatures !== undefined) s.pEnabledValidationFeatures = data.pEnabledValidationFeatures;
    if (data.disabledValidationFeatureCount !== undefined) s.disabledValidationFeatureCount = data.disabledValidationFeatureCount;
    if (data.pDisabledValidationFeatures !== undefined) s.pDisabledValidationFeatures = data.pDisabledValidationFeatures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get enabledValidationFeatureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set enabledValidationFeatureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pEnabledValidationFeatures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pEnabledValidationFeatures(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get disabledValidationFeatureCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set disabledValidationFeatureCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pDisabledValidationFeatures() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pDisabledValidationFeatures(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkPipelineRasterizationStateRasterizationOrderAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationStateRasterizationOrderAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationStateRasterizationOrderAMD(new Uint8Array(VkPipelineRasterizationStateRasterizationOrderAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rasterizationOrder: VkRasterizationOrderAMD;
  }) {
    const s = VkPipelineRasterizationStateRasterizationOrderAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rasterizationOrder !== undefined) s.rasterizationOrder = data.rasterizationOrder;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rasterizationOrder() {
    return this.#view.getUint32(16, LE);
  }
  
  set rasterizationOrder(value: VkRasterizationOrderAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDebugMarkerObjectNameInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugMarkerObjectNameInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugMarkerObjectNameInfoEXT(new Uint8Array(VkDebugMarkerObjectNameInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    objectType: VkDebugReportObjectTypeEXT;
    object: Deno.PointerValue;
    pObjectName: Deno.PointerValue;
  }) {
    const s = VkDebugMarkerObjectNameInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.objectType !== undefined) s.objectType = data.objectType;
    if (data.object !== undefined) s.object = data.object;
    if (data.pObjectName !== undefined) s.pObjectName = data.pObjectName;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: VkDebugReportObjectTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get object() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set object(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pObjectName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pObjectName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDebugMarkerObjectTagInfoEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugMarkerObjectTagInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugMarkerObjectTagInfoEXT(new Uint8Array(VkDebugMarkerObjectTagInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    objectType: VkDebugReportObjectTypeEXT;
    object: Deno.PointerValue;
    tagName: Deno.PointerValue;
    tagSize: Deno.PointerValue;
    pTag: Deno.PointerValue;
  }) {
    const s = VkDebugMarkerObjectTagInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.objectType !== undefined) s.objectType = data.objectType;
    if (data.object !== undefined) s.object = data.object;
    if (data.tagName !== undefined) s.tagName = data.tagName;
    if (data.tagSize !== undefined) s.tagSize = data.tagSize;
    if (data.pTag !== undefined) s.pTag = data.pTag;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: VkDebugReportObjectTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get object() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set object(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get tagName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set tagName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get tagSize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set tagSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pTag() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTag(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkDebugMarkerMarkerInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugMarkerMarkerInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugMarkerMarkerInfoEXT(new Uint8Array(VkDebugMarkerMarkerInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pMarkerName: Deno.PointerValue;
    color: number;
  }) {
    const s = VkDebugMarkerMarkerInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pMarkerName !== undefined) s.pMarkerName = data.pMarkerName;
    if (data.color !== undefined) s.color = data.color;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pMarkerName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pMarkerName(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get color() {
    return this.#view.getFloat32(24, LE);
  }
  
  set color(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
}

export class VkDedicatedAllocationImageCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDedicatedAllocationImageCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDedicatedAllocationImageCreateInfoNV(new Uint8Array(VkDedicatedAllocationImageCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dedicatedAllocation: VkBool32;
  }) {
    const s = VkDedicatedAllocationImageCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dedicatedAllocation !== undefined) s.dedicatedAllocation = data.dedicatedAllocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocation(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDedicatedAllocationBufferCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDedicatedAllocationBufferCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDedicatedAllocationBufferCreateInfoNV(new Uint8Array(VkDedicatedAllocationBufferCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dedicatedAllocation: VkBool32;
  }) {
    const s = VkDedicatedAllocationBufferCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dedicatedAllocation !== undefined) s.dedicatedAllocation = data.dedicatedAllocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocation(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDedicatedAllocationMemoryAllocateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDedicatedAllocationMemoryAllocateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDedicatedAllocationMemoryAllocateInfoNV(new Uint8Array(VkDedicatedAllocationMemoryAllocateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image?: VkImage;
    buffer?: VkBuffer;
  }) {
    const s = VkDedicatedAllocationMemoryAllocateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkExternalImageFormatPropertiesNV implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalImageFormatPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalImageFormatPropertiesNV(new Uint8Array(VkExternalImageFormatPropertiesNV.size));
  }
  
  static create(data: {
    imageFormatProperties: VkImageFormatProperties;
    externalMemoryFeatures?: VkExternalMemoryFeatureFlagsNV;
    exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagsNV;
    compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagsNV;
  }) {
    const s = VkExternalImageFormatPropertiesNV.alloc();
    if (data.imageFormatProperties !== undefined) s.imageFormatProperties = data.imageFormatProperties;
    if (data.externalMemoryFeatures !== undefined) s.externalMemoryFeatures = data.externalMemoryFeatures;
    if (data.exportFromImportedHandleTypes !== undefined) s.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
    if (data.compatibleHandleTypes !== undefined) s.compatibleHandleTypes = data.compatibleHandleTypes;
    return s;
  }
  
  get imageFormatProperties() {
    return new VkImageFormatProperties(this.#data.subarray(0, 0 + VkImageFormatProperties.size));
  }
  
  set imageFormatProperties(value: VkImageFormatProperties) {
    if (value[BUFFER].byteLength < VkImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get externalMemoryFeatures() {
    return this.#view.getUint32(36, LE);
  }
  
  set externalMemoryFeatures(value: VkExternalMemoryFeatureFlagsNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(40, LE);
  }
  
  set exportFromImportedHandleTypes(value: VkExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(44, LE);
  }
  
  set compatibleHandleTypes(value: VkExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export class VkExternalMemoryImageCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalMemoryImageCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalMemoryImageCreateInfoNV(new Uint8Array(VkExternalMemoryImageCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalMemoryHandleTypeFlagsNV;
  }) {
    const s = VkExternalMemoryImageCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExportMemoryAllocateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMemoryAllocateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMemoryAllocateInfoNV(new Uint8Array(VkExportMemoryAllocateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalMemoryHandleTypeFlagsNV;
  }) {
    const s = VkExportMemoryAllocateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImportMemoryWin32HandleInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryWin32HandleInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryWin32HandleInfoNV(new Uint8Array(VkImportMemoryWin32HandleInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType?: VkExternalMemoryHandleTypeFlagsNV;
    handle?: Deno.PointerValue;
  }) {
    const s = VkImportMemoryWin32HandleInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.handle !== undefined) s.handle = data.handle;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkExportMemoryWin32HandleInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMemoryWin32HandleInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMemoryWin32HandleInfoNV(new Uint8Array(VkExportMemoryWin32HandleInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pAttributes?: Deno.PointerValue;
    dwAccess?: number;
  }) {
    const s = VkExportMemoryWin32HandleInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pAttributes !== undefined) s.pAttributes = data.pAttributes;
    if (data.dwAccess !== undefined) s.dwAccess = data.dwAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkWin32KeyedMutexAcquireReleaseInfoNV implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWin32KeyedMutexAcquireReleaseInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWin32KeyedMutexAcquireReleaseInfoNV(new Uint8Array(VkWin32KeyedMutexAcquireReleaseInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    acquireCount?: number;
    pAcquireSyncs: Deno.PointerValue;
    pAcquireKeys: Deno.PointerValue;
    pAcquireTimeoutMilliseconds: Deno.PointerValue;
    releaseCount?: number;
    pReleaseSyncs: Deno.PointerValue;
    pReleaseKeys: Deno.PointerValue;
  }) {
    const s = VkWin32KeyedMutexAcquireReleaseInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.acquireCount !== undefined) s.acquireCount = data.acquireCount;
    if (data.pAcquireSyncs !== undefined) s.pAcquireSyncs = data.pAcquireSyncs;
    if (data.pAcquireKeys !== undefined) s.pAcquireKeys = data.pAcquireKeys;
    if (data.pAcquireTimeoutMilliseconds !== undefined) s.pAcquireTimeoutMilliseconds = data.pAcquireTimeoutMilliseconds;
    if (data.releaseCount !== undefined) s.releaseCount = data.releaseCount;
    if (data.pReleaseSyncs !== undefined) s.pReleaseSyncs = data.pReleaseSyncs;
    if (data.pReleaseKeys !== undefined) s.pReleaseKeys = data.pReleaseKeys;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get acquireCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set acquireCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAcquireSyncs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAcquireSyncs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pAcquireKeys() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAcquireKeys(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pAcquireTimeoutMilliseconds() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAcquireTimeoutMilliseconds(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get releaseCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set releaseCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pReleaseSyncs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pReleaseSyncs(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pReleaseKeys() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pReleaseKeys(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(new Uint8Array(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceGeneratedCommands: VkBool32;
  }) {
    const s = VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceGeneratedCommands !== undefined) s.deviceGeneratedCommands = data.deviceGeneratedCommands;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceGeneratedCommands() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceGeneratedCommands(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDevicePrivateDataCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDevicePrivateDataCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDevicePrivateDataCreateInfo(new Uint8Array(VkDevicePrivateDataCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    privateDataSlotRequestCount: number;
  }) {
    const s = VkDevicePrivateDataCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.privateDataSlotRequestCount !== undefined) s.privateDataSlotRequestCount = data.privateDataSlotRequestCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get privateDataSlotRequestCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set privateDataSlotRequestCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPrivateDataSlotCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPrivateDataSlotCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPrivateDataSlotCreateInfo(new Uint8Array(VkPrivateDataSlotCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkPrivateDataSlotCreateFlags;
  }) {
    const s = VkPrivateDataSlotCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPrivateDataSlotCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePrivateDataFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePrivateDataFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePrivateDataFeatures(new Uint8Array(VkPhysicalDevicePrivateDataFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    privateData: VkBool32;
  }) {
    const s = VkPhysicalDevicePrivateDataFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.privateData !== undefined) s.privateData = data.privateData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get privateData() {
    return this.#view.getUint32(16, LE);
  }
  
  set privateData(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(new Uint8Array(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxGraphicsShaderGroupCount: number;
    maxIndirectSequenceCount: number;
    maxIndirectCommandsTokenCount: number;
    maxIndirectCommandsStreamCount: number;
    maxIndirectCommandsTokenOffset: number;
    maxIndirectCommandsStreamStride: number;
    minSequencesCountBufferOffsetAlignment: number;
    minSequencesIndexBufferOffsetAlignment: number;
    minIndirectCommandsBufferOffsetAlignment: number;
  }) {
    const s = VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxGraphicsShaderGroupCount !== undefined) s.maxGraphicsShaderGroupCount = data.maxGraphicsShaderGroupCount;
    if (data.maxIndirectSequenceCount !== undefined) s.maxIndirectSequenceCount = data.maxIndirectSequenceCount;
    if (data.maxIndirectCommandsTokenCount !== undefined) s.maxIndirectCommandsTokenCount = data.maxIndirectCommandsTokenCount;
    if (data.maxIndirectCommandsStreamCount !== undefined) s.maxIndirectCommandsStreamCount = data.maxIndirectCommandsStreamCount;
    if (data.maxIndirectCommandsTokenOffset !== undefined) s.maxIndirectCommandsTokenOffset = data.maxIndirectCommandsTokenOffset;
    if (data.maxIndirectCommandsStreamStride !== undefined) s.maxIndirectCommandsStreamStride = data.maxIndirectCommandsStreamStride;
    if (data.minSequencesCountBufferOffsetAlignment !== undefined) s.minSequencesCountBufferOffsetAlignment = data.minSequencesCountBufferOffsetAlignment;
    if (data.minSequencesIndexBufferOffsetAlignment !== undefined) s.minSequencesIndexBufferOffsetAlignment = data.minSequencesIndexBufferOffsetAlignment;
    if (data.minIndirectCommandsBufferOffsetAlignment !== undefined) s.minIndirectCommandsBufferOffsetAlignment = data.minIndirectCommandsBufferOffsetAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxGraphicsShaderGroupCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxGraphicsShaderGroupCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxIndirectSequenceCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxIndirectSequenceCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxIndirectCommandsTokenCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxIndirectCommandsTokenCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxIndirectCommandsStreamCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxIndirectCommandsStreamCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxIndirectCommandsTokenOffset() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxIndirectCommandsTokenOffset(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxIndirectCommandsStreamStride() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxIndirectCommandsStreamStride(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minSequencesCountBufferOffsetAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set minSequencesCountBufferOffsetAlignment(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minSequencesIndexBufferOffsetAlignment() {
    return this.#view.getUint32(44, LE);
  }
  
  set minSequencesIndexBufferOffsetAlignment(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get minIndirectCommandsBufferOffsetAlignment() {
    return this.#view.getUint32(48, LE);
  }
  
  set minIndirectCommandsBufferOffsetAlignment(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkPhysicalDeviceMultiDrawPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultiDrawPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultiDrawPropertiesEXT(new Uint8Array(VkPhysicalDeviceMultiDrawPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxMultiDrawCount: number;
  }) {
    const s = VkPhysicalDeviceMultiDrawPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxMultiDrawCount !== undefined) s.maxMultiDrawCount = data.maxMultiDrawCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxMultiDrawCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxMultiDrawCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkGraphicsShaderGroupCreateInfoNV implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGraphicsShaderGroupCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGraphicsShaderGroupCreateInfoNV(new Uint8Array(VkGraphicsShaderGroupCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stageCount: number;
    pStages: Deno.PointerValue;
    pVertexInputState?: Deno.PointerValue;
    pTessellationState?: Deno.PointerValue;
  }) {
    const s = VkGraphicsShaderGroupCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stageCount !== undefined) s.stageCount = data.stageCount;
    if (data.pStages !== undefined) s.pStages = data.pStages;
    if (data.pVertexInputState !== undefined) s.pVertexInputState = data.pVertexInputState;
    if (data.pTessellationState !== undefined) s.pTessellationState = data.pTessellationState;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pVertexInputState() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pVertexInputState(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pTessellationState() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pTessellationState(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkGraphicsPipelineShaderGroupsCreateInfoNV implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGraphicsPipelineShaderGroupsCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGraphicsPipelineShaderGroupsCreateInfoNV(new Uint8Array(VkGraphicsPipelineShaderGroupsCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    groupCount?: number;
    pGroups: Deno.PointerValue;
    pipelineCount?: number;
    pPipelines: Deno.PointerValue;
  }) {
    const s = VkGraphicsPipelineShaderGroupsCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.groupCount !== undefined) s.groupCount = data.groupCount;
    if (data.pGroups !== undefined) s.pGroups = data.pGroups;
    if (data.pipelineCount !== undefined) s.pipelineCount = data.pipelineCount;
    if (data.pPipelines !== undefined) s.pPipelines = data.pPipelines;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pGroups(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pipelineCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set pipelineCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPipelines() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPipelines(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkBindShaderGroupIndirectCommandNV implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindShaderGroupIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindShaderGroupIndirectCommandNV(new Uint8Array(VkBindShaderGroupIndirectCommandNV.size));
  }
  
  static create(data: {
    groupIndex: number;
  }) {
    const s = VkBindShaderGroupIndirectCommandNV.alloc();
    if (data.groupIndex !== undefined) s.groupIndex = data.groupIndex;
    return s;
  }
  
  get groupIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set groupIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export class VkBindIndexBufferIndirectCommandNV implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindIndexBufferIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindIndexBufferIndirectCommandNV(new Uint8Array(VkBindIndexBufferIndirectCommandNV.size));
  }
  
  static create(data: {
    bufferAddress: VkDeviceAddress;
    size: number;
    indexType: VkIndexType;
  }) {
    const s = VkBindIndexBufferIndirectCommandNV.alloc();
    if (data.bufferAddress !== undefined) s.bufferAddress = data.bufferAddress;
    if (data.size !== undefined) s.size = data.size;
    if (data.indexType !== undefined) s.indexType = data.indexType;
    return s;
  }
  
  get bufferAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(12, LE);
  }
  
  set indexType(value: VkIndexType) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkBindVertexBufferIndirectCommandNV implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindVertexBufferIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindVertexBufferIndirectCommandNV(new Uint8Array(VkBindVertexBufferIndirectCommandNV.size));
  }
  
  static create(data: {
    bufferAddress: VkDeviceAddress;
    size: number;
    stride: number;
  }) {
    const s = VkBindVertexBufferIndirectCommandNV.alloc();
    if (data.bufferAddress !== undefined) s.bufferAddress = data.bufferAddress;
    if (data.size !== undefined) s.size = data.size;
    if (data.stride !== undefined) s.stride = data.stride;
    return s;
  }
  
  get bufferAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(12, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkSetStateFlagsIndirectCommandNV implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSetStateFlagsIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSetStateFlagsIndirectCommandNV(new Uint8Array(VkSetStateFlagsIndirectCommandNV.size));
  }
  
  static create(data: {
    data: number;
  }) {
    const s = VkSetStateFlagsIndirectCommandNV.alloc();
    if (data.data !== undefined) s.data = data.data;
    return s;
  }
  
  get data() {
    return this.#view.getUint32(0, LE);
  }
  
  set data(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export class VkIndirectCommandsStreamNV implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkIndirectCommandsStreamNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkIndirectCommandsStreamNV(new Uint8Array(VkIndirectCommandsStreamNV.size));
  }
  
  static create(data: {
    buffer: VkBuffer;
    offset: VkDeviceSize;
  }) {
    const s = VkIndirectCommandsStreamNV.alloc();
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    return s;
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkIndirectCommandsLayoutTokenNV implements IVkStructure {
  static size = 88;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkIndirectCommandsLayoutTokenNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkIndirectCommandsLayoutTokenNV(new Uint8Array(VkIndirectCommandsLayoutTokenNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    tokenType: VkIndirectCommandsTokenTypeNV;
    stream: number;
    offset: number;
    vertexBindingUnit: number;
    vertexDynamicStride: VkBool32;
    pushconstantPipelineLayout?: VkPipelineLayout;
    pushconstantShaderStageFlags?: VkShaderStageFlags;
    pushconstantOffset: number;
    pushconstantSize: number;
    indirectStateFlags?: VkIndirectStateFlagsNV;
    indexTypeCount?: number;
    pIndexTypes: Deno.PointerValue;
    pIndexTypeValues: Deno.PointerValue;
  }) {
    const s = VkIndirectCommandsLayoutTokenNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.tokenType !== undefined) s.tokenType = data.tokenType;
    if (data.stream !== undefined) s.stream = data.stream;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.vertexBindingUnit !== undefined) s.vertexBindingUnit = data.vertexBindingUnit;
    if (data.vertexDynamicStride !== undefined) s.vertexDynamicStride = data.vertexDynamicStride;
    if (data.pushconstantPipelineLayout !== undefined) s.pushconstantPipelineLayout = data.pushconstantPipelineLayout;
    if (data.pushconstantShaderStageFlags !== undefined) s.pushconstantShaderStageFlags = data.pushconstantShaderStageFlags;
    if (data.pushconstantOffset !== undefined) s.pushconstantOffset = data.pushconstantOffset;
    if (data.pushconstantSize !== undefined) s.pushconstantSize = data.pushconstantSize;
    if (data.indirectStateFlags !== undefined) s.indirectStateFlags = data.indirectStateFlags;
    if (data.indexTypeCount !== undefined) s.indexTypeCount = data.indexTypeCount;
    if (data.pIndexTypes !== undefined) s.pIndexTypes = data.pIndexTypes;
    if (data.pIndexTypeValues !== undefined) s.pIndexTypeValues = data.pIndexTypeValues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get tokenType() {
    return this.#view.getUint32(16, LE);
  }
  
  set tokenType(value: VkIndirectCommandsTokenTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stream() {
    return this.#view.getUint32(20, LE);
  }
  
  set stream(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(24, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get vertexBindingUnit() {
    return this.#view.getUint32(28, LE);
  }
  
  set vertexBindingUnit(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get vertexDynamicStride() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexDynamicStride(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pushconstantPipelineLayout() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pushconstantPipelineLayout(value: VkPipelineLayout) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pushconstantShaderStageFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set pushconstantShaderStageFlags(value: VkShaderStageFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pushconstantOffset() {
    return this.#view.getUint32(52, LE);
  }
  
  set pushconstantOffset(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get pushconstantSize() {
    return this.#view.getUint32(56, LE);
  }
  
  set pushconstantSize(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get indirectStateFlags() {
    return this.#view.getUint32(60, LE);
  }
  
  set indirectStateFlags(value: VkIndirectStateFlagsNV) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get indexTypeCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set indexTypeCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pIndexTypes() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pIndexTypes(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get pIndexTypeValues() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pIndexTypeValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
}

export class VkIndirectCommandsLayoutCreateInfoNV implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkIndirectCommandsLayoutCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkIndirectCommandsLayoutCreateInfoNV(new Uint8Array(VkIndirectCommandsLayoutCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkIndirectCommandsLayoutUsageFlagsNV;
    pipelineBindPoint: VkPipelineBindPoint;
    tokenCount: number;
    pTokens: Deno.PointerValue;
    streamCount: number;
    pStreamStrides: Deno.PointerValue;
  }) {
    const s = VkIndirectCommandsLayoutCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.tokenCount !== undefined) s.tokenCount = data.tokenCount;
    if (data.pTokens !== undefined) s.pTokens = data.pTokens;
    if (data.streamCount !== undefined) s.streamCount = data.streamCount;
    if (data.pStreamStrides !== undefined) s.pStreamStrides = data.pStreamStrides;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkIndirectCommandsLayoutUsageFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(20, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tokenCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set tokenCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pTokens() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pTokens(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get streamCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set streamCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pStreamStrides() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pStreamStrides(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkGeneratedCommandsInfoNV implements IVkStructure {
  static size = 120;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeneratedCommandsInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeneratedCommandsInfoNV(new Uint8Array(VkGeneratedCommandsInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineBindPoint: VkPipelineBindPoint;
    pipeline: VkPipeline;
    indirectCommandsLayout: VkIndirectCommandsLayoutNV;
    streamCount: number;
    pStreams: Deno.PointerValue;
    sequencesCount: number;
    preprocessBuffer: VkBuffer;
    preprocessOffset: VkDeviceSize;
    preprocessSize: VkDeviceSize;
    sequencesCountBuffer?: VkBuffer;
    sequencesCountOffset: VkDeviceSize;
    sequencesIndexBuffer?: VkBuffer;
    sequencesIndexOffset: VkDeviceSize;
  }) {
    const s = VkGeneratedCommandsInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.pipeline !== undefined) s.pipeline = data.pipeline;
    if (data.indirectCommandsLayout !== undefined) s.indirectCommandsLayout = data.indirectCommandsLayout;
    if (data.streamCount !== undefined) s.streamCount = data.streamCount;
    if (data.pStreams !== undefined) s.pStreams = data.pStreams;
    if (data.sequencesCount !== undefined) s.sequencesCount = data.sequencesCount;
    if (data.preprocessBuffer !== undefined) s.preprocessBuffer = data.preprocessBuffer;
    if (data.preprocessOffset !== undefined) s.preprocessOffset = data.preprocessOffset;
    if (data.preprocessSize !== undefined) s.preprocessSize = data.preprocessSize;
    if (data.sequencesCountBuffer !== undefined) s.sequencesCountBuffer = data.sequencesCountBuffer;
    if (data.sequencesCountOffset !== undefined) s.sequencesCountOffset = data.sequencesCountOffset;
    if (data.sequencesIndexBuffer !== undefined) s.sequencesIndexBuffer = data.sequencesIndexBuffer;
    if (data.sequencesIndexOffset !== undefined) s.sequencesIndexOffset = data.sequencesIndexOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pipeline(value: VkPipeline) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get indirectCommandsLayout() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indirectCommandsLayout(value: VkIndirectCommandsLayoutNV) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get streamCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set streamCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pStreams() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pStreams(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get sequencesCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set sequencesCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get preprocessBuffer() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set preprocessBuffer(value: VkBuffer) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get preprocessOffset() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set preprocessOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get preprocessSize() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set preprocessSize(value: VkDeviceSize) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get sequencesCountBuffer() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set sequencesCountBuffer(value: VkBuffer) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get sequencesCountOffset() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set sequencesCountOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get sequencesIndexBuffer() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set sequencesIndexBuffer(value: VkBuffer) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
  
  get sequencesIndexOffset() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set sequencesIndexOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
}

export class VkGeneratedCommandsMemoryRequirementsInfoNV implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeneratedCommandsMemoryRequirementsInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeneratedCommandsMemoryRequirementsInfoNV(new Uint8Array(VkGeneratedCommandsMemoryRequirementsInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineBindPoint: VkPipelineBindPoint;
    pipeline: VkPipeline;
    indirectCommandsLayout: VkIndirectCommandsLayoutNV;
    maxSequencesCount: number;
  }) {
    const s = VkGeneratedCommandsMemoryRequirementsInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.pipeline !== undefined) s.pipeline = data.pipeline;
    if (data.indirectCommandsLayout !== undefined) s.indirectCommandsLayout = data.indirectCommandsLayout;
    if (data.maxSequencesCount !== undefined) s.maxSequencesCount = data.maxSequencesCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pipeline(value: VkPipeline) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get indirectCommandsLayout() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indirectCommandsLayout(value: VkIndirectCommandsLayoutNV) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxSequencesCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxSequencesCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkPhysicalDeviceFeatures2 implements IVkStructure {
  static size = 440;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFeatures2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFeatures2(new Uint8Array(VkPhysicalDeviceFeatures2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    features: VkPhysicalDeviceFeatures;
  }) {
    const s = VkPhysicalDeviceFeatures2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.features !== undefined) s.features = data.features;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get features() {
    return new VkPhysicalDeviceFeatures(this.#data.subarray(220, 220 + VkPhysicalDeviceFeatures.size));
  }
  
  set features(value: VkPhysicalDeviceFeatures) {
    if (value[BUFFER].byteLength < VkPhysicalDeviceFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 220);
  }
}

export class VkPhysicalDeviceProperties2 implements IVkStructure {
  static size = 2832;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProperties2(new Uint8Array(VkPhysicalDeviceProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    properties: VkPhysicalDeviceProperties;
  }) {
    const s = VkPhysicalDeviceProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.properties !== undefined) s.properties = data.properties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get properties() {
    return new VkPhysicalDeviceProperties(this.#data.subarray(1416, 1416 + VkPhysicalDeviceProperties.size));
  }
  
  set properties(value: VkPhysicalDeviceProperties) {
    if (value[BUFFER].byteLength < VkPhysicalDeviceProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 1416);
  }
}

export class VkFormatProperties2 implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFormatProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFormatProperties2(new Uint8Array(VkFormatProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    formatProperties: VkFormatProperties;
  }) {
    const s = VkFormatProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.formatProperties !== undefined) s.formatProperties = data.formatProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get formatProperties() {
    return new VkFormatProperties(this.#data.subarray(24, 24 + VkFormatProperties.size));
  }
  
  set formatProperties(value: VkFormatProperties) {
    if (value[BUFFER].byteLength < VkFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkImageFormatProperties2 implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageFormatProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageFormatProperties2(new Uint8Array(VkImageFormatProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageFormatProperties: VkImageFormatProperties;
  }) {
    const s = VkImageFormatProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageFormatProperties !== undefined) s.imageFormatProperties = data.imageFormatProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageFormatProperties() {
    return new VkImageFormatProperties(this.#data.subarray(36, 36 + VkImageFormatProperties.size));
  }
  
  set imageFormatProperties(value: VkImageFormatProperties) {
    if (value[BUFFER].byteLength < VkImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
}

export class VkPhysicalDeviceImageFormatInfo2 implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageFormatInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageFormatInfo2(new Uint8Array(VkPhysicalDeviceImageFormatInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    type: VkImageType;
    tiling: VkImageTiling;
    usage: VkImageUsageFlags;
    flags?: VkImageCreateFlags;
  }) {
    const s = VkPhysicalDeviceImageFormatInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.type !== undefined) s.type = data.type;
    if (data.tiling !== undefined) s.tiling = data.tiling;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: VkImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(24, LE);
  }
  
  set tiling(value: VkImageTiling) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(28, LE);
  }
  
  set usage(value: VkImageUsageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: VkImageCreateFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkQueueFamilyProperties2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyProperties2(new Uint8Array(VkQueueFamilyProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    queueFamilyProperties: VkQueueFamilyProperties;
  }) {
    const s = VkQueueFamilyProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.queueFamilyProperties !== undefined) s.queueFamilyProperties = data.queueFamilyProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get queueFamilyProperties() {
    return new VkQueueFamilyProperties(this.#data.subarray(24, 24 + VkQueueFamilyProperties.size));
  }
  
  set queueFamilyProperties(value: VkQueueFamilyProperties) {
    if (value[BUFFER].byteLength < VkQueueFamilyProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPhysicalDeviceMemoryProperties2 implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryProperties2(new Uint8Array(VkPhysicalDeviceMemoryProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryProperties: VkPhysicalDeviceMemoryProperties;
  }) {
    const s = VkPhysicalDeviceMemoryProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryProperties !== undefined) s.memoryProperties = data.memoryProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryProperties() {
    return new VkPhysicalDeviceMemoryProperties(this.#data.subarray(48, 48 + VkPhysicalDeviceMemoryProperties.size));
  }
  
  set memoryProperties(value: VkPhysicalDeviceMemoryProperties) {
    if (value[BUFFER].byteLength < VkPhysicalDeviceMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkSparseImageFormatProperties2 implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageFormatProperties2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageFormatProperties2(new Uint8Array(VkSparseImageFormatProperties2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    properties: VkSparseImageFormatProperties;
  }) {
    const s = VkSparseImageFormatProperties2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.properties !== undefined) s.properties = data.properties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get properties() {
    return new VkSparseImageFormatProperties(this.#data.subarray(36, 36 + VkSparseImageFormatProperties.size));
  }
  
  set properties(value: VkSparseImageFormatProperties) {
    if (value[BUFFER].byteLength < VkSparseImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
}

export class VkPhysicalDeviceSparseImageFormatInfo2 implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSparseImageFormatInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSparseImageFormatInfo2(new Uint8Array(VkPhysicalDeviceSparseImageFormatInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    type: VkImageType;
    samples: VkSampleCountFlagBits;
    usage: VkImageUsageFlags;
    tiling: VkImageTiling;
  }) {
    const s = VkPhysicalDeviceSparseImageFormatInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.type !== undefined) s.type = data.type;
    if (data.samples !== undefined) s.samples = data.samples;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.tiling !== undefined) s.tiling = data.tiling;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: VkImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(24, LE);
  }
  
  set samples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(28, LE);
  }
  
  set usage(value: VkImageUsageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(32, LE);
  }
  
  set tiling(value: VkImageTiling) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDevicePushDescriptorPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePushDescriptorPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePushDescriptorPropertiesKHR(new Uint8Array(VkPhysicalDevicePushDescriptorPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxPushDescriptors: number;
  }) {
    const s = VkPhysicalDevicePushDescriptorPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxPushDescriptors !== undefined) s.maxPushDescriptors = data.maxPushDescriptors;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxPushDescriptors() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPushDescriptors(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkConformanceVersion implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkConformanceVersion.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkConformanceVersion(new Uint8Array(VkConformanceVersion.size));
  }
  
  static create(data: {
    major: number;
    minor: number;
    subminor: number;
    patch: number;
  }) {
    const s = VkConformanceVersion.alloc();
    if (data.major !== undefined) s.major = data.major;
    if (data.minor !== undefined) s.minor = data.minor;
    if (data.subminor !== undefined) s.subminor = data.subminor;
    if (data.patch !== undefined) s.patch = data.patch;
    return s;
  }
  
  get major() {
    return this.#view.getUint8(0);
  }
  
  set major(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get minor() {
    return this.#view.getUint8(1);
  }
  
  set minor(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get subminor() {
    return this.#view.getUint8(2);
  }
  
  set subminor(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get patch() {
    return this.#view.getUint8(3);
  }
  
  set patch(value: number) {
    this.#view.setUint8(3, Number(value));
  }
}

export class VkPhysicalDeviceDriverProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDriverProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDriverProperties(new Uint8Array(VkPhysicalDeviceDriverProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    driverID: VkDriverId;
    driverName: number;
    driverInfo: number;
    conformanceVersion: VkConformanceVersion;
  }) {
    const s = VkPhysicalDeviceDriverProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.driverID !== undefined) s.driverID = data.driverID;
    if (data.driverName !== undefined) s.driverName = data.driverName;
    if (data.driverInfo !== undefined) s.driverInfo = data.driverInfo;
    if (data.conformanceVersion !== undefined) s.conformanceVersion = data.conformanceVersion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get driverID() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverID(value: VkDriverId) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get driverName() {
    return this.#view.getUint8(20);
  }
  
  set driverName(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get driverInfo() {
    return this.#view.getUint8(21);
  }
  
  set driverInfo(value: number) {
    this.#view.setUint8(21, Number(value));
  }
  
  get conformanceVersion() {
    return new VkConformanceVersion(this.#data.subarray(24, 24 + VkConformanceVersion.size));
  }
  
  set conformanceVersion(value: VkConformanceVersion) {
    if (value[BUFFER].byteLength < VkConformanceVersion.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPresentRegionsKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentRegionsKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentRegionsKHR(new Uint8Array(VkPresentRegionsKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchainCount: number;
    pRegions?: Deno.PointerValue;
  }) {
    const s = VkPresentRegionsKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchainCount !== undefined) s.swapchainCount = data.swapchainCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPresentRegionKHR implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentRegionKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentRegionKHR(new Uint8Array(VkPresentRegionKHR.size));
  }
  
  static create(data: {
    rectangleCount?: number;
    pRectangles?: Deno.PointerValue;
  }) {
    const s = VkPresentRegionKHR.alloc();
    if (data.rectangleCount !== undefined) s.rectangleCount = data.rectangleCount;
    if (data.pRectangles !== undefined) s.pRectangles = data.pRectangles;
    return s;
  }
  
  get rectangleCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set rectangleCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pRectangles() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pRectangles(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkRectLayerKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRectLayerKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRectLayerKHR(new Uint8Array(VkRectLayerKHR.size));
  }
  
  static create(data: {
    offset: VkOffset2D;
    extent: VkExtent2D;
    layer: number;
  }) {
    const s = VkRectLayerKHR.alloc();
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.extent !== undefined) s.extent = data.extent;
    if (data.layer !== undefined) s.layer = data.layer;
    return s;
  }
  
  get offset() {
    return new VkOffset2D(this.#data.subarray(0, 0 + VkOffset2D.size));
  }
  
  set offset(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get extent() {
    return new VkExtent2D(this.#data.subarray(8, 8 + VkExtent2D.size));
  }
  
  set extent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get layer() {
    return this.#view.getUint32(16, LE);
  }
  
  set layer(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceVariablePointersFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVariablePointersFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVariablePointersFeatures(new Uint8Array(VkPhysicalDeviceVariablePointersFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    variablePointersStorageBuffer: VkBool32;
    variablePointers: VkBool32;
  }) {
    const s = VkPhysicalDeviceVariablePointersFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.variablePointersStorageBuffer !== undefined) s.variablePointersStorageBuffer = data.variablePointersStorageBuffer;
    if (data.variablePointers !== undefined) s.variablePointers = data.variablePointers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get variablePointersStorageBuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set variablePointersStorageBuffer(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get variablePointers() {
    return this.#view.getUint32(20, LE);
  }
  
  set variablePointers(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkExternalMemoryProperties implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalMemoryProperties(new Uint8Array(VkExternalMemoryProperties.size));
  }
  
  static create(data: {
    externalMemoryFeatures: VkExternalMemoryFeatureFlags;
    exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlags;
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags;
  }) {
    const s = VkExternalMemoryProperties.alloc();
    if (data.externalMemoryFeatures !== undefined) s.externalMemoryFeatures = data.externalMemoryFeatures;
    if (data.exportFromImportedHandleTypes !== undefined) s.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
    if (data.compatibleHandleTypes !== undefined) s.compatibleHandleTypes = data.compatibleHandleTypes;
    return s;
  }
  
  get externalMemoryFeatures() {
    return this.#view.getUint32(0, LE);
  }
  
  set externalMemoryFeatures(value: VkExternalMemoryFeatureFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(4, LE);
  }
  
  set exportFromImportedHandleTypes(value: VkExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(8, LE);
  }
  
  set compatibleHandleTypes(value: VkExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkPhysicalDeviceExternalImageFormatInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalImageFormatInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalImageFormatInfo(new Uint8Array(VkPhysicalDeviceExternalImageFormatInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType?: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkPhysicalDeviceExternalImageFormatInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExternalImageFormatProperties implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalImageFormatProperties(new Uint8Array(VkExternalImageFormatProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    externalMemoryProperties: VkExternalMemoryProperties;
  }) {
    const s = VkExternalImageFormatProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.externalMemoryProperties !== undefined) s.externalMemoryProperties = data.externalMemoryProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get externalMemoryProperties() {
    return new VkExternalMemoryProperties(this.#data.subarray(24, 24 + VkExternalMemoryProperties.size));
  }
  
  set externalMemoryProperties(value: VkExternalMemoryProperties) {
    if (value[BUFFER].byteLength < VkExternalMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPhysicalDeviceExternalBufferInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalBufferInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalBufferInfo(new Uint8Array(VkPhysicalDeviceExternalBufferInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkBufferCreateFlags;
    usage: VkBufferUsageFlags;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkPhysicalDeviceExternalBufferInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkBufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(20, LE);
  }
  
  set usage(value: VkBufferUsageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkExternalBufferProperties implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalBufferProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalBufferProperties(new Uint8Array(VkExternalBufferProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    externalMemoryProperties: VkExternalMemoryProperties;
  }) {
    const s = VkExternalBufferProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.externalMemoryProperties !== undefined) s.externalMemoryProperties = data.externalMemoryProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get externalMemoryProperties() {
    return new VkExternalMemoryProperties(this.#data.subarray(24, 24 + VkExternalMemoryProperties.size));
  }
  
  set externalMemoryProperties(value: VkExternalMemoryProperties) {
    if (value[BUFFER].byteLength < VkExternalMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPhysicalDeviceIDProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceIDProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceIDProperties(new Uint8Array(VkPhysicalDeviceIDProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceUUID: number;
    driverUUID: number;
    deviceLUID: number;
    deviceNodeMask: number;
    deviceLUIDValid: VkBool32;
  }) {
    const s = VkPhysicalDeviceIDProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceUUID !== undefined) s.deviceUUID = data.deviceUUID;
    if (data.driverUUID !== undefined) s.driverUUID = data.driverUUID;
    if (data.deviceLUID !== undefined) s.deviceLUID = data.deviceLUID;
    if (data.deviceNodeMask !== undefined) s.deviceNodeMask = data.deviceNodeMask;
    if (data.deviceLUIDValid !== undefined) s.deviceLUIDValid = data.deviceLUIDValid;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceUUID() {
    return this.#view.getUint8(16);
  }
  
  set deviceUUID(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get driverUUID() {
    return this.#view.getUint8(17);
  }
  
  set driverUUID(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get deviceLUID() {
    return this.#view.getUint8(18);
  }
  
  set deviceLUID(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get deviceNodeMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceNodeMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get deviceLUIDValid() {
    return this.#view.getUint32(24, LE);
  }
  
  set deviceLUIDValid(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkExternalMemoryImageCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalMemoryImageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalMemoryImageCreateInfo(new Uint8Array(VkExternalMemoryImageCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalMemoryHandleTypeFlags;
  }) {
    const s = VkExternalMemoryImageCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExternalMemoryBufferCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalMemoryBufferCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalMemoryBufferCreateInfo(new Uint8Array(VkExternalMemoryBufferCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalMemoryHandleTypeFlags;
  }) {
    const s = VkExternalMemoryBufferCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExportMemoryAllocateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMemoryAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMemoryAllocateInfo(new Uint8Array(VkExportMemoryAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalMemoryHandleTypeFlags;
  }) {
    const s = VkExportMemoryAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImportMemoryWin32HandleInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryWin32HandleInfoKHR(new Uint8Array(VkImportMemoryWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType?: VkExternalMemoryHandleTypeFlagBits;
    handle?: Deno.PointerValue;
    name?: Deno.PointerValue;
  }) {
    const s = VkImportMemoryWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.handle !== undefined) s.handle = data.handle;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkExportMemoryWin32HandleInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMemoryWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMemoryWin32HandleInfoKHR(new Uint8Array(VkExportMemoryWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pAttributes?: Deno.PointerValue;
    dwAccess: number;
    name: Deno.PointerValue;
  }) {
    const s = VkExportMemoryWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pAttributes !== undefined) s.pAttributes = data.pAttributes;
    if (data.dwAccess !== undefined) s.dwAccess = data.dwAccess;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImportMemoryZirconHandleInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryZirconHandleInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryZirconHandleInfoFUCHSIA(new Uint8Array(VkImportMemoryZirconHandleInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType?: VkExternalMemoryHandleTypeFlagBits;
    handle?: Deno.PointerValue;
  }) {
    const s = VkImportMemoryZirconHandleInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.handle !== undefined) s.handle = data.handle;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkMemoryZirconHandlePropertiesFUCHSIA implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryZirconHandlePropertiesFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryZirconHandlePropertiesFUCHSIA(new Uint8Array(VkMemoryZirconHandlePropertiesFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryTypeBits: number;
  }) {
    const s = VkMemoryZirconHandlePropertiesFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryGetZirconHandleInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryGetZirconHandleInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryGetZirconHandleInfoFUCHSIA(new Uint8Array(VkMemoryGetZirconHandleInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkMemoryGetZirconHandleInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkMemoryWin32HandlePropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryWin32HandlePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryWin32HandlePropertiesKHR(new Uint8Array(VkMemoryWin32HandlePropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryTypeBits: number;
  }) {
    const s = VkMemoryWin32HandlePropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryGetWin32HandleInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryGetWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryGetWin32HandleInfoKHR(new Uint8Array(VkMemoryGetWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkMemoryGetWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkImportMemoryFdInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryFdInfoKHR(new Uint8Array(VkImportMemoryFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType?: VkExternalMemoryHandleTypeFlagBits;
    fd: number;
  }) {
    const s = VkImportMemoryFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.fd !== undefined) s.fd = data.fd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(20, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(20, Number(value), LE);
  }
}

export class VkMemoryFdPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryFdPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryFdPropertiesKHR(new Uint8Array(VkMemoryFdPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryTypeBits: number;
  }) {
    const s = VkMemoryFdPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryGetFdInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryGetFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryGetFdInfoKHR(new Uint8Array(VkMemoryGetFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkMemoryGetFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkWin32KeyedMutexAcquireReleaseInfoKHR implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWin32KeyedMutexAcquireReleaseInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWin32KeyedMutexAcquireReleaseInfoKHR(new Uint8Array(VkWin32KeyedMutexAcquireReleaseInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    acquireCount?: number;
    pAcquireSyncs: Deno.PointerValue;
    pAcquireKeys: Deno.PointerValue;
    pAcquireTimeouts: Deno.PointerValue;
    releaseCount?: number;
    pReleaseSyncs: Deno.PointerValue;
    pReleaseKeys: Deno.PointerValue;
  }) {
    const s = VkWin32KeyedMutexAcquireReleaseInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.acquireCount !== undefined) s.acquireCount = data.acquireCount;
    if (data.pAcquireSyncs !== undefined) s.pAcquireSyncs = data.pAcquireSyncs;
    if (data.pAcquireKeys !== undefined) s.pAcquireKeys = data.pAcquireKeys;
    if (data.pAcquireTimeouts !== undefined) s.pAcquireTimeouts = data.pAcquireTimeouts;
    if (data.releaseCount !== undefined) s.releaseCount = data.releaseCount;
    if (data.pReleaseSyncs !== undefined) s.pReleaseSyncs = data.pReleaseSyncs;
    if (data.pReleaseKeys !== undefined) s.pReleaseKeys = data.pReleaseKeys;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get acquireCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set acquireCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAcquireSyncs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAcquireSyncs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pAcquireKeys() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAcquireKeys(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pAcquireTimeouts() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAcquireTimeouts(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get releaseCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set releaseCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pReleaseSyncs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pReleaseSyncs(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pReleaseKeys() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pReleaseKeys(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceExternalSemaphoreInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalSemaphoreInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalSemaphoreInfo(new Uint8Array(VkPhysicalDeviceExternalSemaphoreInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  }) {
    const s = VkPhysicalDeviceExternalSemaphoreInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExternalSemaphoreProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalSemaphoreProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalSemaphoreProperties(new Uint8Array(VkExternalSemaphoreProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags;
    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags;
    externalSemaphoreFeatures?: VkExternalSemaphoreFeatureFlags;
  }) {
    const s = VkExternalSemaphoreProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.exportFromImportedHandleTypes !== undefined) s.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
    if (data.compatibleHandleTypes !== undefined) s.compatibleHandleTypes = data.compatibleHandleTypes;
    if (data.externalSemaphoreFeatures !== undefined) s.externalSemaphoreFeatures = data.externalSemaphoreFeatures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportFromImportedHandleTypes(value: VkExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(20, LE);
  }
  
  set compatibleHandleTypes(value: VkExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get externalSemaphoreFeatures() {
    return this.#view.getUint32(24, LE);
  }
  
  set externalSemaphoreFeatures(value: VkExternalSemaphoreFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkExportSemaphoreCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportSemaphoreCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportSemaphoreCreateInfo(new Uint8Array(VkExportSemaphoreCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalSemaphoreHandleTypeFlags;
  }) {
    const s = VkExportSemaphoreCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImportSemaphoreWin32HandleInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportSemaphoreWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportSemaphoreWin32HandleInfoKHR(new Uint8Array(VkImportSemaphoreWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    flags?: VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    handle?: Deno.PointerValue;
    name?: Deno.PointerValue;
  }) {
    const s = VkImportSemaphoreWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.handle !== undefined) s.handle = data.handle;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkSemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkExportSemaphoreWin32HandleInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportSemaphoreWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportSemaphoreWin32HandleInfoKHR(new Uint8Array(VkExportSemaphoreWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pAttributes?: Deno.PointerValue;
    dwAccess: number;
    name: Deno.PointerValue;
  }) {
    const s = VkExportSemaphoreWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pAttributes !== undefined) s.pAttributes = data.pAttributes;
    if (data.dwAccess !== undefined) s.dwAccess = data.dwAccess;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkD3D12FenceSubmitInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkD3D12FenceSubmitInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkD3D12FenceSubmitInfoKHR(new Uint8Array(VkD3D12FenceSubmitInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreValuesCount?: number;
    pWaitSemaphoreValues?: Deno.PointerValue;
    signalSemaphoreValuesCount?: number;
    pSignalSemaphoreValues?: Deno.PointerValue;
  }) {
    const s = VkD3D12FenceSubmitInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreValuesCount !== undefined) s.waitSemaphoreValuesCount = data.waitSemaphoreValuesCount;
    if (data.pWaitSemaphoreValues !== undefined) s.pWaitSemaphoreValues = data.pWaitSemaphoreValues;
    if (data.signalSemaphoreValuesCount !== undefined) s.signalSemaphoreValuesCount = data.signalSemaphoreValuesCount;
    if (data.pSignalSemaphoreValues !== undefined) s.pSignalSemaphoreValues = data.pSignalSemaphoreValues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreValuesCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreValuesCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreValues() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get signalSemaphoreValuesCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set signalSemaphoreValuesCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSignalSemaphoreValues() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSignalSemaphoreValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkSemaphoreGetWin32HandleInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreGetWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreGetWin32HandleInfoKHR(new Uint8Array(VkSemaphoreGetWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  }) {
    const s = VkSemaphoreGetWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkImportSemaphoreFdInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportSemaphoreFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportSemaphoreFdInfoKHR(new Uint8Array(VkImportSemaphoreFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    flags?: VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    fd: number;
  }) {
    const s = VkImportSemaphoreFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.fd !== undefined) s.fd = data.fd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkSemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(32, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
}

export class VkSemaphoreGetFdInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreGetFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreGetFdInfoKHR(new Uint8Array(VkSemaphoreGetFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  }) {
    const s = VkSemaphoreGetFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkImportSemaphoreZirconHandleInfoFUCHSIA implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportSemaphoreZirconHandleInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportSemaphoreZirconHandleInfoFUCHSIA(new Uint8Array(VkImportSemaphoreZirconHandleInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    flags?: VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    zirconHandle: Deno.PointerValue;
  }) {
    const s = VkImportSemaphoreZirconHandleInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.zirconHandle !== undefined) s.zirconHandle = data.zirconHandle;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkSemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get zirconHandle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set zirconHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkSemaphoreGetZirconHandleInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreGetZirconHandleInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreGetZirconHandleInfoFUCHSIA(new Uint8Array(VkSemaphoreGetZirconHandleInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  }) {
    const s = VkSemaphoreGetZirconHandleInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceExternalFenceInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalFenceInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalFenceInfo(new Uint8Array(VkPhysicalDeviceExternalFenceInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType: VkExternalFenceHandleTypeFlagBits;
  }) {
    const s = VkPhysicalDeviceExternalFenceInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExternalFenceProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalFenceProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalFenceProperties(new Uint8Array(VkExternalFenceProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags;
    compatibleHandleTypes: VkExternalFenceHandleTypeFlags;
    externalFenceFeatures?: VkExternalFenceFeatureFlags;
  }) {
    const s = VkExternalFenceProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.exportFromImportedHandleTypes !== undefined) s.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
    if (data.compatibleHandleTypes !== undefined) s.compatibleHandleTypes = data.compatibleHandleTypes;
    if (data.externalFenceFeatures !== undefined) s.externalFenceFeatures = data.externalFenceFeatures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportFromImportedHandleTypes(value: VkExternalFenceHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(20, LE);
  }
  
  set compatibleHandleTypes(value: VkExternalFenceHandleTypeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get externalFenceFeatures() {
    return this.#view.getUint32(24, LE);
  }
  
  set externalFenceFeatures(value: VkExternalFenceFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkExportFenceCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportFenceCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportFenceCreateInfo(new Uint8Array(VkExportFenceCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleTypes?: VkExternalFenceHandleTypeFlags;
  }) {
    const s = VkExportFenceCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleTypes !== undefined) s.handleTypes = data.handleTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: VkExternalFenceHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImportFenceWin32HandleInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportFenceWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportFenceWin32HandleInfoKHR(new Uint8Array(VkImportFenceWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fence: VkFence;
    flags?: VkFenceImportFlags;
    handleType: VkExternalFenceHandleTypeFlagBits;
    handle?: Deno.PointerValue;
    name?: Deno.PointerValue;
  }) {
    const s = VkImportFenceWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fence !== undefined) s.fence = data.fence;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.handle !== undefined) s.handle = data.handle;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: VkFence) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkFenceImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: VkExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkExportFenceWin32HandleInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportFenceWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportFenceWin32HandleInfoKHR(new Uint8Array(VkExportFenceWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pAttributes?: Deno.PointerValue;
    dwAccess: number;
    name: Deno.PointerValue;
  }) {
    const s = VkExportFenceWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pAttributes !== undefined) s.pAttributes = data.pAttributes;
    if (data.dwAccess !== undefined) s.dwAccess = data.dwAccess;
    if (data.name !== undefined) s.name = data.name;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkFenceGetWin32HandleInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFenceGetWin32HandleInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFenceGetWin32HandleInfoKHR(new Uint8Array(VkFenceGetWin32HandleInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fence: VkFence;
    handleType: VkExternalFenceHandleTypeFlagBits;
  }) {
    const s = VkFenceGetWin32HandleInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fence !== undefined) s.fence = data.fence;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: VkFence) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkImportFenceFdInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportFenceFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportFenceFdInfoKHR(new Uint8Array(VkImportFenceFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fence: VkFence;
    flags?: VkFenceImportFlags;
    handleType: VkExternalFenceHandleTypeFlagBits;
    fd: number;
  }) {
    const s = VkImportFenceFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fence !== undefined) s.fence = data.fence;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.fd !== undefined) s.fd = data.fd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: VkFence) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: VkFenceImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: VkExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(32, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
}

export class VkFenceGetFdInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFenceGetFdInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFenceGetFdInfoKHR(new Uint8Array(VkFenceGetFdInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fence: VkFence;
    handleType: VkExternalFenceHandleTypeFlagBits;
  }) {
    const s = VkFenceGetFdInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fence !== undefined) s.fence = data.fence;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: VkFence) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceMultiviewFeatures implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultiviewFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultiviewFeatures(new Uint8Array(VkPhysicalDeviceMultiviewFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    multiview: VkBool32;
    multiviewGeometryShader: VkBool32;
    multiviewTessellationShader: VkBool32;
  }) {
    const s = VkPhysicalDeviceMultiviewFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.multiview !== undefined) s.multiview = data.multiview;
    if (data.multiviewGeometryShader !== undefined) s.multiviewGeometryShader = data.multiviewGeometryShader;
    if (data.multiviewTessellationShader !== undefined) s.multiviewTessellationShader = data.multiviewTessellationShader;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get multiview() {
    return this.#view.getUint32(16, LE);
  }
  
  set multiview(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get multiviewGeometryShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set multiviewGeometryShader(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get multiviewTessellationShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set multiviewTessellationShader(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceMultiviewProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultiviewProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultiviewProperties(new Uint8Array(VkPhysicalDeviceMultiviewProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxMultiviewViewCount: number;
    maxMultiviewInstanceIndex: number;
  }) {
    const s = VkPhysicalDeviceMultiviewProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxMultiviewViewCount !== undefined) s.maxMultiviewViewCount = data.maxMultiviewViewCount;
    if (data.maxMultiviewInstanceIndex !== undefined) s.maxMultiviewInstanceIndex = data.maxMultiviewInstanceIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxMultiviewViewCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxMultiviewViewCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxMultiviewInstanceIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxMultiviewInstanceIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkRenderPassMultiviewCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassMultiviewCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassMultiviewCreateInfo(new Uint8Array(VkRenderPassMultiviewCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subpassCount?: number;
    pViewMasks: Deno.PointerValue;
    dependencyCount?: number;
    pViewOffsets: Deno.PointerValue;
    correlationMaskCount?: number;
    pCorrelationMasks: Deno.PointerValue;
  }) {
    const s = VkRenderPassMultiviewCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subpassCount !== undefined) s.subpassCount = data.subpassCount;
    if (data.pViewMasks !== undefined) s.pViewMasks = data.pViewMasks;
    if (data.dependencyCount !== undefined) s.dependencyCount = data.dependencyCount;
    if (data.pViewOffsets !== undefined) s.pViewOffsets = data.pViewOffsets;
    if (data.correlationMaskCount !== undefined) s.correlationMaskCount = data.correlationMaskCount;
    if (data.pCorrelationMasks !== undefined) s.pCorrelationMasks = data.pCorrelationMasks;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pViewMasks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewMasks(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pViewOffsets() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pViewOffsets(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get correlationMaskCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set correlationMaskCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pCorrelationMasks() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pCorrelationMasks(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkSurfaceCapabilities2EXT implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceCapabilities2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceCapabilities2EXT(new Uint8Array(VkSurfaceCapabilities2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minImageCount: number;
    maxImageCount: number;
    currentExtent: VkExtent2D;
    minImageExtent: VkExtent2D;
    maxImageExtent: VkExtent2D;
    maxImageArrayLayers: number;
    supportedTransforms: VkSurfaceTransformFlagsKHR;
    currentTransform: VkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR;
    supportedUsageFlags: VkImageUsageFlags;
    supportedSurfaceCounters?: VkSurfaceCounterFlagsEXT;
  }) {
    const s = VkSurfaceCapabilities2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minImageCount !== undefined) s.minImageCount = data.minImageCount;
    if (data.maxImageCount !== undefined) s.maxImageCount = data.maxImageCount;
    if (data.currentExtent !== undefined) s.currentExtent = data.currentExtent;
    if (data.minImageExtent !== undefined) s.minImageExtent = data.minImageExtent;
    if (data.maxImageExtent !== undefined) s.maxImageExtent = data.maxImageExtent;
    if (data.maxImageArrayLayers !== undefined) s.maxImageArrayLayers = data.maxImageArrayLayers;
    if (data.supportedTransforms !== undefined) s.supportedTransforms = data.supportedTransforms;
    if (data.currentTransform !== undefined) s.currentTransform = data.currentTransform;
    if (data.supportedCompositeAlpha !== undefined) s.supportedCompositeAlpha = data.supportedCompositeAlpha;
    if (data.supportedUsageFlags !== undefined) s.supportedUsageFlags = data.supportedUsageFlags;
    if (data.supportedSurfaceCounters !== undefined) s.supportedSurfaceCounters = data.supportedSurfaceCounters;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minImageCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxImageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxImageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get currentExtent() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set currentExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get minImageExtent() {
    return new VkExtent2D(this.#data.subarray(32, 32 + VkExtent2D.size));
  }
  
  set minImageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get maxImageExtent() {
    return new VkExtent2D(this.#data.subarray(40, 40 + VkExtent2D.size));
  }
  
  set maxImageExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(52, LE);
  }
  
  set supportedTransforms(value: VkSurfaceTransformFlagsKHR) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get currentTransform() {
    return this.#view.getUint32(56, LE);
  }
  
  set currentTransform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get supportedCompositeAlpha() {
    return this.#view.getUint32(60, LE);
  }
  
  set supportedCompositeAlpha(value: VkCompositeAlphaFlagsKHR) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get supportedUsageFlags() {
    return this.#view.getUint32(64, LE);
  }
  
  set supportedUsageFlags(value: VkImageUsageFlags) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get supportedSurfaceCounters() {
    return this.#view.getUint32(68, LE);
  }
  
  set supportedSurfaceCounters(value: VkSurfaceCounterFlagsEXT) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export class VkDisplayPowerInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPowerInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPowerInfoEXT(new Uint8Array(VkDisplayPowerInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    powerState: VkDisplayPowerStateEXT;
  }) {
    const s = VkDisplayPowerInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.powerState !== undefined) s.powerState = data.powerState;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get powerState() {
    return this.#view.getUint32(16, LE);
  }
  
  set powerState(value: VkDisplayPowerStateEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceEventInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceEventInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceEventInfoEXT(new Uint8Array(VkDeviceEventInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceEvent: VkDeviceEventTypeEXT;
  }) {
    const s = VkDeviceEventInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceEvent !== undefined) s.deviceEvent = data.deviceEvent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceEvent() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceEvent(value: VkDeviceEventTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDisplayEventInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayEventInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayEventInfoEXT(new Uint8Array(VkDisplayEventInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    displayEvent: VkDisplayEventTypeEXT;
  }) {
    const s = VkDisplayEventInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.displayEvent !== undefined) s.displayEvent = data.displayEvent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get displayEvent() {
    return this.#view.getUint32(16, LE);
  }
  
  set displayEvent(value: VkDisplayEventTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSwapchainCounterCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSwapchainCounterCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSwapchainCounterCreateInfoEXT(new Uint8Array(VkSwapchainCounterCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    surfaceCounters?: VkSurfaceCounterFlagsEXT;
  }) {
    const s = VkSwapchainCounterCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.surfaceCounters !== undefined) s.surfaceCounters = data.surfaceCounters;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get surfaceCounters() {
    return this.#view.getUint32(16, LE);
  }
  
  set surfaceCounters(value: VkSurfaceCounterFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceGroupProperties implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceGroupProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceGroupProperties(new Uint8Array(VkPhysicalDeviceGroupProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    physicalDeviceCount: number;
    physicalDevices: VkPhysicalDevice;
    subsetAllocation: VkBool32;
  }) {
    const s = VkPhysicalDeviceGroupProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.physicalDeviceCount !== undefined) s.physicalDeviceCount = data.physicalDeviceCount;
    if (data.physicalDevices !== undefined) s.physicalDevices = data.physicalDevices;
    if (data.subsetAllocation !== undefined) s.subsetAllocation = data.subsetAllocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get physicalDeviceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set physicalDeviceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get physicalDevices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set physicalDevices(value: VkPhysicalDevice) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get subsetAllocation() {
    return this.#view.getUint32(32, LE);
  }
  
  set subsetAllocation(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkMemoryAllocateFlagsInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryAllocateFlagsInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryAllocateFlagsInfo(new Uint8Array(VkMemoryAllocateFlagsInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkMemoryAllocateFlags;
    deviceMask: number;
  }) {
    const s = VkMemoryAllocateFlagsInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.deviceMask !== undefined) s.deviceMask = data.deviceMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkMemoryAllocateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkBindBufferMemoryInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindBufferMemoryInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindBufferMemoryInfo(new Uint8Array(VkBindBufferMemoryInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
  }) {
    const s = VkBindBufferMemoryInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkBindBufferMemoryDeviceGroupInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindBufferMemoryDeviceGroupInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindBufferMemoryDeviceGroupInfo(new Uint8Array(VkBindBufferMemoryDeviceGroupInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceIndexCount?: number;
    pDeviceIndices: Deno.PointerValue;
  }) {
    const s = VkBindBufferMemoryDeviceGroupInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceIndexCount !== undefined) s.deviceIndexCount = data.deviceIndexCount;
    if (data.pDeviceIndices !== undefined) s.pDeviceIndices = data.pDeviceIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkBindImageMemoryInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindImageMemoryInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindImageMemoryInfo(new Uint8Array(VkBindImageMemoryInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image: VkImage;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
  }) {
    const s = VkBindImageMemoryInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkBindImageMemoryDeviceGroupInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindImageMemoryDeviceGroupInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindImageMemoryDeviceGroupInfo(new Uint8Array(VkBindImageMemoryDeviceGroupInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceIndexCount?: number;
    pDeviceIndices: Deno.PointerValue;
    splitInstanceBindRegionCount?: number;
    pSplitInstanceBindRegions: Deno.PointerValue;
  }) {
    const s = VkBindImageMemoryDeviceGroupInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceIndexCount !== undefined) s.deviceIndexCount = data.deviceIndexCount;
    if (data.pDeviceIndices !== undefined) s.pDeviceIndices = data.pDeviceIndices;
    if (data.splitInstanceBindRegionCount !== undefined) s.splitInstanceBindRegionCount = data.splitInstanceBindRegionCount;
    if (data.pSplitInstanceBindRegions !== undefined) s.pSplitInstanceBindRegions = data.pSplitInstanceBindRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get splitInstanceBindRegionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set splitInstanceBindRegionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSplitInstanceBindRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSplitInstanceBindRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkDeviceGroupRenderPassBeginInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupRenderPassBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupRenderPassBeginInfo(new Uint8Array(VkDeviceGroupRenderPassBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceMask: number;
    deviceRenderAreaCount?: number;
    pDeviceRenderAreas: Deno.PointerValue;
  }) {
    const s = VkDeviceGroupRenderPassBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceMask !== undefined) s.deviceMask = data.deviceMask;
    if (data.deviceRenderAreaCount !== undefined) s.deviceRenderAreaCount = data.deviceRenderAreaCount;
    if (data.pDeviceRenderAreas !== undefined) s.pDeviceRenderAreas = data.pDeviceRenderAreas;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceRenderAreaCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceRenderAreaCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDeviceRenderAreas() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceRenderAreas(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDeviceGroupCommandBufferBeginInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupCommandBufferBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupCommandBufferBeginInfo(new Uint8Array(VkDeviceGroupCommandBufferBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceMask: number;
  }) {
    const s = VkDeviceGroupCommandBufferBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceMask !== undefined) s.deviceMask = data.deviceMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceGroupSubmitInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupSubmitInfo(new Uint8Array(VkDeviceGroupSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreCount?: number;
    pWaitSemaphoreDeviceIndices: Deno.PointerValue;
    commandBufferCount?: number;
    pCommandBufferDeviceMasks: Deno.PointerValue;
    signalSemaphoreCount?: number;
    pSignalSemaphoreDeviceIndices: Deno.PointerValue;
  }) {
    const s = VkDeviceGroupSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreCount !== undefined) s.waitSemaphoreCount = data.waitSemaphoreCount;
    if (data.pWaitSemaphoreDeviceIndices !== undefined) s.pWaitSemaphoreDeviceIndices = data.pWaitSemaphoreDeviceIndices;
    if (data.commandBufferCount !== undefined) s.commandBufferCount = data.commandBufferCount;
    if (data.pCommandBufferDeviceMasks !== undefined) s.pCommandBufferDeviceMasks = data.pCommandBufferDeviceMasks;
    if (data.signalSemaphoreCount !== undefined) s.signalSemaphoreCount = data.signalSemaphoreCount;
    if (data.pSignalSemaphoreDeviceIndices !== undefined) s.pSignalSemaphoreDeviceIndices = data.pSignalSemaphoreDeviceIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreDeviceIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pCommandBufferDeviceMasks() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCommandBufferDeviceMasks(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pSignalSemaphoreDeviceIndices() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pSignalSemaphoreDeviceIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkDeviceGroupBindSparseInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupBindSparseInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupBindSparseInfo(new Uint8Array(VkDeviceGroupBindSparseInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    resourceDeviceIndex: number;
    memoryDeviceIndex: number;
  }) {
    const s = VkDeviceGroupBindSparseInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.resourceDeviceIndex !== undefined) s.resourceDeviceIndex = data.resourceDeviceIndex;
    if (data.memoryDeviceIndex !== undefined) s.memoryDeviceIndex = data.memoryDeviceIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get resourceDeviceIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set resourceDeviceIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryDeviceIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set memoryDeviceIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkDeviceGroupPresentCapabilitiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupPresentCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupPresentCapabilitiesKHR(new Uint8Array(VkDeviceGroupPresentCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentMask: number;
    modes: VkDeviceGroupPresentModeFlagsKHR;
  }) {
    const s = VkDeviceGroupPresentCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentMask !== undefined) s.presentMask = data.presentMask;
    if (data.modes !== undefined) s.modes = data.modes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get modes() {
    return this.#view.getUint32(20, LE);
  }
  
  set modes(value: VkDeviceGroupPresentModeFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkImageSwapchainCreateInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSwapchainCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSwapchainCreateInfoKHR(new Uint8Array(VkImageSwapchainCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchain?: VkSwapchainKHR;
  }) {
    const s = VkImageSwapchainCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchain !== undefined) s.swapchain = data.swapchain;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: VkSwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkBindImageMemorySwapchainInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindImageMemorySwapchainInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindImageMemorySwapchainInfoKHR(new Uint8Array(VkBindImageMemorySwapchainInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchain: VkSwapchainKHR;
    imageIndex: number;
  }) {
    const s = VkBindImageMemorySwapchainInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchain !== undefined) s.swapchain = data.swapchain;
    if (data.imageIndex !== undefined) s.imageIndex = data.imageIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: VkSwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get imageIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkAcquireNextImageInfoKHR implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAcquireNextImageInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAcquireNextImageInfoKHR(new Uint8Array(VkAcquireNextImageInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchain: VkSwapchainKHR;
    timeout: Deno.PointerValue;
    semaphore?: VkSemaphore;
    fence?: VkFence;
    deviceMask: number;
  }) {
    const s = VkAcquireNextImageInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchain !== undefined) s.swapchain = data.swapchain;
    if (data.timeout !== undefined) s.timeout = data.timeout;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.fence !== undefined) s.fence = data.fence;
    if (data.deviceMask !== undefined) s.deviceMask = data.deviceMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: VkSwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get timeout() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set timeout(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set fence(value: VkFence) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(48, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkDeviceGroupPresentInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupPresentInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupPresentInfoKHR(new Uint8Array(VkDeviceGroupPresentInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchainCount?: number;
    pDeviceMasks: Deno.PointerValue;
    mode: VkDeviceGroupPresentModeFlagBitsKHR;
  }) {
    const s = VkDeviceGroupPresentInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchainCount !== undefined) s.swapchainCount = data.swapchainCount;
    if (data.pDeviceMasks !== undefined) s.pDeviceMasks = data.pDeviceMasks;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceMasks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceMasks(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkDeviceGroupPresentModeFlagBitsKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkDeviceGroupDeviceCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupDeviceCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupDeviceCreateInfo(new Uint8Array(VkDeviceGroupDeviceCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    physicalDeviceCount?: number;
    pPhysicalDevices: Deno.PointerValue;
  }) {
    const s = VkDeviceGroupDeviceCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.physicalDeviceCount !== undefined) s.physicalDeviceCount = data.physicalDeviceCount;
    if (data.pPhysicalDevices !== undefined) s.pPhysicalDevices = data.pPhysicalDevices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get physicalDeviceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set physicalDeviceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pPhysicalDevices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPhysicalDevices(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDeviceGroupSwapchainCreateInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceGroupSwapchainCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceGroupSwapchainCreateInfoKHR(new Uint8Array(VkDeviceGroupSwapchainCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    modes: VkDeviceGroupPresentModeFlagsKHR;
  }) {
    const s = VkDeviceGroupSwapchainCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.modes !== undefined) s.modes = data.modes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get modes() {
    return this.#view.getUint32(16, LE);
  }
  
  set modes(value: VkDeviceGroupPresentModeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDescriptorUpdateTemplateEntry implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorUpdateTemplateEntry.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorUpdateTemplateEntry(new Uint8Array(VkDescriptorUpdateTemplateEntry.size));
  }
  
  static create(data: {
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number;
    descriptorType: VkDescriptorType;
    offset: Deno.PointerValue;
    stride: Deno.PointerValue;
  }) {
    const s = VkDescriptorUpdateTemplateEntry.alloc();
    if (data.dstBinding !== undefined) s.dstBinding = data.dstBinding;
    if (data.dstArrayElement !== undefined) s.dstArrayElement = data.dstArrayElement;
    if (data.descriptorCount !== undefined) s.descriptorCount = data.descriptorCount;
    if (data.descriptorType !== undefined) s.descriptorType = data.descriptorType;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.stride !== undefined) s.stride = data.stride;
    return s;
  }
  
  get dstBinding() {
    return this.#view.getUint32(0, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(12, LE);
  }
  
  set descriptorType(value: VkDescriptorType) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set offset(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get stride() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set stride(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorUpdateTemplateCreateInfo implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorUpdateTemplateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorUpdateTemplateCreateInfo(new Uint8Array(VkDescriptorUpdateTemplateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDescriptorUpdateTemplateCreateFlags;
    descriptorUpdateEntryCount: number;
    pDescriptorUpdateEntries: Deno.PointerValue;
    templateType: VkDescriptorUpdateTemplateType;
    descriptorSetLayout: VkDescriptorSetLayout;
    pipelineBindPoint: VkPipelineBindPoint;
    pipelineLayout: VkPipelineLayout;
    set: number;
  }) {
    const s = VkDescriptorUpdateTemplateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.descriptorUpdateEntryCount !== undefined) s.descriptorUpdateEntryCount = data.descriptorUpdateEntryCount;
    if (data.pDescriptorUpdateEntries !== undefined) s.pDescriptorUpdateEntries = data.pDescriptorUpdateEntries;
    if (data.templateType !== undefined) s.templateType = data.templateType;
    if (data.descriptorSetLayout !== undefined) s.descriptorSetLayout = data.descriptorSetLayout;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.pipelineLayout !== undefined) s.pipelineLayout = data.pipelineLayout;
    if (data.set !== undefined) s.set = data.set;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDescriptorUpdateTemplateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorUpdateEntryCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorUpdateEntryCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDescriptorUpdateEntries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDescriptorUpdateEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get templateType() {
    return this.#view.getUint32(32, LE);
  }
  
  set templateType(value: VkDescriptorUpdateTemplateType) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get descriptorSetLayout() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set descriptorSetLayout(value: VkDescriptorSetLayout) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(48, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pipelineLayout() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pipelineLayout(value: VkPipelineLayout) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get set() {
    return this.#view.getUint32(64, LE);
  }
  
  set set(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
}

/** Chromaticity coordinate */
export class VkXYColorEXT implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkXYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkXYColorEXT(new Uint8Array(VkXYColorEXT.size));
  }
  
  static create(data: {
    x: number;
    y: number;
  }) {
    const s = VkXYColorEXT.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    return s;
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export class VkPhysicalDevicePresentIdFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePresentIdFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePresentIdFeaturesKHR(new Uint8Array(VkPhysicalDevicePresentIdFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentId: VkBool32;
  }) {
    const s = VkPhysicalDevicePresentIdFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentId !== undefined) s.presentId = data.presentId;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentId() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentId(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPresentIdKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentIdKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentIdKHR(new Uint8Array(VkPresentIdKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchainCount: number;
    pPresentIds?: Deno.PointerValue;
  }) {
    const s = VkPresentIdKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchainCount !== undefined) s.swapchainCount = data.swapchainCount;
    if (data.pPresentIds !== undefined) s.pPresentIds = data.pPresentIds;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pPresentIds() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPresentIds(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDevicePresentWaitFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePresentWaitFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePresentWaitFeaturesKHR(new Uint8Array(VkPhysicalDevicePresentWaitFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentWait: VkBool32;
  }) {
    const s = VkPhysicalDevicePresentWaitFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentWait !== undefined) s.presentWait = data.presentWait;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentWait() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentWait(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkHdrMetadataEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkHdrMetadataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkHdrMetadataEXT(new Uint8Array(VkHdrMetadataEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    displayPrimaryRed: VkXYColorEXT;
    displayPrimaryGreen: VkXYColorEXT;
    displayPrimaryBlue: VkXYColorEXT;
    whitePoint: VkXYColorEXT;
    maxLuminance: number;
    minLuminance: number;
    maxContentLightLevel: number;
    maxFrameAverageLightLevel: number;
  }) {
    const s = VkHdrMetadataEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.displayPrimaryRed !== undefined) s.displayPrimaryRed = data.displayPrimaryRed;
    if (data.displayPrimaryGreen !== undefined) s.displayPrimaryGreen = data.displayPrimaryGreen;
    if (data.displayPrimaryBlue !== undefined) s.displayPrimaryBlue = data.displayPrimaryBlue;
    if (data.whitePoint !== undefined) s.whitePoint = data.whitePoint;
    if (data.maxLuminance !== undefined) s.maxLuminance = data.maxLuminance;
    if (data.minLuminance !== undefined) s.minLuminance = data.minLuminance;
    if (data.maxContentLightLevel !== undefined) s.maxContentLightLevel = data.maxContentLightLevel;
    if (data.maxFrameAverageLightLevel !== undefined) s.maxFrameAverageLightLevel = data.maxFrameAverageLightLevel;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get displayPrimaryRed() {
    return new VkXYColorEXT(this.#data.subarray(16, 16 + VkXYColorEXT.size));
  }
  
  set displayPrimaryRed(value: VkXYColorEXT) {
    if (value[BUFFER].byteLength < VkXYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get displayPrimaryGreen() {
    return new VkXYColorEXT(this.#data.subarray(24, 24 + VkXYColorEXT.size));
  }
  
  set displayPrimaryGreen(value: VkXYColorEXT) {
    if (value[BUFFER].byteLength < VkXYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get displayPrimaryBlue() {
    return new VkXYColorEXT(this.#data.subarray(32, 32 + VkXYColorEXT.size));
  }
  
  set displayPrimaryBlue(value: VkXYColorEXT) {
    if (value[BUFFER].byteLength < VkXYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get whitePoint() {
    return new VkXYColorEXT(this.#data.subarray(40, 40 + VkXYColorEXT.size));
  }
  
  set whitePoint(value: VkXYColorEXT) {
    if (value[BUFFER].byteLength < VkXYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get maxLuminance() {
    return this.#view.getFloat32(48, LE);
  }
  
  set maxLuminance(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get minLuminance() {
    return this.#view.getFloat32(52, LE);
  }
  
  set minLuminance(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get maxContentLightLevel() {
    return this.#view.getFloat32(56, LE);
  }
  
  set maxContentLightLevel(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
  
  get maxFrameAverageLightLevel() {
    return this.#view.getFloat32(60, LE);
  }
  
  set maxFrameAverageLightLevel(value: number) {
    this.#view.setFloat32(60, Number(value), LE);
  }
}

export class VkDisplayNativeHdrSurfaceCapabilitiesAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayNativeHdrSurfaceCapabilitiesAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayNativeHdrSurfaceCapabilitiesAMD(new Uint8Array(VkDisplayNativeHdrSurfaceCapabilitiesAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    localDimmingSupport: VkBool32;
  }) {
    const s = VkDisplayNativeHdrSurfaceCapabilitiesAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.localDimmingSupport !== undefined) s.localDimmingSupport = data.localDimmingSupport;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get localDimmingSupport() {
    return this.#view.getUint32(16, LE);
  }
  
  set localDimmingSupport(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSwapchainDisplayNativeHdrCreateInfoAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSwapchainDisplayNativeHdrCreateInfoAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSwapchainDisplayNativeHdrCreateInfoAMD(new Uint8Array(VkSwapchainDisplayNativeHdrCreateInfoAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    localDimmingEnable: VkBool32;
  }) {
    const s = VkSwapchainDisplayNativeHdrCreateInfoAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.localDimmingEnable !== undefined) s.localDimmingEnable = data.localDimmingEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get localDimmingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set localDimmingEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkRefreshCycleDurationGOOGLE implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRefreshCycleDurationGOOGLE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRefreshCycleDurationGOOGLE(new Uint8Array(VkRefreshCycleDurationGOOGLE.size));
  }
  
  static create(data: {
    refreshDuration: Deno.PointerValue;
  }) {
    const s = VkRefreshCycleDurationGOOGLE.alloc();
    if (data.refreshDuration !== undefined) s.refreshDuration = data.refreshDuration;
    return s;
  }
  
  get refreshDuration() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set refreshDuration(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
}

export class VkPastPresentationTimingGOOGLE implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPastPresentationTimingGOOGLE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPastPresentationTimingGOOGLE(new Uint8Array(VkPastPresentationTimingGOOGLE.size));
  }
  
  static create(data: {
    presentID: number;
    desiredPresentTime: Deno.PointerValue;
    actualPresentTime: Deno.PointerValue;
    earliestPresentTime: Deno.PointerValue;
    presentMargin: Deno.PointerValue;
  }) {
    const s = VkPastPresentationTimingGOOGLE.alloc();
    if (data.presentID !== undefined) s.presentID = data.presentID;
    if (data.desiredPresentTime !== undefined) s.desiredPresentTime = data.desiredPresentTime;
    if (data.actualPresentTime !== undefined) s.actualPresentTime = data.actualPresentTime;
    if (data.earliestPresentTime !== undefined) s.earliestPresentTime = data.earliestPresentTime;
    if (data.presentMargin !== undefined) s.presentMargin = data.presentMargin;
    return s;
  }
  
  get presentID() {
    return this.#view.getUint32(0, LE);
  }
  
  set presentID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get desiredPresentTime() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set desiredPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get actualPresentTime() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set actualPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get earliestPresentTime() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set earliestPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get presentMargin() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set presentMargin(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPresentTimesInfoGOOGLE implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentTimesInfoGOOGLE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentTimesInfoGOOGLE(new Uint8Array(VkPresentTimesInfoGOOGLE.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    swapchainCount: number;
    pTimes?: Deno.PointerValue;
  }) {
    const s = VkPresentTimesInfoGOOGLE.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.swapchainCount !== undefined) s.swapchainCount = data.swapchainCount;
    if (data.pTimes !== undefined) s.pTimes = data.pTimes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pTimes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pTimes(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPresentTimeGOOGLE implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentTimeGOOGLE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentTimeGOOGLE(new Uint8Array(VkPresentTimeGOOGLE.size));
  }
  
  static create(data: {
    presentID: number;
    desiredPresentTime: Deno.PointerValue;
  }) {
    const s = VkPresentTimeGOOGLE.alloc();
    if (data.presentID !== undefined) s.presentID = data.presentID;
    if (data.desiredPresentTime !== undefined) s.desiredPresentTime = data.desiredPresentTime;
    return s;
  }
  
  get presentID() {
    return this.#view.getUint32(0, LE);
  }
  
  set presentID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get desiredPresentTime() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set desiredPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkIOSSurfaceCreateInfoMVK implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkIOSSurfaceCreateInfoMVK.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkIOSSurfaceCreateInfoMVK(new Uint8Array(VkIOSSurfaceCreateInfoMVK.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkIOSSurfaceCreateFlagsMVK;
    pView: Deno.PointerValue;
  }) {
    const s = VkIOSSurfaceCreateInfoMVK.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pView !== undefined) s.pView = data.pView;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkIOSSurfaceCreateFlagsMVK) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pView(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkMacOSSurfaceCreateInfoMVK implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMacOSSurfaceCreateInfoMVK.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMacOSSurfaceCreateInfoMVK(new Uint8Array(VkMacOSSurfaceCreateInfoMVK.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkMacOSSurfaceCreateFlagsMVK;
    pView: Deno.PointerValue;
  }) {
    const s = VkMacOSSurfaceCreateInfoMVK.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pView !== undefined) s.pView = data.pView;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkMacOSSurfaceCreateFlagsMVK) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pView(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkMetalSurfaceCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMetalSurfaceCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMetalSurfaceCreateInfoEXT(new Uint8Array(VkMetalSurfaceCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkMetalSurfaceCreateFlagsEXT;
    pLayer: Deno.PointerValue;
  }) {
    const s = VkMetalSurfaceCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pLayer !== undefined) s.pLayer = data.pLayer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkMetalSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pLayer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pLayer(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkViewportWScalingNV implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkViewportWScalingNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkViewportWScalingNV(new Uint8Array(VkViewportWScalingNV.size));
  }
  
  static create(data: {
    xcoeff: number;
    ycoeff: number;
  }) {
    const s = VkViewportWScalingNV.alloc();
    if (data.xcoeff !== undefined) s.xcoeff = data.xcoeff;
    if (data.ycoeff !== undefined) s.ycoeff = data.ycoeff;
    return s;
  }
  
  get xcoeff() {
    return this.#view.getFloat32(0, LE);
  }
  
  set xcoeff(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get ycoeff() {
    return this.#view.getFloat32(4, LE);
  }
  
  set ycoeff(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export class VkPipelineViewportWScalingStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportWScalingStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportWScalingStateCreateInfoNV(new Uint8Array(VkPipelineViewportWScalingStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    viewportWScalingEnable: VkBool32;
    viewportCount: number;
    pViewportWScalings?: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportWScalingStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.viewportWScalingEnable !== undefined) s.viewportWScalingEnable = data.viewportWScalingEnable;
    if (data.viewportCount !== undefined) s.viewportCount = data.viewportCount;
    if (data.pViewportWScalings !== undefined) s.pViewportWScalings = data.pViewportWScalings;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get viewportWScalingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewportWScalingEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportWScalings() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportWScalings(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkViewportSwizzleNV implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkViewportSwizzleNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkViewportSwizzleNV(new Uint8Array(VkViewportSwizzleNV.size));
  }
  
  static create(data: {
    x: VkViewportCoordinateSwizzleNV;
    y: VkViewportCoordinateSwizzleNV;
    z: VkViewportCoordinateSwizzleNV;
    w: VkViewportCoordinateSwizzleNV;
  }) {
    const s = VkViewportSwizzleNV.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    if (data.z !== undefined) s.z = data.z;
    if (data.w !== undefined) s.w = data.w;
    return s;
  }
  
  get x() {
    return this.#view.getUint32(0, LE);
  }
  
  set x(value: VkViewportCoordinateSwizzleNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getUint32(4, LE);
  }
  
  set y(value: VkViewportCoordinateSwizzleNV) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getUint32(8, LE);
  }
  
  set z(value: VkViewportCoordinateSwizzleNV) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get w() {
    return this.#view.getUint32(12, LE);
  }
  
  set w(value: VkViewportCoordinateSwizzleNV) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkPipelineViewportSwizzleStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportSwizzleStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportSwizzleStateCreateInfoNV(new Uint8Array(VkPipelineViewportSwizzleStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineViewportSwizzleStateCreateFlagsNV;
    viewportCount: number;
    pViewportSwizzles: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportSwizzleStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.viewportCount !== undefined) s.viewportCount = data.viewportCount;
    if (data.pViewportSwizzles !== undefined) s.pViewportSwizzles = data.pViewportSwizzles;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineViewportSwizzleStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportSwizzles() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportSwizzles(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDiscardRectanglePropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDiscardRectanglePropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDiscardRectanglePropertiesEXT(new Uint8Array(VkPhysicalDeviceDiscardRectanglePropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxDiscardRectangles: number;
  }) {
    const s = VkPhysicalDeviceDiscardRectanglePropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxDiscardRectangles !== undefined) s.maxDiscardRectangles = data.maxDiscardRectangles;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxDiscardRectangles() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxDiscardRectangles(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineDiscardRectangleStateCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineDiscardRectangleStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineDiscardRectangleStateCreateInfoEXT(new Uint8Array(VkPipelineDiscardRectangleStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineDiscardRectangleStateCreateFlagsEXT;
    discardRectangleMode: VkDiscardRectangleModeEXT;
    discardRectangleCount?: number;
    pDiscardRectangles: Deno.PointerValue;
  }) {
    const s = VkPipelineDiscardRectangleStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.discardRectangleMode !== undefined) s.discardRectangleMode = data.discardRectangleMode;
    if (data.discardRectangleCount !== undefined) s.discardRectangleCount = data.discardRectangleCount;
    if (data.pDiscardRectangles !== undefined) s.pDiscardRectangles = data.pDiscardRectangles;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineDiscardRectangleStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get discardRectangleMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set discardRectangleMode(value: VkDiscardRectangleModeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get discardRectangleCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set discardRectangleCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pDiscardRectangles() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pDiscardRectangles(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(new Uint8Array(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    perViewPositionAllComponents: VkBool32;
  }) {
    const s = VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.perViewPositionAllComponents !== undefined) s.perViewPositionAllComponents = data.perViewPositionAllComponents;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get perViewPositionAllComponents() {
    return this.#view.getUint32(16, LE);
  }
  
  set perViewPositionAllComponents(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkInputAttachmentAspectReference implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkInputAttachmentAspectReference.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkInputAttachmentAspectReference(new Uint8Array(VkInputAttachmentAspectReference.size));
  }
  
  static create(data: {
    subpass: number;
    inputAttachmentIndex: number;
    aspectMask: VkImageAspectFlags;
  }) {
    const s = VkInputAttachmentAspectReference.alloc();
    if (data.subpass !== undefined) s.subpass = data.subpass;
    if (data.inputAttachmentIndex !== undefined) s.inputAttachmentIndex = data.inputAttachmentIndex;
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    return s;
  }
  
  get subpass() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get inputAttachmentIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set inputAttachmentIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get aspectMask() {
    return this.#view.getUint32(8, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkRenderPassInputAttachmentAspectCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassInputAttachmentAspectCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassInputAttachmentAspectCreateInfo(new Uint8Array(VkRenderPassInputAttachmentAspectCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    aspectReferenceCount: number;
    pAspectReferences: Deno.PointerValue;
  }) {
    const s = VkRenderPassInputAttachmentAspectCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.aspectReferenceCount !== undefined) s.aspectReferenceCount = data.aspectReferenceCount;
    if (data.pAspectReferences !== undefined) s.pAspectReferences = data.pAspectReferences;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get aspectReferenceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set aspectReferenceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAspectReferences() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAspectReferences(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceSurfaceInfo2KHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSurfaceInfo2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSurfaceInfo2KHR(new Uint8Array(VkPhysicalDeviceSurfaceInfo2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    surface?: VkSurfaceKHR;
  }) {
    const s = VkPhysicalDeviceSurfaceInfo2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.surface !== undefined) s.surface = data.surface;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set surface(value: VkSurfaceKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSurfaceCapabilities2KHR implements IVkStructure {
  static size = 112;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceCapabilities2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceCapabilities2KHR(new Uint8Array(VkSurfaceCapabilities2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    surfaceCapabilities: VkSurfaceCapabilitiesKHR;
  }) {
    const s = VkSurfaceCapabilities2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.surfaceCapabilities !== undefined) s.surfaceCapabilities = data.surfaceCapabilities;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get surfaceCapabilities() {
    return new VkSurfaceCapabilitiesKHR(this.#data.subarray(56, 56 + VkSurfaceCapabilitiesKHR.size));
  }
  
  set surfaceCapabilities(value: VkSurfaceCapabilitiesKHR) {
    if (value[BUFFER].byteLength < VkSurfaceCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
}

export class VkSurfaceFormat2KHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceFormat2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceFormat2KHR(new Uint8Array(VkSurfaceFormat2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    surfaceFormat: VkSurfaceFormatKHR;
  }) {
    const s = VkSurfaceFormat2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.surfaceFormat !== undefined) s.surfaceFormat = data.surfaceFormat;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get surfaceFormat() {
    return new VkSurfaceFormatKHR(this.#data.subarray(16, 16 + VkSurfaceFormatKHR.size));
  }
  
  set surfaceFormat(value: VkSurfaceFormatKHR) {
    if (value[BUFFER].byteLength < VkSurfaceFormatKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkDisplayProperties2KHR implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayProperties2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayProperties2KHR(new Uint8Array(VkDisplayProperties2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    displayProperties: VkDisplayPropertiesKHR;
  }) {
    const s = VkDisplayProperties2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.displayProperties !== undefined) s.displayProperties = data.displayProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get displayProperties() {
    return new VkDisplayPropertiesKHR(this.#data.subarray(48, 48 + VkDisplayPropertiesKHR.size));
  }
  
  set displayProperties(value: VkDisplayPropertiesKHR) {
    if (value[BUFFER].byteLength < VkDisplayPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkDisplayPlaneProperties2KHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPlaneProperties2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPlaneProperties2KHR(new Uint8Array(VkDisplayPlaneProperties2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    displayPlaneProperties: VkDisplayPlanePropertiesKHR;
  }) {
    const s = VkDisplayPlaneProperties2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.displayPlaneProperties !== undefined) s.displayPlaneProperties = data.displayPlaneProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get displayPlaneProperties() {
    return new VkDisplayPlanePropertiesKHR(this.#data.subarray(16, 16 + VkDisplayPlanePropertiesKHR.size));
  }
  
  set displayPlaneProperties(value: VkDisplayPlanePropertiesKHR) {
    if (value[BUFFER].byteLength < VkDisplayPlanePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkDisplayModeProperties2KHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayModeProperties2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayModeProperties2KHR(new Uint8Array(VkDisplayModeProperties2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    displayModeProperties: VkDisplayModePropertiesKHR;
  }) {
    const s = VkDisplayModeProperties2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.displayModeProperties !== undefined) s.displayModeProperties = data.displayModeProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get displayModeProperties() {
    return new VkDisplayModePropertiesKHR(this.#data.subarray(32, 32 + VkDisplayModePropertiesKHR.size));
  }
  
  set displayModeProperties(value: VkDisplayModePropertiesKHR) {
    if (value[BUFFER].byteLength < VkDisplayModePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkDisplayPlaneInfo2KHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPlaneInfo2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPlaneInfo2KHR(new Uint8Array(VkDisplayPlaneInfo2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mode: VkDisplayModeKHR;
    planeIndex: number;
  }) {
    const s = VkDisplayPlaneInfo2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mode !== undefined) s.mode = data.mode;
    if (data.planeIndex !== undefined) s.planeIndex = data.planeIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mode(value: VkDisplayModeKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get planeIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set planeIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkDisplayPlaneCapabilities2KHR implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDisplayPlaneCapabilities2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDisplayPlaneCapabilities2KHR(new Uint8Array(VkDisplayPlaneCapabilities2KHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    capabilities: VkDisplayPlaneCapabilitiesKHR;
  }) {
    const s = VkDisplayPlaneCapabilities2KHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.capabilities !== undefined) s.capabilities = data.capabilities;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get capabilities() {
    return new VkDisplayPlaneCapabilitiesKHR(this.#data.subarray(72, 72 + VkDisplayPlaneCapabilitiesKHR.size));
  }
  
  set capabilities(value: VkDisplayPlaneCapabilitiesKHR) {
    if (value[BUFFER].byteLength < VkDisplayPlaneCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export class VkSharedPresentSurfaceCapabilitiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSharedPresentSurfaceCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSharedPresentSurfaceCapabilitiesKHR(new Uint8Array(VkSharedPresentSurfaceCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sharedPresentSupportedUsageFlags?: VkImageUsageFlags;
  }) {
    const s = VkSharedPresentSurfaceCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sharedPresentSupportedUsageFlags !== undefined) s.sharedPresentSupportedUsageFlags = data.sharedPresentSupportedUsageFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sharedPresentSupportedUsageFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set sharedPresentSupportedUsageFlags(value: VkImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevice16BitStorageFeatures implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevice16BitStorageFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevice16BitStorageFeatures(new Uint8Array(VkPhysicalDevice16BitStorageFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    storageBuffer16BitAccess: VkBool32;
    uniformAndStorageBuffer16BitAccess: VkBool32;
    storagePushConstant16: VkBool32;
    storageInputOutput16: VkBool32;
  }) {
    const s = VkPhysicalDevice16BitStorageFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.storageBuffer16BitAccess !== undefined) s.storageBuffer16BitAccess = data.storageBuffer16BitAccess;
    if (data.uniformAndStorageBuffer16BitAccess !== undefined) s.uniformAndStorageBuffer16BitAccess = data.uniformAndStorageBuffer16BitAccess;
    if (data.storagePushConstant16 !== undefined) s.storagePushConstant16 = data.storagePushConstant16;
    if (data.storageInputOutput16 !== undefined) s.storageInputOutput16 = data.storageInputOutput16;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get storageBuffer16BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer16BitAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer16BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer16BitAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant16() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant16(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get storageInputOutput16() {
    return this.#view.getUint32(28, LE);
  }
  
  set storageInputOutput16(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceSubgroupProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubgroupProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubgroupProperties(new Uint8Array(VkPhysicalDeviceSubgroupProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subgroupSize: number;
    supportedStages: VkShaderStageFlags;
    supportedOperations: VkSubgroupFeatureFlags;
    quadOperationsInAllStages: VkBool32;
  }) {
    const s = VkPhysicalDeviceSubgroupProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subgroupSize !== undefined) s.subgroupSize = data.subgroupSize;
    if (data.supportedStages !== undefined) s.supportedStages = data.supportedStages;
    if (data.supportedOperations !== undefined) s.supportedOperations = data.supportedOperations;
    if (data.quadOperationsInAllStages !== undefined) s.quadOperationsInAllStages = data.quadOperationsInAllStages;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedStages() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedStages(value: VkShaderStageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get supportedOperations() {
    return this.#view.getUint32(24, LE);
  }
  
  set supportedOperations(value: VkSubgroupFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get quadOperationsInAllStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set quadOperationsInAllStages(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(new Uint8Array(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderSubgroupExtendedTypes: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderSubgroupExtendedTypes !== undefined) s.shaderSubgroupExtendedTypes = data.shaderSubgroupExtendedTypes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderSubgroupExtendedTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupExtendedTypes(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkBufferMemoryRequirementsInfo2 implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferMemoryRequirementsInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferMemoryRequirementsInfo2(new Uint8Array(VkBufferMemoryRequirementsInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
  }) {
    const s = VkBufferMemoryRequirementsInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDeviceBufferMemoryRequirements implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceBufferMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceBufferMemoryRequirements(new Uint8Array(VkDeviceBufferMemoryRequirements.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pCreateInfo: Deno.PointerValue;
  }) {
    const s = VkDeviceBufferMemoryRequirements.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pCreateInfo !== undefined) s.pCreateInfo = data.pCreateInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pCreateInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pCreateInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkImageMemoryRequirementsInfo2 implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageMemoryRequirementsInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageMemoryRequirementsInfo2(new Uint8Array(VkImageMemoryRequirementsInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image: VkImage;
  }) {
    const s = VkImageMemoryRequirementsInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkImageSparseMemoryRequirementsInfo2 implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSparseMemoryRequirementsInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSparseMemoryRequirementsInfo2(new Uint8Array(VkImageSparseMemoryRequirementsInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image: VkImage;
  }) {
    const s = VkImageSparseMemoryRequirementsInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDeviceImageMemoryRequirements implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceImageMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceImageMemoryRequirements(new Uint8Array(VkDeviceImageMemoryRequirements.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pCreateInfo: Deno.PointerValue;
    planeAspect?: VkImageAspectFlagBits;
  }) {
    const s = VkDeviceImageMemoryRequirements.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pCreateInfo !== undefined) s.pCreateInfo = data.pCreateInfo;
    if (data.planeAspect !== undefined) s.planeAspect = data.planeAspect;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pCreateInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pCreateInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(24, LE);
  }
  
  set planeAspect(value: VkImageAspectFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkMemoryRequirements2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryRequirements2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryRequirements2(new Uint8Array(VkMemoryRequirements2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryRequirements: VkMemoryRequirements;
  }) {
    const s = VkMemoryRequirements2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryRequirements !== undefined) s.memoryRequirements = data.memoryRequirements;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryRequirements() {
    return new VkMemoryRequirements(this.#data.subarray(24, 24 + VkMemoryRequirements.size));
  }
  
  set memoryRequirements(value: VkMemoryRequirements) {
    if (value[BUFFER].byteLength < VkMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkSparseImageMemoryRequirements2 implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSparseImageMemoryRequirements2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSparseImageMemoryRequirements2(new Uint8Array(VkSparseImageMemoryRequirements2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryRequirements: VkSparseImageMemoryRequirements;
  }) {
    const s = VkSparseImageMemoryRequirements2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryRequirements !== undefined) s.memoryRequirements = data.memoryRequirements;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryRequirements() {
    return new VkSparseImageMemoryRequirements(this.#data.subarray(72, 72 + VkSparseImageMemoryRequirements.size));
  }
  
  set memoryRequirements(value: VkSparseImageMemoryRequirements) {
    if (value[BUFFER].byteLength < VkSparseImageMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export class VkPhysicalDevicePointClippingProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePointClippingProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePointClippingProperties(new Uint8Array(VkPhysicalDevicePointClippingProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pointClippingBehavior: VkPointClippingBehavior;
  }) {
    const s = VkPhysicalDevicePointClippingProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pointClippingBehavior !== undefined) s.pointClippingBehavior = data.pointClippingBehavior;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pointClippingBehavior() {
    return this.#view.getUint32(16, LE);
  }
  
  set pointClippingBehavior(value: VkPointClippingBehavior) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryDedicatedRequirements implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryDedicatedRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryDedicatedRequirements(new Uint8Array(VkMemoryDedicatedRequirements.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    prefersDedicatedAllocation: VkBool32;
    requiresDedicatedAllocation: VkBool32;
  }) {
    const s = VkMemoryDedicatedRequirements.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.prefersDedicatedAllocation !== undefined) s.prefersDedicatedAllocation = data.prefersDedicatedAllocation;
    if (data.requiresDedicatedAllocation !== undefined) s.requiresDedicatedAllocation = data.requiresDedicatedAllocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get prefersDedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set prefersDedicatedAllocation(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get requiresDedicatedAllocation() {
    return this.#view.getUint32(20, LE);
  }
  
  set requiresDedicatedAllocation(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkMemoryDedicatedAllocateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryDedicatedAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryDedicatedAllocateInfo(new Uint8Array(VkMemoryDedicatedAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image?: VkImage;
    buffer?: VkBuffer;
  }) {
    const s = VkMemoryDedicatedAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkImageViewUsageCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewUsageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewUsageCreateInfo(new Uint8Array(VkImageViewUsageCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    usage: VkImageUsageFlags;
  }) {
    const s = VkImageViewUsageCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.usage !== undefined) s.usage = data.usage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: VkImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineTessellationDomainOriginStateCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineTessellationDomainOriginStateCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineTessellationDomainOriginStateCreateInfo(new Uint8Array(VkPipelineTessellationDomainOriginStateCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    domainOrigin: VkTessellationDomainOrigin;
  }) {
    const s = VkPipelineTessellationDomainOriginStateCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.domainOrigin !== undefined) s.domainOrigin = data.domainOrigin;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get domainOrigin() {
    return this.#view.getUint32(16, LE);
  }
  
  set domainOrigin(value: VkTessellationDomainOrigin) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSamplerYcbcrConversionInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerYcbcrConversionInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerYcbcrConversionInfo(new Uint8Array(VkSamplerYcbcrConversionInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    conversion: VkSamplerYcbcrConversion;
  }) {
    const s = VkSamplerYcbcrConversionInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.conversion !== undefined) s.conversion = data.conversion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get conversion() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set conversion(value: VkSamplerYcbcrConversion) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSamplerYcbcrConversionCreateInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerYcbcrConversionCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerYcbcrConversionCreateInfo(new Uint8Array(VkSamplerYcbcrConversionCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    ycbcrModel: VkSamplerYcbcrModelConversion;
    ycbcrRange: VkSamplerYcbcrRange;
    components: VkComponentMapping;
    xChromaOffset: VkChromaLocation;
    yChromaOffset: VkChromaLocation;
    chromaFilter: VkFilter;
    forceExplicitReconstruction: VkBool32;
  }) {
    const s = VkSamplerYcbcrConversionCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.ycbcrModel !== undefined) s.ycbcrModel = data.ycbcrModel;
    if (data.ycbcrRange !== undefined) s.ycbcrRange = data.ycbcrRange;
    if (data.components !== undefined) s.components = data.components;
    if (data.xChromaOffset !== undefined) s.xChromaOffset = data.xChromaOffset;
    if (data.yChromaOffset !== undefined) s.yChromaOffset = data.yChromaOffset;
    if (data.chromaFilter !== undefined) s.chromaFilter = data.chromaFilter;
    if (data.forceExplicitReconstruction !== undefined) s.forceExplicitReconstruction = data.forceExplicitReconstruction;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get ycbcrModel() {
    return this.#view.getUint32(20, LE);
  }
  
  set ycbcrModel(value: VkSamplerYcbcrModelConversion) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get ycbcrRange() {
    return this.#view.getUint32(24, LE);
  }
  
  set ycbcrRange(value: VkSamplerYcbcrRange) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get components() {
    return new VkComponentMapping(this.#data.subarray(32, 32 + VkComponentMapping.size));
  }
  
  set components(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get xChromaOffset() {
    return this.#view.getUint32(48, LE);
  }
  
  set xChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get yChromaOffset() {
    return this.#view.getUint32(52, LE);
  }
  
  set yChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get chromaFilter() {
    return this.#view.getUint32(56, LE);
  }
  
  set chromaFilter(value: VkFilter) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get forceExplicitReconstruction() {
    return this.#view.getUint32(60, LE);
  }
  
  set forceExplicitReconstruction(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class VkBindImagePlaneMemoryInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindImagePlaneMemoryInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindImagePlaneMemoryInfo(new Uint8Array(VkBindImagePlaneMemoryInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    planeAspect: VkImageAspectFlagBits;
  }) {
    const s = VkBindImagePlaneMemoryInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.planeAspect !== undefined) s.planeAspect = data.planeAspect;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(16, LE);
  }
  
  set planeAspect(value: VkImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImagePlaneMemoryRequirementsInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImagePlaneMemoryRequirementsInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImagePlaneMemoryRequirementsInfo(new Uint8Array(VkImagePlaneMemoryRequirementsInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    planeAspect: VkImageAspectFlagBits;
  }) {
    const s = VkImagePlaneMemoryRequirementsInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.planeAspect !== undefined) s.planeAspect = data.planeAspect;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(16, LE);
  }
  
  set planeAspect(value: VkImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceSamplerYcbcrConversionFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSamplerYcbcrConversionFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSamplerYcbcrConversionFeatures(new Uint8Array(VkPhysicalDeviceSamplerYcbcrConversionFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    samplerYcbcrConversion: VkBool32;
  }) {
    const s = VkPhysicalDeviceSamplerYcbcrConversionFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.samplerYcbcrConversion !== undefined) s.samplerYcbcrConversion = data.samplerYcbcrConversion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get samplerYcbcrConversion() {
    return this.#view.getUint32(16, LE);
  }
  
  set samplerYcbcrConversion(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSamplerYcbcrConversionImageFormatProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerYcbcrConversionImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerYcbcrConversionImageFormatProperties(new Uint8Array(VkSamplerYcbcrConversionImageFormatProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    combinedImageSamplerDescriptorCount: number;
  }) {
    const s = VkSamplerYcbcrConversionImageFormatProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.combinedImageSamplerDescriptorCount !== undefined) s.combinedImageSamplerDescriptorCount = data.combinedImageSamplerDescriptorCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get combinedImageSamplerDescriptorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set combinedImageSamplerDescriptorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkTextureLODGatherFormatPropertiesAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTextureLODGatherFormatPropertiesAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTextureLODGatherFormatPropertiesAMD(new Uint8Array(VkTextureLODGatherFormatPropertiesAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supportsTextureGatherLODBiasAMD: VkBool32;
  }) {
    const s = VkTextureLODGatherFormatPropertiesAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supportsTextureGatherLODBiasAMD !== undefined) s.supportsTextureGatherLODBiasAMD = data.supportsTextureGatherLODBiasAMD;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supportsTextureGatherLODBiasAMD() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportsTextureGatherLODBiasAMD(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkConditionalRenderingBeginInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkConditionalRenderingBeginInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkConditionalRenderingBeginInfoEXT(new Uint8Array(VkConditionalRenderingBeginInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    flags?: VkConditionalRenderingFlagsEXT;
  }) {
    const s = VkConditionalRenderingBeginInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: VkConditionalRenderingFlagsEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkProtectedSubmitInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkProtectedSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkProtectedSubmitInfo(new Uint8Array(VkProtectedSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    protectedSubmit: VkBool32;
  }) {
    const s = VkProtectedSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.protectedSubmit !== undefined) s.protectedSubmit = data.protectedSubmit;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get protectedSubmit() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedSubmit(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceProtectedMemoryFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProtectedMemoryFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProtectedMemoryFeatures(new Uint8Array(VkPhysicalDeviceProtectedMemoryFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    protectedMemory: VkBool32;
  }) {
    const s = VkPhysicalDeviceProtectedMemoryFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.protectedMemory !== undefined) s.protectedMemory = data.protectedMemory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get protectedMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedMemory(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceProtectedMemoryProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProtectedMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProtectedMemoryProperties(new Uint8Array(VkPhysicalDeviceProtectedMemoryProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    protectedNoFault: VkBool32;
  }) {
    const s = VkPhysicalDeviceProtectedMemoryProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.protectedNoFault !== undefined) s.protectedNoFault = data.protectedNoFault;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get protectedNoFault() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedNoFault(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceQueueInfo2 implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceQueueInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceQueueInfo2(new Uint8Array(VkDeviceQueueInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDeviceQueueCreateFlags;
    queueFamilyIndex: number;
    queueIndex: number;
  }) {
    const s = VkDeviceQueueInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.queueFamilyIndex !== undefined) s.queueFamilyIndex = data.queueFamilyIndex;
    if (data.queueIndex !== undefined) s.queueIndex = data.queueIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceQueueCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queueIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set queueIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPipelineCoverageToColorStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCoverageToColorStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCoverageToColorStateCreateInfoNV(new Uint8Array(VkPipelineCoverageToColorStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCoverageToColorStateCreateFlagsNV;
    coverageToColorEnable: VkBool32;
    coverageToColorLocation?: number;
  }) {
    const s = VkPipelineCoverageToColorStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.coverageToColorEnable !== undefined) s.coverageToColorEnable = data.coverageToColorEnable;
    if (data.coverageToColorLocation !== undefined) s.coverageToColorLocation = data.coverageToColorLocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCoverageToColorStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageToColorEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageToColorEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get coverageToColorLocation() {
    return this.#view.getUint32(24, LE);
  }
  
  set coverageToColorLocation(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceSamplerFilterMinmaxProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSamplerFilterMinmaxProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSamplerFilterMinmaxProperties(new Uint8Array(VkPhysicalDeviceSamplerFilterMinmaxProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    filterMinmaxSingleComponentFormats: VkBool32;
    filterMinmaxImageComponentMapping: VkBool32;
  }) {
    const s = VkPhysicalDeviceSamplerFilterMinmaxProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.filterMinmaxSingleComponentFormats !== undefined) s.filterMinmaxSingleComponentFormats = data.filterMinmaxSingleComponentFormats;
    if (data.filterMinmaxImageComponentMapping !== undefined) s.filterMinmaxImageComponentMapping = data.filterMinmaxImageComponentMapping;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get filterMinmaxSingleComponentFormats() {
    return this.#view.getUint32(16, LE);
  }
  
  set filterMinmaxSingleComponentFormats(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get filterMinmaxImageComponentMapping() {
    return this.#view.getUint32(20, LE);
  }
  
  set filterMinmaxImageComponentMapping(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkSampleLocationEXT implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSampleLocationEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSampleLocationEXT(new Uint8Array(VkSampleLocationEXT.size));
  }
  
  static create(data: {
    x: number;
    y: number;
  }) {
    const s = VkSampleLocationEXT.alloc();
    if (data.x !== undefined) s.x = data.x;
    if (data.y !== undefined) s.y = data.y;
    return s;
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export class VkSampleLocationsInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSampleLocationsInfoEXT(new Uint8Array(VkSampleLocationsInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampleLocationsPerPixel: VkSampleCountFlagBits;
    sampleLocationGridSize: VkExtent2D;
    sampleLocationsCount?: number;
    pSampleLocations: Deno.PointerValue;
  }) {
    const s = VkSampleLocationsInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampleLocationsPerPixel !== undefined) s.sampleLocationsPerPixel = data.sampleLocationsPerPixel;
    if (data.sampleLocationGridSize !== undefined) s.sampleLocationGridSize = data.sampleLocationGridSize;
    if (data.sampleLocationsCount !== undefined) s.sampleLocationsCount = data.sampleLocationsCount;
    if (data.pSampleLocations !== undefined) s.pSampleLocations = data.pSampleLocations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampleLocationsPerPixel() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationsPerPixel(value: VkSampleCountFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleLocationGridSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set sampleLocationGridSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get sampleLocationsCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set sampleLocationsCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSampleLocations() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSampleLocations(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkAttachmentSampleLocationsEXT implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentSampleLocationsEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentSampleLocationsEXT(new Uint8Array(VkAttachmentSampleLocationsEXT.size));
  }
  
  static create(data: {
    attachmentIndex: number;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  }) {
    const s = VkAttachmentSampleLocationsEXT.alloc();
    if (data.attachmentIndex !== undefined) s.attachmentIndex = data.attachmentIndex;
    if (data.sampleLocationsInfo !== undefined) s.sampleLocationsInfo = data.sampleLocationsInfo;
    return s;
  }
  
  get attachmentIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set attachmentIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new VkSampleLocationsInfoEXT(this.#data.subarray(48, 48 + VkSampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: VkSampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < VkSampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkSubpassSampleLocationsEXT implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassSampleLocationsEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassSampleLocationsEXT(new Uint8Array(VkSubpassSampleLocationsEXT.size));
  }
  
  static create(data: {
    subpassIndex: number;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  }) {
    const s = VkSubpassSampleLocationsEXT.alloc();
    if (data.subpassIndex !== undefined) s.subpassIndex = data.subpassIndex;
    if (data.sampleLocationsInfo !== undefined) s.sampleLocationsInfo = data.sampleLocationsInfo;
    return s;
  }
  
  get subpassIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpassIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new VkSampleLocationsInfoEXT(this.#data.subarray(48, 48 + VkSampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: VkSampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < VkSampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkRenderPassSampleLocationsBeginInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassSampleLocationsBeginInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassSampleLocationsBeginInfoEXT(new Uint8Array(VkRenderPassSampleLocationsBeginInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachmentInitialSampleLocationsCount?: number;
    pAttachmentInitialSampleLocations: Deno.PointerValue;
    postSubpassSampleLocationsCount?: number;
    pPostSubpassSampleLocations: Deno.PointerValue;
  }) {
    const s = VkRenderPassSampleLocationsBeginInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachmentInitialSampleLocationsCount !== undefined) s.attachmentInitialSampleLocationsCount = data.attachmentInitialSampleLocationsCount;
    if (data.pAttachmentInitialSampleLocations !== undefined) s.pAttachmentInitialSampleLocations = data.pAttachmentInitialSampleLocations;
    if (data.postSubpassSampleLocationsCount !== undefined) s.postSubpassSampleLocationsCount = data.postSubpassSampleLocationsCount;
    if (data.pPostSubpassSampleLocations !== undefined) s.pPostSubpassSampleLocations = data.pPostSubpassSampleLocations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachmentInitialSampleLocationsCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentInitialSampleLocationsCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachmentInitialSampleLocations() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachmentInitialSampleLocations(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get postSubpassSampleLocationsCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set postSubpassSampleLocationsCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPostSubpassSampleLocations() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPostSubpassSampleLocations(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkPipelineSampleLocationsStateCreateInfoEXT implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineSampleLocationsStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineSampleLocationsStateCreateInfoEXT(new Uint8Array(VkPipelineSampleLocationsStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampleLocationsEnable: VkBool32;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  }) {
    const s = VkPipelineSampleLocationsStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampleLocationsEnable !== undefined) s.sampleLocationsEnable = data.sampleLocationsEnable;
    if (data.sampleLocationsInfo !== undefined) s.sampleLocationsInfo = data.sampleLocationsInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampleLocationsEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationsEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new VkSampleLocationsInfoEXT(this.#data.subarray(48, 48 + VkSampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: VkSampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < VkSampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkPhysicalDeviceSampleLocationsPropertiesEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSampleLocationsPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSampleLocationsPropertiesEXT(new Uint8Array(VkPhysicalDeviceSampleLocationsPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampleLocationSampleCounts: VkSampleCountFlags;
    maxSampleLocationGridSize: VkExtent2D;
    sampleLocationCoordinateRange: number;
    sampleLocationSubPixelBits: number;
    variableSampleLocations: VkBool32;
  }) {
    const s = VkPhysicalDeviceSampleLocationsPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampleLocationSampleCounts !== undefined) s.sampleLocationSampleCounts = data.sampleLocationSampleCounts;
    if (data.maxSampleLocationGridSize !== undefined) s.maxSampleLocationGridSize = data.maxSampleLocationGridSize;
    if (data.sampleLocationCoordinateRange !== undefined) s.sampleLocationCoordinateRange = data.sampleLocationCoordinateRange;
    if (data.sampleLocationSubPixelBits !== undefined) s.sampleLocationSubPixelBits = data.sampleLocationSubPixelBits;
    if (data.variableSampleLocations !== undefined) s.variableSampleLocations = data.variableSampleLocations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampleLocationSampleCounts() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSampleLocationGridSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set maxSampleLocationGridSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get sampleLocationCoordinateRange() {
    return this.#view.getFloat32(32, LE);
  }
  
  set sampleLocationCoordinateRange(value: number) {
    this.#view.setFloat32(32, Number(value), LE);
  }
  
  get sampleLocationSubPixelBits() {
    return this.#view.getUint32(36, LE);
  }
  
  set sampleLocationSubPixelBits(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get variableSampleLocations() {
    return this.#view.getUint32(40, LE);
  }
  
  set variableSampleLocations(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkMultisamplePropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMultisamplePropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMultisamplePropertiesEXT(new Uint8Array(VkMultisamplePropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxSampleLocationGridSize: VkExtent2D;
  }) {
    const s = VkMultisamplePropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxSampleLocationGridSize !== undefined) s.maxSampleLocationGridSize = data.maxSampleLocationGridSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxSampleLocationGridSize() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set maxSampleLocationGridSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkSamplerReductionModeCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerReductionModeCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerReductionModeCreateInfo(new Uint8Array(VkSamplerReductionModeCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    reductionMode: VkSamplerReductionMode;
  }) {
    const s = VkSamplerReductionModeCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.reductionMode !== undefined) s.reductionMode = data.reductionMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get reductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set reductionMode(value: VkSamplerReductionMode) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(new Uint8Array(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    advancedBlendCoherentOperations: VkBool32;
  }) {
    const s = VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.advancedBlendCoherentOperations !== undefined) s.advancedBlendCoherentOperations = data.advancedBlendCoherentOperations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get advancedBlendCoherentOperations() {
    return this.#view.getUint32(16, LE);
  }
  
  set advancedBlendCoherentOperations(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceMultiDrawFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultiDrawFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultiDrawFeaturesEXT(new Uint8Array(VkPhysicalDeviceMultiDrawFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    multiDraw: VkBool32;
  }) {
    const s = VkPhysicalDeviceMultiDrawFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.multiDraw !== undefined) s.multiDraw = data.multiDraw;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get multiDraw() {
    return this.#view.getUint32(16, LE);
  }
  
  set multiDraw(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(new Uint8Array(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    advancedBlendMaxColorAttachments: number;
    advancedBlendIndependentBlend: VkBool32;
    advancedBlendNonPremultipliedSrcColor: VkBool32;
    advancedBlendNonPremultipliedDstColor: VkBool32;
    advancedBlendCorrelatedOverlap: VkBool32;
    advancedBlendAllOperations: VkBool32;
  }) {
    const s = VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.advancedBlendMaxColorAttachments !== undefined) s.advancedBlendMaxColorAttachments = data.advancedBlendMaxColorAttachments;
    if (data.advancedBlendIndependentBlend !== undefined) s.advancedBlendIndependentBlend = data.advancedBlendIndependentBlend;
    if (data.advancedBlendNonPremultipliedSrcColor !== undefined) s.advancedBlendNonPremultipliedSrcColor = data.advancedBlendNonPremultipliedSrcColor;
    if (data.advancedBlendNonPremultipliedDstColor !== undefined) s.advancedBlendNonPremultipliedDstColor = data.advancedBlendNonPremultipliedDstColor;
    if (data.advancedBlendCorrelatedOverlap !== undefined) s.advancedBlendCorrelatedOverlap = data.advancedBlendCorrelatedOverlap;
    if (data.advancedBlendAllOperations !== undefined) s.advancedBlendAllOperations = data.advancedBlendAllOperations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get advancedBlendMaxColorAttachments() {
    return this.#view.getUint32(16, LE);
  }
  
  set advancedBlendMaxColorAttachments(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get advancedBlendIndependentBlend() {
    return this.#view.getUint32(20, LE);
  }
  
  set advancedBlendIndependentBlend(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get advancedBlendNonPremultipliedSrcColor() {
    return this.#view.getUint32(24, LE);
  }
  
  set advancedBlendNonPremultipliedSrcColor(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get advancedBlendNonPremultipliedDstColor() {
    return this.#view.getUint32(28, LE);
  }
  
  set advancedBlendNonPremultipliedDstColor(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get advancedBlendCorrelatedOverlap() {
    return this.#view.getUint32(32, LE);
  }
  
  set advancedBlendCorrelatedOverlap(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get advancedBlendAllOperations() {
    return this.#view.getUint32(36, LE);
  }
  
  set advancedBlendAllOperations(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export class VkPipelineColorBlendAdvancedStateCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineColorBlendAdvancedStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineColorBlendAdvancedStateCreateInfoEXT(new Uint8Array(VkPipelineColorBlendAdvancedStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcPremultiplied: VkBool32;
    dstPremultiplied: VkBool32;
    blendOverlap: VkBlendOverlapEXT;
  }) {
    const s = VkPipelineColorBlendAdvancedStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcPremultiplied !== undefined) s.srcPremultiplied = data.srcPremultiplied;
    if (data.dstPremultiplied !== undefined) s.dstPremultiplied = data.dstPremultiplied;
    if (data.blendOverlap !== undefined) s.blendOverlap = data.blendOverlap;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcPremultiplied() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcPremultiplied(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstPremultiplied() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstPremultiplied(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get blendOverlap() {
    return this.#view.getUint32(24, LE);
  }
  
  set blendOverlap(value: VkBlendOverlapEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceInlineUniformBlockFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceInlineUniformBlockFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceInlineUniformBlockFeatures(new Uint8Array(VkPhysicalDeviceInlineUniformBlockFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    inlineUniformBlock: VkBool32;
    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
  }) {
    const s = VkPhysicalDeviceInlineUniformBlockFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.inlineUniformBlock !== undefined) s.inlineUniformBlock = data.inlineUniformBlock;
    if (data.descriptorBindingInlineUniformBlockUpdateAfterBind !== undefined) s.descriptorBindingInlineUniformBlockUpdateAfterBind = data.descriptorBindingInlineUniformBlockUpdateAfterBind;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get inlineUniformBlock() {
    return this.#view.getUint32(16, LE);
  }
  
  set inlineUniformBlock(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorBindingInlineUniformBlockUpdateAfterBind() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorBindingInlineUniformBlockUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceInlineUniformBlockProperties implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceInlineUniformBlockProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceInlineUniformBlockProperties(new Uint8Array(VkPhysicalDeviceInlineUniformBlockProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxInlineUniformBlockSize: number;
    maxPerStageDescriptorInlineUniformBlocks: number;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number;
    maxDescriptorSetInlineUniformBlocks: number;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number;
  }) {
    const s = VkPhysicalDeviceInlineUniformBlockProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxInlineUniformBlockSize !== undefined) s.maxInlineUniformBlockSize = data.maxInlineUniformBlockSize;
    if (data.maxPerStageDescriptorInlineUniformBlocks !== undefined) s.maxPerStageDescriptorInlineUniformBlocks = data.maxPerStageDescriptorInlineUniformBlocks;
    if (data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks !== undefined) s.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    if (data.maxDescriptorSetInlineUniformBlocks !== undefined) s.maxDescriptorSetInlineUniformBlocks = data.maxDescriptorSetInlineUniformBlocks;
    if (data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks !== undefined) s.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxInlineUniformBlockSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInlineUniformBlockSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxPerStageDescriptorInlineUniformBlocks() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxPerStageDescriptorInlineUniformBlocks(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxDescriptorSetInlineUniformBlocks() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxDescriptorSetInlineUniformBlocks(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkWriteDescriptorSetInlineUniformBlock implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWriteDescriptorSetInlineUniformBlock.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWriteDescriptorSetInlineUniformBlock(new Uint8Array(VkWriteDescriptorSetInlineUniformBlock.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dataSize: number;
    pData: Deno.PointerValue;
  }) {
    const s = VkWriteDescriptorSetInlineUniformBlock.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dataSize !== undefined) s.dataSize = data.dataSize;
    if (data.pData !== undefined) s.pData = data.pData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dataSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set dataSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorPoolInlineUniformBlockCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorPoolInlineUniformBlockCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorPoolInlineUniformBlockCreateInfo(new Uint8Array(VkDescriptorPoolInlineUniformBlockCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxInlineUniformBlockBindings: number;
  }) {
    const s = VkDescriptorPoolInlineUniformBlockCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxInlineUniformBlockBindings !== undefined) s.maxInlineUniformBlockBindings = data.maxInlineUniformBlockBindings;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxInlineUniformBlockBindings() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInlineUniformBlockBindings(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineCoverageModulationStateCreateInfoNV implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCoverageModulationStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCoverageModulationStateCreateInfoNV(new Uint8Array(VkPipelineCoverageModulationStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCoverageModulationStateCreateFlagsNV;
    coverageModulationMode: VkCoverageModulationModeNV;
    coverageModulationTableEnable: VkBool32;
    coverageModulationTableCount?: number;
    pCoverageModulationTable?: Deno.PointerValue;
  }) {
    const s = VkPipelineCoverageModulationStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.coverageModulationMode !== undefined) s.coverageModulationMode = data.coverageModulationMode;
    if (data.coverageModulationTableEnable !== undefined) s.coverageModulationTableEnable = data.coverageModulationTableEnable;
    if (data.coverageModulationTableCount !== undefined) s.coverageModulationTableCount = data.coverageModulationTableCount;
    if (data.pCoverageModulationTable !== undefined) s.pCoverageModulationTable = data.pCoverageModulationTable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCoverageModulationStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageModulationMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageModulationMode(value: VkCoverageModulationModeNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get coverageModulationTableEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set coverageModulationTableEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get coverageModulationTableCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set coverageModulationTableCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pCoverageModulationTable() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pCoverageModulationTable(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageFormatListCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageFormatListCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageFormatListCreateInfo(new Uint8Array(VkImageFormatListCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    viewFormatCount?: number;
    pViewFormats: Deno.PointerValue;
  }) {
    const s = VkImageFormatListCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.viewFormatCount !== undefined) s.viewFormatCount = data.viewFormatCount;
    if (data.pViewFormats !== undefined) s.pViewFormats = data.pViewFormats;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get viewFormatCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewFormatCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pViewFormats() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewFormats(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkValidationCacheCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkValidationCacheCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkValidationCacheCreateInfoEXT(new Uint8Array(VkValidationCacheCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkValidationCacheCreateFlagsEXT;
    initialDataSize?: Deno.PointerValue;
    pInitialData: Deno.PointerValue;
  }) {
    const s = VkValidationCacheCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.initialDataSize !== undefined) s.initialDataSize = data.initialDataSize;
    if (data.pInitialData !== undefined) s.pInitialData = data.pInitialData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkValidationCacheCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialDataSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pInitialData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInitialData(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkShaderModuleValidationCacheCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShaderModuleValidationCacheCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShaderModuleValidationCacheCreateInfoEXT(new Uint8Array(VkShaderModuleValidationCacheCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    validationCache: VkValidationCacheEXT;
  }) {
    const s = VkShaderModuleValidationCacheCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.validationCache !== undefined) s.validationCache = data.validationCache;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get validationCache() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set validationCache(value: VkValidationCacheEXT) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceMaintenance3Properties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMaintenance3Properties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMaintenance3Properties(new Uint8Array(VkPhysicalDeviceMaintenance3Properties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxPerSetDescriptors: number;
    maxMemoryAllocationSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceMaintenance3Properties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxPerSetDescriptors !== undefined) s.maxPerSetDescriptors = data.maxPerSetDescriptors;
    if (data.maxMemoryAllocationSize !== undefined) s.maxMemoryAllocationSize = data.maxMemoryAllocationSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxPerSetDescriptors() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPerSetDescriptors(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxMemoryAllocationSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxMemoryAllocationSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceMaintenance4Features implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMaintenance4Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMaintenance4Features(new Uint8Array(VkPhysicalDeviceMaintenance4Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maintenance4: VkBool32;
  }) {
    const s = VkPhysicalDeviceMaintenance4Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maintenance4 !== undefined) s.maintenance4 = data.maintenance4;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maintenance4() {
    return this.#view.getUint32(16, LE);
  }
  
  set maintenance4(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceMaintenance4Properties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMaintenance4Properties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMaintenance4Properties(new Uint8Array(VkPhysicalDeviceMaintenance4Properties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxBufferSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceMaintenance4Properties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxBufferSize !== undefined) s.maxBufferSize = data.maxBufferSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxBufferSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxBufferSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDescriptorSetLayoutSupport implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetLayoutSupport.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetLayoutSupport(new Uint8Array(VkDescriptorSetLayoutSupport.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supported: VkBool32;
  }) {
    const s = VkDescriptorSetLayoutSupport.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supported !== undefined) s.supported = data.supported;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supported() {
    return this.#view.getUint32(16, LE);
  }
  
  set supported(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderDrawParametersFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderDrawParametersFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderDrawParametersFeatures(new Uint8Array(VkPhysicalDeviceShaderDrawParametersFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderDrawParameters: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderDrawParametersFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderDrawParameters !== undefined) s.shaderDrawParameters = data.shaderDrawParameters;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderDrawParameters() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderDrawParameters(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderFloat16Int8Features implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderFloat16Int8Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderFloat16Int8Features(new Uint8Array(VkPhysicalDeviceShaderFloat16Int8Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderFloat16: VkBool32;
    shaderInt8: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderFloat16Int8Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderFloat16 !== undefined) s.shaderFloat16 = data.shaderFloat16;
    if (data.shaderInt8 !== undefined) s.shaderInt8 = data.shaderInt8;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderFloat16() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderFloat16(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderInt8() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderInt8(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceFloatControlsProperties implements IVkStructure {
  static size = 88;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFloatControlsProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFloatControlsProperties(new Uint8Array(VkPhysicalDeviceFloatControlsProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    denormBehaviorIndependence: VkShaderFloatControlsIndependence;
    roundingModeIndependence: VkShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16: VkBool32;
    shaderSignedZeroInfNanPreserveFloat32: VkBool32;
    shaderSignedZeroInfNanPreserveFloat64: VkBool32;
    shaderDenormPreserveFloat16: VkBool32;
    shaderDenormPreserveFloat32: VkBool32;
    shaderDenormPreserveFloat64: VkBool32;
    shaderDenormFlushToZeroFloat16: VkBool32;
    shaderDenormFlushToZeroFloat32: VkBool32;
    shaderDenormFlushToZeroFloat64: VkBool32;
    shaderRoundingModeRTEFloat16: VkBool32;
    shaderRoundingModeRTEFloat32: VkBool32;
    shaderRoundingModeRTEFloat64: VkBool32;
    shaderRoundingModeRTZFloat16: VkBool32;
    shaderRoundingModeRTZFloat32: VkBool32;
    shaderRoundingModeRTZFloat64: VkBool32;
  }) {
    const s = VkPhysicalDeviceFloatControlsProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.denormBehaviorIndependence !== undefined) s.denormBehaviorIndependence = data.denormBehaviorIndependence;
    if (data.roundingModeIndependence !== undefined) s.roundingModeIndependence = data.roundingModeIndependence;
    if (data.shaderSignedZeroInfNanPreserveFloat16 !== undefined) s.shaderSignedZeroInfNanPreserveFloat16 = data.shaderSignedZeroInfNanPreserveFloat16;
    if (data.shaderSignedZeroInfNanPreserveFloat32 !== undefined) s.shaderSignedZeroInfNanPreserveFloat32 = data.shaderSignedZeroInfNanPreserveFloat32;
    if (data.shaderSignedZeroInfNanPreserveFloat64 !== undefined) s.shaderSignedZeroInfNanPreserveFloat64 = data.shaderSignedZeroInfNanPreserveFloat64;
    if (data.shaderDenormPreserveFloat16 !== undefined) s.shaderDenormPreserveFloat16 = data.shaderDenormPreserveFloat16;
    if (data.shaderDenormPreserveFloat32 !== undefined) s.shaderDenormPreserveFloat32 = data.shaderDenormPreserveFloat32;
    if (data.shaderDenormPreserveFloat64 !== undefined) s.shaderDenormPreserveFloat64 = data.shaderDenormPreserveFloat64;
    if (data.shaderDenormFlushToZeroFloat16 !== undefined) s.shaderDenormFlushToZeroFloat16 = data.shaderDenormFlushToZeroFloat16;
    if (data.shaderDenormFlushToZeroFloat32 !== undefined) s.shaderDenormFlushToZeroFloat32 = data.shaderDenormFlushToZeroFloat32;
    if (data.shaderDenormFlushToZeroFloat64 !== undefined) s.shaderDenormFlushToZeroFloat64 = data.shaderDenormFlushToZeroFloat64;
    if (data.shaderRoundingModeRTEFloat16 !== undefined) s.shaderRoundingModeRTEFloat16 = data.shaderRoundingModeRTEFloat16;
    if (data.shaderRoundingModeRTEFloat32 !== undefined) s.shaderRoundingModeRTEFloat32 = data.shaderRoundingModeRTEFloat32;
    if (data.shaderRoundingModeRTEFloat64 !== undefined) s.shaderRoundingModeRTEFloat64 = data.shaderRoundingModeRTEFloat64;
    if (data.shaderRoundingModeRTZFloat16 !== undefined) s.shaderRoundingModeRTZFloat16 = data.shaderRoundingModeRTZFloat16;
    if (data.shaderRoundingModeRTZFloat32 !== undefined) s.shaderRoundingModeRTZFloat32 = data.shaderRoundingModeRTZFloat32;
    if (data.shaderRoundingModeRTZFloat64 !== undefined) s.shaderRoundingModeRTZFloat64 = data.shaderRoundingModeRTZFloat64;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get denormBehaviorIndependence() {
    return this.#view.getUint32(16, LE);
  }
  
  set denormBehaviorIndependence(value: VkShaderFloatControlsIndependence) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get roundingModeIndependence() {
    return this.#view.getUint32(20, LE);
  }
  
  set roundingModeIndependence(value: VkShaderFloatControlsIndependence) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat16() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat16(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat32() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat32(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat64() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat64(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat16() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderDenormPreserveFloat16(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat32() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderDenormPreserveFloat32(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat64() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderDenormPreserveFloat64(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat16() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderDenormFlushToZeroFloat16(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat32() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderDenormFlushToZeroFloat32(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat64() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderDenormFlushToZeroFloat64(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat16() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderRoundingModeRTEFloat16(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat32() {
    return this.#view.getUint32(64, LE);
  }
  
  set shaderRoundingModeRTEFloat32(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat64() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderRoundingModeRTEFloat64(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat16() {
    return this.#view.getUint32(72, LE);
  }
  
  set shaderRoundingModeRTZFloat16(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat32() {
    return this.#view.getUint32(76, LE);
  }
  
  set shaderRoundingModeRTZFloat32(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat64() {
    return this.#view.getUint32(80, LE);
  }
  
  set shaderRoundingModeRTZFloat64(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export class VkPhysicalDeviceHostQueryResetFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceHostQueryResetFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceHostQueryResetFeatures(new Uint8Array(VkPhysicalDeviceHostQueryResetFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    hostQueryReset: VkBool32;
  }) {
    const s = VkPhysicalDeviceHostQueryResetFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.hostQueryReset !== undefined) s.hostQueryReset = data.hostQueryReset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get hostQueryReset() {
    return this.#view.getUint32(16, LE);
  }
  
  set hostQueryReset(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkNativeBufferUsage2ANDROID implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkNativeBufferUsage2ANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkNativeBufferUsage2ANDROID(new Uint8Array(VkNativeBufferUsage2ANDROID.size));
  }
  
  static create(data: {
    consumer: Deno.PointerValue;
    producer: Deno.PointerValue;
  }) {
    const s = VkNativeBufferUsage2ANDROID.alloc();
    if (data.consumer !== undefined) s.consumer = data.consumer;
    if (data.producer !== undefined) s.producer = data.producer;
    return s;
  }
  
  get consumer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set consumer(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get producer() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set producer(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkNativeBufferANDROID implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkNativeBufferANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkNativeBufferANDROID(new Uint8Array(VkNativeBufferANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handle: Deno.PointerValue;
    stride: number;
    format: number;
    usage: number;
    usage2: VkNativeBufferUsage2ANDROID;
  }) {
    const s = VkNativeBufferANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handle !== undefined) s.handle = data.handle;
    if (data.stride !== undefined) s.stride = data.stride;
    if (data.format !== undefined) s.format = data.format;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.usage2 !== undefined) s.usage2 = data.usage2;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get stride() {
    return this.#view.getInt32(24, LE);
  }
  
  set stride(value: number) {
    this.#view.setInt32(24, Number(value), LE);
  }
  
  get format() {
    return this.#view.getInt32(28, LE);
  }
  
  set format(value: number) {
    this.#view.setInt32(28, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getInt32(32, LE);
  }
  
  set usage(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
  
  get usage2() {
    return new VkNativeBufferUsage2ANDROID(this.#data.subarray(48, 48 + VkNativeBufferUsage2ANDROID.size));
  }
  
  set usage2(value: VkNativeBufferUsage2ANDROID) {
    if (value[BUFFER].byteLength < VkNativeBufferUsage2ANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkSwapchainImageCreateInfoANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSwapchainImageCreateInfoANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSwapchainImageCreateInfoANDROID(new Uint8Array(VkSwapchainImageCreateInfoANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    usage: VkSwapchainImageUsageFlagsANDROID;
  }) {
    const s = VkSwapchainImageCreateInfoANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.usage !== undefined) s.usage = data.usage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: VkSwapchainImageUsageFlagsANDROID) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePresentationPropertiesANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePresentationPropertiesANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePresentationPropertiesANDROID(new Uint8Array(VkPhysicalDevicePresentationPropertiesANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sharedImage: VkBool32;
  }) {
    const s = VkPhysicalDevicePresentationPropertiesANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sharedImage !== undefined) s.sharedImage = data.sharedImage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sharedImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set sharedImage(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkShaderResourceUsageAMD implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShaderResourceUsageAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShaderResourceUsageAMD(new Uint8Array(VkShaderResourceUsageAMD.size));
  }
  
  static create(data: {
    numUsedVgprs: number;
    numUsedSgprs: number;
    ldsSizePerLocalWorkGroup: number;
    ldsUsageSizeInBytes: Deno.PointerValue;
    scratchMemUsageInBytes: Deno.PointerValue;
  }) {
    const s = VkShaderResourceUsageAMD.alloc();
    if (data.numUsedVgprs !== undefined) s.numUsedVgprs = data.numUsedVgprs;
    if (data.numUsedSgprs !== undefined) s.numUsedSgprs = data.numUsedSgprs;
    if (data.ldsSizePerLocalWorkGroup !== undefined) s.ldsSizePerLocalWorkGroup = data.ldsSizePerLocalWorkGroup;
    if (data.ldsUsageSizeInBytes !== undefined) s.ldsUsageSizeInBytes = data.ldsUsageSizeInBytes;
    if (data.scratchMemUsageInBytes !== undefined) s.scratchMemUsageInBytes = data.scratchMemUsageInBytes;
    return s;
  }
  
  get numUsedVgprs() {
    return this.#view.getUint32(0, LE);
  }
  
  set numUsedVgprs(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get numUsedSgprs() {
    return this.#view.getUint32(4, LE);
  }
  
  set numUsedSgprs(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get ldsSizePerLocalWorkGroup() {
    return this.#view.getUint32(8, LE);
  }
  
  set ldsSizePerLocalWorkGroup(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get ldsUsageSizeInBytes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set ldsUsageSizeInBytes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get scratchMemUsageInBytes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set scratchMemUsageInBytes(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkShaderStatisticsInfoAMD implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShaderStatisticsInfoAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShaderStatisticsInfoAMD(new Uint8Array(VkShaderStatisticsInfoAMD.size));
  }
  
  static create(data: {
    shaderStageMask: VkShaderStageFlags;
    resourceUsage: VkShaderResourceUsageAMD;
    numPhysicalVgprs: number;
    numPhysicalSgprs: number;
    numAvailableVgprs: number;
    numAvailableSgprs: number;
    computeWorkGroupSize: number;
  }) {
    const s = VkShaderStatisticsInfoAMD.alloc();
    if (data.shaderStageMask !== undefined) s.shaderStageMask = data.shaderStageMask;
    if (data.resourceUsage !== undefined) s.resourceUsage = data.resourceUsage;
    if (data.numPhysicalVgprs !== undefined) s.numPhysicalVgprs = data.numPhysicalVgprs;
    if (data.numPhysicalSgprs !== undefined) s.numPhysicalSgprs = data.numPhysicalSgprs;
    if (data.numAvailableVgprs !== undefined) s.numAvailableVgprs = data.numAvailableVgprs;
    if (data.numAvailableSgprs !== undefined) s.numAvailableSgprs = data.numAvailableSgprs;
    if (data.computeWorkGroupSize !== undefined) s.computeWorkGroupSize = data.computeWorkGroupSize;
    return s;
  }
  
  get shaderStageMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set shaderStageMask(value: VkShaderStageFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get resourceUsage() {
    return new VkShaderResourceUsageAMD(this.#data.subarray(32, 32 + VkShaderResourceUsageAMD.size));
  }
  
  set resourceUsage(value: VkShaderResourceUsageAMD) {
    if (value[BUFFER].byteLength < VkShaderResourceUsageAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get numPhysicalVgprs() {
    return this.#view.getUint32(64, LE);
  }
  
  set numPhysicalVgprs(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get numPhysicalSgprs() {
    return this.#view.getUint32(68, LE);
  }
  
  set numPhysicalSgprs(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get numAvailableVgprs() {
    return this.#view.getUint32(72, LE);
  }
  
  set numAvailableVgprs(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get numAvailableSgprs() {
    return this.#view.getUint32(76, LE);
  }
  
  set numAvailableSgprs(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get computeWorkGroupSize() {
    return this.#view.getUint32(80, LE);
  }
  
  set computeWorkGroupSize(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export class VkDeviceQueueGlobalPriorityCreateInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceQueueGlobalPriorityCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceQueueGlobalPriorityCreateInfoKHR(new Uint8Array(VkDeviceQueueGlobalPriorityCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    globalPriority: VkQueueGlobalPriorityKHR;
  }) {
    const s = VkDeviceQueueGlobalPriorityCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.globalPriority !== undefined) s.globalPriority = data.globalPriority;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get globalPriority() {
    return this.#view.getUint32(16, LE);
  }
  
  set globalPriority(value: VkQueueGlobalPriorityKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(new Uint8Array(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    globalPriorityQuery: VkBool32;
  }) {
    const s = VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.globalPriorityQuery !== undefined) s.globalPriorityQuery = data.globalPriorityQuery;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get globalPriorityQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set globalPriorityQuery(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkQueueFamilyGlobalPriorityPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyGlobalPriorityPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyGlobalPriorityPropertiesKHR(new Uint8Array(VkQueueFamilyGlobalPriorityPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    priorityCount: number;
    priorities: VkQueueGlobalPriorityKHR;
  }) {
    const s = VkQueueFamilyGlobalPriorityPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.priorityCount !== undefined) s.priorityCount = data.priorityCount;
    if (data.priorities !== undefined) s.priorities = data.priorities;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get priorityCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set priorityCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get priorities() {
    return this.#view.getUint32(20, LE);
  }
  
  set priorities(value: VkQueueGlobalPriorityKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkDebugUtilsObjectNameInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugUtilsObjectNameInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugUtilsObjectNameInfoEXT(new Uint8Array(VkDebugUtilsObjectNameInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    objectType: VkObjectType;
    objectHandle: Deno.PointerValue;
    pObjectName?: Deno.PointerValue;
  }) {
    const s = VkDebugUtilsObjectNameInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.objectType !== undefined) s.objectType = data.objectType;
    if (data.objectHandle !== undefined) s.objectHandle = data.objectHandle;
    if (data.pObjectName !== undefined) s.pObjectName = data.pObjectName;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: VkObjectType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pObjectName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pObjectName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDebugUtilsObjectTagInfoEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugUtilsObjectTagInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugUtilsObjectTagInfoEXT(new Uint8Array(VkDebugUtilsObjectTagInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    objectType: VkObjectType;
    objectHandle: Deno.PointerValue;
    tagName: Deno.PointerValue;
    tagSize: Deno.PointerValue;
    pTag: Deno.PointerValue;
  }) {
    const s = VkDebugUtilsObjectTagInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.objectType !== undefined) s.objectType = data.objectType;
    if (data.objectHandle !== undefined) s.objectHandle = data.objectHandle;
    if (data.tagName !== undefined) s.tagName = data.tagName;
    if (data.tagSize !== undefined) s.tagSize = data.tagSize;
    if (data.pTag !== undefined) s.pTag = data.pTag;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: VkObjectType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get tagName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set tagName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get tagSize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set tagSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pTag() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTag(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkDebugUtilsLabelEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugUtilsLabelEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugUtilsLabelEXT(new Uint8Array(VkDebugUtilsLabelEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pLabelName: Deno.PointerValue;
    color: number;
  }) {
    const s = VkDebugUtilsLabelEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pLabelName !== undefined) s.pLabelName = data.pLabelName;
    if (data.color !== undefined) s.color = data.color;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pLabelName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pLabelName(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get color() {
    return this.#view.getFloat32(24, LE);
  }
  
  set color(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
}

export class VkDebugUtilsMessengerCreateInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugUtilsMessengerCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugUtilsMessengerCreateInfoEXT(new Uint8Array(VkDebugUtilsMessengerCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDebugUtilsMessengerCreateFlagsEXT;
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT;
    messageType: VkDebugUtilsMessageTypeFlagsEXT;
    pfnUserCallback: Deno.PointerValue;
    pUserData?: Deno.PointerValue;
  }) {
    const s = VkDebugUtilsMessengerCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.messageSeverity !== undefined) s.messageSeverity = data.messageSeverity;
    if (data.messageType !== undefined) s.messageType = data.messageType;
    if (data.pfnUserCallback !== undefined) s.pfnUserCallback = data.pfnUserCallback;
    if (data.pUserData !== undefined) s.pUserData = data.pUserData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDebugUtilsMessengerCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get messageSeverity() {
    return this.#view.getUint32(20, LE);
  }
  
  set messageSeverity(value: VkDebugUtilsMessageSeverityFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get messageType() {
    return this.#view.getUint32(24, LE);
  }
  
  set messageType(value: VkDebugUtilsMessageTypeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pfnUserCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnUserCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pUserData(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkDebugUtilsMessengerCallbackDataEXT implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDebugUtilsMessengerCallbackDataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDebugUtilsMessengerCallbackDataEXT(new Uint8Array(VkDebugUtilsMessengerCallbackDataEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDebugUtilsMessengerCallbackDataFlagsEXT;
    pMessageIdName?: Deno.PointerValue;
    messageIdNumber: number;
    pMessage: Deno.PointerValue;
    queueLabelCount?: number;
    pQueueLabels: Deno.PointerValue;
    cmdBufLabelCount?: number;
    pCmdBufLabels: Deno.PointerValue;
    objectCount?: number;
    pObjects: Deno.PointerValue;
  }) {
    const s = VkDebugUtilsMessengerCallbackDataEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pMessageIdName !== undefined) s.pMessageIdName = data.pMessageIdName;
    if (data.messageIdNumber !== undefined) s.messageIdNumber = data.messageIdNumber;
    if (data.pMessage !== undefined) s.pMessage = data.pMessage;
    if (data.queueLabelCount !== undefined) s.queueLabelCount = data.queueLabelCount;
    if (data.pQueueLabels !== undefined) s.pQueueLabels = data.pQueueLabels;
    if (data.cmdBufLabelCount !== undefined) s.cmdBufLabelCount = data.cmdBufLabelCount;
    if (data.pCmdBufLabels !== undefined) s.pCmdBufLabels = data.pCmdBufLabels;
    if (data.objectCount !== undefined) s.objectCount = data.objectCount;
    if (data.pObjects !== undefined) s.pObjects = data.pObjects;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDebugUtilsMessengerCallbackDataFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pMessageIdName() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMessageIdName(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get messageIdNumber() {
    return this.#view.getInt32(32, LE);
  }
  
  set messageIdNumber(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
  
  get pMessage() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pMessage(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get queueLabelCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set queueLabelCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pQueueLabels() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pQueueLabels(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get cmdBufLabelCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set cmdBufLabelCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pCmdBufLabels() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pCmdBufLabels(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get objectCount() {
    return this.#view.getUint32(80, LE);
  }
  
  set objectCount(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get pObjects() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pObjects(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDeviceMemoryReportFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(new Uint8Array(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceMemoryReport: VkBool32;
  }) {
    const s = VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceMemoryReport !== undefined) s.deviceMemoryReport = data.deviceMemoryReport;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceMemoryReport() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMemoryReport(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceDeviceMemoryReportCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceDeviceMemoryReportCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceDeviceMemoryReportCreateInfoEXT(new Uint8Array(VkDeviceDeviceMemoryReportCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkDeviceMemoryReportFlagsEXT;
    pfnUserCallback: Deno.PointerValue;
    pUserData: Deno.PointerValue;
  }) {
    const s = VkDeviceDeviceMemoryReportCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pfnUserCallback !== undefined) s.pfnUserCallback = data.pfnUserCallback;
    if (data.pUserData !== undefined) s.pUserData = data.pUserData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceMemoryReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pfnUserCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnUserCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pUserData(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDeviceMemoryReportCallbackDataEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceMemoryReportCallbackDataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceMemoryReportCallbackDataEXT(new Uint8Array(VkDeviceMemoryReportCallbackDataEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkDeviceMemoryReportFlagsEXT;
    type: VkDeviceMemoryReportEventTypeEXT;
    memoryObjectId: Deno.PointerValue;
    size: VkDeviceSize;
    objectType: VkObjectType;
    objectHandle: Deno.PointerValue;
    heapIndex: number;
  }) {
    const s = VkDeviceMemoryReportCallbackDataEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.type !== undefined) s.type = data.type;
    if (data.memoryObjectId !== undefined) s.memoryObjectId = data.memoryObjectId;
    if (data.size !== undefined) s.size = data.size;
    if (data.objectType !== undefined) s.objectType = data.objectType;
    if (data.objectHandle !== undefined) s.objectHandle = data.objectHandle;
    if (data.heapIndex !== undefined) s.heapIndex = data.heapIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceMemoryReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: VkDeviceMemoryReportEventTypeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get memoryObjectId() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memoryObjectId(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(40, LE);
  }
  
  set objectType(value: VkObjectType) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get heapIndex() {
    return this.#view.getUint32(56, LE);
  }
  
  set heapIndex(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkImportMemoryHostPointerInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryHostPointerInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryHostPointerInfoEXT(new Uint8Array(VkImportMemoryHostPointerInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    handleType: VkExternalMemoryHandleTypeFlagBits;
    pHostPointer: Deno.PointerValue;
  }) {
    const s = VkImportMemoryHostPointerInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    if (data.pHostPointer !== undefined) s.pHostPointer = data.pHostPointer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pHostPointer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pHostPointer(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkMemoryHostPointerPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryHostPointerPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryHostPointerPropertiesEXT(new Uint8Array(VkMemoryHostPointerPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryTypeBits: number;
  }) {
    const s = VkMemoryHostPointerPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceExternalMemoryHostPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalMemoryHostPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalMemoryHostPropertiesEXT(new Uint8Array(VkPhysicalDeviceExternalMemoryHostPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minImportedHostPointerAlignment: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceExternalMemoryHostPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minImportedHostPointerAlignment !== undefined) s.minImportedHostPointerAlignment = data.minImportedHostPointerAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minImportedHostPointerAlignment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set minImportedHostPointerAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceConservativeRasterizationPropertiesEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceConservativeRasterizationPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceConservativeRasterizationPropertiesEXT(new Uint8Array(VkPhysicalDeviceConservativeRasterizationPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    primitiveOverestimationSize: number;
    maxExtraPrimitiveOverestimationSize: number;
    extraPrimitiveOverestimationSizeGranularity: number;
    primitiveUnderestimation: VkBool32;
    conservativePointAndLineRasterization: VkBool32;
    degenerateTrianglesRasterized: VkBool32;
    degenerateLinesRasterized: VkBool32;
    fullyCoveredFragmentShaderInputVariable: VkBool32;
    conservativeRasterizationPostDepthCoverage: VkBool32;
  }) {
    const s = VkPhysicalDeviceConservativeRasterizationPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.primitiveOverestimationSize !== undefined) s.primitiveOverestimationSize = data.primitiveOverestimationSize;
    if (data.maxExtraPrimitiveOverestimationSize !== undefined) s.maxExtraPrimitiveOverestimationSize = data.maxExtraPrimitiveOverestimationSize;
    if (data.extraPrimitiveOverestimationSizeGranularity !== undefined) s.extraPrimitiveOverestimationSizeGranularity = data.extraPrimitiveOverestimationSizeGranularity;
    if (data.primitiveUnderestimation !== undefined) s.primitiveUnderestimation = data.primitiveUnderestimation;
    if (data.conservativePointAndLineRasterization !== undefined) s.conservativePointAndLineRasterization = data.conservativePointAndLineRasterization;
    if (data.degenerateTrianglesRasterized !== undefined) s.degenerateTrianglesRasterized = data.degenerateTrianglesRasterized;
    if (data.degenerateLinesRasterized !== undefined) s.degenerateLinesRasterized = data.degenerateLinesRasterized;
    if (data.fullyCoveredFragmentShaderInputVariable !== undefined) s.fullyCoveredFragmentShaderInputVariable = data.fullyCoveredFragmentShaderInputVariable;
    if (data.conservativeRasterizationPostDepthCoverage !== undefined) s.conservativeRasterizationPostDepthCoverage = data.conservativeRasterizationPostDepthCoverage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get primitiveOverestimationSize() {
    return this.#view.getFloat32(16, LE);
  }
  
  set primitiveOverestimationSize(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxExtraPrimitiveOverestimationSize() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxExtraPrimitiveOverestimationSize(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
  
  get extraPrimitiveOverestimationSizeGranularity() {
    return this.#view.getFloat32(24, LE);
  }
  
  set extraPrimitiveOverestimationSizeGranularity(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
  
  get primitiveUnderestimation() {
    return this.#view.getUint32(28, LE);
  }
  
  set primitiveUnderestimation(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get conservativePointAndLineRasterization() {
    return this.#view.getUint32(32, LE);
  }
  
  set conservativePointAndLineRasterization(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get degenerateTrianglesRasterized() {
    return this.#view.getUint32(36, LE);
  }
  
  set degenerateTrianglesRasterized(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get degenerateLinesRasterized() {
    return this.#view.getUint32(40, LE);
  }
  
  set degenerateLinesRasterized(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get fullyCoveredFragmentShaderInputVariable() {
    return this.#view.getUint32(44, LE);
  }
  
  set fullyCoveredFragmentShaderInputVariable(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get conservativeRasterizationPostDepthCoverage() {
    return this.#view.getUint32(48, LE);
  }
  
  set conservativeRasterizationPostDepthCoverage(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkCalibratedTimestampInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCalibratedTimestampInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCalibratedTimestampInfoEXT(new Uint8Array(VkCalibratedTimestampInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    timeDomain: VkTimeDomainEXT;
  }) {
    const s = VkCalibratedTimestampInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.timeDomain !== undefined) s.timeDomain = data.timeDomain;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get timeDomain() {
    return this.#view.getUint32(16, LE);
  }
  
  set timeDomain(value: VkTimeDomainEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderCorePropertiesAMD implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderCorePropertiesAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderCorePropertiesAMD(new Uint8Array(VkPhysicalDeviceShaderCorePropertiesAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderEngineCount: number;
    shaderArraysPerEngineCount: number;
    computeUnitsPerShaderArray: number;
    simdPerComputeUnit: number;
    wavefrontsPerSimd: number;
    wavefrontSize: number;
    sgprsPerSimd: number;
    minSgprAllocation: number;
    maxSgprAllocation: number;
    sgprAllocationGranularity: number;
    vgprsPerSimd: number;
    minVgprAllocation: number;
    maxVgprAllocation: number;
    vgprAllocationGranularity: number;
  }) {
    const s = VkPhysicalDeviceShaderCorePropertiesAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderEngineCount !== undefined) s.shaderEngineCount = data.shaderEngineCount;
    if (data.shaderArraysPerEngineCount !== undefined) s.shaderArraysPerEngineCount = data.shaderArraysPerEngineCount;
    if (data.computeUnitsPerShaderArray !== undefined) s.computeUnitsPerShaderArray = data.computeUnitsPerShaderArray;
    if (data.simdPerComputeUnit !== undefined) s.simdPerComputeUnit = data.simdPerComputeUnit;
    if (data.wavefrontsPerSimd !== undefined) s.wavefrontsPerSimd = data.wavefrontsPerSimd;
    if (data.wavefrontSize !== undefined) s.wavefrontSize = data.wavefrontSize;
    if (data.sgprsPerSimd !== undefined) s.sgprsPerSimd = data.sgprsPerSimd;
    if (data.minSgprAllocation !== undefined) s.minSgprAllocation = data.minSgprAllocation;
    if (data.maxSgprAllocation !== undefined) s.maxSgprAllocation = data.maxSgprAllocation;
    if (data.sgprAllocationGranularity !== undefined) s.sgprAllocationGranularity = data.sgprAllocationGranularity;
    if (data.vgprsPerSimd !== undefined) s.vgprsPerSimd = data.vgprsPerSimd;
    if (data.minVgprAllocation !== undefined) s.minVgprAllocation = data.minVgprAllocation;
    if (data.maxVgprAllocation !== undefined) s.maxVgprAllocation = data.maxVgprAllocation;
    if (data.vgprAllocationGranularity !== undefined) s.vgprAllocationGranularity = data.vgprAllocationGranularity;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderEngineCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderEngineCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderArraysPerEngineCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderArraysPerEngineCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get computeUnitsPerShaderArray() {
    return this.#view.getUint32(24, LE);
  }
  
  set computeUnitsPerShaderArray(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get simdPerComputeUnit() {
    return this.#view.getUint32(28, LE);
  }
  
  set simdPerComputeUnit(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get wavefrontsPerSimd() {
    return this.#view.getUint32(32, LE);
  }
  
  set wavefrontsPerSimd(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get wavefrontSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set wavefrontSize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get sgprsPerSimd() {
    return this.#view.getUint32(40, LE);
  }
  
  set sgprsPerSimd(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minSgprAllocation() {
    return this.#view.getUint32(44, LE);
  }
  
  set minSgprAllocation(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxSgprAllocation() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxSgprAllocation(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get sgprAllocationGranularity() {
    return this.#view.getUint32(52, LE);
  }
  
  set sgprAllocationGranularity(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get vgprsPerSimd() {
    return this.#view.getUint32(56, LE);
  }
  
  set vgprsPerSimd(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get minVgprAllocation() {
    return this.#view.getUint32(60, LE);
  }
  
  set minVgprAllocation(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxVgprAllocation() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxVgprAllocation(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get vgprAllocationGranularity() {
    return this.#view.getUint32(68, LE);
  }
  
  set vgprAllocationGranularity(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderCoreProperties2AMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderCoreProperties2AMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderCoreProperties2AMD(new Uint8Array(VkPhysicalDeviceShaderCoreProperties2AMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD;
    activeComputeUnitCount: number;
  }) {
    const s = VkPhysicalDeviceShaderCoreProperties2AMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderCoreFeatures !== undefined) s.shaderCoreFeatures = data.shaderCoreFeatures;
    if (data.activeComputeUnitCount !== undefined) s.activeComputeUnitCount = data.activeComputeUnitCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderCoreFeatures() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderCoreFeatures(value: VkShaderCorePropertiesFlagsAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get activeComputeUnitCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set activeComputeUnitCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPipelineRasterizationConservativeStateCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationConservativeStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationConservativeStateCreateInfoEXT(new Uint8Array(VkPipelineRasterizationConservativeStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineRasterizationConservativeStateCreateFlagsEXT;
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT;
    extraPrimitiveOverestimationSize: number;
  }) {
    const s = VkPipelineRasterizationConservativeStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.conservativeRasterizationMode !== undefined) s.conservativeRasterizationMode = data.conservativeRasterizationMode;
    if (data.extraPrimitiveOverestimationSize !== undefined) s.extraPrimitiveOverestimationSize = data.extraPrimitiveOverestimationSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineRasterizationConservativeStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get conservativeRasterizationMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set conservativeRasterizationMode(value: VkConservativeRasterizationModeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extraPrimitiveOverestimationSize() {
    return this.#view.getFloat32(24, LE);
  }
  
  set extraPrimitiveOverestimationSize(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorIndexingFeatures implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorIndexingFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorIndexingFeatures(new Uint8Array(VkPhysicalDeviceDescriptorIndexingFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderInputAttachmentArrayDynamicIndexing: VkBool32;
    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32;
    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32;
    shaderUniformBufferArrayNonUniformIndexing: VkBool32;
    shaderSampledImageArrayNonUniformIndexing: VkBool32;
    shaderStorageBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageImageArrayNonUniformIndexing: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexing: VkBool32;
    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32;
    descriptorBindingUniformBufferUpdateAfterBind: VkBool32;
    descriptorBindingSampledImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageBufferUpdateAfterBind: VkBool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingUpdateUnusedWhilePending: VkBool32;
    descriptorBindingPartiallyBound: VkBool32;
    descriptorBindingVariableDescriptorCount: VkBool32;
    runtimeDescriptorArray: VkBool32;
  }) {
    const s = VkPhysicalDeviceDescriptorIndexingFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderInputAttachmentArrayDynamicIndexing !== undefined) s.shaderInputAttachmentArrayDynamicIndexing = data.shaderInputAttachmentArrayDynamicIndexing;
    if (data.shaderUniformTexelBufferArrayDynamicIndexing !== undefined) s.shaderUniformTexelBufferArrayDynamicIndexing = data.shaderUniformTexelBufferArrayDynamicIndexing;
    if (data.shaderStorageTexelBufferArrayDynamicIndexing !== undefined) s.shaderStorageTexelBufferArrayDynamicIndexing = data.shaderStorageTexelBufferArrayDynamicIndexing;
    if (data.shaderUniformBufferArrayNonUniformIndexing !== undefined) s.shaderUniformBufferArrayNonUniformIndexing = data.shaderUniformBufferArrayNonUniformIndexing;
    if (data.shaderSampledImageArrayNonUniformIndexing !== undefined) s.shaderSampledImageArrayNonUniformIndexing = data.shaderSampledImageArrayNonUniformIndexing;
    if (data.shaderStorageBufferArrayNonUniformIndexing !== undefined) s.shaderStorageBufferArrayNonUniformIndexing = data.shaderStorageBufferArrayNonUniformIndexing;
    if (data.shaderStorageImageArrayNonUniformIndexing !== undefined) s.shaderStorageImageArrayNonUniformIndexing = data.shaderStorageImageArrayNonUniformIndexing;
    if (data.shaderInputAttachmentArrayNonUniformIndexing !== undefined) s.shaderInputAttachmentArrayNonUniformIndexing = data.shaderInputAttachmentArrayNonUniformIndexing;
    if (data.shaderUniformTexelBufferArrayNonUniformIndexing !== undefined) s.shaderUniformTexelBufferArrayNonUniformIndexing = data.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (data.shaderStorageTexelBufferArrayNonUniformIndexing !== undefined) s.shaderStorageTexelBufferArrayNonUniformIndexing = data.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (data.descriptorBindingUniformBufferUpdateAfterBind !== undefined) s.descriptorBindingUniformBufferUpdateAfterBind = data.descriptorBindingUniformBufferUpdateAfterBind;
    if (data.descriptorBindingSampledImageUpdateAfterBind !== undefined) s.descriptorBindingSampledImageUpdateAfterBind = data.descriptorBindingSampledImageUpdateAfterBind;
    if (data.descriptorBindingStorageImageUpdateAfterBind !== undefined) s.descriptorBindingStorageImageUpdateAfterBind = data.descriptorBindingStorageImageUpdateAfterBind;
    if (data.descriptorBindingStorageBufferUpdateAfterBind !== undefined) s.descriptorBindingStorageBufferUpdateAfterBind = data.descriptorBindingStorageBufferUpdateAfterBind;
    if (data.descriptorBindingUniformTexelBufferUpdateAfterBind !== undefined) s.descriptorBindingUniformTexelBufferUpdateAfterBind = data.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (data.descriptorBindingStorageTexelBufferUpdateAfterBind !== undefined) s.descriptorBindingStorageTexelBufferUpdateAfterBind = data.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (data.descriptorBindingUpdateUnusedWhilePending !== undefined) s.descriptorBindingUpdateUnusedWhilePending = data.descriptorBindingUpdateUnusedWhilePending;
    if (data.descriptorBindingPartiallyBound !== undefined) s.descriptorBindingPartiallyBound = data.descriptorBindingPartiallyBound;
    if (data.descriptorBindingVariableDescriptorCount !== undefined) s.descriptorBindingVariableDescriptorCount = data.descriptorBindingVariableDescriptorCount;
    if (data.runtimeDescriptorArray !== undefined) s.runtimeDescriptorArray = data.runtimeDescriptorArray;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderInputAttachmentArrayDynamicIndexing() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderInputAttachmentArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderUniformTexelBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderStorageTexelBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexing() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexing() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexing() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderUniformTexelBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderStorageTexelBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get descriptorBindingUniformBufferUpdateAfterBind() {
    return this.#view.getUint32(56, LE);
  }
  
  set descriptorBindingUniformBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get descriptorBindingSampledImageUpdateAfterBind() {
    return this.#view.getUint32(60, LE);
  }
  
  set descriptorBindingSampledImageUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get descriptorBindingStorageImageUpdateAfterBind() {
    return this.#view.getUint32(64, LE);
  }
  
  set descriptorBindingStorageImageUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get descriptorBindingStorageBufferUpdateAfterBind() {
    return this.#view.getUint32(68, LE);
  }
  
  set descriptorBindingStorageBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get descriptorBindingUniformTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(72, LE);
  }
  
  set descriptorBindingUniformTexelBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get descriptorBindingStorageTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(76, LE);
  }
  
  set descriptorBindingStorageTexelBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get descriptorBindingUpdateUnusedWhilePending() {
    return this.#view.getUint32(80, LE);
  }
  
  set descriptorBindingUpdateUnusedWhilePending(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get descriptorBindingPartiallyBound() {
    return this.#view.getUint32(84, LE);
  }
  
  set descriptorBindingPartiallyBound(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get descriptorBindingVariableDescriptorCount() {
    return this.#view.getUint32(88, LE);
  }
  
  set descriptorBindingVariableDescriptorCount(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get runtimeDescriptorArray() {
    return this.#view.getUint32(92, LE);
  }
  
  set runtimeDescriptorArray(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorIndexingProperties implements IVkStructure {
  static size = 112;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorIndexingProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorIndexingProperties(new Uint8Array(VkPhysicalDeviceDescriptorIndexingProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxUpdateAfterBindDescriptorsInAllPools: number;
    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32;
    shaderSampledImageArrayNonUniformIndexingNative: VkBool32;
    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32;
    shaderStorageImageArrayNonUniformIndexingNative: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32;
    robustBufferAccessUpdateAfterBind: VkBool32;
    quadDivergentImplicitLod: VkBool32;
    maxPerStageDescriptorUpdateAfterBindSamplers: number;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;
    maxPerStageDescriptorUpdateAfterBindSampledImages: number;
    maxPerStageDescriptorUpdateAfterBindStorageImages: number;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: number;
    maxPerStageUpdateAfterBindResources: number;
    maxDescriptorSetUpdateAfterBindSamplers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindStorageBuffers: number;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindSampledImages: number;
    maxDescriptorSetUpdateAfterBindStorageImages: number;
    maxDescriptorSetUpdateAfterBindInputAttachments: number;
  }) {
    const s = VkPhysicalDeviceDescriptorIndexingProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxUpdateAfterBindDescriptorsInAllPools !== undefined) s.maxUpdateAfterBindDescriptorsInAllPools = data.maxUpdateAfterBindDescriptorsInAllPools;
    if (data.shaderUniformBufferArrayNonUniformIndexingNative !== undefined) s.shaderUniformBufferArrayNonUniformIndexingNative = data.shaderUniformBufferArrayNonUniformIndexingNative;
    if (data.shaderSampledImageArrayNonUniformIndexingNative !== undefined) s.shaderSampledImageArrayNonUniformIndexingNative = data.shaderSampledImageArrayNonUniformIndexingNative;
    if (data.shaderStorageBufferArrayNonUniformIndexingNative !== undefined) s.shaderStorageBufferArrayNonUniformIndexingNative = data.shaderStorageBufferArrayNonUniformIndexingNative;
    if (data.shaderStorageImageArrayNonUniformIndexingNative !== undefined) s.shaderStorageImageArrayNonUniformIndexingNative = data.shaderStorageImageArrayNonUniformIndexingNative;
    if (data.shaderInputAttachmentArrayNonUniformIndexingNative !== undefined) s.shaderInputAttachmentArrayNonUniformIndexingNative = data.shaderInputAttachmentArrayNonUniformIndexingNative;
    if (data.robustBufferAccessUpdateAfterBind !== undefined) s.robustBufferAccessUpdateAfterBind = data.robustBufferAccessUpdateAfterBind;
    if (data.quadDivergentImplicitLod !== undefined) s.quadDivergentImplicitLod = data.quadDivergentImplicitLod;
    if (data.maxPerStageDescriptorUpdateAfterBindSamplers !== undefined) s.maxPerStageDescriptorUpdateAfterBindSamplers = data.maxPerStageDescriptorUpdateAfterBindSamplers;
    if (data.maxPerStageDescriptorUpdateAfterBindUniformBuffers !== undefined) s.maxPerStageDescriptorUpdateAfterBindUniformBuffers = data.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    if (data.maxPerStageDescriptorUpdateAfterBindStorageBuffers !== undefined) s.maxPerStageDescriptorUpdateAfterBindStorageBuffers = data.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    if (data.maxPerStageDescriptorUpdateAfterBindSampledImages !== undefined) s.maxPerStageDescriptorUpdateAfterBindSampledImages = data.maxPerStageDescriptorUpdateAfterBindSampledImages;
    if (data.maxPerStageDescriptorUpdateAfterBindStorageImages !== undefined) s.maxPerStageDescriptorUpdateAfterBindStorageImages = data.maxPerStageDescriptorUpdateAfterBindStorageImages;
    if (data.maxPerStageDescriptorUpdateAfterBindInputAttachments !== undefined) s.maxPerStageDescriptorUpdateAfterBindInputAttachments = data.maxPerStageDescriptorUpdateAfterBindInputAttachments;
    if (data.maxPerStageUpdateAfterBindResources !== undefined) s.maxPerStageUpdateAfterBindResources = data.maxPerStageUpdateAfterBindResources;
    if (data.maxDescriptorSetUpdateAfterBindSamplers !== undefined) s.maxDescriptorSetUpdateAfterBindSamplers = data.maxDescriptorSetUpdateAfterBindSamplers;
    if (data.maxDescriptorSetUpdateAfterBindUniformBuffers !== undefined) s.maxDescriptorSetUpdateAfterBindUniformBuffers = data.maxDescriptorSetUpdateAfterBindUniformBuffers;
    if (data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic !== undefined) s.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    if (data.maxDescriptorSetUpdateAfterBindStorageBuffers !== undefined) s.maxDescriptorSetUpdateAfterBindStorageBuffers = data.maxDescriptorSetUpdateAfterBindStorageBuffers;
    if (data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic !== undefined) s.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    if (data.maxDescriptorSetUpdateAfterBindSampledImages !== undefined) s.maxDescriptorSetUpdateAfterBindSampledImages = data.maxDescriptorSetUpdateAfterBindSampledImages;
    if (data.maxDescriptorSetUpdateAfterBindStorageImages !== undefined) s.maxDescriptorSetUpdateAfterBindStorageImages = data.maxDescriptorSetUpdateAfterBindStorageImages;
    if (data.maxDescriptorSetUpdateAfterBindInputAttachments !== undefined) s.maxDescriptorSetUpdateAfterBindInputAttachments = data.maxDescriptorSetUpdateAfterBindInputAttachments;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxUpdateAfterBindDescriptorsInAllPools() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxUpdateAfterBindDescriptorsInAllPools(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexingNative() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get robustBufferAccessUpdateAfterBind() {
    return this.#view.getUint32(40, LE);
  }
  
  set robustBufferAccessUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get quadDivergentImplicitLod() {
    return this.#view.getUint32(44, LE);
  }
  
  set quadDivergentImplicitLod(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSamplers() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSampledImages() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageImages() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxPerStageUpdateAfterBindResources() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxPerStageUpdateAfterBindResources(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSamplers() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(80, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffersDynamic(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffersDynamic(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSampledImages() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageImages() {
    return this.#view.getUint32(100, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
}

export class VkDescriptorSetLayoutBindingFlagsCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetLayoutBindingFlagsCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetLayoutBindingFlagsCreateInfo(new Uint8Array(VkDescriptorSetLayoutBindingFlagsCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    bindingCount?: number;
    pBindingFlags?: Deno.PointerValue;
  }) {
    const s = VkDescriptorSetLayoutBindingFlagsCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.bindingCount !== undefined) s.bindingCount = data.bindingCount;
    if (data.pBindingFlags !== undefined) s.pBindingFlags = data.pBindingFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get bindingCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set bindingCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pBindingFlags() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pBindingFlags(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorSetVariableDescriptorCountAllocateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetVariableDescriptorCountAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetVariableDescriptorCountAllocateInfo(new Uint8Array(VkDescriptorSetVariableDescriptorCountAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorSetCount?: number;
    pDescriptorCounts: Deno.PointerValue;
  }) {
    const s = VkDescriptorSetVariableDescriptorCountAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorSetCount !== undefined) s.descriptorSetCount = data.descriptorSetCount;
    if (data.pDescriptorCounts !== undefined) s.pDescriptorCounts = data.pDescriptorCounts;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorSetCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorSetCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDescriptorCounts() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDescriptorCounts(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDescriptorSetVariableDescriptorCountLayoutSupport implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetVariableDescriptorCountLayoutSupport.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetVariableDescriptorCountLayoutSupport(new Uint8Array(VkDescriptorSetVariableDescriptorCountLayoutSupport.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxVariableDescriptorCount: number;
  }) {
    const s = VkDescriptorSetVariableDescriptorCountLayoutSupport.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxVariableDescriptorCount !== undefined) s.maxVariableDescriptorCount = data.maxVariableDescriptorCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxVariableDescriptorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxVariableDescriptorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkAttachmentDescription2 implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentDescription2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentDescription2(new Uint8Array(VkAttachmentDescription2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkAttachmentDescriptionFlags;
    format: VkFormat;
    samples: VkSampleCountFlagBits;
    loadOp: VkAttachmentLoadOp;
    storeOp: VkAttachmentStoreOp;
    stencilLoadOp: VkAttachmentLoadOp;
    stencilStoreOp: VkAttachmentStoreOp;
    initialLayout: VkImageLayout;
    finalLayout: VkImageLayout;
  }) {
    const s = VkAttachmentDescription2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.format !== undefined) s.format = data.format;
    if (data.samples !== undefined) s.samples = data.samples;
    if (data.loadOp !== undefined) s.loadOp = data.loadOp;
    if (data.storeOp !== undefined) s.storeOp = data.storeOp;
    if (data.stencilLoadOp !== undefined) s.stencilLoadOp = data.stencilLoadOp;
    if (data.stencilStoreOp !== undefined) s.stencilStoreOp = data.stencilStoreOp;
    if (data.initialLayout !== undefined) s.initialLayout = data.initialLayout;
    if (data.finalLayout !== undefined) s.finalLayout = data.finalLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkAttachmentDescriptionFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(20, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(24, LE);
  }
  
  set samples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(28, LE);
  }
  
  set loadOp(value: VkAttachmentLoadOp) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(32, LE);
  }
  
  set storeOp(value: VkAttachmentStoreOp) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilLoadOp() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilLoadOp(value: VkAttachmentLoadOp) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get stencilStoreOp() {
    return this.#view.getUint32(40, LE);
  }
  
  set stencilStoreOp(value: VkAttachmentStoreOp) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(44, LE);
  }
  
  set initialLayout(value: VkImageLayout) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get finalLayout() {
    return this.#view.getUint32(48, LE);
  }
  
  set finalLayout(value: VkImageLayout) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkAttachmentReference2 implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentReference2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentReference2(new Uint8Array(VkAttachmentReference2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachment: number;
    layout: VkImageLayout;
    aspectMask: VkImageAspectFlags;
  }) {
    const s = VkAttachmentReference2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachment !== undefined) s.attachment = data.attachment;
    if (data.layout !== undefined) s.layout = data.layout;
    if (data.aspectMask !== undefined) s.aspectMask = data.aspectMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachment() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachment(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getUint32(20, LE);
  }
  
  set layout(value: VkImageLayout) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get aspectMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set aspectMask(value: VkImageAspectFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkSubpassDescription2 implements IVkStructure {
  static size = 88;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassDescription2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassDescription2(new Uint8Array(VkSubpassDescription2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSubpassDescriptionFlags;
    pipelineBindPoint: VkPipelineBindPoint;
    viewMask: number;
    inputAttachmentCount?: number;
    pInputAttachments: Deno.PointerValue;
    colorAttachmentCount?: number;
    pColorAttachments: Deno.PointerValue;
    pResolveAttachments?: Deno.PointerValue;
    pDepthStencilAttachment?: Deno.PointerValue;
    preserveAttachmentCount?: number;
    pPreserveAttachments: Deno.PointerValue;
  }) {
    const s = VkSubpassDescription2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pipelineBindPoint !== undefined) s.pipelineBindPoint = data.pipelineBindPoint;
    if (data.viewMask !== undefined) s.viewMask = data.viewMask;
    if (data.inputAttachmentCount !== undefined) s.inputAttachmentCount = data.inputAttachmentCount;
    if (data.pInputAttachments !== undefined) s.pInputAttachments = data.pInputAttachments;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachments !== undefined) s.pColorAttachments = data.pColorAttachments;
    if (data.pResolveAttachments !== undefined) s.pResolveAttachments = data.pResolveAttachments;
    if (data.pDepthStencilAttachment !== undefined) s.pDepthStencilAttachment = data.pDepthStencilAttachment;
    if (data.preserveAttachmentCount !== undefined) s.preserveAttachmentCount = data.preserveAttachmentCount;
    if (data.pPreserveAttachments !== undefined) s.pPreserveAttachments = data.pPreserveAttachments;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSubpassDescriptionFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(20, LE);
  }
  
  set pipelineBindPoint(value: VkPipelineBindPoint) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get inputAttachmentCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set inputAttachmentCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pInputAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInputAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pColorAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get pResolveAttachments() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pResolveAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pDepthStencilAttachment() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pDepthStencilAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get preserveAttachmentCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set preserveAttachmentCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pPreserveAttachments() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pPreserveAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
}

export class VkSubpassDependency2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassDependency2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassDependency2(new Uint8Array(VkSubpassDependency2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcSubpass: number;
    dstSubpass: number;
    srcStageMask?: VkPipelineStageFlags;
    dstStageMask?: VkPipelineStageFlags;
    srcAccessMask?: VkAccessFlags;
    dstAccessMask?: VkAccessFlags;
    dependencyFlags?: VkDependencyFlags;
    viewOffset: number;
  }) {
    const s = VkSubpassDependency2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcSubpass !== undefined) s.srcSubpass = data.srcSubpass;
    if (data.dstSubpass !== undefined) s.dstSubpass = data.dstSubpass;
    if (data.srcStageMask !== undefined) s.srcStageMask = data.srcStageMask;
    if (data.dstStageMask !== undefined) s.dstStageMask = data.dstStageMask;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.dependencyFlags !== undefined) s.dependencyFlags = data.dependencyFlags;
    if (data.viewOffset !== undefined) s.viewOffset = data.viewOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcSubpass() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcSubpass(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstSubpass() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstSubpass(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcStageMask(value: VkPipelineStageFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstStageMask(value: VkPipelineStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(32, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(36, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(40, LE);
  }
  
  set dependencyFlags(value: VkDependencyFlags) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get viewOffset() {
    return this.#view.getInt32(44, LE);
  }
  
  set viewOffset(value: number) {
    this.#view.setInt32(44, Number(value), LE);
  }
}

export class VkRenderPassCreateInfo2 implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassCreateInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassCreateInfo2(new Uint8Array(VkRenderPassCreateInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkRenderPassCreateFlags;
    attachmentCount?: number;
    pAttachments: Deno.PointerValue;
    subpassCount: number;
    pSubpasses: Deno.PointerValue;
    dependencyCount?: number;
    pDependencies: Deno.PointerValue;
    correlatedViewMaskCount?: number;
    pCorrelatedViewMasks: Deno.PointerValue;
  }) {
    const s = VkRenderPassCreateInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pAttachments !== undefined) s.pAttachments = data.pAttachments;
    if (data.subpassCount !== undefined) s.subpassCount = data.subpassCount;
    if (data.pSubpasses !== undefined) s.pSubpasses = data.pSubpasses;
    if (data.dependencyCount !== undefined) s.dependencyCount = data.dependencyCount;
    if (data.pDependencies !== undefined) s.pDependencies = data.pDependencies;
    if (data.correlatedViewMaskCount !== undefined) s.correlatedViewMaskCount = data.correlatedViewMaskCount;
    if (data.pCorrelatedViewMasks !== undefined) s.pCorrelatedViewMasks = data.pCorrelatedViewMasks;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkRenderPassCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSubpasses() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSubpasses(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pDependencies() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pDependencies(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get correlatedViewMaskCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set correlatedViewMaskCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pCorrelatedViewMasks() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pCorrelatedViewMasks(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
}

export class VkSubpassBeginInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassBeginInfo(new Uint8Array(VkSubpassBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    contents: VkSubpassContents;
  }) {
    const s = VkSubpassBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.contents !== undefined) s.contents = data.contents;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get contents() {
    return this.#view.getUint32(16, LE);
  }
  
  set contents(value: VkSubpassContents) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSubpassEndInfo implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassEndInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassEndInfo(new Uint8Array(VkSubpassEndInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
  }) {
    const s = VkSubpassEndInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceTimelineSemaphoreFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTimelineSemaphoreFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTimelineSemaphoreFeatures(new Uint8Array(VkPhysicalDeviceTimelineSemaphoreFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    timelineSemaphore: VkBool32;
  }) {
    const s = VkPhysicalDeviceTimelineSemaphoreFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.timelineSemaphore !== undefined) s.timelineSemaphore = data.timelineSemaphore;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get timelineSemaphore() {
    return this.#view.getUint32(16, LE);
  }
  
  set timelineSemaphore(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceTimelineSemaphoreProperties implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTimelineSemaphoreProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTimelineSemaphoreProperties(new Uint8Array(VkPhysicalDeviceTimelineSemaphoreProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxTimelineSemaphoreValueDifference: Deno.PointerValue;
  }) {
    const s = VkPhysicalDeviceTimelineSemaphoreProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxTimelineSemaphoreValueDifference !== undefined) s.maxTimelineSemaphoreValueDifference = data.maxTimelineSemaphoreValueDifference;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxTimelineSemaphoreValueDifference() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxTimelineSemaphoreValueDifference(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSemaphoreTypeCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreTypeCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreTypeCreateInfo(new Uint8Array(VkSemaphoreTypeCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphoreType: VkSemaphoreType;
    initialValue: Deno.PointerValue;
  }) {
    const s = VkSemaphoreTypeCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphoreType !== undefined) s.semaphoreType = data.semaphoreType;
    if (data.initialValue !== undefined) s.initialValue = data.initialValue;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphoreType() {
    return this.#view.getUint32(16, LE);
  }
  
  set semaphoreType(value: VkSemaphoreType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialValue() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialValue(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkTimelineSemaphoreSubmitInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTimelineSemaphoreSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTimelineSemaphoreSubmitInfo(new Uint8Array(VkTimelineSemaphoreSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    waitSemaphoreValueCount?: number;
    pWaitSemaphoreValues?: Deno.PointerValue;
    signalSemaphoreValueCount?: number;
    pSignalSemaphoreValues?: Deno.PointerValue;
  }) {
    const s = VkTimelineSemaphoreSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.waitSemaphoreValueCount !== undefined) s.waitSemaphoreValueCount = data.waitSemaphoreValueCount;
    if (data.pWaitSemaphoreValues !== undefined) s.pWaitSemaphoreValues = data.pWaitSemaphoreValues;
    if (data.signalSemaphoreValueCount !== undefined) s.signalSemaphoreValueCount = data.signalSemaphoreValueCount;
    if (data.pSignalSemaphoreValues !== undefined) s.pSignalSemaphoreValues = data.pSignalSemaphoreValues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get waitSemaphoreValueCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreValueCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreValues() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get signalSemaphoreValueCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set signalSemaphoreValueCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSignalSemaphoreValues() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSignalSemaphoreValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkSemaphoreWaitInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreWaitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreWaitInfo(new Uint8Array(VkSemaphoreWaitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSemaphoreWaitFlags;
    semaphoreCount: number;
    pSemaphores: Deno.PointerValue;
    pValues: Deno.PointerValue;
  }) {
    const s = VkSemaphoreWaitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.semaphoreCount !== undefined) s.semaphoreCount = data.semaphoreCount;
    if (data.pSemaphores !== undefined) s.pSemaphores = data.pSemaphores;
    if (data.pValues !== undefined) s.pValues = data.pValues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSemaphoreWaitFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get semaphoreCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set semaphoreCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pSemaphores(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pValues() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pValues(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkSemaphoreSignalInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreSignalInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreSignalInfo(new Uint8Array(VkSemaphoreSignalInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    value: Deno.PointerValue;
  }) {
    const s = VkSemaphoreSignalInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.value !== undefined) s.value = data.value;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get value() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set value(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVertexInputBindingDivisorDescriptionEXT implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVertexInputBindingDivisorDescriptionEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVertexInputBindingDivisorDescriptionEXT(new Uint8Array(VkVertexInputBindingDivisorDescriptionEXT.size));
  }
  
  static create(data: {
    binding: number;
    divisor: number;
  }) {
    const s = VkVertexInputBindingDivisorDescriptionEXT.alloc();
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.divisor !== undefined) s.divisor = data.divisor;
    return s;
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get divisor() {
    return this.#view.getUint32(4, LE);
  }
  
  set divisor(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkPipelineVertexInputDivisorStateCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineVertexInputDivisorStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineVertexInputDivisorStateCreateInfoEXT(new Uint8Array(VkPipelineVertexInputDivisorStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexBindingDivisorCount: number;
    pVertexBindingDivisors: Deno.PointerValue;
  }) {
    const s = VkPipelineVertexInputDivisorStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexBindingDivisorCount !== undefined) s.vertexBindingDivisorCount = data.vertexBindingDivisorCount;
    if (data.pVertexBindingDivisors !== undefined) s.pVertexBindingDivisors = data.pVertexBindingDivisors;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexBindingDivisorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexBindingDivisorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pVertexBindingDivisors() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVertexBindingDivisors(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(new Uint8Array(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxVertexAttribDivisor: number;
  }) {
    const s = VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxVertexAttribDivisor !== undefined) s.maxVertexAttribDivisor = data.maxVertexAttribDivisor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxVertexAttribDivisor() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxVertexAttribDivisor(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePCIBusInfoPropertiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePCIBusInfoPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePCIBusInfoPropertiesEXT(new Uint8Array(VkPhysicalDevicePCIBusInfoPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pciDomain: number;
    pciBus: number;
    pciDevice: number;
    pciFunction: number;
  }) {
    const s = VkPhysicalDevicePCIBusInfoPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pciDomain !== undefined) s.pciDomain = data.pciDomain;
    if (data.pciBus !== undefined) s.pciBus = data.pciBus;
    if (data.pciDevice !== undefined) s.pciDevice = data.pciDevice;
    if (data.pciFunction !== undefined) s.pciFunction = data.pciFunction;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pciDomain() {
    return this.#view.getUint32(16, LE);
  }
  
  set pciDomain(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pciBus() {
    return this.#view.getUint32(20, LE);
  }
  
  set pciBus(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pciDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set pciDevice(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pciFunction() {
    return this.#view.getUint32(28, LE);
  }
  
  set pciFunction(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkImportAndroidHardwareBufferInfoANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportAndroidHardwareBufferInfoANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportAndroidHardwareBufferInfoANDROID(new Uint8Array(VkImportAndroidHardwareBufferInfoANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: Deno.PointerValue;
  }) {
    const s = VkImportAndroidHardwareBufferInfoANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAndroidHardwareBufferUsageANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAndroidHardwareBufferUsageANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAndroidHardwareBufferUsageANDROID(new Uint8Array(VkAndroidHardwareBufferUsageANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    androidHardwareBufferUsage: Deno.PointerValue;
  }) {
    const s = VkAndroidHardwareBufferUsageANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.androidHardwareBufferUsage !== undefined) s.androidHardwareBufferUsage = data.androidHardwareBufferUsage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get androidHardwareBufferUsage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set androidHardwareBufferUsage(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAndroidHardwareBufferPropertiesANDROID implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAndroidHardwareBufferPropertiesANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAndroidHardwareBufferPropertiesANDROID(new Uint8Array(VkAndroidHardwareBufferPropertiesANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    allocationSize: VkDeviceSize;
    memoryTypeBits: number;
  }) {
    const s = VkAndroidHardwareBufferPropertiesANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.allocationSize !== undefined) s.allocationSize = data.allocationSize;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get allocationSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set allocationSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(24, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkMemoryGetAndroidHardwareBufferInfoANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryGetAndroidHardwareBufferInfoANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryGetAndroidHardwareBufferInfoANDROID(new Uint8Array(VkMemoryGetAndroidHardwareBufferInfoANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
  }) {
    const s = VkMemoryGetAndroidHardwareBufferInfoANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAndroidHardwareBufferFormatPropertiesANDROID implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAndroidHardwareBufferFormatPropertiesANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAndroidHardwareBufferFormatPropertiesANDROID(new Uint8Array(VkAndroidHardwareBufferFormatPropertiesANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    externalFormat: Deno.PointerValue;
    formatFeatures: VkFormatFeatureFlags;
    samplerYcbcrConversionComponents: VkComponentMapping;
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion;
    suggestedYcbcrRange: VkSamplerYcbcrRange;
    suggestedXChromaOffset: VkChromaLocation;
    suggestedYChromaOffset: VkChromaLocation;
  }) {
    const s = VkAndroidHardwareBufferFormatPropertiesANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.externalFormat !== undefined) s.externalFormat = data.externalFormat;
    if (data.formatFeatures !== undefined) s.formatFeatures = data.formatFeatures;
    if (data.samplerYcbcrConversionComponents !== undefined) s.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
    if (data.suggestedYcbcrModel !== undefined) s.suggestedYcbcrModel = data.suggestedYcbcrModel;
    if (data.suggestedYcbcrRange !== undefined) s.suggestedYcbcrRange = data.suggestedYcbcrRange;
    if (data.suggestedXChromaOffset !== undefined) s.suggestedXChromaOffset = data.suggestedXChromaOffset;
    if (data.suggestedYChromaOffset !== undefined) s.suggestedYChromaOffset = data.suggestedYChromaOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getUint32(32, LE);
  }
  
  set formatFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get samplerYcbcrConversionComponents() {
    return new VkComponentMapping(this.#data.subarray(48, 48 + VkComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(64, LE);
  }
  
  set suggestedYcbcrModel(value: VkSamplerYcbcrModelConversion) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(68, LE);
  }
  
  set suggestedYcbcrRange(value: VkSamplerYcbcrRange) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(72, LE);
  }
  
  set suggestedXChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(76, LE);
  }
  
  set suggestedYChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(76, Number(value), LE);
  }
}

export class VkCommandBufferInheritanceConditionalRenderingInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferInheritanceConditionalRenderingInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferInheritanceConditionalRenderingInfoEXT(new Uint8Array(VkCommandBufferInheritanceConditionalRenderingInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    conditionalRenderingEnable: VkBool32;
  }) {
    const s = VkCommandBufferInheritanceConditionalRenderingInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.conditionalRenderingEnable !== undefined) s.conditionalRenderingEnable = data.conditionalRenderingEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get conditionalRenderingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set conditionalRenderingEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExternalFormatANDROID implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExternalFormatANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExternalFormatANDROID(new Uint8Array(VkExternalFormatANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    externalFormat: Deno.PointerValue;
  }) {
    const s = VkExternalFormatANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.externalFormat !== undefined) s.externalFormat = data.externalFormat;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDevice8BitStorageFeatures implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevice8BitStorageFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevice8BitStorageFeatures(new Uint8Array(VkPhysicalDevice8BitStorageFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    storageBuffer8BitAccess: VkBool32;
    uniformAndStorageBuffer8BitAccess: VkBool32;
    storagePushConstant8: VkBool32;
  }) {
    const s = VkPhysicalDevice8BitStorageFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.storageBuffer8BitAccess !== undefined) s.storageBuffer8BitAccess = data.storageBuffer8BitAccess;
    if (data.uniformAndStorageBuffer8BitAccess !== undefined) s.uniformAndStorageBuffer8BitAccess = data.uniformAndStorageBuffer8BitAccess;
    if (data.storagePushConstant8 !== undefined) s.storagePushConstant8 = data.storagePushConstant8;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get storageBuffer8BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer8BitAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer8BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer8BitAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant8() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant8(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceConditionalRenderingFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceConditionalRenderingFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceConditionalRenderingFeaturesEXT(new Uint8Array(VkPhysicalDeviceConditionalRenderingFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    conditionalRendering: VkBool32;
    inheritedConditionalRendering: VkBool32;
  }) {
    const s = VkPhysicalDeviceConditionalRenderingFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.conditionalRendering !== undefined) s.conditionalRendering = data.conditionalRendering;
    if (data.inheritedConditionalRendering !== undefined) s.inheritedConditionalRendering = data.inheritedConditionalRendering;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get conditionalRendering() {
    return this.#view.getUint32(16, LE);
  }
  
  set conditionalRendering(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inheritedConditionalRendering() {
    return this.#view.getUint32(20, LE);
  }
  
  set inheritedConditionalRendering(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkanMemoryModelFeatures implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkanMemoryModelFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkanMemoryModelFeatures(new Uint8Array(VkPhysicalDeviceVulkanMemoryModelFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vulkanMemoryModel: VkBool32;
    vulkanMemoryModelDeviceScope: VkBool32;
    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32;
  }) {
    const s = VkPhysicalDeviceVulkanMemoryModelFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vulkanMemoryModel !== undefined) s.vulkanMemoryModel = data.vulkanMemoryModel;
    if (data.vulkanMemoryModelDeviceScope !== undefined) s.vulkanMemoryModelDeviceScope = data.vulkanMemoryModelDeviceScope;
    if (data.vulkanMemoryModelAvailabilityVisibilityChains !== undefined) s.vulkanMemoryModelAvailabilityVisibilityChains = data.vulkanMemoryModelAvailabilityVisibilityChains;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vulkanMemoryModel() {
    return this.#view.getUint32(16, LE);
  }
  
  set vulkanMemoryModel(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vulkanMemoryModelDeviceScope() {
    return this.#view.getUint32(20, LE);
  }
  
  set vulkanMemoryModelDeviceScope(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vulkanMemoryModelAvailabilityVisibilityChains() {
    return this.#view.getUint32(24, LE);
  }
  
  set vulkanMemoryModelAvailabilityVisibilityChains(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderAtomicInt64Features implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderAtomicInt64Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderAtomicInt64Features(new Uint8Array(VkPhysicalDeviceShaderAtomicInt64Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderBufferInt64Atomics: VkBool32;
    shaderSharedInt64Atomics: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderAtomicInt64Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderBufferInt64Atomics !== undefined) s.shaderBufferInt64Atomics = data.shaderBufferInt64Atomics;
    if (data.shaderSharedInt64Atomics !== undefined) s.shaderSharedInt64Atomics = data.shaderSharedInt64Atomics;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderBufferInt64Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferInt64Atomics(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderSharedInt64Atomics() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderSharedInt64Atomics(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderAtomicFloatFeaturesEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(new Uint8Array(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderBufferFloat32Atomics: VkBool32;
    shaderBufferFloat32AtomicAdd: VkBool32;
    shaderBufferFloat64Atomics: VkBool32;
    shaderBufferFloat64AtomicAdd: VkBool32;
    shaderSharedFloat32Atomics: VkBool32;
    shaderSharedFloat32AtomicAdd: VkBool32;
    shaderSharedFloat64Atomics: VkBool32;
    shaderSharedFloat64AtomicAdd: VkBool32;
    shaderImageFloat32Atomics: VkBool32;
    shaderImageFloat32AtomicAdd: VkBool32;
    sparseImageFloat32Atomics: VkBool32;
    sparseImageFloat32AtomicAdd: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderBufferFloat32Atomics !== undefined) s.shaderBufferFloat32Atomics = data.shaderBufferFloat32Atomics;
    if (data.shaderBufferFloat32AtomicAdd !== undefined) s.shaderBufferFloat32AtomicAdd = data.shaderBufferFloat32AtomicAdd;
    if (data.shaderBufferFloat64Atomics !== undefined) s.shaderBufferFloat64Atomics = data.shaderBufferFloat64Atomics;
    if (data.shaderBufferFloat64AtomicAdd !== undefined) s.shaderBufferFloat64AtomicAdd = data.shaderBufferFloat64AtomicAdd;
    if (data.shaderSharedFloat32Atomics !== undefined) s.shaderSharedFloat32Atomics = data.shaderSharedFloat32Atomics;
    if (data.shaderSharedFloat32AtomicAdd !== undefined) s.shaderSharedFloat32AtomicAdd = data.shaderSharedFloat32AtomicAdd;
    if (data.shaderSharedFloat64Atomics !== undefined) s.shaderSharedFloat64Atomics = data.shaderSharedFloat64Atomics;
    if (data.shaderSharedFloat64AtomicAdd !== undefined) s.shaderSharedFloat64AtomicAdd = data.shaderSharedFloat64AtomicAdd;
    if (data.shaderImageFloat32Atomics !== undefined) s.shaderImageFloat32Atomics = data.shaderImageFloat32Atomics;
    if (data.shaderImageFloat32AtomicAdd !== undefined) s.shaderImageFloat32AtomicAdd = data.shaderImageFloat32AtomicAdd;
    if (data.sparseImageFloat32Atomics !== undefined) s.sparseImageFloat32Atomics = data.sparseImageFloat32Atomics;
    if (data.sparseImageFloat32AtomicAdd !== undefined) s.sparseImageFloat32AtomicAdd = data.sparseImageFloat32AtomicAdd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderBufferFloat32Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferFloat32Atomics(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderBufferFloat32AtomicAdd() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderBufferFloat32AtomicAdd(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderBufferFloat64Atomics() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderBufferFloat64Atomics(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderBufferFloat64AtomicAdd() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderBufferFloat64AtomicAdd(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSharedFloat32Atomics() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSharedFloat32Atomics(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderSharedFloat32AtomicAdd() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderSharedFloat32AtomicAdd(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedFloat64Atomics() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedFloat64Atomics(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderSharedFloat64AtomicAdd() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderSharedFloat64AtomicAdd(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderImageFloat32Atomics() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderImageFloat32Atomics(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderImageFloat32AtomicAdd() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderImageFloat32AtomicAdd(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get sparseImageFloat32Atomics() {
    return this.#view.getUint32(56, LE);
  }
  
  set sparseImageFloat32Atomics(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sparseImageFloat32AtomicAdd() {
    return this.#view.getUint32(60, LE);
  }
  
  set sparseImageFloat32AtomicAdd(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(new Uint8Array(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderBufferFloat16Atomics: VkBool32;
    shaderBufferFloat16AtomicAdd: VkBool32;
    shaderBufferFloat16AtomicMinMax: VkBool32;
    shaderBufferFloat32AtomicMinMax: VkBool32;
    shaderBufferFloat64AtomicMinMax: VkBool32;
    shaderSharedFloat16Atomics: VkBool32;
    shaderSharedFloat16AtomicAdd: VkBool32;
    shaderSharedFloat16AtomicMinMax: VkBool32;
    shaderSharedFloat32AtomicMinMax: VkBool32;
    shaderSharedFloat64AtomicMinMax: VkBool32;
    shaderImageFloat32AtomicMinMax: VkBool32;
    sparseImageFloat32AtomicMinMax: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderBufferFloat16Atomics !== undefined) s.shaderBufferFloat16Atomics = data.shaderBufferFloat16Atomics;
    if (data.shaderBufferFloat16AtomicAdd !== undefined) s.shaderBufferFloat16AtomicAdd = data.shaderBufferFloat16AtomicAdd;
    if (data.shaderBufferFloat16AtomicMinMax !== undefined) s.shaderBufferFloat16AtomicMinMax = data.shaderBufferFloat16AtomicMinMax;
    if (data.shaderBufferFloat32AtomicMinMax !== undefined) s.shaderBufferFloat32AtomicMinMax = data.shaderBufferFloat32AtomicMinMax;
    if (data.shaderBufferFloat64AtomicMinMax !== undefined) s.shaderBufferFloat64AtomicMinMax = data.shaderBufferFloat64AtomicMinMax;
    if (data.shaderSharedFloat16Atomics !== undefined) s.shaderSharedFloat16Atomics = data.shaderSharedFloat16Atomics;
    if (data.shaderSharedFloat16AtomicAdd !== undefined) s.shaderSharedFloat16AtomicAdd = data.shaderSharedFloat16AtomicAdd;
    if (data.shaderSharedFloat16AtomicMinMax !== undefined) s.shaderSharedFloat16AtomicMinMax = data.shaderSharedFloat16AtomicMinMax;
    if (data.shaderSharedFloat32AtomicMinMax !== undefined) s.shaderSharedFloat32AtomicMinMax = data.shaderSharedFloat32AtomicMinMax;
    if (data.shaderSharedFloat64AtomicMinMax !== undefined) s.shaderSharedFloat64AtomicMinMax = data.shaderSharedFloat64AtomicMinMax;
    if (data.shaderImageFloat32AtomicMinMax !== undefined) s.shaderImageFloat32AtomicMinMax = data.shaderImageFloat32AtomicMinMax;
    if (data.sparseImageFloat32AtomicMinMax !== undefined) s.sparseImageFloat32AtomicMinMax = data.sparseImageFloat32AtomicMinMax;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderBufferFloat16Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferFloat16Atomics(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderBufferFloat16AtomicAdd() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderBufferFloat16AtomicAdd(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderBufferFloat16AtomicMinMax() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderBufferFloat16AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderBufferFloat32AtomicMinMax() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderBufferFloat32AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderBufferFloat64AtomicMinMax() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderBufferFloat64AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderSharedFloat16Atomics() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderSharedFloat16Atomics(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedFloat16AtomicAdd() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedFloat16AtomicAdd(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderSharedFloat16AtomicMinMax() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderSharedFloat16AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderSharedFloat32AtomicMinMax() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderSharedFloat32AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderSharedFloat64AtomicMinMax() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderSharedFloat64AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderImageFloat32AtomicMinMax() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderImageFloat32AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sparseImageFloat32AtomicMinMax() {
    return this.#view.getUint32(60, LE);
  }
  
  set sparseImageFloat32AtomicMinMax(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(new Uint8Array(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexAttributeInstanceRateDivisor: VkBool32;
    vertexAttributeInstanceRateZeroDivisor: VkBool32;
  }) {
    const s = VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexAttributeInstanceRateDivisor !== undefined) s.vertexAttributeInstanceRateDivisor = data.vertexAttributeInstanceRateDivisor;
    if (data.vertexAttributeInstanceRateZeroDivisor !== undefined) s.vertexAttributeInstanceRateZeroDivisor = data.vertexAttributeInstanceRateZeroDivisor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexAttributeInstanceRateDivisor() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexAttributeInstanceRateDivisor(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexAttributeInstanceRateZeroDivisor() {
    return this.#view.getUint32(20, LE);
  }
  
  set vertexAttributeInstanceRateZeroDivisor(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkQueueFamilyCheckpointPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyCheckpointPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyCheckpointPropertiesNV(new Uint8Array(VkQueueFamilyCheckpointPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    checkpointExecutionStageMask: VkPipelineStageFlags;
  }) {
    const s = VkQueueFamilyCheckpointPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.checkpointExecutionStageMask !== undefined) s.checkpointExecutionStageMask = data.checkpointExecutionStageMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get checkpointExecutionStageMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set checkpointExecutionStageMask(value: VkPipelineStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCheckpointDataNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCheckpointDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCheckpointDataNV(new Uint8Array(VkCheckpointDataNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stage: VkPipelineStageFlagBits;
    pCheckpointMarker: Deno.PointerValue;
  }) {
    const s = VkCheckpointDataNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stage !== undefined) s.stage = data.stage;
    if (data.pCheckpointMarker !== undefined) s.pCheckpointMarker = data.pCheckpointMarker;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stage() {
    return this.#view.getUint32(16, LE);
  }
  
  set stage(value: VkPipelineStageFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pCheckpointMarker() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCheckpointMarker(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDepthStencilResolveProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDepthStencilResolveProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDepthStencilResolveProperties(new Uint8Array(VkPhysicalDeviceDepthStencilResolveProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supportedDepthResolveModes: VkResolveModeFlags;
    supportedStencilResolveModes: VkResolveModeFlags;
    independentResolveNone: VkBool32;
    independentResolve: VkBool32;
  }) {
    const s = VkPhysicalDeviceDepthStencilResolveProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supportedDepthResolveModes !== undefined) s.supportedDepthResolveModes = data.supportedDepthResolveModes;
    if (data.supportedStencilResolveModes !== undefined) s.supportedStencilResolveModes = data.supportedStencilResolveModes;
    if (data.independentResolveNone !== undefined) s.independentResolveNone = data.independentResolveNone;
    if (data.independentResolve !== undefined) s.independentResolve = data.independentResolve;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supportedDepthResolveModes() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedDepthResolveModes(value: VkResolveModeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedStencilResolveModes() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedStencilResolveModes(value: VkResolveModeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get independentResolveNone() {
    return this.#view.getUint32(24, LE);
  }
  
  set independentResolveNone(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get independentResolve() {
    return this.#view.getUint32(28, LE);
  }
  
  set independentResolve(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkSubpassDescriptionDepthStencilResolve implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassDescriptionDepthStencilResolve.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassDescriptionDepthStencilResolve(new Uint8Array(VkSubpassDescriptionDepthStencilResolve.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    depthResolveMode: VkResolveModeFlagBits;
    stencilResolveMode: VkResolveModeFlagBits;
    pDepthStencilResolveAttachment?: Deno.PointerValue;
  }) {
    const s = VkSubpassDescriptionDepthStencilResolve.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.depthResolveMode !== undefined) s.depthResolveMode = data.depthResolveMode;
    if (data.stencilResolveMode !== undefined) s.stencilResolveMode = data.stencilResolveMode;
    if (data.pDepthStencilResolveAttachment !== undefined) s.pDepthStencilResolveAttachment = data.pDepthStencilResolveAttachment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get depthResolveMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthResolveMode(value: VkResolveModeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilResolveMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilResolveMode(value: VkResolveModeFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDepthStencilResolveAttachment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDepthStencilResolveAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkImageViewASTCDecodeModeEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewASTCDecodeModeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewASTCDecodeModeEXT(new Uint8Array(VkImageViewASTCDecodeModeEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    decodeMode: VkFormat;
  }) {
    const s = VkImageViewASTCDecodeModeEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.decodeMode !== undefined) s.decodeMode = data.decodeMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get decodeMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set decodeMode(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceASTCDecodeFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceASTCDecodeFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceASTCDecodeFeaturesEXT(new Uint8Array(VkPhysicalDeviceASTCDecodeFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    decodeModeSharedExponent: VkBool32;
  }) {
    const s = VkPhysicalDeviceASTCDecodeFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.decodeModeSharedExponent !== undefined) s.decodeModeSharedExponent = data.decodeModeSharedExponent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get decodeModeSharedExponent() {
    return this.#view.getUint32(16, LE);
  }
  
  set decodeModeSharedExponent(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceTransformFeedbackFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTransformFeedbackFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTransformFeedbackFeaturesEXT(new Uint8Array(VkPhysicalDeviceTransformFeedbackFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    transformFeedback: VkBool32;
    geometryStreams: VkBool32;
  }) {
    const s = VkPhysicalDeviceTransformFeedbackFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.transformFeedback !== undefined) s.transformFeedback = data.transformFeedback;
    if (data.geometryStreams !== undefined) s.geometryStreams = data.geometryStreams;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get transformFeedback() {
    return this.#view.getUint32(16, LE);
  }
  
  set transformFeedback(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometryStreams() {
    return this.#view.getUint32(20, LE);
  }
  
  set geometryStreams(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceTransformFeedbackPropertiesEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTransformFeedbackPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTransformFeedbackPropertiesEXT(new Uint8Array(VkPhysicalDeviceTransformFeedbackPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxTransformFeedbackStreams: number;
    maxTransformFeedbackBuffers: number;
    maxTransformFeedbackBufferSize: VkDeviceSize;
    maxTransformFeedbackStreamDataSize: number;
    maxTransformFeedbackBufferDataSize: number;
    maxTransformFeedbackBufferDataStride: number;
    transformFeedbackQueries: VkBool32;
    transformFeedbackStreamsLinesTriangles: VkBool32;
    transformFeedbackRasterizationStreamSelect: VkBool32;
    transformFeedbackDraw: VkBool32;
  }) {
    const s = VkPhysicalDeviceTransformFeedbackPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxTransformFeedbackStreams !== undefined) s.maxTransformFeedbackStreams = data.maxTransformFeedbackStreams;
    if (data.maxTransformFeedbackBuffers !== undefined) s.maxTransformFeedbackBuffers = data.maxTransformFeedbackBuffers;
    if (data.maxTransformFeedbackBufferSize !== undefined) s.maxTransformFeedbackBufferSize = data.maxTransformFeedbackBufferSize;
    if (data.maxTransformFeedbackStreamDataSize !== undefined) s.maxTransformFeedbackStreamDataSize = data.maxTransformFeedbackStreamDataSize;
    if (data.maxTransformFeedbackBufferDataSize !== undefined) s.maxTransformFeedbackBufferDataSize = data.maxTransformFeedbackBufferDataSize;
    if (data.maxTransformFeedbackBufferDataStride !== undefined) s.maxTransformFeedbackBufferDataStride = data.maxTransformFeedbackBufferDataStride;
    if (data.transformFeedbackQueries !== undefined) s.transformFeedbackQueries = data.transformFeedbackQueries;
    if (data.transformFeedbackStreamsLinesTriangles !== undefined) s.transformFeedbackStreamsLinesTriangles = data.transformFeedbackStreamsLinesTriangles;
    if (data.transformFeedbackRasterizationStreamSelect !== undefined) s.transformFeedbackRasterizationStreamSelect = data.transformFeedbackRasterizationStreamSelect;
    if (data.transformFeedbackDraw !== undefined) s.transformFeedbackDraw = data.transformFeedbackDraw;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxTransformFeedbackStreams() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxTransformFeedbackStreams(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTransformFeedbackBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTransformFeedbackBuffers(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxTransformFeedbackBufferSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get maxTransformFeedbackStreamDataSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxTransformFeedbackStreamDataSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferDataSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxTransformFeedbackBufferDataSize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferDataStride() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxTransformFeedbackBufferDataStride(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get transformFeedbackQueries() {
    return this.#view.getUint32(44, LE);
  }
  
  set transformFeedbackQueries(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get transformFeedbackStreamsLinesTriangles() {
    return this.#view.getUint32(48, LE);
  }
  
  set transformFeedbackStreamsLinesTriangles(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get transformFeedbackRasterizationStreamSelect() {
    return this.#view.getUint32(52, LE);
  }
  
  set transformFeedbackRasterizationStreamSelect(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get transformFeedbackDraw() {
    return this.#view.getUint32(56, LE);
  }
  
  set transformFeedbackDraw(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkPipelineRasterizationStateStreamCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationStateStreamCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationStateStreamCreateInfoEXT(new Uint8Array(VkPipelineRasterizationStateStreamCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineRasterizationStateStreamCreateFlagsEXT;
    rasterizationStream: number;
  }) {
    const s = VkPipelineRasterizationStateStreamCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.rasterizationStream !== undefined) s.rasterizationStream = data.rasterizationStream;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineRasterizationStateStreamCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationStream() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationStream(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(new Uint8Array(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    representativeFragmentTest: VkBool32;
  }) {
    const s = VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.representativeFragmentTest !== undefined) s.representativeFragmentTest = data.representativeFragmentTest;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get representativeFragmentTest() {
    return this.#view.getUint32(16, LE);
  }
  
  set representativeFragmentTest(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineRepresentativeFragmentTestStateCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRepresentativeFragmentTestStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRepresentativeFragmentTestStateCreateInfoNV(new Uint8Array(VkPipelineRepresentativeFragmentTestStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    representativeFragmentTestEnable: VkBool32;
  }) {
    const s = VkPipelineRepresentativeFragmentTestStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.representativeFragmentTestEnable !== undefined) s.representativeFragmentTestEnable = data.representativeFragmentTestEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get representativeFragmentTestEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set representativeFragmentTestEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceExclusiveScissorFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExclusiveScissorFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExclusiveScissorFeaturesNV(new Uint8Array(VkPhysicalDeviceExclusiveScissorFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    exclusiveScissor: VkBool32;
  }) {
    const s = VkPhysicalDeviceExclusiveScissorFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.exclusiveScissor !== undefined) s.exclusiveScissor = data.exclusiveScissor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get exclusiveScissor() {
    return this.#view.getUint32(16, LE);
  }
  
  set exclusiveScissor(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineViewportExclusiveScissorStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportExclusiveScissorStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportExclusiveScissorStateCreateInfoNV(new Uint8Array(VkPipelineViewportExclusiveScissorStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    exclusiveScissorCount?: number;
    pExclusiveScissors: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportExclusiveScissorStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.exclusiveScissorCount !== undefined) s.exclusiveScissorCount = data.exclusiveScissorCount;
    if (data.pExclusiveScissors !== undefined) s.pExclusiveScissors = data.pExclusiveScissors;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get exclusiveScissorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set exclusiveScissorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pExclusiveScissors() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pExclusiveScissors(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceCornerSampledImageFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCornerSampledImageFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCornerSampledImageFeaturesNV(new Uint8Array(VkPhysicalDeviceCornerSampledImageFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    cornerSampledImage: VkBool32;
  }) {
    const s = VkPhysicalDeviceCornerSampledImageFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.cornerSampledImage !== undefined) s.cornerSampledImage = data.cornerSampledImage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get cornerSampledImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set cornerSampledImage(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceComputeShaderDerivativesFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(new Uint8Array(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    computeDerivativeGroupQuads: VkBool32;
    computeDerivativeGroupLinear: VkBool32;
  }) {
    const s = VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.computeDerivativeGroupQuads !== undefined) s.computeDerivativeGroupQuads = data.computeDerivativeGroupQuads;
    if (data.computeDerivativeGroupLinear !== undefined) s.computeDerivativeGroupLinear = data.computeDerivativeGroupLinear;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get computeDerivativeGroupQuads() {
    return this.#view.getUint32(16, LE);
  }
  
  set computeDerivativeGroupQuads(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get computeDerivativeGroupLinear() {
    return this.#view.getUint32(20, LE);
  }
  
  set computeDerivativeGroupLinear(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderImageFootprintFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderImageFootprintFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderImageFootprintFeaturesNV(new Uint8Array(VkPhysicalDeviceShaderImageFootprintFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageFootprint: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderImageFootprintFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageFootprint !== undefined) s.imageFootprint = data.imageFootprint;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageFootprint() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageFootprint(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(new Uint8Array(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dedicatedAllocationImageAliasing: VkBool32;
  }) {
    const s = VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dedicatedAllocationImageAliasing !== undefined) s.dedicatedAllocationImageAliasing = data.dedicatedAllocationImageAliasing;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dedicatedAllocationImageAliasing() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocationImageAliasing(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCopyMemoryIndirectFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(new Uint8Array(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    indirectCopy: VkBool32;
  }) {
    const s = VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.indirectCopy !== undefined) s.indirectCopy = data.indirectCopy;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get indirectCopy() {
    return this.#view.getUint32(16, LE);
  }
  
  set indirectCopy(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCopyMemoryIndirectPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(new Uint8Array(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supportedQueues: VkQueueFlags;
  }) {
    const s = VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supportedQueues !== undefined) s.supportedQueues = data.supportedQueues;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supportedQueues() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedQueues(value: VkQueueFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceMemoryDecompressionFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryDecompressionFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryDecompressionFeaturesNV(new Uint8Array(VkPhysicalDeviceMemoryDecompressionFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryDecompression: VkBool32;
  }) {
    const s = VkPhysicalDeviceMemoryDecompressionFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryDecompression !== undefined) s.memoryDecompression = data.memoryDecompression;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryDecompression() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryDecompression(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceMemoryDecompressionPropertiesNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryDecompressionPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryDecompressionPropertiesNV(new Uint8Array(VkPhysicalDeviceMemoryDecompressionPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    decompressionMethods: VkMemoryDecompressionMethodFlagsNV;
    maxDecompressionIndirectCount: Deno.PointerValue;
  }) {
    const s = VkPhysicalDeviceMemoryDecompressionPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.decompressionMethods !== undefined) s.decompressionMethods = data.decompressionMethods;
    if (data.maxDecompressionIndirectCount !== undefined) s.maxDecompressionIndirectCount = data.maxDecompressionIndirectCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get decompressionMethods() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set decompressionMethods(value: VkMemoryDecompressionMethodFlagsNV) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get maxDecompressionIndirectCount() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxDecompressionIndirectCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkShadingRatePaletteNV implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShadingRatePaletteNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShadingRatePaletteNV(new Uint8Array(VkShadingRatePaletteNV.size));
  }
  
  static create(data: {
    shadingRatePaletteEntryCount: number;
    pShadingRatePaletteEntries: Deno.PointerValue;
  }) {
    const s = VkShadingRatePaletteNV.alloc();
    if (data.shadingRatePaletteEntryCount !== undefined) s.shadingRatePaletteEntryCount = data.shadingRatePaletteEntryCount;
    if (data.pShadingRatePaletteEntries !== undefined) s.pShadingRatePaletteEntries = data.pShadingRatePaletteEntries;
    return s;
  }
  
  get shadingRatePaletteEntryCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set shadingRatePaletteEntryCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pShadingRatePaletteEntries() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pShadingRatePaletteEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkPipelineViewportShadingRateImageStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportShadingRateImageStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportShadingRateImageStateCreateInfoNV(new Uint8Array(VkPipelineViewportShadingRateImageStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shadingRateImageEnable: VkBool32;
    viewportCount?: number;
    pShadingRatePalettes: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportShadingRateImageStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shadingRateImageEnable !== undefined) s.shadingRateImageEnable = data.shadingRateImageEnable;
    if (data.viewportCount !== undefined) s.viewportCount = data.viewportCount;
    if (data.pShadingRatePalettes !== undefined) s.pShadingRatePalettes = data.pShadingRatePalettes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shadingRateImageEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateImageEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pShadingRatePalettes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pShadingRatePalettes(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceShadingRateImageFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShadingRateImageFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShadingRateImageFeaturesNV(new Uint8Array(VkPhysicalDeviceShadingRateImageFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shadingRateImage: VkBool32;
    shadingRateCoarseSampleOrder: VkBool32;
  }) {
    const s = VkPhysicalDeviceShadingRateImageFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shadingRateImage !== undefined) s.shadingRateImage = data.shadingRateImage;
    if (data.shadingRateCoarseSampleOrder !== undefined) s.shadingRateCoarseSampleOrder = data.shadingRateCoarseSampleOrder;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shadingRateImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateImage(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shadingRateCoarseSampleOrder() {
    return this.#view.getUint32(20, LE);
  }
  
  set shadingRateCoarseSampleOrder(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceShadingRateImagePropertiesNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShadingRateImagePropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShadingRateImagePropertiesNV(new Uint8Array(VkPhysicalDeviceShadingRateImagePropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shadingRateTexelSize: VkExtent2D;
    shadingRatePaletteSize: number;
    shadingRateMaxCoarseSamples: number;
  }) {
    const s = VkPhysicalDeviceShadingRateImagePropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shadingRateTexelSize !== undefined) s.shadingRateTexelSize = data.shadingRateTexelSize;
    if (data.shadingRatePaletteSize !== undefined) s.shadingRatePaletteSize = data.shadingRatePaletteSize;
    if (data.shadingRateMaxCoarseSamples !== undefined) s.shadingRateMaxCoarseSamples = data.shadingRateMaxCoarseSamples;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shadingRateTexelSize() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set shadingRateTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get shadingRatePaletteSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set shadingRatePaletteSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shadingRateMaxCoarseSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set shadingRateMaxCoarseSamples(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceInvocationMaskFeaturesHUAWEI implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(new Uint8Array(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    invocationMask: VkBool32;
  }) {
    const s = VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.invocationMask !== undefined) s.invocationMask = data.invocationMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get invocationMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set invocationMask(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCoarseSampleLocationNV implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCoarseSampleLocationNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCoarseSampleLocationNV(new Uint8Array(VkCoarseSampleLocationNV.size));
  }
  
  static create(data: {
    pixelX: number;
    pixelY: number;
    sample: number;
  }) {
    const s = VkCoarseSampleLocationNV.alloc();
    if (data.pixelX !== undefined) s.pixelX = data.pixelX;
    if (data.pixelY !== undefined) s.pixelY = data.pixelY;
    if (data.sample !== undefined) s.sample = data.sample;
    return s;
  }
  
  get pixelX() {
    return this.#view.getUint32(0, LE);
  }
  
  set pixelX(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pixelY() {
    return this.#view.getUint32(4, LE);
  }
  
  set pixelY(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sample() {
    return this.#view.getUint32(8, LE);
  }
  
  set sample(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkCoarseSampleOrderCustomNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCoarseSampleOrderCustomNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCoarseSampleOrderCustomNV(new Uint8Array(VkCoarseSampleOrderCustomNV.size));
  }
  
  static create(data: {
    shadingRate: VkShadingRatePaletteEntryNV;
    sampleCount: number;
    sampleLocationCount: number;
    pSampleLocations: Deno.PointerValue;
  }) {
    const s = VkCoarseSampleOrderCustomNV.alloc();
    if (data.shadingRate !== undefined) s.shadingRate = data.shadingRate;
    if (data.sampleCount !== undefined) s.sampleCount = data.sampleCount;
    if (data.sampleLocationCount !== undefined) s.sampleLocationCount = data.sampleLocationCount;
    if (data.pSampleLocations !== undefined) s.pSampleLocations = data.pSampleLocations;
    return s;
  }
  
  get shadingRate() {
    return this.#view.getUint32(0, LE);
  }
  
  set shadingRate(value: VkShadingRatePaletteEntryNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set sampleCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sampleLocationCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set sampleLocationCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pSampleLocations() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pSampleLocations(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPipelineViewportCoarseSampleOrderStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(new Uint8Array(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampleOrderType: VkCoarseSampleOrderTypeNV;
    customSampleOrderCount?: number;
    pCustomSampleOrders: Deno.PointerValue;
  }) {
    const s = VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampleOrderType !== undefined) s.sampleOrderType = data.sampleOrderType;
    if (data.customSampleOrderCount !== undefined) s.customSampleOrderCount = data.customSampleOrderCount;
    if (data.pCustomSampleOrders !== undefined) s.pCustomSampleOrders = data.pCustomSampleOrders;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampleOrderType() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleOrderType(value: VkCoarseSampleOrderTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get customSampleOrderCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set customSampleOrderCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pCustomSampleOrders() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCustomSampleOrders(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceMeshShaderFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMeshShaderFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMeshShaderFeaturesNV(new Uint8Array(VkPhysicalDeviceMeshShaderFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    taskShader: VkBool32;
    meshShader: VkBool32;
  }) {
    const s = VkPhysicalDeviceMeshShaderFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.taskShader !== undefined) s.taskShader = data.taskShader;
    if (data.meshShader !== undefined) s.meshShader = data.meshShader;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get taskShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set taskShader(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get meshShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set meshShader(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceMeshShaderPropertiesNV implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMeshShaderPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMeshShaderPropertiesNV(new Uint8Array(VkPhysicalDeviceMeshShaderPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxDrawMeshTasksCount: number;
    maxTaskWorkGroupInvocations: number;
    maxTaskWorkGroupSize: number;
    maxTaskTotalMemorySize: number;
    maxTaskOutputCount: number;
    maxMeshWorkGroupInvocations: number;
    maxMeshWorkGroupSize: number;
    maxMeshTotalMemorySize: number;
    maxMeshOutputVertices: number;
    maxMeshOutputPrimitives: number;
    maxMeshMultiviewViewCount: number;
    meshOutputPerVertexGranularity: number;
    meshOutputPerPrimitiveGranularity: number;
  }) {
    const s = VkPhysicalDeviceMeshShaderPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxDrawMeshTasksCount !== undefined) s.maxDrawMeshTasksCount = data.maxDrawMeshTasksCount;
    if (data.maxTaskWorkGroupInvocations !== undefined) s.maxTaskWorkGroupInvocations = data.maxTaskWorkGroupInvocations;
    if (data.maxTaskWorkGroupSize !== undefined) s.maxTaskWorkGroupSize = data.maxTaskWorkGroupSize;
    if (data.maxTaskTotalMemorySize !== undefined) s.maxTaskTotalMemorySize = data.maxTaskTotalMemorySize;
    if (data.maxTaskOutputCount !== undefined) s.maxTaskOutputCount = data.maxTaskOutputCount;
    if (data.maxMeshWorkGroupInvocations !== undefined) s.maxMeshWorkGroupInvocations = data.maxMeshWorkGroupInvocations;
    if (data.maxMeshWorkGroupSize !== undefined) s.maxMeshWorkGroupSize = data.maxMeshWorkGroupSize;
    if (data.maxMeshTotalMemorySize !== undefined) s.maxMeshTotalMemorySize = data.maxMeshTotalMemorySize;
    if (data.maxMeshOutputVertices !== undefined) s.maxMeshOutputVertices = data.maxMeshOutputVertices;
    if (data.maxMeshOutputPrimitives !== undefined) s.maxMeshOutputPrimitives = data.maxMeshOutputPrimitives;
    if (data.maxMeshMultiviewViewCount !== undefined) s.maxMeshMultiviewViewCount = data.maxMeshMultiviewViewCount;
    if (data.meshOutputPerVertexGranularity !== undefined) s.meshOutputPerVertexGranularity = data.meshOutputPerVertexGranularity;
    if (data.meshOutputPerPrimitiveGranularity !== undefined) s.meshOutputPerPrimitiveGranularity = data.meshOutputPerPrimitiveGranularity;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxDrawMeshTasksCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxDrawMeshTasksCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTaskWorkGroupInvocations() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxTaskWorkGroupSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxTaskWorkGroupSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxTaskTotalMemorySize() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxTaskTotalMemorySize(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxTaskOutputCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxTaskOutputCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxMeshWorkGroupInvocations() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxMeshWorkGroupSize() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxMeshWorkGroupSize(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxMeshTotalMemorySize() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxMeshTotalMemorySize(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxMeshOutputVertices() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxMeshOutputVertices(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxMeshOutputPrimitives() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxMeshOutputPrimitives(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxMeshMultiviewViewCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxMeshMultiviewViewCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get meshOutputPerVertexGranularity() {
    return this.#view.getUint32(60, LE);
  }
  
  set meshOutputPerVertexGranularity(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get meshOutputPerPrimitiveGranularity() {
    return this.#view.getUint32(64, LE);
  }
  
  set meshOutputPerPrimitiveGranularity(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
}

export class VkDrawMeshTasksIndirectCommandNV implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrawMeshTasksIndirectCommandNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrawMeshTasksIndirectCommandNV(new Uint8Array(VkDrawMeshTasksIndirectCommandNV.size));
  }
  
  static create(data: {
    taskCount: number;
    firstTask: number;
  }) {
    const s = VkDrawMeshTasksIndirectCommandNV.alloc();
    if (data.taskCount !== undefined) s.taskCount = data.taskCount;
    if (data.firstTask !== undefined) s.firstTask = data.firstTask;
    return s;
  }
  
  get taskCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set taskCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get firstTask() {
    return this.#view.getUint32(4, LE);
  }
  
  set firstTask(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export class VkPhysicalDeviceMeshShaderFeaturesEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMeshShaderFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMeshShaderFeaturesEXT(new Uint8Array(VkPhysicalDeviceMeshShaderFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    taskShader: VkBool32;
    meshShader: VkBool32;
    multiviewMeshShader: VkBool32;
    primitiveFragmentShadingRateMeshShader: VkBool32;
    meshShaderQueries: VkBool32;
  }) {
    const s = VkPhysicalDeviceMeshShaderFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.taskShader !== undefined) s.taskShader = data.taskShader;
    if (data.meshShader !== undefined) s.meshShader = data.meshShader;
    if (data.multiviewMeshShader !== undefined) s.multiviewMeshShader = data.multiviewMeshShader;
    if (data.primitiveFragmentShadingRateMeshShader !== undefined) s.primitiveFragmentShadingRateMeshShader = data.primitiveFragmentShadingRateMeshShader;
    if (data.meshShaderQueries !== undefined) s.meshShaderQueries = data.meshShaderQueries;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get taskShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set taskShader(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get meshShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set meshShader(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get multiviewMeshShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set multiviewMeshShader(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get primitiveFragmentShadingRateMeshShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set primitiveFragmentShadingRateMeshShader(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get meshShaderQueries() {
    return this.#view.getUint32(32, LE);
  }
  
  set meshShaderQueries(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceMeshShaderPropertiesEXT implements IVkStructure {
  static size = 128;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMeshShaderPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMeshShaderPropertiesEXT(new Uint8Array(VkPhysicalDeviceMeshShaderPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxTaskWorkGroupTotalCount: number;
    maxTaskWorkGroupCount: number;
    maxTaskWorkGroupInvocations: number;
    maxTaskWorkGroupSize: number;
    maxTaskPayloadSize: number;
    maxTaskSharedMemorySize: number;
    maxTaskPayloadAndSharedMemorySize: number;
    maxMeshWorkGroupTotalCount: number;
    maxMeshWorkGroupCount: number;
    maxMeshWorkGroupInvocations: number;
    maxMeshWorkGroupSize: number;
    maxMeshSharedMemorySize: number;
    maxMeshPayloadAndSharedMemorySize: number;
    maxMeshOutputMemorySize: number;
    maxMeshPayloadAndOutputMemorySize: number;
    maxMeshOutputComponents: number;
    maxMeshOutputVertices: number;
    maxMeshOutputPrimitives: number;
    maxMeshOutputLayers: number;
    maxMeshMultiviewViewCount: number;
    meshOutputPerVertexGranularity: number;
    meshOutputPerPrimitiveGranularity: number;
    maxPreferredTaskWorkGroupInvocations: number;
    maxPreferredMeshWorkGroupInvocations: number;
    prefersLocalInvocationVertexOutput: VkBool32;
    prefersLocalInvocationPrimitiveOutput: VkBool32;
    prefersCompactVertexOutput: VkBool32;
    prefersCompactPrimitiveOutput: VkBool32;
  }) {
    const s = VkPhysicalDeviceMeshShaderPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxTaskWorkGroupTotalCount !== undefined) s.maxTaskWorkGroupTotalCount = data.maxTaskWorkGroupTotalCount;
    if (data.maxTaskWorkGroupCount !== undefined) s.maxTaskWorkGroupCount = data.maxTaskWorkGroupCount;
    if (data.maxTaskWorkGroupInvocations !== undefined) s.maxTaskWorkGroupInvocations = data.maxTaskWorkGroupInvocations;
    if (data.maxTaskWorkGroupSize !== undefined) s.maxTaskWorkGroupSize = data.maxTaskWorkGroupSize;
    if (data.maxTaskPayloadSize !== undefined) s.maxTaskPayloadSize = data.maxTaskPayloadSize;
    if (data.maxTaskSharedMemorySize !== undefined) s.maxTaskSharedMemorySize = data.maxTaskSharedMemorySize;
    if (data.maxTaskPayloadAndSharedMemorySize !== undefined) s.maxTaskPayloadAndSharedMemorySize = data.maxTaskPayloadAndSharedMemorySize;
    if (data.maxMeshWorkGroupTotalCount !== undefined) s.maxMeshWorkGroupTotalCount = data.maxMeshWorkGroupTotalCount;
    if (data.maxMeshWorkGroupCount !== undefined) s.maxMeshWorkGroupCount = data.maxMeshWorkGroupCount;
    if (data.maxMeshWorkGroupInvocations !== undefined) s.maxMeshWorkGroupInvocations = data.maxMeshWorkGroupInvocations;
    if (data.maxMeshWorkGroupSize !== undefined) s.maxMeshWorkGroupSize = data.maxMeshWorkGroupSize;
    if (data.maxMeshSharedMemorySize !== undefined) s.maxMeshSharedMemorySize = data.maxMeshSharedMemorySize;
    if (data.maxMeshPayloadAndSharedMemorySize !== undefined) s.maxMeshPayloadAndSharedMemorySize = data.maxMeshPayloadAndSharedMemorySize;
    if (data.maxMeshOutputMemorySize !== undefined) s.maxMeshOutputMemorySize = data.maxMeshOutputMemorySize;
    if (data.maxMeshPayloadAndOutputMemorySize !== undefined) s.maxMeshPayloadAndOutputMemorySize = data.maxMeshPayloadAndOutputMemorySize;
    if (data.maxMeshOutputComponents !== undefined) s.maxMeshOutputComponents = data.maxMeshOutputComponents;
    if (data.maxMeshOutputVertices !== undefined) s.maxMeshOutputVertices = data.maxMeshOutputVertices;
    if (data.maxMeshOutputPrimitives !== undefined) s.maxMeshOutputPrimitives = data.maxMeshOutputPrimitives;
    if (data.maxMeshOutputLayers !== undefined) s.maxMeshOutputLayers = data.maxMeshOutputLayers;
    if (data.maxMeshMultiviewViewCount !== undefined) s.maxMeshMultiviewViewCount = data.maxMeshMultiviewViewCount;
    if (data.meshOutputPerVertexGranularity !== undefined) s.meshOutputPerVertexGranularity = data.meshOutputPerVertexGranularity;
    if (data.meshOutputPerPrimitiveGranularity !== undefined) s.meshOutputPerPrimitiveGranularity = data.meshOutputPerPrimitiveGranularity;
    if (data.maxPreferredTaskWorkGroupInvocations !== undefined) s.maxPreferredTaskWorkGroupInvocations = data.maxPreferredTaskWorkGroupInvocations;
    if (data.maxPreferredMeshWorkGroupInvocations !== undefined) s.maxPreferredMeshWorkGroupInvocations = data.maxPreferredMeshWorkGroupInvocations;
    if (data.prefersLocalInvocationVertexOutput !== undefined) s.prefersLocalInvocationVertexOutput = data.prefersLocalInvocationVertexOutput;
    if (data.prefersLocalInvocationPrimitiveOutput !== undefined) s.prefersLocalInvocationPrimitiveOutput = data.prefersLocalInvocationPrimitiveOutput;
    if (data.prefersCompactVertexOutput !== undefined) s.prefersCompactVertexOutput = data.prefersCompactVertexOutput;
    if (data.prefersCompactPrimitiveOutput !== undefined) s.prefersCompactPrimitiveOutput = data.prefersCompactPrimitiveOutput;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxTaskWorkGroupTotalCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxTaskWorkGroupTotalCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTaskWorkGroupCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTaskWorkGroupCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxTaskWorkGroupInvocations() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxTaskWorkGroupSize() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxTaskWorkGroupSize(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxTaskPayloadSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxTaskPayloadSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxTaskSharedMemorySize() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxTaskSharedMemorySize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxTaskPayloadAndSharedMemorySize() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxTaskPayloadAndSharedMemorySize(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxMeshWorkGroupTotalCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxMeshWorkGroupTotalCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxMeshWorkGroupCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxMeshWorkGroupCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxMeshWorkGroupInvocations() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxMeshWorkGroupSize() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxMeshWorkGroupSize(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxMeshSharedMemorySize() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxMeshSharedMemorySize(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxMeshPayloadAndSharedMemorySize() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxMeshPayloadAndSharedMemorySize(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxMeshOutputMemorySize() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxMeshOutputMemorySize(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxMeshPayloadAndOutputMemorySize() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxMeshPayloadAndOutputMemorySize(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get maxMeshOutputComponents() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxMeshOutputComponents(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxMeshOutputVertices() {
    return this.#view.getUint32(80, LE);
  }
  
  set maxMeshOutputVertices(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxMeshOutputPrimitives() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxMeshOutputPrimitives(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxMeshOutputLayers() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxMeshOutputLayers(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get maxMeshMultiviewViewCount() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxMeshMultiviewViewCount(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get meshOutputPerVertexGranularity() {
    return this.#view.getUint32(96, LE);
  }
  
  set meshOutputPerVertexGranularity(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get meshOutputPerPrimitiveGranularity() {
    return this.#view.getUint32(100, LE);
  }
  
  set meshOutputPerPrimitiveGranularity(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxPreferredTaskWorkGroupInvocations() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxPreferredTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get maxPreferredMeshWorkGroupInvocations() {
    return this.#view.getUint32(108, LE);
  }
  
  set maxPreferredMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get prefersLocalInvocationVertexOutput() {
    return this.#view.getUint32(112, LE);
  }
  
  set prefersLocalInvocationVertexOutput(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get prefersLocalInvocationPrimitiveOutput() {
    return this.#view.getUint32(116, LE);
  }
  
  set prefersLocalInvocationPrimitiveOutput(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get prefersCompactVertexOutput() {
    return this.#view.getUint32(120, LE);
  }
  
  set prefersCompactVertexOutput(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get prefersCompactPrimitiveOutput() {
    return this.#view.getUint32(124, LE);
  }
  
  set prefersCompactPrimitiveOutput(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
}

export class VkDrawMeshTasksIndirectCommandEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrawMeshTasksIndirectCommandEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrawMeshTasksIndirectCommandEXT(new Uint8Array(VkDrawMeshTasksIndirectCommandEXT.size));
  }
  
  static create(data: {
    groupCountX: number;
    groupCountY: number;
    groupCountZ: number;
  }) {
    const s = VkDrawMeshTasksIndirectCommandEXT.alloc();
    if (data.groupCountX !== undefined) s.groupCountX = data.groupCountX;
    if (data.groupCountY !== undefined) s.groupCountY = data.groupCountY;
    if (data.groupCountZ !== undefined) s.groupCountZ = data.groupCountZ;
    return s;
  }
  
  get groupCountX() {
    return this.#view.getUint32(0, LE);
  }
  
  set groupCountX(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get groupCountY() {
    return this.#view.getUint32(4, LE);
  }
  
  set groupCountY(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get groupCountZ() {
    return this.#view.getUint32(8, LE);
  }
  
  set groupCountZ(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkRayTracingShaderGroupCreateInfoNV implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRayTracingShaderGroupCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRayTracingShaderGroupCreateInfoNV(new Uint8Array(VkRayTracingShaderGroupCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkRayTracingShaderGroupTypeKHR;
    generalShader: number;
    closestHitShader: number;
    anyHitShader: number;
    intersectionShader: number;
  }) {
    const s = VkRayTracingShaderGroupCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.generalShader !== undefined) s.generalShader = data.generalShader;
    if (data.closestHitShader !== undefined) s.closestHitShader = data.closestHitShader;
    if (data.anyHitShader !== undefined) s.anyHitShader = data.anyHitShader;
    if (data.intersectionShader !== undefined) s.intersectionShader = data.intersectionShader;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkRayTracingShaderGroupTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get generalShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set generalShader(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get closestHitShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set closestHitShader(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get anyHitShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set anyHitShader(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get intersectionShader() {
    return this.#view.getUint32(32, LE);
  }
  
  set intersectionShader(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkRayTracingShaderGroupCreateInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRayTracingShaderGroupCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRayTracingShaderGroupCreateInfoKHR(new Uint8Array(VkRayTracingShaderGroupCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkRayTracingShaderGroupTypeKHR;
    generalShader: number;
    closestHitShader: number;
    anyHitShader: number;
    intersectionShader: number;
    pShaderGroupCaptureReplayHandle?: Deno.PointerValue;
  }) {
    const s = VkRayTracingShaderGroupCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.generalShader !== undefined) s.generalShader = data.generalShader;
    if (data.closestHitShader !== undefined) s.closestHitShader = data.closestHitShader;
    if (data.anyHitShader !== undefined) s.anyHitShader = data.anyHitShader;
    if (data.intersectionShader !== undefined) s.intersectionShader = data.intersectionShader;
    if (data.pShaderGroupCaptureReplayHandle !== undefined) s.pShaderGroupCaptureReplayHandle = data.pShaderGroupCaptureReplayHandle;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkRayTracingShaderGroupTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get generalShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set generalShader(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get closestHitShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set closestHitShader(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get anyHitShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set anyHitShader(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get intersectionShader() {
    return this.#view.getUint32(32, LE);
  }
  
  set intersectionShader(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pShaderGroupCaptureReplayHandle() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pShaderGroupCaptureReplayHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkRayTracingPipelineCreateInfoNV implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRayTracingPipelineCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRayTracingPipelineCreateInfoNV(new Uint8Array(VkRayTracingPipelineCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCreateFlags;
    stageCount: number;
    pStages: Deno.PointerValue;
    groupCount: number;
    pGroups: Deno.PointerValue;
    maxRecursionDepth: number;
    layout: VkPipelineLayout;
    basePipelineHandle?: VkPipeline;
    basePipelineIndex: number;
  }) {
    const s = VkRayTracingPipelineCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.stageCount !== undefined) s.stageCount = data.stageCount;
    if (data.pStages !== undefined) s.pStages = data.pStages;
    if (data.groupCount !== undefined) s.groupCount = data.groupCount;
    if (data.pGroups !== undefined) s.pGroups = data.pGroups;
    if (data.maxRecursionDepth !== undefined) s.maxRecursionDepth = data.maxRecursionDepth;
    if (data.layout !== undefined) s.layout = data.layout;
    if (data.basePipelineHandle !== undefined) s.basePipelineHandle = data.basePipelineHandle;
    if (data.basePipelineIndex !== undefined) s.basePipelineIndex = data.basePipelineIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pGroups(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get maxRecursionDepth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxRecursionDepth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set layout(value: VkPipelineLayout) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set basePipelineHandle(value: VkPipeline) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(72, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(72, Number(value), LE);
  }
}

export class VkRayTracingPipelineCreateInfoKHR implements IVkStructure {
  static size = 104;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRayTracingPipelineCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRayTracingPipelineCreateInfoKHR(new Uint8Array(VkRayTracingPipelineCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCreateFlags;
    stageCount?: number;
    pStages: Deno.PointerValue;
    groupCount?: number;
    pGroups: Deno.PointerValue;
    maxPipelineRayRecursionDepth: number;
    pLibraryInfo?: Deno.PointerValue;
    pLibraryInterface?: Deno.PointerValue;
    pDynamicState?: Deno.PointerValue;
    layout: VkPipelineLayout;
    basePipelineHandle?: VkPipeline;
    basePipelineIndex: number;
  }) {
    const s = VkRayTracingPipelineCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.stageCount !== undefined) s.stageCount = data.stageCount;
    if (data.pStages !== undefined) s.pStages = data.pStages;
    if (data.groupCount !== undefined) s.groupCount = data.groupCount;
    if (data.pGroups !== undefined) s.pGroups = data.pGroups;
    if (data.maxPipelineRayRecursionDepth !== undefined) s.maxPipelineRayRecursionDepth = data.maxPipelineRayRecursionDepth;
    if (data.pLibraryInfo !== undefined) s.pLibraryInfo = data.pLibraryInfo;
    if (data.pLibraryInterface !== undefined) s.pLibraryInterface = data.pLibraryInterface;
    if (data.pDynamicState !== undefined) s.pDynamicState = data.pDynamicState;
    if (data.layout !== undefined) s.layout = data.layout;
    if (data.basePipelineHandle !== undefined) s.basePipelineHandle = data.basePipelineHandle;
    if (data.basePipelineIndex !== undefined) s.basePipelineIndex = data.basePipelineIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pGroups(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get maxPipelineRayRecursionDepth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxPipelineRayRecursionDepth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pLibraryInfo() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pLibraryInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pLibraryInterface() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pLibraryInterface(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get pDynamicState() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pDynamicState(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set layout(value: VkPipelineLayout) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set basePipelineHandle(value: VkPipeline) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(96, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(96, Number(value), LE);
  }
}

export class VkGeometryTrianglesNV implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeometryTrianglesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeometryTrianglesNV(new Uint8Array(VkGeometryTrianglesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexData?: VkBuffer;
    vertexOffset: VkDeviceSize;
    vertexCount: number;
    vertexStride: VkDeviceSize;
    vertexFormat: VkFormat;
    indexData?: VkBuffer;
    indexOffset: VkDeviceSize;
    indexCount: number;
    indexType: VkIndexType;
    transformData?: VkBuffer;
    transformOffset: VkDeviceSize;
  }) {
    const s = VkGeometryTrianglesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexData !== undefined) s.vertexData = data.vertexData;
    if (data.vertexOffset !== undefined) s.vertexOffset = data.vertexOffset;
    if (data.vertexCount !== undefined) s.vertexCount = data.vertexCount;
    if (data.vertexStride !== undefined) s.vertexStride = data.vertexStride;
    if (data.vertexFormat !== undefined) s.vertexFormat = data.vertexFormat;
    if (data.indexData !== undefined) s.indexData = data.indexData;
    if (data.indexOffset !== undefined) s.indexOffset = data.indexOffset;
    if (data.indexCount !== undefined) s.indexCount = data.indexCount;
    if (data.indexType !== undefined) s.indexType = data.indexType;
    if (data.transformData !== undefined) s.transformData = data.transformData;
    if (data.transformOffset !== undefined) s.transformOffset = data.transformOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set vertexData(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get vertexOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set vertexOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get vertexCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get vertexStride() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set vertexStride(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get vertexFormat() {
    return this.#view.getUint32(48, LE);
  }
  
  set vertexFormat(value: VkFormat) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get indexData() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set indexData(value: VkBuffer) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get indexOffset() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set indexOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get indexCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(76, LE);
  }
  
  set indexType(value: VkIndexType) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get transformData() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set transformData(value: VkBuffer) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get transformOffset() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set transformOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export class VkGeometryAABBNV implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeometryAABBNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeometryAABBNV(new Uint8Array(VkGeometryAABBNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    aabbData?: VkBuffer;
    numAABBs: number;
    stride: number;
    offset: VkDeviceSize;
  }) {
    const s = VkGeometryAABBNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.aabbData !== undefined) s.aabbData = data.aabbData;
    if (data.numAABBs !== undefined) s.numAABBs = data.numAABBs;
    if (data.stride !== undefined) s.stride = data.stride;
    if (data.offset !== undefined) s.offset = data.offset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get aabbData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set aabbData(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get numAABBs() {
    return this.#view.getUint32(24, LE);
  }
  
  set numAABBs(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(28, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkGeometryDataNV implements IVkStructure {
  static size = 192;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeometryDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeometryDataNV(new Uint8Array(VkGeometryDataNV.size));
  }
  
  static create(data: {
    triangles: VkGeometryTrianglesNV;
    aabbs: VkGeometryAABBNV;
  }) {
    const s = VkGeometryDataNV.alloc();
    if (data.triangles !== undefined) s.triangles = data.triangles;
    if (data.aabbs !== undefined) s.aabbs = data.aabbs;
    return s;
  }
  
  get triangles() {
    return new VkGeometryTrianglesNV(this.#data.subarray(0, 0 + VkGeometryTrianglesNV.size));
  }
  
  set triangles(value: VkGeometryTrianglesNV) {
    if (value[BUFFER].byteLength < VkGeometryTrianglesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aabbs() {
    return new VkGeometryAABBNV(this.#data.subarray(120, 120 + VkGeometryAABBNV.size));
  }
  
  set aabbs(value: VkGeometryAABBNV) {
    if (value[BUFFER].byteLength < VkGeometryAABBNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 120);
  }
}

export class VkGeometryNV implements IVkStructure {
  static size = 576;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGeometryNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGeometryNV(new Uint8Array(VkGeometryNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    geometryType: VkGeometryTypeKHR;
    geometry: VkGeometryDataNV;
    flags?: VkGeometryFlagsKHR;
  }) {
    const s = VkGeometryNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.geometryType !== undefined) s.geometryType = data.geometryType;
    if (data.geometry !== undefined) s.geometry = data.geometry;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get geometryType() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryType(value: VkGeometryTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometry() {
    return new VkGeometryDataNV(this.#data.subarray(192, 192 + VkGeometryDataNV.size));
  }
  
  set geometry(value: VkGeometryDataNV) {
    if (value[BUFFER].byteLength < VkGeometryDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 192);
  }
  
  get flags() {
    return this.#view.getUint32(384, LE);
  }
  
  set flags(value: VkGeometryFlagsKHR) {
    this.#view.setUint32(384, Number(value), LE);
  }
}

export class VkAccelerationStructureInfoNV implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureInfoNV(new Uint8Array(VkAccelerationStructureInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkAccelerationStructureTypeNV;
    flags?: VkBuildAccelerationStructureFlagsNV;
    instanceCount?: number;
    geometryCount?: number;
    pGeometries: Deno.PointerValue;
  }) {
    const s = VkAccelerationStructureInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.instanceCount !== undefined) s.instanceCount = data.instanceCount;
    if (data.geometryCount !== undefined) s.geometryCount = data.geometryCount;
    if (data.pGeometries !== undefined) s.pGeometries = data.pGeometries;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkAccelerationStructureTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkBuildAccelerationStructureFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get geometryCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set geometryCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pGeometries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pGeometries(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkAccelerationStructureCreateInfoNV implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureCreateInfoNV(new Uint8Array(VkAccelerationStructureCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    compactedSize: VkDeviceSize;
    info: VkAccelerationStructureInfoNV;
  }) {
    const s = VkAccelerationStructureCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.compactedSize !== undefined) s.compactedSize = data.compactedSize;
    if (data.info !== undefined) s.info = data.info;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get compactedSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set compactedSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get info() {
    return new VkAccelerationStructureInfoNV(this.#data.subarray(40, 40 + VkAccelerationStructureInfoNV.size));
  }
  
  set info(value: VkAccelerationStructureInfoNV) {
    if (value[BUFFER].byteLength < VkAccelerationStructureInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
}

export class VkBindAccelerationStructureMemoryInfoNV implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindAccelerationStructureMemoryInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindAccelerationStructureMemoryInfoNV(new Uint8Array(VkBindAccelerationStructureMemoryInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructure: VkAccelerationStructureNV;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
    deviceIndexCount?: number;
    pDeviceIndices: Deno.PointerValue;
  }) {
    const s = VkBindAccelerationStructureMemoryInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructure !== undefined) s.accelerationStructure = data.accelerationStructure;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    if (data.deviceIndexCount !== undefined) s.deviceIndexCount = data.deviceIndexCount;
    if (data.pDeviceIndices !== undefined) s.pDeviceIndices = data.pDeviceIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: VkAccelerationStructureNV) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pDeviceIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkWriteDescriptorSetAccelerationStructureKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWriteDescriptorSetAccelerationStructureKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWriteDescriptorSetAccelerationStructureKHR(new Uint8Array(VkWriteDescriptorSetAccelerationStructureKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructureCount: number;
    pAccelerationStructures?: Deno.PointerValue;
  }) {
    const s = VkWriteDescriptorSetAccelerationStructureKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructureCount !== undefined) s.accelerationStructureCount = data.accelerationStructureCount;
    if (data.pAccelerationStructures !== undefined) s.pAccelerationStructures = data.pAccelerationStructures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAccelerationStructures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAccelerationStructures(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkWriteDescriptorSetAccelerationStructureNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkWriteDescriptorSetAccelerationStructureNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkWriteDescriptorSetAccelerationStructureNV(new Uint8Array(VkWriteDescriptorSetAccelerationStructureNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructureCount: number;
    pAccelerationStructures?: Deno.PointerValue;
  }) {
    const s = VkWriteDescriptorSetAccelerationStructureNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructureCount !== undefined) s.accelerationStructureCount = data.accelerationStructureCount;
    if (data.pAccelerationStructures !== undefined) s.pAccelerationStructures = data.pAccelerationStructures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAccelerationStructures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAccelerationStructures(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkAccelerationStructureMemoryRequirementsInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureMemoryRequirementsInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureMemoryRequirementsInfoNV(new Uint8Array(VkAccelerationStructureMemoryRequirementsInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkAccelerationStructureMemoryRequirementsTypeNV;
    accelerationStructure: VkAccelerationStructureNV;
  }) {
    const s = VkAccelerationStructureMemoryRequirementsInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.accelerationStructure !== undefined) s.accelerationStructure = data.accelerationStructure;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkAccelerationStructureMemoryRequirementsTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructure(value: VkAccelerationStructureNV) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceAccelerationStructureFeaturesKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceAccelerationStructureFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceAccelerationStructureFeaturesKHR(new Uint8Array(VkPhysicalDeviceAccelerationStructureFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructure: VkBool32;
    accelerationStructureCaptureReplay: VkBool32;
    accelerationStructureIndirectBuild: VkBool32;
    accelerationStructureHostCommands: VkBool32;
    descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32;
  }) {
    const s = VkPhysicalDeviceAccelerationStructureFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructure !== undefined) s.accelerationStructure = data.accelerationStructure;
    if (data.accelerationStructureCaptureReplay !== undefined) s.accelerationStructureCaptureReplay = data.accelerationStructureCaptureReplay;
    if (data.accelerationStructureIndirectBuild !== undefined) s.accelerationStructureIndirectBuild = data.accelerationStructureIndirectBuild;
    if (data.accelerationStructureHostCommands !== undefined) s.accelerationStructureHostCommands = data.accelerationStructureHostCommands;
    if (data.descriptorBindingAccelerationStructureUpdateAfterBind !== undefined) s.descriptorBindingAccelerationStructureUpdateAfterBind = data.descriptorBindingAccelerationStructureUpdateAfterBind;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructure(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructureCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set accelerationStructureCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get accelerationStructureIndirectBuild() {
    return this.#view.getUint32(24, LE);
  }
  
  set accelerationStructureIndirectBuild(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get accelerationStructureHostCommands() {
    return this.#view.getUint32(28, LE);
  }
  
  set accelerationStructureHostCommands(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get descriptorBindingAccelerationStructureUpdateAfterBind() {
    return this.#view.getUint32(32, LE);
  }
  
  set descriptorBindingAccelerationStructureUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingPipelineFeaturesKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingPipelineFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingPipelineFeaturesKHR(new Uint8Array(VkPhysicalDeviceRayTracingPipelineFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayTracingPipeline: VkBool32;
    rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32;
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32;
    rayTracingPipelineTraceRaysIndirect: VkBool32;
    rayTraversalPrimitiveCulling: VkBool32;
  }) {
    const s = VkPhysicalDeviceRayTracingPipelineFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayTracingPipeline !== undefined) s.rayTracingPipeline = data.rayTracingPipeline;
    if (data.rayTracingPipelineShaderGroupHandleCaptureReplay !== undefined) s.rayTracingPipelineShaderGroupHandleCaptureReplay = data.rayTracingPipelineShaderGroupHandleCaptureReplay;
    if (data.rayTracingPipelineShaderGroupHandleCaptureReplayMixed !== undefined) s.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = data.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
    if (data.rayTracingPipelineTraceRaysIndirect !== undefined) s.rayTracingPipelineTraceRaysIndirect = data.rayTracingPipelineTraceRaysIndirect;
    if (data.rayTraversalPrimitiveCulling !== undefined) s.rayTraversalPrimitiveCulling = data.rayTraversalPrimitiveCulling;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayTracingPipeline() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingPipeline(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingPipelineShaderGroupHandleCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingPipelineShaderGroupHandleCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rayTracingPipelineShaderGroupHandleCaptureReplayMixed() {
    return this.#view.getUint32(24, LE);
  }
  
  set rayTracingPipelineShaderGroupHandleCaptureReplayMixed(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rayTracingPipelineTraceRaysIndirect() {
    return this.#view.getUint32(28, LE);
  }
  
  set rayTracingPipelineTraceRaysIndirect(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get rayTraversalPrimitiveCulling() {
    return this.#view.getUint32(32, LE);
  }
  
  set rayTraversalPrimitiveCulling(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayQueryFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayQueryFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayQueryFeaturesKHR(new Uint8Array(VkPhysicalDeviceRayQueryFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayQuery: VkBool32;
  }) {
    const s = VkPhysicalDeviceRayQueryFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayQuery !== undefined) s.rayQuery = data.rayQuery;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayQuery(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceAccelerationStructurePropertiesKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceAccelerationStructurePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceAccelerationStructurePropertiesKHR(new Uint8Array(VkPhysicalDeviceAccelerationStructurePropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxGeometryCount: Deno.PointerValue;
    maxInstanceCount: Deno.PointerValue;
    maxPrimitiveCount: Deno.PointerValue;
    maxPerStageDescriptorAccelerationStructures: number;
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: number;
    maxDescriptorSetAccelerationStructures: number;
    maxDescriptorSetUpdateAfterBindAccelerationStructures: number;
    minAccelerationStructureScratchOffsetAlignment: number;
  }) {
    const s = VkPhysicalDeviceAccelerationStructurePropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxGeometryCount !== undefined) s.maxGeometryCount = data.maxGeometryCount;
    if (data.maxInstanceCount !== undefined) s.maxInstanceCount = data.maxInstanceCount;
    if (data.maxPrimitiveCount !== undefined) s.maxPrimitiveCount = data.maxPrimitiveCount;
    if (data.maxPerStageDescriptorAccelerationStructures !== undefined) s.maxPerStageDescriptorAccelerationStructures = data.maxPerStageDescriptorAccelerationStructures;
    if (data.maxPerStageDescriptorUpdateAfterBindAccelerationStructures !== undefined) s.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = data.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
    if (data.maxDescriptorSetAccelerationStructures !== undefined) s.maxDescriptorSetAccelerationStructures = data.maxDescriptorSetAccelerationStructures;
    if (data.maxDescriptorSetUpdateAfterBindAccelerationStructures !== undefined) s.maxDescriptorSetUpdateAfterBindAccelerationStructures = data.maxDescriptorSetUpdateAfterBindAccelerationStructures;
    if (data.minAccelerationStructureScratchOffsetAlignment !== undefined) s.minAccelerationStructureScratchOffsetAlignment = data.minAccelerationStructureScratchOffsetAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxGeometryCount() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxGeometryCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get maxInstanceCount() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxInstanceCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get maxPrimitiveCount() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set maxPrimitiveCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxPerStageDescriptorAccelerationStructures() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxPerStageDescriptorAccelerationStructures(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindAccelerationStructures() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindAccelerationStructures(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxDescriptorSetAccelerationStructures() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxDescriptorSetAccelerationStructures(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindAccelerationStructures() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindAccelerationStructures(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get minAccelerationStructureScratchOffsetAlignment() {
    return this.#view.getUint32(56, LE);
  }
  
  set minAccelerationStructureScratchOffsetAlignment(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingPipelinePropertiesKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingPipelinePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingPipelinePropertiesKHR(new Uint8Array(VkPhysicalDeviceRayTracingPipelinePropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderGroupHandleSize: number;
    maxRayRecursionDepth: number;
    maxShaderGroupStride: number;
    shaderGroupBaseAlignment: number;
    shaderGroupHandleCaptureReplaySize: number;
    maxRayDispatchInvocationCount: number;
    shaderGroupHandleAlignment: number;
    maxRayHitAttributeSize: number;
  }) {
    const s = VkPhysicalDeviceRayTracingPipelinePropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderGroupHandleSize !== undefined) s.shaderGroupHandleSize = data.shaderGroupHandleSize;
    if (data.maxRayRecursionDepth !== undefined) s.maxRayRecursionDepth = data.maxRayRecursionDepth;
    if (data.maxShaderGroupStride !== undefined) s.maxShaderGroupStride = data.maxShaderGroupStride;
    if (data.shaderGroupBaseAlignment !== undefined) s.shaderGroupBaseAlignment = data.shaderGroupBaseAlignment;
    if (data.shaderGroupHandleCaptureReplaySize !== undefined) s.shaderGroupHandleCaptureReplaySize = data.shaderGroupHandleCaptureReplaySize;
    if (data.maxRayDispatchInvocationCount !== undefined) s.maxRayDispatchInvocationCount = data.maxRayDispatchInvocationCount;
    if (data.shaderGroupHandleAlignment !== undefined) s.shaderGroupHandleAlignment = data.shaderGroupHandleAlignment;
    if (data.maxRayHitAttributeSize !== undefined) s.maxRayHitAttributeSize = data.maxRayHitAttributeSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderGroupHandleSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderGroupHandleSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxRayRecursionDepth() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxRayRecursionDepth(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxShaderGroupStride() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxShaderGroupStride(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderGroupBaseAlignment() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderGroupBaseAlignment(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderGroupHandleCaptureReplaySize() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderGroupHandleCaptureReplaySize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxRayDispatchInvocationCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxRayDispatchInvocationCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderGroupHandleAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderGroupHandleAlignment(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxRayHitAttributeSize() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxRayHitAttributeSize(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingPropertiesNV implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingPropertiesNV(new Uint8Array(VkPhysicalDeviceRayTracingPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderGroupHandleSize: number;
    maxRecursionDepth: number;
    maxShaderGroupStride: number;
    shaderGroupBaseAlignment: number;
    maxGeometryCount: Deno.PointerValue;
    maxInstanceCount: Deno.PointerValue;
    maxTriangleCount: Deno.PointerValue;
    maxDescriptorSetAccelerationStructures: number;
  }) {
    const s = VkPhysicalDeviceRayTracingPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderGroupHandleSize !== undefined) s.shaderGroupHandleSize = data.shaderGroupHandleSize;
    if (data.maxRecursionDepth !== undefined) s.maxRecursionDepth = data.maxRecursionDepth;
    if (data.maxShaderGroupStride !== undefined) s.maxShaderGroupStride = data.maxShaderGroupStride;
    if (data.shaderGroupBaseAlignment !== undefined) s.shaderGroupBaseAlignment = data.shaderGroupBaseAlignment;
    if (data.maxGeometryCount !== undefined) s.maxGeometryCount = data.maxGeometryCount;
    if (data.maxInstanceCount !== undefined) s.maxInstanceCount = data.maxInstanceCount;
    if (data.maxTriangleCount !== undefined) s.maxTriangleCount = data.maxTriangleCount;
    if (data.maxDescriptorSetAccelerationStructures !== undefined) s.maxDescriptorSetAccelerationStructures = data.maxDescriptorSetAccelerationStructures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderGroupHandleSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderGroupHandleSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxRecursionDepth() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxRecursionDepth(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxShaderGroupStride() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxShaderGroupStride(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderGroupBaseAlignment() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderGroupBaseAlignment(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxGeometryCount() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set maxGeometryCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxInstanceCount() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set maxInstanceCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get maxTriangleCount() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set maxTriangleCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get maxDescriptorSetAccelerationStructures() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxDescriptorSetAccelerationStructures(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkStridedDeviceAddressRegionKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkStridedDeviceAddressRegionKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkStridedDeviceAddressRegionKHR(new Uint8Array(VkStridedDeviceAddressRegionKHR.size));
  }
  
  static create(data: {
    deviceAddress?: VkDeviceAddress;
    stride: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkStridedDeviceAddressRegionKHR.alloc();
    if (data.deviceAddress !== undefined) s.deviceAddress = data.deviceAddress;
    if (data.stride !== undefined) s.stride = data.stride;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set deviceAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get stride() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set stride(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkTraceRaysIndirectCommandKHR implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTraceRaysIndirectCommandKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTraceRaysIndirectCommandKHR(new Uint8Array(VkTraceRaysIndirectCommandKHR.size));
  }
  
  static create(data: {
    width: number;
    height: number;
    depth: number;
  }) {
    const s = VkTraceRaysIndirectCommandKHR.alloc();
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.depth !== undefined) s.depth = data.depth;
    return s;
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(8, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkTraceRaysIndirectCommand2KHR implements IVkStructure {
  static size = 104;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTraceRaysIndirectCommand2KHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTraceRaysIndirectCommand2KHR(new Uint8Array(VkTraceRaysIndirectCommand2KHR.size));
  }
  
  static create(data: {
    raygenShaderRecordAddress: VkDeviceAddress;
    raygenShaderRecordSize: VkDeviceSize;
    missShaderBindingTableAddress: VkDeviceAddress;
    missShaderBindingTableSize: VkDeviceSize;
    missShaderBindingTableStride: VkDeviceSize;
    hitShaderBindingTableAddress: VkDeviceAddress;
    hitShaderBindingTableSize: VkDeviceSize;
    hitShaderBindingTableStride: VkDeviceSize;
    callableShaderBindingTableAddress: VkDeviceAddress;
    callableShaderBindingTableSize: VkDeviceSize;
    callableShaderBindingTableStride: VkDeviceSize;
    width: number;
    height: number;
    depth: number;
  }) {
    const s = VkTraceRaysIndirectCommand2KHR.alloc();
    if (data.raygenShaderRecordAddress !== undefined) s.raygenShaderRecordAddress = data.raygenShaderRecordAddress;
    if (data.raygenShaderRecordSize !== undefined) s.raygenShaderRecordSize = data.raygenShaderRecordSize;
    if (data.missShaderBindingTableAddress !== undefined) s.missShaderBindingTableAddress = data.missShaderBindingTableAddress;
    if (data.missShaderBindingTableSize !== undefined) s.missShaderBindingTableSize = data.missShaderBindingTableSize;
    if (data.missShaderBindingTableStride !== undefined) s.missShaderBindingTableStride = data.missShaderBindingTableStride;
    if (data.hitShaderBindingTableAddress !== undefined) s.hitShaderBindingTableAddress = data.hitShaderBindingTableAddress;
    if (data.hitShaderBindingTableSize !== undefined) s.hitShaderBindingTableSize = data.hitShaderBindingTableSize;
    if (data.hitShaderBindingTableStride !== undefined) s.hitShaderBindingTableStride = data.hitShaderBindingTableStride;
    if (data.callableShaderBindingTableAddress !== undefined) s.callableShaderBindingTableAddress = data.callableShaderBindingTableAddress;
    if (data.callableShaderBindingTableSize !== undefined) s.callableShaderBindingTableSize = data.callableShaderBindingTableSize;
    if (data.callableShaderBindingTableStride !== undefined) s.callableShaderBindingTableStride = data.callableShaderBindingTableStride;
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.depth !== undefined) s.depth = data.depth;
    return s;
  }
  
  get raygenShaderRecordAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set raygenShaderRecordAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get raygenShaderRecordSize() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set raygenShaderRecordSize(value: VkDeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get missShaderBindingTableAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set missShaderBindingTableAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get missShaderBindingTableSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set missShaderBindingTableSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get missShaderBindingTableStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set missShaderBindingTableStride(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get hitShaderBindingTableAddress() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set hitShaderBindingTableAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get hitShaderBindingTableSize() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set hitShaderBindingTableSize(value: VkDeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get hitShaderBindingTableStride() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set hitShaderBindingTableStride(value: VkDeviceSize) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get callableShaderBindingTableAddress() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set callableShaderBindingTableAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get callableShaderBindingTableSize() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set callableShaderBindingTableSize(value: VkDeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get callableShaderBindingTableStride() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set callableShaderBindingTableStride(value: VkDeviceSize) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(88, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(92, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(96, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(new Uint8Array(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayTracingMaintenance1: VkBool32;
    rayTracingPipelineTraceRaysIndirect2: VkBool32;
  }) {
    const s = VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayTracingMaintenance1 !== undefined) s.rayTracingMaintenance1 = data.rayTracingMaintenance1;
    if (data.rayTracingPipelineTraceRaysIndirect2 !== undefined) s.rayTracingPipelineTraceRaysIndirect2 = data.rayTracingPipelineTraceRaysIndirect2;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayTracingMaintenance1() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingMaintenance1(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingPipelineTraceRaysIndirect2() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingPipelineTraceRaysIndirect2(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkDrmFormatModifierPropertiesListEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrmFormatModifierPropertiesListEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrmFormatModifierPropertiesListEXT(new Uint8Array(VkDrmFormatModifierPropertiesListEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifierCount?: number;
    pDrmFormatModifierProperties?: Deno.PointerValue;
  }) {
    const s = VkDrmFormatModifierPropertiesListEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifierCount !== undefined) s.drmFormatModifierCount = data.drmFormatModifierCount;
    if (data.pDrmFormatModifierProperties !== undefined) s.pDrmFormatModifierProperties = data.pDrmFormatModifierProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifierProperties() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifierProperties(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDrmFormatModifierPropertiesEXT implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrmFormatModifierPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrmFormatModifierPropertiesEXT(new Uint8Array(VkDrmFormatModifierPropertiesEXT.size));
  }
  
  static create(data: {
    drmFormatModifier: Deno.PointerValue;
    drmFormatModifierPlaneCount: number;
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags;
  }) {
    const s = VkDrmFormatModifierPropertiesEXT.alloc();
    if (data.drmFormatModifier !== undefined) s.drmFormatModifier = data.drmFormatModifier;
    if (data.drmFormatModifierPlaneCount !== undefined) s.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
    if (data.drmFormatModifierTilingFeatures !== undefined) s.drmFormatModifierTilingFeatures = data.drmFormatModifierTilingFeatures;
    return s;
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get drmFormatModifierTilingFeatures() {
    return this.#view.getUint32(12, LE);
  }
  
  set drmFormatModifierTilingFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkPhysicalDeviceImageDrmFormatModifierInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageDrmFormatModifierInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageDrmFormatModifierInfoEXT(new Uint8Array(VkPhysicalDeviceImageDrmFormatModifierInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifier: Deno.PointerValue;
    sharingMode: VkSharingMode;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: Deno.PointerValue;
  }) {
    const s = VkPhysicalDeviceImageDrmFormatModifierInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifier !== undefined) s.drmFormatModifier = data.drmFormatModifier;
    if (data.sharingMode !== undefined) s.sharingMode = data.sharingMode;
    if (data.queueFamilyIndexCount !== undefined) s.queueFamilyIndexCount = data.queueFamilyIndexCount;
    if (data.pQueueFamilyIndices !== undefined) s.pQueueFamilyIndices = data.pQueueFamilyIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set sharingMode(value: VkSharingMode) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pQueueFamilyIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageDrmFormatModifierListCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageDrmFormatModifierListCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageDrmFormatModifierListCreateInfoEXT(new Uint8Array(VkImageDrmFormatModifierListCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifierCount: number;
    pDrmFormatModifiers: Deno.PointerValue;
  }) {
    const s = VkImageDrmFormatModifierListCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifierCount !== undefined) s.drmFormatModifierCount = data.drmFormatModifierCount;
    if (data.pDrmFormatModifiers !== undefined) s.pDrmFormatModifiers = data.pDrmFormatModifiers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifiers() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifiers(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkImageDrmFormatModifierExplicitCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageDrmFormatModifierExplicitCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageDrmFormatModifierExplicitCreateInfoEXT(new Uint8Array(VkImageDrmFormatModifierExplicitCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifier: Deno.PointerValue;
    drmFormatModifierPlaneCount: number;
    pPlaneLayouts: Deno.PointerValue;
  }) {
    const s = VkImageDrmFormatModifierExplicitCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifier !== undefined) s.drmFormatModifier = data.drmFormatModifier;
    if (data.drmFormatModifierPlaneCount !== undefined) s.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
    if (data.pPlaneLayouts !== undefined) s.pPlaneLayouts = data.pPlaneLayouts;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPlaneLayouts() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPlaneLayouts(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageDrmFormatModifierPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageDrmFormatModifierPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageDrmFormatModifierPropertiesEXT(new Uint8Array(VkImageDrmFormatModifierPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifier: Deno.PointerValue;
  }) {
    const s = VkImageDrmFormatModifierPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifier !== undefined) s.drmFormatModifier = data.drmFormatModifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkImageStencilUsageCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageStencilUsageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageStencilUsageCreateInfo(new Uint8Array(VkImageStencilUsageCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stencilUsage: VkImageUsageFlags;
  }) {
    const s = VkImageStencilUsageCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stencilUsage !== undefined) s.stencilUsage = data.stencilUsage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stencilUsage() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilUsage(value: VkImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceMemoryOverallocationCreateInfoAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceMemoryOverallocationCreateInfoAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceMemoryOverallocationCreateInfoAMD(new Uint8Array(VkDeviceMemoryOverallocationCreateInfoAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD;
  }) {
    const s = VkDeviceMemoryOverallocationCreateInfoAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.overallocationBehavior !== undefined) s.overallocationBehavior = data.overallocationBehavior;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get overallocationBehavior() {
    return this.#view.getUint32(16, LE);
  }
  
  set overallocationBehavior(value: VkMemoryOverallocationBehaviorAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMapFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMapFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMapFeaturesEXT(new Uint8Array(VkPhysicalDeviceFragmentDensityMapFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityMap: VkBool32;
    fragmentDensityMapDynamic: VkBool32;
    fragmentDensityMapNonSubsampledImages: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMapFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityMap !== undefined) s.fragmentDensityMap = data.fragmentDensityMap;
    if (data.fragmentDensityMapDynamic !== undefined) s.fragmentDensityMapDynamic = data.fragmentDensityMapDynamic;
    if (data.fragmentDensityMapNonSubsampledImages !== undefined) s.fragmentDensityMapNonSubsampledImages = data.fragmentDensityMapNonSubsampledImages;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityMap() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMap(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentDensityMapDynamic() {
    return this.#view.getUint32(20, LE);
  }
  
  set fragmentDensityMapDynamic(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get fragmentDensityMapNonSubsampledImages() {
    return this.#view.getUint32(24, LE);
  }
  
  set fragmentDensityMapNonSubsampledImages(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMap2FeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(new Uint8Array(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityMapDeferred: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityMapDeferred !== undefined) s.fragmentDensityMapDeferred = data.fragmentDensityMapDeferred;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityMapDeferred() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMapDeferred(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(new Uint8Array(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityMapOffset: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityMapOffset !== undefined) s.fragmentDensityMapOffset = data.fragmentDensityMapOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityMapOffset() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMapOffset(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMapPropertiesEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMapPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMapPropertiesEXT(new Uint8Array(VkPhysicalDeviceFragmentDensityMapPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minFragmentDensityTexelSize: VkExtent2D;
    maxFragmentDensityTexelSize: VkExtent2D;
    fragmentDensityInvocations: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMapPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minFragmentDensityTexelSize !== undefined) s.minFragmentDensityTexelSize = data.minFragmentDensityTexelSize;
    if (data.maxFragmentDensityTexelSize !== undefined) s.maxFragmentDensityTexelSize = data.maxFragmentDensityTexelSize;
    if (data.fragmentDensityInvocations !== undefined) s.fragmentDensityInvocations = data.fragmentDensityInvocations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minFragmentDensityTexelSize() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set minFragmentDensityTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxFragmentDensityTexelSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set maxFragmentDensityTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get fragmentDensityInvocations() {
    return this.#view.getUint32(32, LE);
  }
  
  set fragmentDensityInvocations(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMap2PropertiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(new Uint8Array(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subsampledLoads: VkBool32;
    subsampledCoarseReconstructionEarlyAccess: VkBool32;
    maxSubsampledArrayLayers: number;
    maxDescriptorSetSubsampledSamplers: number;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subsampledLoads !== undefined) s.subsampledLoads = data.subsampledLoads;
    if (data.subsampledCoarseReconstructionEarlyAccess !== undefined) s.subsampledCoarseReconstructionEarlyAccess = data.subsampledCoarseReconstructionEarlyAccess;
    if (data.maxSubsampledArrayLayers !== undefined) s.maxSubsampledArrayLayers = data.maxSubsampledArrayLayers;
    if (data.maxDescriptorSetSubsampledSamplers !== undefined) s.maxDescriptorSetSubsampledSamplers = data.maxDescriptorSetSubsampledSamplers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subsampledLoads() {
    return this.#view.getUint32(16, LE);
  }
  
  set subsampledLoads(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get subsampledCoarseReconstructionEarlyAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set subsampledCoarseReconstructionEarlyAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxSubsampledArrayLayers() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxSubsampledArrayLayers(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxDescriptorSetSubsampledSamplers() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxDescriptorSetSubsampledSamplers(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(new Uint8Array(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityOffsetGranularity: VkExtent2D;
  }) {
    const s = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityOffsetGranularity !== undefined) s.fragmentDensityOffsetGranularity = data.fragmentDensityOffsetGranularity;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityOffsetGranularity() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set fragmentDensityOffsetGranularity(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkRenderPassFragmentDensityMapCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassFragmentDensityMapCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassFragmentDensityMapCreateInfoEXT(new Uint8Array(VkRenderPassFragmentDensityMapCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityMapAttachment: VkAttachmentReference;
  }) {
    const s = VkRenderPassFragmentDensityMapCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityMapAttachment !== undefined) s.fragmentDensityMapAttachment = data.fragmentDensityMapAttachment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityMapAttachment() {
    return new VkAttachmentReference(this.#data.subarray(16, 16 + VkAttachmentReference.size));
  }
  
  set fragmentDensityMapAttachment(value: VkAttachmentReference) {
    if (value[BUFFER].byteLength < VkAttachmentReference.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export class VkSubpassFragmentDensityMapOffsetEndInfoQCOM implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassFragmentDensityMapOffsetEndInfoQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassFragmentDensityMapOffsetEndInfoQCOM(new Uint8Array(VkSubpassFragmentDensityMapOffsetEndInfoQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentDensityOffsetCount?: number;
    pFragmentDensityOffsets: Deno.PointerValue;
  }) {
    const s = VkSubpassFragmentDensityMapOffsetEndInfoQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentDensityOffsetCount !== undefined) s.fragmentDensityOffsetCount = data.fragmentDensityOffsetCount;
    if (data.pFragmentDensityOffsets !== undefined) s.pFragmentDensityOffsets = data.pFragmentDensityOffsets;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentDensityOffsetCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityOffsetCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pFragmentDensityOffsets() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFragmentDensityOffsets(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceScalarBlockLayoutFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceScalarBlockLayoutFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceScalarBlockLayoutFeatures(new Uint8Array(VkPhysicalDeviceScalarBlockLayoutFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    scalarBlockLayout: VkBool32;
  }) {
    const s = VkPhysicalDeviceScalarBlockLayoutFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.scalarBlockLayout !== undefined) s.scalarBlockLayout = data.scalarBlockLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get scalarBlockLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set scalarBlockLayout(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSurfaceProtectedCapabilitiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceProtectedCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceProtectedCapabilitiesKHR(new Uint8Array(VkSurfaceProtectedCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supportsProtected: VkBool32;
  }) {
    const s = VkSurfaceProtectedCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supportsProtected !== undefined) s.supportsProtected = data.supportsProtected;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supportsProtected() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportsProtected(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceUniformBufferStandardLayoutFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceUniformBufferStandardLayoutFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceUniformBufferStandardLayoutFeatures(new Uint8Array(VkPhysicalDeviceUniformBufferStandardLayoutFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    uniformBufferStandardLayout: VkBool32;
  }) {
    const s = VkPhysicalDeviceUniformBufferStandardLayoutFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.uniformBufferStandardLayout !== undefined) s.uniformBufferStandardLayout = data.uniformBufferStandardLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get uniformBufferStandardLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set uniformBufferStandardLayout(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceDepthClipEnableFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDepthClipEnableFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDepthClipEnableFeaturesEXT(new Uint8Array(VkPhysicalDeviceDepthClipEnableFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    depthClipEnable: VkBool32;
  }) {
    const s = VkPhysicalDeviceDepthClipEnableFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.depthClipEnable !== undefined) s.depthClipEnable = data.depthClipEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get depthClipEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClipEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineRasterizationDepthClipStateCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationDepthClipStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationDepthClipStateCreateInfoEXT(new Uint8Array(VkPipelineRasterizationDepthClipStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineRasterizationDepthClipStateCreateFlagsEXT;
    depthClipEnable: VkBool32;
  }) {
    const s = VkPipelineRasterizationDepthClipStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.depthClipEnable !== undefined) s.depthClipEnable = data.depthClipEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineRasterizationDepthClipStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthClipEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthClipEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceMemoryBudgetPropertiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryBudgetPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryBudgetPropertiesEXT(new Uint8Array(VkPhysicalDeviceMemoryBudgetPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    heapBudget: VkDeviceSize;
    heapUsage: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceMemoryBudgetPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.heapBudget !== undefined) s.heapBudget = data.heapBudget;
    if (data.heapUsage !== undefined) s.heapUsage = data.heapUsage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get heapBudget() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set heapBudget(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get heapUsage() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set heapUsage(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceMemoryPriorityFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMemoryPriorityFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMemoryPriorityFeaturesEXT(new Uint8Array(VkPhysicalDeviceMemoryPriorityFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryPriority: VkBool32;
  }) {
    const s = VkPhysicalDeviceMemoryPriorityFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryPriority !== undefined) s.memoryPriority = data.memoryPriority;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryPriority() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryPriority(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryPriorityAllocateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryPriorityAllocateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryPriorityAllocateInfoEXT(new Uint8Array(VkMemoryPriorityAllocateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    priority: number;
  }) {
    const s = VkMemoryPriorityAllocateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.priority !== undefined) s.priority = data.priority;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get priority() {
    return this.#view.getFloat32(16, LE);
  }
  
  set priority(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(new Uint8Array(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pageableDeviceLocalMemory: VkBool32;
  }) {
    const s = VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pageableDeviceLocalMemory !== undefined) s.pageableDeviceLocalMemory = data.pageableDeviceLocalMemory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pageableDeviceLocalMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set pageableDeviceLocalMemory(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceBufferDeviceAddressFeatures implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceBufferDeviceAddressFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceBufferDeviceAddressFeatures(new Uint8Array(VkPhysicalDeviceBufferDeviceAddressFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    bufferDeviceAddress: VkBool32;
    bufferDeviceAddressCaptureReplay: VkBool32;
    bufferDeviceAddressMultiDevice: VkBool32;
  }) {
    const s = VkPhysicalDeviceBufferDeviceAddressFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.bufferDeviceAddress !== undefined) s.bufferDeviceAddress = data.bufferDeviceAddress;
    if (data.bufferDeviceAddressCaptureReplay !== undefined) s.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
    if (data.bufferDeviceAddressMultiDevice !== undefined) s.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(16, LE);
  }
  
  set bufferDeviceAddress(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceBufferDeviceAddressFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(new Uint8Array(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    bufferDeviceAddress: VkBool32;
    bufferDeviceAddressCaptureReplay: VkBool32;
    bufferDeviceAddressMultiDevice: VkBool32;
  }) {
    const s = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.bufferDeviceAddress !== undefined) s.bufferDeviceAddress = data.bufferDeviceAddress;
    if (data.bufferDeviceAddressCaptureReplay !== undefined) s.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
    if (data.bufferDeviceAddressMultiDevice !== undefined) s.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(16, LE);
  }
  
  set bufferDeviceAddress(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkBufferDeviceAddressInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferDeviceAddressInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferDeviceAddressInfo(new Uint8Array(VkBufferDeviceAddressInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
  }) {
    const s = VkBufferDeviceAddressInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkBufferOpaqueCaptureAddressCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferOpaqueCaptureAddressCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferOpaqueCaptureAddressCreateInfo(new Uint8Array(VkBufferOpaqueCaptureAddressCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    opaqueCaptureAddress: Deno.PointerValue;
  }) {
    const s = VkBufferOpaqueCaptureAddressCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.opaqueCaptureAddress !== undefined) s.opaqueCaptureAddress = data.opaqueCaptureAddress;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get opaqueCaptureAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureAddress(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkBufferDeviceAddressCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferDeviceAddressCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferDeviceAddressCreateInfoEXT(new Uint8Array(VkBufferDeviceAddressCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceAddress: VkDeviceAddress;
  }) {
    const s = VkBufferDeviceAddressCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceAddress !== undefined) s.deviceAddress = data.deviceAddress;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set deviceAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceImageViewImageFormatInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageViewImageFormatInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageViewImageFormatInfoEXT(new Uint8Array(VkPhysicalDeviceImageViewImageFormatInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageViewType: VkImageViewType;
  }) {
    const s = VkPhysicalDeviceImageViewImageFormatInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageViewType !== undefined) s.imageViewType = data.imageViewType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageViewType() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageViewType(value: VkImageViewType) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkFilterCubicImageViewImageFormatPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFilterCubicImageViewImageFormatPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFilterCubicImageViewImageFormatPropertiesEXT(new Uint8Array(VkFilterCubicImageViewImageFormatPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    filterCubic: VkBool32;
    filterCubicMinmax: VkBool32;
  }) {
    const s = VkFilterCubicImageViewImageFormatPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.filterCubic !== undefined) s.filterCubic = data.filterCubic;
    if (data.filterCubicMinmax !== undefined) s.filterCubicMinmax = data.filterCubicMinmax;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get filterCubic() {
    return this.#view.getUint32(16, LE);
  }
  
  set filterCubic(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get filterCubicMinmax() {
    return this.#view.getUint32(20, LE);
  }
  
  set filterCubicMinmax(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceImagelessFramebufferFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImagelessFramebufferFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImagelessFramebufferFeatures(new Uint8Array(VkPhysicalDeviceImagelessFramebufferFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imagelessFramebuffer: VkBool32;
  }) {
    const s = VkPhysicalDeviceImagelessFramebufferFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imagelessFramebuffer !== undefined) s.imagelessFramebuffer = data.imagelessFramebuffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imagelessFramebuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set imagelessFramebuffer(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkFramebufferAttachmentsCreateInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFramebufferAttachmentsCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFramebufferAttachmentsCreateInfo(new Uint8Array(VkFramebufferAttachmentsCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachmentImageInfoCount?: number;
    pAttachmentImageInfos: Deno.PointerValue;
  }) {
    const s = VkFramebufferAttachmentsCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachmentImageInfoCount !== undefined) s.attachmentImageInfoCount = data.attachmentImageInfoCount;
    if (data.pAttachmentImageInfos !== undefined) s.pAttachmentImageInfos = data.pAttachmentImageInfos;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachmentImageInfoCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentImageInfoCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachmentImageInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachmentImageInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkFramebufferAttachmentImageInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFramebufferAttachmentImageInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFramebufferAttachmentImageInfo(new Uint8Array(VkFramebufferAttachmentImageInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkImageCreateFlags;
    usage: VkImageUsageFlags;
    width: number;
    height: number;
    layerCount: number;
    viewFormatCount?: number;
    pViewFormats: Deno.PointerValue;
  }) {
    const s = VkFramebufferAttachmentImageInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.usage !== undefined) s.usage = data.usage;
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    if (data.viewFormatCount !== undefined) s.viewFormatCount = data.viewFormatCount;
    if (data.pViewFormats !== undefined) s.pViewFormats = data.pViewFormats;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkImageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(20, LE);
  }
  
  set usage(value: VkImageUsageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(24, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(28, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get viewFormatCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set viewFormatCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pViewFormats() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pViewFormats(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkRenderPassAttachmentBeginInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassAttachmentBeginInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassAttachmentBeginInfo(new Uint8Array(VkRenderPassAttachmentBeginInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachmentCount?: number;
    pAttachments: Deno.PointerValue;
  }) {
    const s = VkRenderPassAttachmentBeginInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pAttachments !== undefined) s.pAttachments = data.pAttachments;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceTextureCompressionASTCHDRFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTextureCompressionASTCHDRFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTextureCompressionASTCHDRFeatures(new Uint8Array(VkPhysicalDeviceTextureCompressionASTCHDRFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    textureCompressionASTC_HDR: VkBool32;
  }) {
    const s = VkPhysicalDeviceTextureCompressionASTCHDRFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.textureCompressionASTC_HDR !== undefined) s.textureCompressionASTC_HDR = data.textureCompressionASTC_HDR;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get textureCompressionASTC_HDR() {
    return this.#view.getUint32(16, LE);
  }
  
  set textureCompressionASTC_HDR(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCooperativeMatrixFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCooperativeMatrixFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCooperativeMatrixFeaturesNV(new Uint8Array(VkPhysicalDeviceCooperativeMatrixFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    cooperativeMatrix: VkBool32;
    cooperativeMatrixRobustBufferAccess: VkBool32;
  }) {
    const s = VkPhysicalDeviceCooperativeMatrixFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.cooperativeMatrix !== undefined) s.cooperativeMatrix = data.cooperativeMatrix;
    if (data.cooperativeMatrixRobustBufferAccess !== undefined) s.cooperativeMatrixRobustBufferAccess = data.cooperativeMatrixRobustBufferAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get cooperativeMatrix() {
    return this.#view.getUint32(16, LE);
  }
  
  set cooperativeMatrix(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get cooperativeMatrixRobustBufferAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set cooperativeMatrixRobustBufferAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceCooperativeMatrixPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCooperativeMatrixPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCooperativeMatrixPropertiesNV(new Uint8Array(VkPhysicalDeviceCooperativeMatrixPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    cooperativeMatrixSupportedStages: VkShaderStageFlags;
  }) {
    const s = VkPhysicalDeviceCooperativeMatrixPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.cooperativeMatrixSupportedStages !== undefined) s.cooperativeMatrixSupportedStages = data.cooperativeMatrixSupportedStages;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get cooperativeMatrixSupportedStages() {
    return this.#view.getUint32(16, LE);
  }
  
  set cooperativeMatrixSupportedStages(value: VkShaderStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCooperativeMatrixPropertiesNV implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCooperativeMatrixPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCooperativeMatrixPropertiesNV(new Uint8Array(VkCooperativeMatrixPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    MSize: number;
    NSize: number;
    KSize: number;
    AType: VkComponentTypeNV;
    BType: VkComponentTypeNV;
    CType: VkComponentTypeNV;
    DType: VkComponentTypeNV;
    scope: VkScopeNV;
  }) {
    const s = VkCooperativeMatrixPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.MSize !== undefined) s.MSize = data.MSize;
    if (data.NSize !== undefined) s.NSize = data.NSize;
    if (data.KSize !== undefined) s.KSize = data.KSize;
    if (data.AType !== undefined) s.AType = data.AType;
    if (data.BType !== undefined) s.BType = data.BType;
    if (data.CType !== undefined) s.CType = data.CType;
    if (data.DType !== undefined) s.DType = data.DType;
    if (data.scope !== undefined) s.scope = data.scope;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get MSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set MSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get NSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set NSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get KSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set KSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get AType() {
    return this.#view.getUint32(28, LE);
  }
  
  set AType(value: VkComponentTypeNV) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get BType() {
    return this.#view.getUint32(32, LE);
  }
  
  set BType(value: VkComponentTypeNV) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get CType() {
    return this.#view.getUint32(36, LE);
  }
  
  set CType(value: VkComponentTypeNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get DType() {
    return this.#view.getUint32(40, LE);
  }
  
  set DType(value: VkComponentTypeNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get scope() {
    return this.#view.getUint32(44, LE);
  }
  
  set scope(value: VkScopeNV) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export class VkPhysicalDeviceYcbcrImageArraysFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(new Uint8Array(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    ycbcrImageArrays: VkBool32;
  }) {
    const s = VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.ycbcrImageArrays !== undefined) s.ycbcrImageArrays = data.ycbcrImageArrays;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get ycbcrImageArrays() {
    return this.#view.getUint32(16, LE);
  }
  
  set ycbcrImageArrays(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImageViewHandleInfoNVX implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewHandleInfoNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewHandleInfoNVX(new Uint8Array(VkImageViewHandleInfoNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageView: VkImageView;
    descriptorType: VkDescriptorType;
    sampler?: VkSampler;
  }) {
    const s = VkImageViewHandleInfoNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.descriptorType !== undefined) s.descriptorType = data.descriptorType;
    if (data.sampler !== undefined) s.sampler = data.sampler;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorType(value: VkDescriptorType) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sampler() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set sampler(value: VkSampler) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageViewAddressPropertiesNVX implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewAddressPropertiesNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewAddressPropertiesNVX(new Uint8Array(VkImageViewAddressPropertiesNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceAddress: VkDeviceAddress;
    size: VkDeviceSize;
  }) {
    const s = VkImageViewAddressPropertiesNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceAddress !== undefined) s.deviceAddress = data.deviceAddress;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set deviceAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPresentFrameTokenGGP implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPresentFrameTokenGGP.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPresentFrameTokenGGP(new Uint8Array(VkPresentFrameTokenGGP.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    frameToken: Deno.PointerValue;
  }) {
    const s = VkPresentFrameTokenGGP.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.frameToken !== undefined) s.frameToken = data.frameToken;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get frameToken() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set frameToken(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPipelineCreationFeedback implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCreationFeedback.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCreationFeedback(new Uint8Array(VkPipelineCreationFeedback.size));
  }
  
  static create(data: {
    flags: VkPipelineCreationFeedbackFlags;
    duration: Deno.PointerValue;
  }) {
    const s = VkPipelineCreationFeedback.alloc();
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.duration !== undefined) s.duration = data.duration;
    return s;
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: VkPipelineCreationFeedbackFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get duration() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set duration(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkPipelineCreationFeedbackCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCreationFeedbackCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCreationFeedbackCreateInfo(new Uint8Array(VkPipelineCreationFeedbackCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pPipelineCreationFeedback: Deno.PointerValue;
    pipelineStageCreationFeedbackCount?: number;
    pPipelineStageCreationFeedbacks: Deno.PointerValue;
  }) {
    const s = VkPipelineCreationFeedbackCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pPipelineCreationFeedback !== undefined) s.pPipelineCreationFeedback = data.pPipelineCreationFeedback;
    if (data.pipelineStageCreationFeedbackCount !== undefined) s.pipelineStageCreationFeedbackCount = data.pipelineStageCreationFeedbackCount;
    if (data.pPipelineStageCreationFeedbacks !== undefined) s.pPipelineStageCreationFeedbacks = data.pPipelineStageCreationFeedbacks;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pPipelineCreationFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pPipelineCreationFeedback(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pipelineStageCreationFeedbackCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set pipelineStageCreationFeedbackCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPipelineStageCreationFeedbacks() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPipelineStageCreationFeedbacks(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkSurfaceFullScreenExclusiveInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceFullScreenExclusiveInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceFullScreenExclusiveInfoEXT(new Uint8Array(VkSurfaceFullScreenExclusiveInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fullScreenExclusive: VkFullScreenExclusiveEXT;
  }) {
    const s = VkSurfaceFullScreenExclusiveInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fullScreenExclusive !== undefined) s.fullScreenExclusive = data.fullScreenExclusive;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fullScreenExclusive() {
    return this.#view.getUint32(16, LE);
  }
  
  set fullScreenExclusive(value: VkFullScreenExclusiveEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSurfaceFullScreenExclusiveWin32InfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceFullScreenExclusiveWin32InfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceFullScreenExclusiveWin32InfoEXT(new Uint8Array(VkSurfaceFullScreenExclusiveWin32InfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    hmonitor: Deno.PointerValue;
  }) {
    const s = VkSurfaceFullScreenExclusiveWin32InfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.hmonitor !== undefined) s.hmonitor = data.hmonitor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get hmonitor() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set hmonitor(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSurfaceCapabilitiesFullScreenExclusiveEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceCapabilitiesFullScreenExclusiveEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceCapabilitiesFullScreenExclusiveEXT(new Uint8Array(VkSurfaceCapabilitiesFullScreenExclusiveEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fullScreenExclusiveSupported: VkBool32;
  }) {
    const s = VkSurfaceCapabilitiesFullScreenExclusiveEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fullScreenExclusiveSupported !== undefined) s.fullScreenExclusiveSupported = data.fullScreenExclusiveSupported;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fullScreenExclusiveSupported() {
    return this.#view.getUint32(16, LE);
  }
  
  set fullScreenExclusiveSupported(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePresentBarrierFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePresentBarrierFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePresentBarrierFeaturesNV(new Uint8Array(VkPhysicalDevicePresentBarrierFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentBarrier: VkBool32;
  }) {
    const s = VkPhysicalDevicePresentBarrierFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentBarrier !== undefined) s.presentBarrier = data.presentBarrier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentBarrier() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrier(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSurfaceCapabilitiesPresentBarrierNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSurfaceCapabilitiesPresentBarrierNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSurfaceCapabilitiesPresentBarrierNV(new Uint8Array(VkSurfaceCapabilitiesPresentBarrierNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentBarrierSupported: VkBool32;
  }) {
    const s = VkSurfaceCapabilitiesPresentBarrierNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentBarrierSupported !== undefined) s.presentBarrierSupported = data.presentBarrierSupported;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentBarrierSupported() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrierSupported(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSwapchainPresentBarrierCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSwapchainPresentBarrierCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSwapchainPresentBarrierCreateInfoNV(new Uint8Array(VkSwapchainPresentBarrierCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    presentBarrierEnable: VkBool32;
  }) {
    const s = VkSwapchainPresentBarrierCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.presentBarrierEnable !== undefined) s.presentBarrierEnable = data.presentBarrierEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get presentBarrierEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrierEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePerformanceQueryFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePerformanceQueryFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePerformanceQueryFeaturesKHR(new Uint8Array(VkPhysicalDevicePerformanceQueryFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    performanceCounterQueryPools: VkBool32;
    performanceCounterMultipleQueryPools: VkBool32;
  }) {
    const s = VkPhysicalDevicePerformanceQueryFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.performanceCounterQueryPools !== undefined) s.performanceCounterQueryPools = data.performanceCounterQueryPools;
    if (data.performanceCounterMultipleQueryPools !== undefined) s.performanceCounterMultipleQueryPools = data.performanceCounterMultipleQueryPools;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get performanceCounterQueryPools() {
    return this.#view.getUint32(16, LE);
  }
  
  set performanceCounterQueryPools(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get performanceCounterMultipleQueryPools() {
    return this.#view.getUint32(20, LE);
  }
  
  set performanceCounterMultipleQueryPools(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDevicePerformanceQueryPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePerformanceQueryPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePerformanceQueryPropertiesKHR(new Uint8Array(VkPhysicalDevicePerformanceQueryPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    allowCommandBufferQueryCopies: VkBool32;
  }) {
    const s = VkPhysicalDevicePerformanceQueryPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.allowCommandBufferQueryCopies !== undefined) s.allowCommandBufferQueryCopies = data.allowCommandBufferQueryCopies;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get allowCommandBufferQueryCopies() {
    return this.#view.getUint32(16, LE);
  }
  
  set allowCommandBufferQueryCopies(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPerformanceCounterKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceCounterKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceCounterKHR(new Uint8Array(VkPerformanceCounterKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    unit: VkPerformanceCounterUnitKHR;
    scope: VkPerformanceCounterScopeKHR;
    storage: VkPerformanceCounterStorageKHR;
    uuid: number;
  }) {
    const s = VkPerformanceCounterKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.unit !== undefined) s.unit = data.unit;
    if (data.scope !== undefined) s.scope = data.scope;
    if (data.storage !== undefined) s.storage = data.storage;
    if (data.uuid !== undefined) s.uuid = data.uuid;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get unit() {
    return this.#view.getUint32(16, LE);
  }
  
  set unit(value: VkPerformanceCounterUnitKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get scope() {
    return this.#view.getUint32(20, LE);
  }
  
  set scope(value: VkPerformanceCounterScopeKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storage() {
    return this.#view.getUint32(24, LE);
  }
  
  set storage(value: VkPerformanceCounterStorageKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uuid() {
    return this.#view.getUint8(28);
  }
  
  set uuid(value: number) {
    this.#view.setUint8(28, Number(value));
  }
}

export class VkPerformanceCounterDescriptionKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceCounterDescriptionKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceCounterDescriptionKHR(new Uint8Array(VkPerformanceCounterDescriptionKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPerformanceCounterDescriptionFlagsKHR;
    name: number;
    category: number;
    description: number;
  }) {
    const s = VkPerformanceCounterDescriptionKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.name !== undefined) s.name = data.name;
    if (data.category !== undefined) s.category = data.category;
    if (data.description !== undefined) s.description = data.description;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPerformanceCounterDescriptionFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get name() {
    return this.#view.getUint8(20);
  }
  
  set name(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get category() {
    return this.#view.getUint8(21);
  }
  
  set category(value: number) {
    this.#view.setUint8(21, Number(value));
  }
  
  get description() {
    return this.#view.getUint8(22);
  }
  
  set description(value: number) {
    this.#view.setUint8(22, Number(value));
  }
}

export class VkQueryPoolPerformanceCreateInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueryPoolPerformanceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueryPoolPerformanceCreateInfoKHR(new Uint8Array(VkQueryPoolPerformanceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    queueFamilyIndex: number;
    counterIndexCount: number;
    pCounterIndices: Deno.PointerValue;
  }) {
    const s = VkQueryPoolPerformanceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.queueFamilyIndex !== undefined) s.queueFamilyIndex = data.queueFamilyIndex;
    if (data.counterIndexCount !== undefined) s.counterIndexCount = data.counterIndexCount;
    if (data.pCounterIndices !== undefined) s.pCounterIndices = data.pCounterIndices;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get counterIndexCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set counterIndexCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pCounterIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCounterIndices(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkAcquireProfilingLockInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAcquireProfilingLockInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAcquireProfilingLockInfoKHR(new Uint8Array(VkAcquireProfilingLockInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkAcquireProfilingLockFlagsKHR;
    timeout: Deno.PointerValue;
  }) {
    const s = VkAcquireProfilingLockInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.timeout !== undefined) s.timeout = data.timeout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkAcquireProfilingLockFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get timeout() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set timeout(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPerformanceQuerySubmitInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceQuerySubmitInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceQuerySubmitInfoKHR(new Uint8Array(VkPerformanceQuerySubmitInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    counterPassIndex: number;
  }) {
    const s = VkPerformanceQuerySubmitInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.counterPassIndex !== undefined) s.counterPassIndex = data.counterPassIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get counterPassIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set counterPassIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkHeadlessSurfaceCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkHeadlessSurfaceCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkHeadlessSurfaceCreateInfoEXT(new Uint8Array(VkHeadlessSurfaceCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkHeadlessSurfaceCreateFlagsEXT;
  }) {
    const s = VkHeadlessSurfaceCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkHeadlessSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCoverageReductionModeFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCoverageReductionModeFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCoverageReductionModeFeaturesNV(new Uint8Array(VkPhysicalDeviceCoverageReductionModeFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    coverageReductionMode: VkBool32;
  }) {
    const s = VkPhysicalDeviceCoverageReductionModeFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.coverageReductionMode !== undefined) s.coverageReductionMode = data.coverageReductionMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set coverageReductionMode(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineCoverageReductionStateCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCoverageReductionStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCoverageReductionStateCreateInfoNV(new Uint8Array(VkPipelineCoverageReductionStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkPipelineCoverageReductionStateCreateFlagsNV;
    coverageReductionMode: VkCoverageReductionModeNV;
  }) {
    const s = VkPipelineCoverageReductionStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.coverageReductionMode !== undefined) s.coverageReductionMode = data.coverageReductionMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkPipelineCoverageReductionStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageReductionMode(value: VkCoverageReductionModeNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkFramebufferMixedSamplesCombinationNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFramebufferMixedSamplesCombinationNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFramebufferMixedSamplesCombinationNV(new Uint8Array(VkFramebufferMixedSamplesCombinationNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    coverageReductionMode: VkCoverageReductionModeNV;
    rasterizationSamples: VkSampleCountFlagBits;
    depthStencilSamples: VkSampleCountFlags;
    colorSamples: VkSampleCountFlags;
  }) {
    const s = VkFramebufferMixedSamplesCombinationNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.coverageReductionMode !== undefined) s.coverageReductionMode = data.coverageReductionMode;
    if (data.rasterizationSamples !== undefined) s.rasterizationSamples = data.rasterizationSamples;
    if (data.depthStencilSamples !== undefined) s.depthStencilSamples = data.depthStencilSamples;
    if (data.colorSamples !== undefined) s.colorSamples = data.colorSamples;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set coverageReductionMode(value: VkCoverageReductionModeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get depthStencilSamples() {
    return this.#view.getUint32(24, LE);
  }
  
  set depthStencilSamples(value: VkSampleCountFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get colorSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set colorSamples(value: VkSampleCountFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(new Uint8Array(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderIntegerFunctions2: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderIntegerFunctions2 !== undefined) s.shaderIntegerFunctions2 = data.shaderIntegerFunctions2;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderIntegerFunctions2() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderIntegerFunctions2(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPerformanceValueINTEL implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceValueINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceValueINTEL(new Uint8Array(VkPerformanceValueINTEL.size));
  }
  
  static create(data: {
    type: VkPerformanceValueTypeINTEL;
    data: VkPerformanceValueDataINTEL;
  }) {
    const s = VkPerformanceValueINTEL.alloc();
    if (data.type !== undefined) s.type = data.type;
    if (data.data !== undefined) s.data = data.data;
    return s;
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: VkPerformanceValueTypeINTEL) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u32","u64","f32","u32","buffer"]}`);
  }
  
  set data(value: VkPerformanceValueDataINTEL) {
    throw new Error(`Unknown type: {"union":["u32","u64","f32","u32","buffer"]}`);
  }
}

export class VkInitializePerformanceApiInfoINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkInitializePerformanceApiInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkInitializePerformanceApiInfoINTEL(new Uint8Array(VkInitializePerformanceApiInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pUserData?: Deno.PointerValue;
  }) {
    const s = VkInitializePerformanceApiInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pUserData !== undefined) s.pUserData = data.pUserData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pUserData(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkQueryPoolPerformanceQueryCreateInfoINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueryPoolPerformanceQueryCreateInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueryPoolPerformanceQueryCreateInfoINTEL(new Uint8Array(VkQueryPoolPerformanceQueryCreateInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL;
  }) {
    const s = VkQueryPoolPerformanceQueryCreateInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.performanceCountersSampling !== undefined) s.performanceCountersSampling = data.performanceCountersSampling;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get performanceCountersSampling() {
    return this.#view.getUint32(16, LE);
  }
  
  set performanceCountersSampling(value: VkQueryPoolSamplingModeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPerformanceMarkerInfoINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceMarkerInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceMarkerInfoINTEL(new Uint8Array(VkPerformanceMarkerInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    marker: Deno.PointerValue;
  }) {
    const s = VkPerformanceMarkerInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.marker !== undefined) s.marker = data.marker;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get marker() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set marker(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPerformanceStreamMarkerInfoINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceStreamMarkerInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceStreamMarkerInfoINTEL(new Uint8Array(VkPerformanceStreamMarkerInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    marker: number;
  }) {
    const s = VkPerformanceStreamMarkerInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.marker !== undefined) s.marker = data.marker;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get marker() {
    return this.#view.getUint32(16, LE);
  }
  
  set marker(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPerformanceOverrideInfoINTEL implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceOverrideInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceOverrideInfoINTEL(new Uint8Array(VkPerformanceOverrideInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkPerformanceOverrideTypeINTEL;
    enable: VkBool32;
    parameter: Deno.PointerValue;
  }) {
    const s = VkPerformanceOverrideInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.enable !== undefined) s.enable = data.enable;
    if (data.parameter !== undefined) s.parameter = data.parameter;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkPerformanceOverrideTypeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get enable() {
    return this.#view.getUint32(20, LE);
  }
  
  set enable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get parameter() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set parameter(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPerformanceConfigurationAcquireInfoINTEL implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceConfigurationAcquireInfoINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPerformanceConfigurationAcquireInfoINTEL(new Uint8Array(VkPerformanceConfigurationAcquireInfoINTEL.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkPerformanceConfigurationTypeINTEL;
  }) {
    const s = VkPerformanceConfigurationAcquireInfoINTEL.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkPerformanceConfigurationTypeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderClockFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderClockFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderClockFeaturesKHR(new Uint8Array(VkPhysicalDeviceShaderClockFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderSubgroupClock: VkBool32;
    shaderDeviceClock: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderClockFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderSubgroupClock !== undefined) s.shaderSubgroupClock = data.shaderSubgroupClock;
    if (data.shaderDeviceClock !== undefined) s.shaderDeviceClock = data.shaderDeviceClock;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderSubgroupClock() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupClock(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderDeviceClock() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderDeviceClock(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceIndexTypeUint8FeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceIndexTypeUint8FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceIndexTypeUint8FeaturesEXT(new Uint8Array(VkPhysicalDeviceIndexTypeUint8FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    indexTypeUint8: VkBool32;
  }) {
    const s = VkPhysicalDeviceIndexTypeUint8FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.indexTypeUint8 !== undefined) s.indexTypeUint8 = data.indexTypeUint8;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get indexTypeUint8() {
    return this.#view.getUint32(16, LE);
  }
  
  set indexTypeUint8(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderSMBuiltinsPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(new Uint8Array(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderSMCount: number;
    shaderWarpsPerSM: number;
  }) {
    const s = VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderSMCount !== undefined) s.shaderSMCount = data.shaderSMCount;
    if (data.shaderWarpsPerSM !== undefined) s.shaderWarpsPerSM = data.shaderWarpsPerSM;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderSMCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSMCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderWarpsPerSM() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderWarpsPerSM(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderSMBuiltinsFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(new Uint8Array(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderSMBuiltins: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderSMBuiltins !== undefined) s.shaderSMBuiltins = data.shaderSMBuiltins;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderSMBuiltins() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSMBuiltins(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(new Uint8Array(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentShaderSampleInterlock: VkBool32;
    fragmentShaderPixelInterlock: VkBool32;
    fragmentShaderShadingRateInterlock: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentShaderSampleInterlock !== undefined) s.fragmentShaderSampleInterlock = data.fragmentShaderSampleInterlock;
    if (data.fragmentShaderPixelInterlock !== undefined) s.fragmentShaderPixelInterlock = data.fragmentShaderPixelInterlock;
    if (data.fragmentShaderShadingRateInterlock !== undefined) s.fragmentShaderShadingRateInterlock = data.fragmentShaderShadingRateInterlock;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentShaderSampleInterlock() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShaderSampleInterlock(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentShaderPixelInterlock() {
    return this.#view.getUint32(20, LE);
  }
  
  set fragmentShaderPixelInterlock(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get fragmentShaderShadingRateInterlock() {
    return this.#view.getUint32(24, LE);
  }
  
  set fragmentShaderShadingRateInterlock(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(new Uint8Array(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    separateDepthStencilLayouts: VkBool32;
  }) {
    const s = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.separateDepthStencilLayouts !== undefined) s.separateDepthStencilLayouts = data.separateDepthStencilLayouts;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get separateDepthStencilLayouts() {
    return this.#view.getUint32(16, LE);
  }
  
  set separateDepthStencilLayouts(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkAttachmentReferenceStencilLayout implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentReferenceStencilLayout.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentReferenceStencilLayout(new Uint8Array(VkAttachmentReferenceStencilLayout.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stencilLayout: VkImageLayout;
  }) {
    const s = VkAttachmentReferenceStencilLayout.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stencilLayout !== undefined) s.stencilLayout = data.stencilLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stencilLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilLayout(value: VkImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(new Uint8Array(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    primitiveTopologyListRestart: VkBool32;
    primitiveTopologyPatchListRestart: VkBool32;
  }) {
    const s = VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.primitiveTopologyListRestart !== undefined) s.primitiveTopologyListRestart = data.primitiveTopologyListRestart;
    if (data.primitiveTopologyPatchListRestart !== undefined) s.primitiveTopologyPatchListRestart = data.primitiveTopologyPatchListRestart;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get primitiveTopologyListRestart() {
    return this.#view.getUint32(16, LE);
  }
  
  set primitiveTopologyListRestart(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitiveTopologyPatchListRestart() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitiveTopologyPatchListRestart(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkAttachmentDescriptionStencilLayout implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentDescriptionStencilLayout.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentDescriptionStencilLayout(new Uint8Array(VkAttachmentDescriptionStencilLayout.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stencilInitialLayout: VkImageLayout;
    stencilFinalLayout: VkImageLayout;
  }) {
    const s = VkAttachmentDescriptionStencilLayout.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stencilInitialLayout !== undefined) s.stencilInitialLayout = data.stencilInitialLayout;
    if (data.stencilFinalLayout !== undefined) s.stencilFinalLayout = data.stencilFinalLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stencilInitialLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilInitialLayout(value: VkImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilFinalLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilFinalLayout(value: VkImageLayout) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(new Uint8Array(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineExecutableInfo: VkBool32;
  }) {
    const s = VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineExecutableInfo !== undefined) s.pipelineExecutableInfo = data.pipelineExecutableInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineExecutableInfo() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineExecutableInfo(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineInfoKHR(new Uint8Array(VkPipelineInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipeline: VkPipeline;
  }) {
    const s = VkPipelineInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipeline !== undefined) s.pipeline = data.pipeline;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pipeline(value: VkPipeline) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPipelineExecutablePropertiesKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineExecutablePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineExecutablePropertiesKHR(new Uint8Array(VkPipelineExecutablePropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stages: VkShaderStageFlags;
    name: number;
    description: number;
    subgroupSize: number;
  }) {
    const s = VkPipelineExecutablePropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stages !== undefined) s.stages = data.stages;
    if (data.name !== undefined) s.name = data.name;
    if (data.description !== undefined) s.description = data.description;
    if (data.subgroupSize !== undefined) s.subgroupSize = data.subgroupSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stages() {
    return this.#view.getUint32(16, LE);
  }
  
  set stages(value: VkShaderStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get name() {
    return this.#view.getUint8(20);
  }
  
  set name(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get description() {
    return this.#view.getUint8(21);
  }
  
  set description(value: number) {
    this.#view.setUint8(21, Number(value));
  }
  
  get subgroupSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPipelineExecutableInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineExecutableInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineExecutableInfoKHR(new Uint8Array(VkPipelineExecutableInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipeline: VkPipeline;
    executableIndex: number;
  }) {
    const s = VkPipelineExecutableInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipeline !== undefined) s.pipeline = data.pipeline;
    if (data.executableIndex !== undefined) s.executableIndex = data.executableIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pipeline(value: VkPipeline) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get executableIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set executableIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPipelineExecutableStatisticKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineExecutableStatisticKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineExecutableStatisticKHR(new Uint8Array(VkPipelineExecutableStatisticKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    name: number;
    description: number;
    format: VkPipelineExecutableStatisticFormatKHR;
    value: VkPipelineExecutableStatisticValueKHR;
  }) {
    const s = VkPipelineExecutableStatisticKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.name !== undefined) s.name = data.name;
    if (data.description !== undefined) s.description = data.description;
    if (data.format !== undefined) s.format = data.format;
    if (data.value !== undefined) s.value = data.value;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getUint8(16);
  }
  
  set name(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get description() {
    return this.#view.getUint8(17);
  }
  
  set description(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get format() {
    return this.#view.getUint32(20, LE);
  }
  
  set format(value: VkPipelineExecutableStatisticFormatKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get value() {
    throw new Error(`Unknown type: {"union":["u32","i64","u64","f64"]}`);
  }
  
  set value(value: VkPipelineExecutableStatisticValueKHR) {
    throw new Error(`Unknown type: {"union":["u32","i64","u64","f64"]}`);
  }
}

export class VkPipelineExecutableInternalRepresentationKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineExecutableInternalRepresentationKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineExecutableInternalRepresentationKHR(new Uint8Array(VkPipelineExecutableInternalRepresentationKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    name: number;
    description: number;
    isText: VkBool32;
    dataSize: Deno.PointerValue;
    pData?: Deno.PointerValue;
  }) {
    const s = VkPipelineExecutableInternalRepresentationKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.name !== undefined) s.name = data.name;
    if (data.description !== undefined) s.description = data.description;
    if (data.isText !== undefined) s.isText = data.isText;
    if (data.dataSize !== undefined) s.dataSize = data.dataSize;
    if (data.pData !== undefined) s.pData = data.pData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getUint8(16);
  }
  
  set name(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get description() {
    return this.#view.getUint8(17);
  }
  
  set description(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get isText() {
    return this.#view.getUint32(20, LE);
  }
  
  set isText(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pData(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(new Uint8Array(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderDemoteToHelperInvocation: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderDemoteToHelperInvocation !== undefined) s.shaderDemoteToHelperInvocation = data.shaderDemoteToHelperInvocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderDemoteToHelperInvocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderDemoteToHelperInvocation(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(new Uint8Array(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    texelBufferAlignment: VkBool32;
  }) {
    const s = VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.texelBufferAlignment !== undefined) s.texelBufferAlignment = data.texelBufferAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get texelBufferAlignment() {
    return this.#view.getUint32(16, LE);
  }
  
  set texelBufferAlignment(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceTexelBufferAlignmentProperties implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTexelBufferAlignmentProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTexelBufferAlignmentProperties(new Uint8Array(VkPhysicalDeviceTexelBufferAlignmentProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    storageTexelBufferOffsetAlignmentBytes: VkDeviceSize;
    storageTexelBufferOffsetSingleTexelAlignment: VkBool32;
    uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize;
    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32;
  }) {
    const s = VkPhysicalDeviceTexelBufferAlignmentProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.storageTexelBufferOffsetAlignmentBytes !== undefined) s.storageTexelBufferOffsetAlignmentBytes = data.storageTexelBufferOffsetAlignmentBytes;
    if (data.storageTexelBufferOffsetSingleTexelAlignment !== undefined) s.storageTexelBufferOffsetSingleTexelAlignment = data.storageTexelBufferOffsetSingleTexelAlignment;
    if (data.uniformTexelBufferOffsetAlignmentBytes !== undefined) s.uniformTexelBufferOffsetAlignmentBytes = data.uniformTexelBufferOffsetAlignmentBytes;
    if (data.uniformTexelBufferOffsetSingleTexelAlignment !== undefined) s.uniformTexelBufferOffsetSingleTexelAlignment = data.uniformTexelBufferOffsetSingleTexelAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get storageTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set storageTexelBufferOffsetAlignmentBytes(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get storageTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(24, LE);
  }
  
  set storageTexelBufferOffsetSingleTexelAlignment(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uniformTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set uniformTexelBufferOffsetAlignmentBytes(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get uniformTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set uniformTexelBufferOffsetSingleTexelAlignment(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkPhysicalDeviceSubgroupSizeControlFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubgroupSizeControlFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubgroupSizeControlFeatures(new Uint8Array(VkPhysicalDeviceSubgroupSizeControlFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subgroupSizeControl: VkBool32;
    computeFullSubgroups: VkBool32;
  }) {
    const s = VkPhysicalDeviceSubgroupSizeControlFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subgroupSizeControl !== undefined) s.subgroupSizeControl = data.subgroupSizeControl;
    if (data.computeFullSubgroups !== undefined) s.computeFullSubgroups = data.computeFullSubgroups;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subgroupSizeControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set subgroupSizeControl(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get computeFullSubgroups() {
    return this.#view.getUint32(20, LE);
  }
  
  set computeFullSubgroups(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceSubgroupSizeControlProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubgroupSizeControlProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubgroupSizeControlProperties(new Uint8Array(VkPhysicalDeviceSubgroupSizeControlProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minSubgroupSize: number;
    maxSubgroupSize: number;
    maxComputeWorkgroupSubgroups: number;
    requiredSubgroupSizeStages: VkShaderStageFlags;
  }) {
    const s = VkPhysicalDeviceSubgroupSizeControlProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minSubgroupSize !== undefined) s.minSubgroupSize = data.minSubgroupSize;
    if (data.maxSubgroupSize !== undefined) s.maxSubgroupSize = data.maxSubgroupSize;
    if (data.maxComputeWorkgroupSubgroups !== undefined) s.maxComputeWorkgroupSubgroups = data.maxComputeWorkgroupSubgroups;
    if (data.requiredSubgroupSizeStages !== undefined) s.requiredSubgroupSizeStages = data.requiredSubgroupSizeStages;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set minSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSubgroupSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSubgroupSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxComputeWorkgroupSubgroups() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxComputeWorkgroupSubgroups(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get requiredSubgroupSizeStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set requiredSubgroupSizeStages(value: VkShaderStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPipelineShaderStageRequiredSubgroupSizeCreateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(new Uint8Array(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    requiredSubgroupSize: number;
  }) {
    const s = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.requiredSubgroupSize !== undefined) s.requiredSubgroupSize = data.requiredSubgroupSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get requiredSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set requiredSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSubpassShadingPipelineCreateInfoHUAWEI implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassShadingPipelineCreateInfoHUAWEI.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassShadingPipelineCreateInfoHUAWEI(new Uint8Array(VkSubpassShadingPipelineCreateInfoHUAWEI.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    renderPass: VkRenderPass;
    subpass: number;
  }) {
    const s = VkSubpassShadingPipelineCreateInfoHUAWEI.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.renderPass !== undefined) s.renderPass = data.renderPass;
    if (data.subpass !== undefined) s.subpass = data.subpass;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: VkRenderPass) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(24, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceSubpassShadingPropertiesHUAWEI implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(new Uint8Array(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxSubpassShadingWorkgroupSizeAspectRatio: number;
  }) {
    const s = VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxSubpassShadingWorkgroupSizeAspectRatio !== undefined) s.maxSubpassShadingWorkgroupSizeAspectRatio = data.maxSubpassShadingWorkgroupSizeAspectRatio;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxSubpassShadingWorkgroupSizeAspectRatio() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxSubpassShadingWorkgroupSizeAspectRatio(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMemoryOpaqueCaptureAddressAllocateInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryOpaqueCaptureAddressAllocateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryOpaqueCaptureAddressAllocateInfo(new Uint8Array(VkMemoryOpaqueCaptureAddressAllocateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    opaqueCaptureAddress: Deno.PointerValue;
  }) {
    const s = VkMemoryOpaqueCaptureAddressAllocateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.opaqueCaptureAddress !== undefined) s.opaqueCaptureAddress = data.opaqueCaptureAddress;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get opaqueCaptureAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureAddress(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDeviceMemoryOpaqueCaptureAddressInfo implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceMemoryOpaqueCaptureAddressInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceMemoryOpaqueCaptureAddressInfo(new Uint8Array(VkDeviceMemoryOpaqueCaptureAddressInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
  }) {
    const s = VkDeviceMemoryOpaqueCaptureAddressInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceLineRasterizationFeaturesEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceLineRasterizationFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceLineRasterizationFeaturesEXT(new Uint8Array(VkPhysicalDeviceLineRasterizationFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rectangularLines: VkBool32;
    bresenhamLines: VkBool32;
    smoothLines: VkBool32;
    stippledRectangularLines: VkBool32;
    stippledBresenhamLines: VkBool32;
    stippledSmoothLines: VkBool32;
  }) {
    const s = VkPhysicalDeviceLineRasterizationFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rectangularLines !== undefined) s.rectangularLines = data.rectangularLines;
    if (data.bresenhamLines !== undefined) s.bresenhamLines = data.bresenhamLines;
    if (data.smoothLines !== undefined) s.smoothLines = data.smoothLines;
    if (data.stippledRectangularLines !== undefined) s.stippledRectangularLines = data.stippledRectangularLines;
    if (data.stippledBresenhamLines !== undefined) s.stippledBresenhamLines = data.stippledBresenhamLines;
    if (data.stippledSmoothLines !== undefined) s.stippledSmoothLines = data.stippledSmoothLines;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rectangularLines() {
    return this.#view.getUint32(16, LE);
  }
  
  set rectangularLines(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bresenhamLines() {
    return this.#view.getUint32(20, LE);
  }
  
  set bresenhamLines(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get smoothLines() {
    return this.#view.getUint32(24, LE);
  }
  
  set smoothLines(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get stippledRectangularLines() {
    return this.#view.getUint32(28, LE);
  }
  
  set stippledRectangularLines(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get stippledBresenhamLines() {
    return this.#view.getUint32(32, LE);
  }
  
  set stippledBresenhamLines(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stippledSmoothLines() {
    return this.#view.getUint32(36, LE);
  }
  
  set stippledSmoothLines(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export class VkPhysicalDeviceLineRasterizationPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceLineRasterizationPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceLineRasterizationPropertiesEXT(new Uint8Array(VkPhysicalDeviceLineRasterizationPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    lineSubPixelPrecisionBits: number;
  }) {
    const s = VkPhysicalDeviceLineRasterizationPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.lineSubPixelPrecisionBits !== undefined) s.lineSubPixelPrecisionBits = data.lineSubPixelPrecisionBits;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get lineSubPixelPrecisionBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set lineSubPixelPrecisionBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineRasterizationLineStateCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationLineStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationLineStateCreateInfoEXT(new Uint8Array(VkPipelineRasterizationLineStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    lineRasterizationMode: VkLineRasterizationModeEXT;
    stippledLineEnable: VkBool32;
    lineStippleFactor: number;
    lineStipplePattern: number;
  }) {
    const s = VkPipelineRasterizationLineStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.lineRasterizationMode !== undefined) s.lineRasterizationMode = data.lineRasterizationMode;
    if (data.stippledLineEnable !== undefined) s.stippledLineEnable = data.stippledLineEnable;
    if (data.lineStippleFactor !== undefined) s.lineStippleFactor = data.lineStippleFactor;
    if (data.lineStipplePattern !== undefined) s.lineStipplePattern = data.lineStipplePattern;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get lineRasterizationMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set lineRasterizationMode(value: VkLineRasterizationModeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stippledLineEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set stippledLineEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get lineStippleFactor() {
    return this.#view.getUint32(24, LE);
  }
  
  set lineStippleFactor(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get lineStipplePattern() {
    return this.#view.getUint16(28, LE);
  }
  
  set lineStipplePattern(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
}

export class VkPhysicalDevicePipelineCreationCacheControlFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelineCreationCacheControlFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelineCreationCacheControlFeatures(new Uint8Array(VkPhysicalDevicePipelineCreationCacheControlFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineCreationCacheControl: VkBool32;
  }) {
    const s = VkPhysicalDevicePipelineCreationCacheControlFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineCreationCacheControl !== undefined) s.pipelineCreationCacheControl = data.pipelineCreationCacheControl;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineCreationCacheControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineCreationCacheControl(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkan11Features implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan11Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan11Features(new Uint8Array(VkPhysicalDeviceVulkan11Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    storageBuffer16BitAccess: VkBool32;
    uniformAndStorageBuffer16BitAccess: VkBool32;
    storagePushConstant16: VkBool32;
    storageInputOutput16: VkBool32;
    multiview: VkBool32;
    multiviewGeometryShader: VkBool32;
    multiviewTessellationShader: VkBool32;
    variablePointersStorageBuffer: VkBool32;
    variablePointers: VkBool32;
    protectedMemory: VkBool32;
    samplerYcbcrConversion: VkBool32;
    shaderDrawParameters: VkBool32;
  }) {
    const s = VkPhysicalDeviceVulkan11Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.storageBuffer16BitAccess !== undefined) s.storageBuffer16BitAccess = data.storageBuffer16BitAccess;
    if (data.uniformAndStorageBuffer16BitAccess !== undefined) s.uniformAndStorageBuffer16BitAccess = data.uniformAndStorageBuffer16BitAccess;
    if (data.storagePushConstant16 !== undefined) s.storagePushConstant16 = data.storagePushConstant16;
    if (data.storageInputOutput16 !== undefined) s.storageInputOutput16 = data.storageInputOutput16;
    if (data.multiview !== undefined) s.multiview = data.multiview;
    if (data.multiviewGeometryShader !== undefined) s.multiviewGeometryShader = data.multiviewGeometryShader;
    if (data.multiviewTessellationShader !== undefined) s.multiviewTessellationShader = data.multiviewTessellationShader;
    if (data.variablePointersStorageBuffer !== undefined) s.variablePointersStorageBuffer = data.variablePointersStorageBuffer;
    if (data.variablePointers !== undefined) s.variablePointers = data.variablePointers;
    if (data.protectedMemory !== undefined) s.protectedMemory = data.protectedMemory;
    if (data.samplerYcbcrConversion !== undefined) s.samplerYcbcrConversion = data.samplerYcbcrConversion;
    if (data.shaderDrawParameters !== undefined) s.shaderDrawParameters = data.shaderDrawParameters;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get storageBuffer16BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer16BitAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer16BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer16BitAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant16() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant16(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get storageInputOutput16() {
    return this.#view.getUint32(28, LE);
  }
  
  set storageInputOutput16(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get multiview() {
    return this.#view.getUint32(32, LE);
  }
  
  set multiview(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multiviewGeometryShader() {
    return this.#view.getUint32(36, LE);
  }
  
  set multiviewGeometryShader(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get multiviewTessellationShader() {
    return this.#view.getUint32(40, LE);
  }
  
  set multiviewTessellationShader(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get variablePointersStorageBuffer() {
    return this.#view.getUint32(44, LE);
  }
  
  set variablePointersStorageBuffer(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get variablePointers() {
    return this.#view.getUint32(48, LE);
  }
  
  set variablePointers(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get protectedMemory() {
    return this.#view.getUint32(52, LE);
  }
  
  set protectedMemory(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get samplerYcbcrConversion() {
    return this.#view.getUint32(56, LE);
  }
  
  set samplerYcbcrConversion(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderDrawParameters() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderDrawParameters(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkan11Properties implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan11Properties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan11Properties(new Uint8Array(VkPhysicalDeviceVulkan11Properties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceUUID: number;
    driverUUID: number;
    deviceLUID: number;
    deviceNodeMask: number;
    deviceLUIDValid: VkBool32;
    subgroupSize: number;
    subgroupSupportedStages: VkShaderStageFlags;
    subgroupSupportedOperations: VkSubgroupFeatureFlags;
    subgroupQuadOperationsInAllStages: VkBool32;
    pointClippingBehavior: VkPointClippingBehavior;
    maxMultiviewViewCount: number;
    maxMultiviewInstanceIndex: number;
    protectedNoFault: VkBool32;
    maxPerSetDescriptors: number;
    maxMemoryAllocationSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceVulkan11Properties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceUUID !== undefined) s.deviceUUID = data.deviceUUID;
    if (data.driverUUID !== undefined) s.driverUUID = data.driverUUID;
    if (data.deviceLUID !== undefined) s.deviceLUID = data.deviceLUID;
    if (data.deviceNodeMask !== undefined) s.deviceNodeMask = data.deviceNodeMask;
    if (data.deviceLUIDValid !== undefined) s.deviceLUIDValid = data.deviceLUIDValid;
    if (data.subgroupSize !== undefined) s.subgroupSize = data.subgroupSize;
    if (data.subgroupSupportedStages !== undefined) s.subgroupSupportedStages = data.subgroupSupportedStages;
    if (data.subgroupSupportedOperations !== undefined) s.subgroupSupportedOperations = data.subgroupSupportedOperations;
    if (data.subgroupQuadOperationsInAllStages !== undefined) s.subgroupQuadOperationsInAllStages = data.subgroupQuadOperationsInAllStages;
    if (data.pointClippingBehavior !== undefined) s.pointClippingBehavior = data.pointClippingBehavior;
    if (data.maxMultiviewViewCount !== undefined) s.maxMultiviewViewCount = data.maxMultiviewViewCount;
    if (data.maxMultiviewInstanceIndex !== undefined) s.maxMultiviewInstanceIndex = data.maxMultiviewInstanceIndex;
    if (data.protectedNoFault !== undefined) s.protectedNoFault = data.protectedNoFault;
    if (data.maxPerSetDescriptors !== undefined) s.maxPerSetDescriptors = data.maxPerSetDescriptors;
    if (data.maxMemoryAllocationSize !== undefined) s.maxMemoryAllocationSize = data.maxMemoryAllocationSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceUUID() {
    return this.#view.getUint8(16);
  }
  
  set deviceUUID(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get driverUUID() {
    return this.#view.getUint8(17);
  }
  
  set driverUUID(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get deviceLUID() {
    return this.#view.getUint8(18);
  }
  
  set deviceLUID(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get deviceNodeMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceNodeMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get deviceLUIDValid() {
    return this.#view.getUint32(24, LE);
  }
  
  set deviceLUIDValid(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get subgroupSize() {
    return this.#view.getUint32(28, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get subgroupSupportedStages() {
    return this.#view.getUint32(32, LE);
  }
  
  set subgroupSupportedStages(value: VkShaderStageFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get subgroupSupportedOperations() {
    return this.#view.getUint32(36, LE);
  }
  
  set subgroupSupportedOperations(value: VkSubgroupFeatureFlags) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get subgroupQuadOperationsInAllStages() {
    return this.#view.getUint32(40, LE);
  }
  
  set subgroupQuadOperationsInAllStages(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pointClippingBehavior() {
    return this.#view.getUint32(44, LE);
  }
  
  set pointClippingBehavior(value: VkPointClippingBehavior) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxMultiviewViewCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxMultiviewViewCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxMultiviewInstanceIndex() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxMultiviewInstanceIndex(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get protectedNoFault() {
    return this.#view.getUint32(56, LE);
  }
  
  set protectedNoFault(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxPerSetDescriptors() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxPerSetDescriptors(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxMemoryAllocationSize() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set maxMemoryAllocationSize(value: VkDeviceSize) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceVulkan12Features implements IVkStructure {
  static size = 208;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan12Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan12Features(new Uint8Array(VkPhysicalDeviceVulkan12Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    samplerMirrorClampToEdge: VkBool32;
    drawIndirectCount: VkBool32;
    storageBuffer8BitAccess: VkBool32;
    uniformAndStorageBuffer8BitAccess: VkBool32;
    storagePushConstant8: VkBool32;
    shaderBufferInt64Atomics: VkBool32;
    shaderSharedInt64Atomics: VkBool32;
    shaderFloat16: VkBool32;
    shaderInt8: VkBool32;
    descriptorIndexing: VkBool32;
    shaderInputAttachmentArrayDynamicIndexing: VkBool32;
    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32;
    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32;
    shaderUniformBufferArrayNonUniformIndexing: VkBool32;
    shaderSampledImageArrayNonUniformIndexing: VkBool32;
    shaderStorageBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageImageArrayNonUniformIndexing: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexing: VkBool32;
    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32;
    descriptorBindingUniformBufferUpdateAfterBind: VkBool32;
    descriptorBindingSampledImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageBufferUpdateAfterBind: VkBool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingUpdateUnusedWhilePending: VkBool32;
    descriptorBindingPartiallyBound: VkBool32;
    descriptorBindingVariableDescriptorCount: VkBool32;
    runtimeDescriptorArray: VkBool32;
    samplerFilterMinmax: VkBool32;
    scalarBlockLayout: VkBool32;
    imagelessFramebuffer: VkBool32;
    uniformBufferStandardLayout: VkBool32;
    shaderSubgroupExtendedTypes: VkBool32;
    separateDepthStencilLayouts: VkBool32;
    hostQueryReset: VkBool32;
    timelineSemaphore: VkBool32;
    bufferDeviceAddress: VkBool32;
    bufferDeviceAddressCaptureReplay: VkBool32;
    bufferDeviceAddressMultiDevice: VkBool32;
    vulkanMemoryModel: VkBool32;
    vulkanMemoryModelDeviceScope: VkBool32;
    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32;
    shaderOutputViewportIndex: VkBool32;
    shaderOutputLayer: VkBool32;
    subgroupBroadcastDynamicId: VkBool32;
  }) {
    const s = VkPhysicalDeviceVulkan12Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.samplerMirrorClampToEdge !== undefined) s.samplerMirrorClampToEdge = data.samplerMirrorClampToEdge;
    if (data.drawIndirectCount !== undefined) s.drawIndirectCount = data.drawIndirectCount;
    if (data.storageBuffer8BitAccess !== undefined) s.storageBuffer8BitAccess = data.storageBuffer8BitAccess;
    if (data.uniformAndStorageBuffer8BitAccess !== undefined) s.uniformAndStorageBuffer8BitAccess = data.uniformAndStorageBuffer8BitAccess;
    if (data.storagePushConstant8 !== undefined) s.storagePushConstant8 = data.storagePushConstant8;
    if (data.shaderBufferInt64Atomics !== undefined) s.shaderBufferInt64Atomics = data.shaderBufferInt64Atomics;
    if (data.shaderSharedInt64Atomics !== undefined) s.shaderSharedInt64Atomics = data.shaderSharedInt64Atomics;
    if (data.shaderFloat16 !== undefined) s.shaderFloat16 = data.shaderFloat16;
    if (data.shaderInt8 !== undefined) s.shaderInt8 = data.shaderInt8;
    if (data.descriptorIndexing !== undefined) s.descriptorIndexing = data.descriptorIndexing;
    if (data.shaderInputAttachmentArrayDynamicIndexing !== undefined) s.shaderInputAttachmentArrayDynamicIndexing = data.shaderInputAttachmentArrayDynamicIndexing;
    if (data.shaderUniformTexelBufferArrayDynamicIndexing !== undefined) s.shaderUniformTexelBufferArrayDynamicIndexing = data.shaderUniformTexelBufferArrayDynamicIndexing;
    if (data.shaderStorageTexelBufferArrayDynamicIndexing !== undefined) s.shaderStorageTexelBufferArrayDynamicIndexing = data.shaderStorageTexelBufferArrayDynamicIndexing;
    if (data.shaderUniformBufferArrayNonUniformIndexing !== undefined) s.shaderUniformBufferArrayNonUniformIndexing = data.shaderUniformBufferArrayNonUniformIndexing;
    if (data.shaderSampledImageArrayNonUniformIndexing !== undefined) s.shaderSampledImageArrayNonUniformIndexing = data.shaderSampledImageArrayNonUniformIndexing;
    if (data.shaderStorageBufferArrayNonUniformIndexing !== undefined) s.shaderStorageBufferArrayNonUniformIndexing = data.shaderStorageBufferArrayNonUniformIndexing;
    if (data.shaderStorageImageArrayNonUniformIndexing !== undefined) s.shaderStorageImageArrayNonUniformIndexing = data.shaderStorageImageArrayNonUniformIndexing;
    if (data.shaderInputAttachmentArrayNonUniformIndexing !== undefined) s.shaderInputAttachmentArrayNonUniformIndexing = data.shaderInputAttachmentArrayNonUniformIndexing;
    if (data.shaderUniformTexelBufferArrayNonUniformIndexing !== undefined) s.shaderUniformTexelBufferArrayNonUniformIndexing = data.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (data.shaderStorageTexelBufferArrayNonUniformIndexing !== undefined) s.shaderStorageTexelBufferArrayNonUniformIndexing = data.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (data.descriptorBindingUniformBufferUpdateAfterBind !== undefined) s.descriptorBindingUniformBufferUpdateAfterBind = data.descriptorBindingUniformBufferUpdateAfterBind;
    if (data.descriptorBindingSampledImageUpdateAfterBind !== undefined) s.descriptorBindingSampledImageUpdateAfterBind = data.descriptorBindingSampledImageUpdateAfterBind;
    if (data.descriptorBindingStorageImageUpdateAfterBind !== undefined) s.descriptorBindingStorageImageUpdateAfterBind = data.descriptorBindingStorageImageUpdateAfterBind;
    if (data.descriptorBindingStorageBufferUpdateAfterBind !== undefined) s.descriptorBindingStorageBufferUpdateAfterBind = data.descriptorBindingStorageBufferUpdateAfterBind;
    if (data.descriptorBindingUniformTexelBufferUpdateAfterBind !== undefined) s.descriptorBindingUniformTexelBufferUpdateAfterBind = data.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (data.descriptorBindingStorageTexelBufferUpdateAfterBind !== undefined) s.descriptorBindingStorageTexelBufferUpdateAfterBind = data.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (data.descriptorBindingUpdateUnusedWhilePending !== undefined) s.descriptorBindingUpdateUnusedWhilePending = data.descriptorBindingUpdateUnusedWhilePending;
    if (data.descriptorBindingPartiallyBound !== undefined) s.descriptorBindingPartiallyBound = data.descriptorBindingPartiallyBound;
    if (data.descriptorBindingVariableDescriptorCount !== undefined) s.descriptorBindingVariableDescriptorCount = data.descriptorBindingVariableDescriptorCount;
    if (data.runtimeDescriptorArray !== undefined) s.runtimeDescriptorArray = data.runtimeDescriptorArray;
    if (data.samplerFilterMinmax !== undefined) s.samplerFilterMinmax = data.samplerFilterMinmax;
    if (data.scalarBlockLayout !== undefined) s.scalarBlockLayout = data.scalarBlockLayout;
    if (data.imagelessFramebuffer !== undefined) s.imagelessFramebuffer = data.imagelessFramebuffer;
    if (data.uniformBufferStandardLayout !== undefined) s.uniformBufferStandardLayout = data.uniformBufferStandardLayout;
    if (data.shaderSubgroupExtendedTypes !== undefined) s.shaderSubgroupExtendedTypes = data.shaderSubgroupExtendedTypes;
    if (data.separateDepthStencilLayouts !== undefined) s.separateDepthStencilLayouts = data.separateDepthStencilLayouts;
    if (data.hostQueryReset !== undefined) s.hostQueryReset = data.hostQueryReset;
    if (data.timelineSemaphore !== undefined) s.timelineSemaphore = data.timelineSemaphore;
    if (data.bufferDeviceAddress !== undefined) s.bufferDeviceAddress = data.bufferDeviceAddress;
    if (data.bufferDeviceAddressCaptureReplay !== undefined) s.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
    if (data.bufferDeviceAddressMultiDevice !== undefined) s.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
    if (data.vulkanMemoryModel !== undefined) s.vulkanMemoryModel = data.vulkanMemoryModel;
    if (data.vulkanMemoryModelDeviceScope !== undefined) s.vulkanMemoryModelDeviceScope = data.vulkanMemoryModelDeviceScope;
    if (data.vulkanMemoryModelAvailabilityVisibilityChains !== undefined) s.vulkanMemoryModelAvailabilityVisibilityChains = data.vulkanMemoryModelAvailabilityVisibilityChains;
    if (data.shaderOutputViewportIndex !== undefined) s.shaderOutputViewportIndex = data.shaderOutputViewportIndex;
    if (data.shaderOutputLayer !== undefined) s.shaderOutputLayer = data.shaderOutputLayer;
    if (data.subgroupBroadcastDynamicId !== undefined) s.subgroupBroadcastDynamicId = data.subgroupBroadcastDynamicId;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get samplerMirrorClampToEdge() {
    return this.#view.getUint32(16, LE);
  }
  
  set samplerMirrorClampToEdge(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get drawIndirectCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set drawIndirectCount(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storageBuffer8BitAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set storageBuffer8BitAccess(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uniformAndStorageBuffer8BitAccess() {
    return this.#view.getUint32(28, LE);
  }
  
  set uniformAndStorageBuffer8BitAccess(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get storagePushConstant8() {
    return this.#view.getUint32(32, LE);
  }
  
  set storagePushConstant8(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderBufferInt64Atomics() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderBufferInt64Atomics(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedInt64Atomics() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedInt64Atomics(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderFloat16() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderFloat16(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderInt8() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderInt8(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get descriptorIndexing() {
    return this.#view.getUint32(52, LE);
  }
  
  set descriptorIndexing(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayDynamicIndexing() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderInputAttachmentArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderUniformTexelBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(64, LE);
  }
  
  set shaderStorageTexelBufferArrayDynamicIndexing(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexing() {
    return this.#view.getUint32(72, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(76, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexing() {
    return this.#view.getUint32(80, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexing() {
    return this.#view.getUint32(84, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(88, LE);
  }
  
  set shaderUniformTexelBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(92, LE);
  }
  
  set shaderStorageTexelBufferArrayNonUniformIndexing(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get descriptorBindingUniformBufferUpdateAfterBind() {
    return this.#view.getUint32(96, LE);
  }
  
  set descriptorBindingUniformBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get descriptorBindingSampledImageUpdateAfterBind() {
    return this.#view.getUint32(100, LE);
  }
  
  set descriptorBindingSampledImageUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get descriptorBindingStorageImageUpdateAfterBind() {
    return this.#view.getUint32(104, LE);
  }
  
  set descriptorBindingStorageImageUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get descriptorBindingStorageBufferUpdateAfterBind() {
    return this.#view.getUint32(108, LE);
  }
  
  set descriptorBindingStorageBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get descriptorBindingUniformTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(112, LE);
  }
  
  set descriptorBindingUniformTexelBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get descriptorBindingStorageTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(116, LE);
  }
  
  set descriptorBindingStorageTexelBufferUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get descriptorBindingUpdateUnusedWhilePending() {
    return this.#view.getUint32(120, LE);
  }
  
  set descriptorBindingUpdateUnusedWhilePending(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get descriptorBindingPartiallyBound() {
    return this.#view.getUint32(124, LE);
  }
  
  set descriptorBindingPartiallyBound(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get descriptorBindingVariableDescriptorCount() {
    return this.#view.getUint32(128, LE);
  }
  
  set descriptorBindingVariableDescriptorCount(value: VkBool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get runtimeDescriptorArray() {
    return this.#view.getUint32(132, LE);
  }
  
  set runtimeDescriptorArray(value: VkBool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get samplerFilterMinmax() {
    return this.#view.getUint32(136, LE);
  }
  
  set samplerFilterMinmax(value: VkBool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get scalarBlockLayout() {
    return this.#view.getUint32(140, LE);
  }
  
  set scalarBlockLayout(value: VkBool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get imagelessFramebuffer() {
    return this.#view.getUint32(144, LE);
  }
  
  set imagelessFramebuffer(value: VkBool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get uniformBufferStandardLayout() {
    return this.#view.getUint32(148, LE);
  }
  
  set uniformBufferStandardLayout(value: VkBool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get shaderSubgroupExtendedTypes() {
    return this.#view.getUint32(152, LE);
  }
  
  set shaderSubgroupExtendedTypes(value: VkBool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get separateDepthStencilLayouts() {
    return this.#view.getUint32(156, LE);
  }
  
  set separateDepthStencilLayouts(value: VkBool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get hostQueryReset() {
    return this.#view.getUint32(160, LE);
  }
  
  set hostQueryReset(value: VkBool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get timelineSemaphore() {
    return this.#view.getUint32(164, LE);
  }
  
  set timelineSemaphore(value: VkBool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(168, LE);
  }
  
  set bufferDeviceAddress(value: VkBool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(172, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: VkBool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(176, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: VkBool32) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get vulkanMemoryModel() {
    return this.#view.getUint32(180, LE);
  }
  
  set vulkanMemoryModel(value: VkBool32) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get vulkanMemoryModelDeviceScope() {
    return this.#view.getUint32(184, LE);
  }
  
  set vulkanMemoryModelDeviceScope(value: VkBool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get vulkanMemoryModelAvailabilityVisibilityChains() {
    return this.#view.getUint32(188, LE);
  }
  
  set vulkanMemoryModelAvailabilityVisibilityChains(value: VkBool32) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get shaderOutputViewportIndex() {
    return this.#view.getUint32(192, LE);
  }
  
  set shaderOutputViewportIndex(value: VkBool32) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get shaderOutputLayer() {
    return this.#view.getUint32(196, LE);
  }
  
  set shaderOutputLayer(value: VkBool32) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get subgroupBroadcastDynamicId() {
    return this.#view.getUint32(200, LE);
  }
  
  set subgroupBroadcastDynamicId(value: VkBool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkan12Properties implements IVkStructure {
  static size = 232;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan12Properties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan12Properties(new Uint8Array(VkPhysicalDeviceVulkan12Properties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    driverID: VkDriverId;
    driverName: number;
    driverInfo: number;
    conformanceVersion: VkConformanceVersion;
    denormBehaviorIndependence: VkShaderFloatControlsIndependence;
    roundingModeIndependence: VkShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16: VkBool32;
    shaderSignedZeroInfNanPreserveFloat32: VkBool32;
    shaderSignedZeroInfNanPreserveFloat64: VkBool32;
    shaderDenormPreserveFloat16: VkBool32;
    shaderDenormPreserveFloat32: VkBool32;
    shaderDenormPreserveFloat64: VkBool32;
    shaderDenormFlushToZeroFloat16: VkBool32;
    shaderDenormFlushToZeroFloat32: VkBool32;
    shaderDenormFlushToZeroFloat64: VkBool32;
    shaderRoundingModeRTEFloat16: VkBool32;
    shaderRoundingModeRTEFloat32: VkBool32;
    shaderRoundingModeRTEFloat64: VkBool32;
    shaderRoundingModeRTZFloat16: VkBool32;
    shaderRoundingModeRTZFloat32: VkBool32;
    shaderRoundingModeRTZFloat64: VkBool32;
    maxUpdateAfterBindDescriptorsInAllPools: number;
    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32;
    shaderSampledImageArrayNonUniformIndexingNative: VkBool32;
    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32;
    shaderStorageImageArrayNonUniformIndexingNative: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32;
    robustBufferAccessUpdateAfterBind: VkBool32;
    quadDivergentImplicitLod: VkBool32;
    maxPerStageDescriptorUpdateAfterBindSamplers: number;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;
    maxPerStageDescriptorUpdateAfterBindSampledImages: number;
    maxPerStageDescriptorUpdateAfterBindStorageImages: number;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: number;
    maxPerStageUpdateAfterBindResources: number;
    maxDescriptorSetUpdateAfterBindSamplers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindStorageBuffers: number;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindSampledImages: number;
    maxDescriptorSetUpdateAfterBindStorageImages: number;
    maxDescriptorSetUpdateAfterBindInputAttachments: number;
    supportedDepthResolveModes: VkResolveModeFlags;
    supportedStencilResolveModes: VkResolveModeFlags;
    independentResolveNone: VkBool32;
    independentResolve: VkBool32;
    filterMinmaxSingleComponentFormats: VkBool32;
    filterMinmaxImageComponentMapping: VkBool32;
    maxTimelineSemaphoreValueDifference: Deno.PointerValue;
    framebufferIntegerColorSampleCounts?: VkSampleCountFlags;
  }) {
    const s = VkPhysicalDeviceVulkan12Properties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.driverID !== undefined) s.driverID = data.driverID;
    if (data.driverName !== undefined) s.driverName = data.driverName;
    if (data.driverInfo !== undefined) s.driverInfo = data.driverInfo;
    if (data.conformanceVersion !== undefined) s.conformanceVersion = data.conformanceVersion;
    if (data.denormBehaviorIndependence !== undefined) s.denormBehaviorIndependence = data.denormBehaviorIndependence;
    if (data.roundingModeIndependence !== undefined) s.roundingModeIndependence = data.roundingModeIndependence;
    if (data.shaderSignedZeroInfNanPreserveFloat16 !== undefined) s.shaderSignedZeroInfNanPreserveFloat16 = data.shaderSignedZeroInfNanPreserveFloat16;
    if (data.shaderSignedZeroInfNanPreserveFloat32 !== undefined) s.shaderSignedZeroInfNanPreserveFloat32 = data.shaderSignedZeroInfNanPreserveFloat32;
    if (data.shaderSignedZeroInfNanPreserveFloat64 !== undefined) s.shaderSignedZeroInfNanPreserveFloat64 = data.shaderSignedZeroInfNanPreserveFloat64;
    if (data.shaderDenormPreserveFloat16 !== undefined) s.shaderDenormPreserveFloat16 = data.shaderDenormPreserveFloat16;
    if (data.shaderDenormPreserveFloat32 !== undefined) s.shaderDenormPreserveFloat32 = data.shaderDenormPreserveFloat32;
    if (data.shaderDenormPreserveFloat64 !== undefined) s.shaderDenormPreserveFloat64 = data.shaderDenormPreserveFloat64;
    if (data.shaderDenormFlushToZeroFloat16 !== undefined) s.shaderDenormFlushToZeroFloat16 = data.shaderDenormFlushToZeroFloat16;
    if (data.shaderDenormFlushToZeroFloat32 !== undefined) s.shaderDenormFlushToZeroFloat32 = data.shaderDenormFlushToZeroFloat32;
    if (data.shaderDenormFlushToZeroFloat64 !== undefined) s.shaderDenormFlushToZeroFloat64 = data.shaderDenormFlushToZeroFloat64;
    if (data.shaderRoundingModeRTEFloat16 !== undefined) s.shaderRoundingModeRTEFloat16 = data.shaderRoundingModeRTEFloat16;
    if (data.shaderRoundingModeRTEFloat32 !== undefined) s.shaderRoundingModeRTEFloat32 = data.shaderRoundingModeRTEFloat32;
    if (data.shaderRoundingModeRTEFloat64 !== undefined) s.shaderRoundingModeRTEFloat64 = data.shaderRoundingModeRTEFloat64;
    if (data.shaderRoundingModeRTZFloat16 !== undefined) s.shaderRoundingModeRTZFloat16 = data.shaderRoundingModeRTZFloat16;
    if (data.shaderRoundingModeRTZFloat32 !== undefined) s.shaderRoundingModeRTZFloat32 = data.shaderRoundingModeRTZFloat32;
    if (data.shaderRoundingModeRTZFloat64 !== undefined) s.shaderRoundingModeRTZFloat64 = data.shaderRoundingModeRTZFloat64;
    if (data.maxUpdateAfterBindDescriptorsInAllPools !== undefined) s.maxUpdateAfterBindDescriptorsInAllPools = data.maxUpdateAfterBindDescriptorsInAllPools;
    if (data.shaderUniformBufferArrayNonUniformIndexingNative !== undefined) s.shaderUniformBufferArrayNonUniformIndexingNative = data.shaderUniformBufferArrayNonUniformIndexingNative;
    if (data.shaderSampledImageArrayNonUniformIndexingNative !== undefined) s.shaderSampledImageArrayNonUniformIndexingNative = data.shaderSampledImageArrayNonUniformIndexingNative;
    if (data.shaderStorageBufferArrayNonUniformIndexingNative !== undefined) s.shaderStorageBufferArrayNonUniformIndexingNative = data.shaderStorageBufferArrayNonUniformIndexingNative;
    if (data.shaderStorageImageArrayNonUniformIndexingNative !== undefined) s.shaderStorageImageArrayNonUniformIndexingNative = data.shaderStorageImageArrayNonUniformIndexingNative;
    if (data.shaderInputAttachmentArrayNonUniformIndexingNative !== undefined) s.shaderInputAttachmentArrayNonUniformIndexingNative = data.shaderInputAttachmentArrayNonUniformIndexingNative;
    if (data.robustBufferAccessUpdateAfterBind !== undefined) s.robustBufferAccessUpdateAfterBind = data.robustBufferAccessUpdateAfterBind;
    if (data.quadDivergentImplicitLod !== undefined) s.quadDivergentImplicitLod = data.quadDivergentImplicitLod;
    if (data.maxPerStageDescriptorUpdateAfterBindSamplers !== undefined) s.maxPerStageDescriptorUpdateAfterBindSamplers = data.maxPerStageDescriptorUpdateAfterBindSamplers;
    if (data.maxPerStageDescriptorUpdateAfterBindUniformBuffers !== undefined) s.maxPerStageDescriptorUpdateAfterBindUniformBuffers = data.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    if (data.maxPerStageDescriptorUpdateAfterBindStorageBuffers !== undefined) s.maxPerStageDescriptorUpdateAfterBindStorageBuffers = data.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    if (data.maxPerStageDescriptorUpdateAfterBindSampledImages !== undefined) s.maxPerStageDescriptorUpdateAfterBindSampledImages = data.maxPerStageDescriptorUpdateAfterBindSampledImages;
    if (data.maxPerStageDescriptorUpdateAfterBindStorageImages !== undefined) s.maxPerStageDescriptorUpdateAfterBindStorageImages = data.maxPerStageDescriptorUpdateAfterBindStorageImages;
    if (data.maxPerStageDescriptorUpdateAfterBindInputAttachments !== undefined) s.maxPerStageDescriptorUpdateAfterBindInputAttachments = data.maxPerStageDescriptorUpdateAfterBindInputAttachments;
    if (data.maxPerStageUpdateAfterBindResources !== undefined) s.maxPerStageUpdateAfterBindResources = data.maxPerStageUpdateAfterBindResources;
    if (data.maxDescriptorSetUpdateAfterBindSamplers !== undefined) s.maxDescriptorSetUpdateAfterBindSamplers = data.maxDescriptorSetUpdateAfterBindSamplers;
    if (data.maxDescriptorSetUpdateAfterBindUniformBuffers !== undefined) s.maxDescriptorSetUpdateAfterBindUniformBuffers = data.maxDescriptorSetUpdateAfterBindUniformBuffers;
    if (data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic !== undefined) s.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    if (data.maxDescriptorSetUpdateAfterBindStorageBuffers !== undefined) s.maxDescriptorSetUpdateAfterBindStorageBuffers = data.maxDescriptorSetUpdateAfterBindStorageBuffers;
    if (data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic !== undefined) s.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    if (data.maxDescriptorSetUpdateAfterBindSampledImages !== undefined) s.maxDescriptorSetUpdateAfterBindSampledImages = data.maxDescriptorSetUpdateAfterBindSampledImages;
    if (data.maxDescriptorSetUpdateAfterBindStorageImages !== undefined) s.maxDescriptorSetUpdateAfterBindStorageImages = data.maxDescriptorSetUpdateAfterBindStorageImages;
    if (data.maxDescriptorSetUpdateAfterBindInputAttachments !== undefined) s.maxDescriptorSetUpdateAfterBindInputAttachments = data.maxDescriptorSetUpdateAfterBindInputAttachments;
    if (data.supportedDepthResolveModes !== undefined) s.supportedDepthResolveModes = data.supportedDepthResolveModes;
    if (data.supportedStencilResolveModes !== undefined) s.supportedStencilResolveModes = data.supportedStencilResolveModes;
    if (data.independentResolveNone !== undefined) s.independentResolveNone = data.independentResolveNone;
    if (data.independentResolve !== undefined) s.independentResolve = data.independentResolve;
    if (data.filterMinmaxSingleComponentFormats !== undefined) s.filterMinmaxSingleComponentFormats = data.filterMinmaxSingleComponentFormats;
    if (data.filterMinmaxImageComponentMapping !== undefined) s.filterMinmaxImageComponentMapping = data.filterMinmaxImageComponentMapping;
    if (data.maxTimelineSemaphoreValueDifference !== undefined) s.maxTimelineSemaphoreValueDifference = data.maxTimelineSemaphoreValueDifference;
    if (data.framebufferIntegerColorSampleCounts !== undefined) s.framebufferIntegerColorSampleCounts = data.framebufferIntegerColorSampleCounts;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get driverID() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverID(value: VkDriverId) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get driverName() {
    return this.#view.getUint8(20);
  }
  
  set driverName(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get driverInfo() {
    return this.#view.getUint8(21);
  }
  
  set driverInfo(value: number) {
    this.#view.setUint8(21, Number(value));
  }
  
  get conformanceVersion() {
    return new VkConformanceVersion(this.#data.subarray(24, 24 + VkConformanceVersion.size));
  }
  
  set conformanceVersion(value: VkConformanceVersion) {
    if (value[BUFFER].byteLength < VkConformanceVersion.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get denormBehaviorIndependence() {
    return this.#view.getUint32(28, LE);
  }
  
  set denormBehaviorIndependence(value: VkShaderFloatControlsIndependence) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get roundingModeIndependence() {
    return this.#view.getUint32(32, LE);
  }
  
  set roundingModeIndependence(value: VkShaderFloatControlsIndependence) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat16() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat16(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat32() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat32(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat64() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat64(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat16() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderDenormPreserveFloat16(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat32() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderDenormPreserveFloat32(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat64() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderDenormPreserveFloat64(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat16() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderDenormFlushToZeroFloat16(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat32() {
    return this.#view.getUint32(64, LE);
  }
  
  set shaderDenormFlushToZeroFloat32(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat64() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderDenormFlushToZeroFloat64(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat16() {
    return this.#view.getUint32(72, LE);
  }
  
  set shaderRoundingModeRTEFloat16(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat32() {
    return this.#view.getUint32(76, LE);
  }
  
  set shaderRoundingModeRTEFloat32(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat64() {
    return this.#view.getUint32(80, LE);
  }
  
  set shaderRoundingModeRTEFloat64(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat16() {
    return this.#view.getUint32(84, LE);
  }
  
  set shaderRoundingModeRTZFloat16(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat32() {
    return this.#view.getUint32(88, LE);
  }
  
  set shaderRoundingModeRTZFloat32(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat64() {
    return this.#view.getUint32(92, LE);
  }
  
  set shaderRoundingModeRTZFloat64(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxUpdateAfterBindDescriptorsInAllPools() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxUpdateAfterBindDescriptorsInAllPools(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(100, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(104, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(108, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(112, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexingNative() {
    return this.#view.getUint32(116, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexingNative(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get robustBufferAccessUpdateAfterBind() {
    return this.#view.getUint32(120, LE);
  }
  
  set robustBufferAccessUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get quadDivergentImplicitLod() {
    return this.#view.getUint32(124, LE);
  }
  
  set quadDivergentImplicitLod(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSamplers() {
    return this.#view.getUint32(128, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(132, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(136, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSampledImages() {
    return this.#view.getUint32(140, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageImages() {
    return this.#view.getUint32(144, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(148, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get maxPerStageUpdateAfterBindResources() {
    return this.#view.getUint32(152, LE);
  }
  
  set maxPerStageUpdateAfterBindResources(value: number) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSamplers() {
    return this.#view.getUint32(156, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(160, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
    return this.#view.getUint32(164, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffersDynamic(value: number) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(168, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
    return this.#view.getUint32(172, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffersDynamic(value: number) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSampledImages() {
    return this.#view.getUint32(176, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageImages() {
    return this.#view.getUint32(180, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(184, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get supportedDepthResolveModes() {
    return this.#view.getUint32(188, LE);
  }
  
  set supportedDepthResolveModes(value: VkResolveModeFlags) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get supportedStencilResolveModes() {
    return this.#view.getUint32(192, LE);
  }
  
  set supportedStencilResolveModes(value: VkResolveModeFlags) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get independentResolveNone() {
    return this.#view.getUint32(196, LE);
  }
  
  set independentResolveNone(value: VkBool32) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get independentResolve() {
    return this.#view.getUint32(200, LE);
  }
  
  set independentResolve(value: VkBool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get filterMinmaxSingleComponentFormats() {
    return this.#view.getUint32(204, LE);
  }
  
  set filterMinmaxSingleComponentFormats(value: VkBool32) {
    this.#view.setUint32(204, Number(value), LE);
  }
  
  get filterMinmaxImageComponentMapping() {
    return this.#view.getUint32(208, LE);
  }
  
  set filterMinmaxImageComponentMapping(value: VkBool32) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get maxTimelineSemaphoreValueDifference() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set maxTimelineSemaphoreValueDifference(value: Deno.PointerValue) {
    this.#view.setBigUint64(216, BigInt(value), LE);
  }
  
  get framebufferIntegerColorSampleCounts() {
    return this.#view.getUint32(224, LE);
  }
  
  set framebufferIntegerColorSampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(224, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkan13Features implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan13Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan13Features(new Uint8Array(VkPhysicalDeviceVulkan13Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    robustImageAccess: VkBool32;
    inlineUniformBlock: VkBool32;
    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
    pipelineCreationCacheControl: VkBool32;
    privateData: VkBool32;
    shaderDemoteToHelperInvocation: VkBool32;
    shaderTerminateInvocation: VkBool32;
    subgroupSizeControl: VkBool32;
    computeFullSubgroups: VkBool32;
    synchronization2: VkBool32;
    textureCompressionASTC_HDR: VkBool32;
    shaderZeroInitializeWorkgroupMemory: VkBool32;
    dynamicRendering: VkBool32;
    shaderIntegerDotProduct: VkBool32;
    maintenance4: VkBool32;
  }) {
    const s = VkPhysicalDeviceVulkan13Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.robustImageAccess !== undefined) s.robustImageAccess = data.robustImageAccess;
    if (data.inlineUniformBlock !== undefined) s.inlineUniformBlock = data.inlineUniformBlock;
    if (data.descriptorBindingInlineUniformBlockUpdateAfterBind !== undefined) s.descriptorBindingInlineUniformBlockUpdateAfterBind = data.descriptorBindingInlineUniformBlockUpdateAfterBind;
    if (data.pipelineCreationCacheControl !== undefined) s.pipelineCreationCacheControl = data.pipelineCreationCacheControl;
    if (data.privateData !== undefined) s.privateData = data.privateData;
    if (data.shaderDemoteToHelperInvocation !== undefined) s.shaderDemoteToHelperInvocation = data.shaderDemoteToHelperInvocation;
    if (data.shaderTerminateInvocation !== undefined) s.shaderTerminateInvocation = data.shaderTerminateInvocation;
    if (data.subgroupSizeControl !== undefined) s.subgroupSizeControl = data.subgroupSizeControl;
    if (data.computeFullSubgroups !== undefined) s.computeFullSubgroups = data.computeFullSubgroups;
    if (data.synchronization2 !== undefined) s.synchronization2 = data.synchronization2;
    if (data.textureCompressionASTC_HDR !== undefined) s.textureCompressionASTC_HDR = data.textureCompressionASTC_HDR;
    if (data.shaderZeroInitializeWorkgroupMemory !== undefined) s.shaderZeroInitializeWorkgroupMemory = data.shaderZeroInitializeWorkgroupMemory;
    if (data.dynamicRendering !== undefined) s.dynamicRendering = data.dynamicRendering;
    if (data.shaderIntegerDotProduct !== undefined) s.shaderIntegerDotProduct = data.shaderIntegerDotProduct;
    if (data.maintenance4 !== undefined) s.maintenance4 = data.maintenance4;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get robustImageAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustImageAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inlineUniformBlock() {
    return this.#view.getUint32(20, LE);
  }
  
  set inlineUniformBlock(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get descriptorBindingInlineUniformBlockUpdateAfterBind() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorBindingInlineUniformBlockUpdateAfterBind(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pipelineCreationCacheControl() {
    return this.#view.getUint32(28, LE);
  }
  
  set pipelineCreationCacheControl(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get privateData() {
    return this.#view.getUint32(32, LE);
  }
  
  set privateData(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderDemoteToHelperInvocation() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderDemoteToHelperInvocation(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderTerminateInvocation() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderTerminateInvocation(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get subgroupSizeControl() {
    return this.#view.getUint32(44, LE);
  }
  
  set subgroupSizeControl(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get computeFullSubgroups() {
    return this.#view.getUint32(48, LE);
  }
  
  set computeFullSubgroups(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get synchronization2() {
    return this.#view.getUint32(52, LE);
  }
  
  set synchronization2(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get textureCompressionASTC_HDR() {
    return this.#view.getUint32(56, LE);
  }
  
  set textureCompressionASTC_HDR(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderZeroInitializeWorkgroupMemory() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderZeroInitializeWorkgroupMemory(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get dynamicRendering() {
    return this.#view.getUint32(64, LE);
  }
  
  set dynamicRendering(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderIntegerDotProduct() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderIntegerDotProduct(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maintenance4() {
    return this.#view.getUint32(72, LE);
  }
  
  set maintenance4(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
}

export class VkPhysicalDeviceVulkan13Properties implements IVkStructure {
  static size = 216;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVulkan13Properties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVulkan13Properties(new Uint8Array(VkPhysicalDeviceVulkan13Properties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minSubgroupSize: number;
    maxSubgroupSize: number;
    maxComputeWorkgroupSubgroups: number;
    requiredSubgroupSizeStages: VkShaderStageFlags;
    maxInlineUniformBlockSize: number;
    maxPerStageDescriptorInlineUniformBlocks: number;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number;
    maxDescriptorSetInlineUniformBlocks: number;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number;
    maxInlineUniformTotalSize: number;
    integerDotProduct8BitUnsignedAccelerated: VkBool32;
    integerDotProduct8BitSignedAccelerated: VkBool32;
    integerDotProduct8BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32;
    integerDotProduct4x8BitPackedSignedAccelerated: VkBool32;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProduct16BitUnsignedAccelerated: VkBool32;
    integerDotProduct16BitSignedAccelerated: VkBool32;
    integerDotProduct16BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct32BitUnsignedAccelerated: VkBool32;
    integerDotProduct32BitSignedAccelerated: VkBool32;
    integerDotProduct32BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct64BitUnsignedAccelerated: VkBool32;
    integerDotProduct64BitSignedAccelerated: VkBool32;
    integerDotProduct64BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32;
    storageTexelBufferOffsetAlignmentBytes: VkDeviceSize;
    storageTexelBufferOffsetSingleTexelAlignment: VkBool32;
    uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize;
    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32;
    maxBufferSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceVulkan13Properties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minSubgroupSize !== undefined) s.minSubgroupSize = data.minSubgroupSize;
    if (data.maxSubgroupSize !== undefined) s.maxSubgroupSize = data.maxSubgroupSize;
    if (data.maxComputeWorkgroupSubgroups !== undefined) s.maxComputeWorkgroupSubgroups = data.maxComputeWorkgroupSubgroups;
    if (data.requiredSubgroupSizeStages !== undefined) s.requiredSubgroupSizeStages = data.requiredSubgroupSizeStages;
    if (data.maxInlineUniformBlockSize !== undefined) s.maxInlineUniformBlockSize = data.maxInlineUniformBlockSize;
    if (data.maxPerStageDescriptorInlineUniformBlocks !== undefined) s.maxPerStageDescriptorInlineUniformBlocks = data.maxPerStageDescriptorInlineUniformBlocks;
    if (data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks !== undefined) s.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    if (data.maxDescriptorSetInlineUniformBlocks !== undefined) s.maxDescriptorSetInlineUniformBlocks = data.maxDescriptorSetInlineUniformBlocks;
    if (data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks !== undefined) s.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    if (data.maxInlineUniformTotalSize !== undefined) s.maxInlineUniformTotalSize = data.maxInlineUniformTotalSize;
    if (data.integerDotProduct8BitUnsignedAccelerated !== undefined) s.integerDotProduct8BitUnsignedAccelerated = data.integerDotProduct8BitUnsignedAccelerated;
    if (data.integerDotProduct8BitSignedAccelerated !== undefined) s.integerDotProduct8BitSignedAccelerated = data.integerDotProduct8BitSignedAccelerated;
    if (data.integerDotProduct8BitMixedSignednessAccelerated !== undefined) s.integerDotProduct8BitMixedSignednessAccelerated = data.integerDotProduct8BitMixedSignednessAccelerated;
    if (data.integerDotProduct4x8BitPackedUnsignedAccelerated !== undefined) s.integerDotProduct4x8BitPackedUnsignedAccelerated = data.integerDotProduct4x8BitPackedUnsignedAccelerated;
    if (data.integerDotProduct4x8BitPackedSignedAccelerated !== undefined) s.integerDotProduct4x8BitPackedSignedAccelerated = data.integerDotProduct4x8BitPackedSignedAccelerated;
    if (data.integerDotProduct4x8BitPackedMixedSignednessAccelerated !== undefined) s.integerDotProduct4x8BitPackedMixedSignednessAccelerated = data.integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    if (data.integerDotProduct16BitUnsignedAccelerated !== undefined) s.integerDotProduct16BitUnsignedAccelerated = data.integerDotProduct16BitUnsignedAccelerated;
    if (data.integerDotProduct16BitSignedAccelerated !== undefined) s.integerDotProduct16BitSignedAccelerated = data.integerDotProduct16BitSignedAccelerated;
    if (data.integerDotProduct16BitMixedSignednessAccelerated !== undefined) s.integerDotProduct16BitMixedSignednessAccelerated = data.integerDotProduct16BitMixedSignednessAccelerated;
    if (data.integerDotProduct32BitUnsignedAccelerated !== undefined) s.integerDotProduct32BitUnsignedAccelerated = data.integerDotProduct32BitUnsignedAccelerated;
    if (data.integerDotProduct32BitSignedAccelerated !== undefined) s.integerDotProduct32BitSignedAccelerated = data.integerDotProduct32BitSignedAccelerated;
    if (data.integerDotProduct32BitMixedSignednessAccelerated !== undefined) s.integerDotProduct32BitMixedSignednessAccelerated = data.integerDotProduct32BitMixedSignednessAccelerated;
    if (data.integerDotProduct64BitUnsignedAccelerated !== undefined) s.integerDotProduct64BitUnsignedAccelerated = data.integerDotProduct64BitUnsignedAccelerated;
    if (data.integerDotProduct64BitSignedAccelerated !== undefined) s.integerDotProduct64BitSignedAccelerated = data.integerDotProduct64BitSignedAccelerated;
    if (data.integerDotProduct64BitMixedSignednessAccelerated !== undefined) s.integerDotProduct64BitMixedSignednessAccelerated = data.integerDotProduct64BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitSignedAccelerated = data.integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitSignedAccelerated = data.integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitSignedAccelerated = data.integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitSignedAccelerated = data.integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    if (data.storageTexelBufferOffsetAlignmentBytes !== undefined) s.storageTexelBufferOffsetAlignmentBytes = data.storageTexelBufferOffsetAlignmentBytes;
    if (data.storageTexelBufferOffsetSingleTexelAlignment !== undefined) s.storageTexelBufferOffsetSingleTexelAlignment = data.storageTexelBufferOffsetSingleTexelAlignment;
    if (data.uniformTexelBufferOffsetAlignmentBytes !== undefined) s.uniformTexelBufferOffsetAlignmentBytes = data.uniformTexelBufferOffsetAlignmentBytes;
    if (data.uniformTexelBufferOffsetSingleTexelAlignment !== undefined) s.uniformTexelBufferOffsetSingleTexelAlignment = data.uniformTexelBufferOffsetSingleTexelAlignment;
    if (data.maxBufferSize !== undefined) s.maxBufferSize = data.maxBufferSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set minSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSubgroupSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSubgroupSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxComputeWorkgroupSubgroups() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxComputeWorkgroupSubgroups(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get requiredSubgroupSizeStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set requiredSubgroupSizeStages(value: VkShaderStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxInlineUniformBlockSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxInlineUniformBlockSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxPerStageDescriptorInlineUniformBlocks() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxPerStageDescriptorInlineUniformBlocks(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxDescriptorSetInlineUniformBlocks() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxDescriptorSetInlineUniformBlocks(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxInlineUniformTotalSize() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxInlineUniformTotalSize(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get integerDotProduct8BitUnsignedAccelerated() {
    return this.#view.getUint32(56, LE);
  }
  
  set integerDotProduct8BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get integerDotProduct8BitSignedAccelerated() {
    return this.#view.getUint32(60, LE);
  }
  
  set integerDotProduct8BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get integerDotProduct8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(64, LE);
  }
  
  set integerDotProduct8BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(68, LE);
  }
  
  set integerDotProduct4x8BitPackedUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(72, LE);
  }
  
  set integerDotProduct4x8BitPackedSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(76, LE);
  }
  
  set integerDotProduct4x8BitPackedMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get integerDotProduct16BitUnsignedAccelerated() {
    return this.#view.getUint32(80, LE);
  }
  
  set integerDotProduct16BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get integerDotProduct16BitSignedAccelerated() {
    return this.#view.getUint32(84, LE);
  }
  
  set integerDotProduct16BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get integerDotProduct16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(88, LE);
  }
  
  set integerDotProduct16BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get integerDotProduct32BitUnsignedAccelerated() {
    return this.#view.getUint32(92, LE);
  }
  
  set integerDotProduct32BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get integerDotProduct32BitSignedAccelerated() {
    return this.#view.getUint32(96, LE);
  }
  
  set integerDotProduct32BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get integerDotProduct32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(100, LE);
  }
  
  set integerDotProduct32BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get integerDotProduct64BitUnsignedAccelerated() {
    return this.#view.getUint32(104, LE);
  }
  
  set integerDotProduct64BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get integerDotProduct64BitSignedAccelerated() {
    return this.#view.getUint32(108, LE);
  }
  
  set integerDotProduct64BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get integerDotProduct64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(112, LE);
  }
  
  set integerDotProduct64BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
    return this.#view.getUint32(116, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
    return this.#view.getUint32(120, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(124, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(128, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(132, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(136, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
    return this.#view.getUint32(140, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
    return this.#view.getUint32(144, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(148, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
    return this.#view.getUint32(152, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
    return this.#view.getUint32(156, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(160, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
    return this.#view.getUint32(164, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
    return this.#view.getUint32(168, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(172, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get storageTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set storageTexelBufferOffsetAlignmentBytes(value: VkDeviceSize) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
  
  get storageTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(184, LE);
  }
  
  set storageTexelBufferOffsetSingleTexelAlignment(value: VkBool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get uniformTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set uniformTexelBufferOffsetAlignmentBytes(value: VkDeviceSize) {
    this.#view.setBigUint64(192, BigInt(value), LE);
  }
  
  get uniformTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(200, LE);
  }
  
  set uniformTexelBufferOffsetSingleTexelAlignment(value: VkBool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get maxBufferSize() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set maxBufferSize(value: VkDeviceSize) {
    this.#view.setBigUint64(208, BigInt(value), LE);
  }
}

export class VkPipelineCompilerControlCreateInfoAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineCompilerControlCreateInfoAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineCompilerControlCreateInfoAMD(new Uint8Array(VkPipelineCompilerControlCreateInfoAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    compilerControlFlags?: VkPipelineCompilerControlFlagsAMD;
  }) {
    const s = VkPipelineCompilerControlCreateInfoAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.compilerControlFlags !== undefined) s.compilerControlFlags = data.compilerControlFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get compilerControlFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set compilerControlFlags(value: VkPipelineCompilerControlFlagsAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCoherentMemoryFeaturesAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCoherentMemoryFeaturesAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCoherentMemoryFeaturesAMD(new Uint8Array(VkPhysicalDeviceCoherentMemoryFeaturesAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceCoherentMemory: VkBool32;
  }) {
    const s = VkPhysicalDeviceCoherentMemoryFeaturesAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceCoherentMemory !== undefined) s.deviceCoherentMemory = data.deviceCoherentMemory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceCoherentMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceCoherentMemory(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceToolProperties implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceToolProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceToolProperties(new Uint8Array(VkPhysicalDeviceToolProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    name: number;
    version: number;
    purposes: VkToolPurposeFlags;
    description: number;
    layer: number;
  }) {
    const s = VkPhysicalDeviceToolProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.name !== undefined) s.name = data.name;
    if (data.version !== undefined) s.version = data.version;
    if (data.purposes !== undefined) s.purposes = data.purposes;
    if (data.description !== undefined) s.description = data.description;
    if (data.layer !== undefined) s.layer = data.layer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get name() {
    return this.#view.getUint8(16);
  }
  
  set name(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get version() {
    return this.#view.getUint8(17);
  }
  
  set version(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get purposes() {
    return this.#view.getUint32(20, LE);
  }
  
  set purposes(value: VkToolPurposeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get description() {
    return this.#view.getUint8(24);
  }
  
  set description(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get layer() {
    return this.#view.getUint8(25);
  }
  
  set layer(value: number) {
    this.#view.setUint8(25, Number(value));
  }
}

export class VkSamplerCustomBorderColorCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerCustomBorderColorCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerCustomBorderColorCreateInfoEXT(new Uint8Array(VkSamplerCustomBorderColorCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    customBorderColor: VkClearColorValue;
    format: VkFormat;
  }) {
    const s = VkSamplerCustomBorderColorCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.customBorderColor !== undefined) s.customBorderColor = data.customBorderColor;
    if (data.format !== undefined) s.format = data.format;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get customBorderColor() {
    throw new Error(`Unknown type: {"union":["f32","i32","u32"]}`);
  }
  
  set customBorderColor(value: VkClearColorValue) {
    throw new Error(`Unknown type: {"union":["f32","i32","u32"]}`);
  }
  
  get format() {
    return this.#view.getUint32(20, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceCustomBorderColorPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCustomBorderColorPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCustomBorderColorPropertiesEXT(new Uint8Array(VkPhysicalDeviceCustomBorderColorPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxCustomBorderColorSamplers: number;
  }) {
    const s = VkPhysicalDeviceCustomBorderColorPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxCustomBorderColorSamplers !== undefined) s.maxCustomBorderColorSamplers = data.maxCustomBorderColorSamplers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxCustomBorderColorSamplers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxCustomBorderColorSamplers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceCustomBorderColorFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceCustomBorderColorFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceCustomBorderColorFeaturesEXT(new Uint8Array(VkPhysicalDeviceCustomBorderColorFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    customBorderColors: VkBool32;
    customBorderColorWithoutFormat: VkBool32;
  }) {
    const s = VkPhysicalDeviceCustomBorderColorFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.customBorderColors !== undefined) s.customBorderColors = data.customBorderColors;
    if (data.customBorderColorWithoutFormat !== undefined) s.customBorderColorWithoutFormat = data.customBorderColorWithoutFormat;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get customBorderColors() {
    return this.#view.getUint32(16, LE);
  }
  
  set customBorderColors(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get customBorderColorWithoutFormat() {
    return this.#view.getUint32(20, LE);
  }
  
  set customBorderColorWithoutFormat(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkSamplerBorderColorComponentMappingCreateInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerBorderColorComponentMappingCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerBorderColorComponentMappingCreateInfoEXT(new Uint8Array(VkSamplerBorderColorComponentMappingCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    components: VkComponentMapping;
    srgb: VkBool32;
  }) {
    const s = VkSamplerBorderColorComponentMappingCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.components !== undefined) s.components = data.components;
    if (data.srgb !== undefined) s.srgb = data.srgb;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get components() {
    return new VkComponentMapping(this.#data.subarray(16, 16 + VkComponentMapping.size));
  }
  
  set components(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srgb() {
    return this.#view.getUint32(32, LE);
  }
  
  set srgb(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceBorderColorSwizzleFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(new Uint8Array(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    borderColorSwizzle: VkBool32;
    borderColorSwizzleFromImage: VkBool32;
  }) {
    const s = VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.borderColorSwizzle !== undefined) s.borderColorSwizzle = data.borderColorSwizzle;
    if (data.borderColorSwizzleFromImage !== undefined) s.borderColorSwizzleFromImage = data.borderColorSwizzleFromImage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get borderColorSwizzle() {
    return this.#view.getUint32(16, LE);
  }
  
  set borderColorSwizzle(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get borderColorSwizzleFromImage() {
    return this.#view.getUint32(20, LE);
  }
  
  set borderColorSwizzleFromImage(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkAccelerationStructureGeometryTrianglesDataKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryTrianglesDataKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureGeometryTrianglesDataKHR(new Uint8Array(VkAccelerationStructureGeometryTrianglesDataKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexFormat: VkFormat;
    vertexData: VkDeviceOrHostAddressConstKHR;
    vertexStride: VkDeviceSize;
    maxVertex: number;
    indexType: VkIndexType;
    indexData: VkDeviceOrHostAddressConstKHR;
    transformData: VkDeviceOrHostAddressConstKHR;
  }) {
    const s = VkAccelerationStructureGeometryTrianglesDataKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexFormat !== undefined) s.vertexFormat = data.vertexFormat;
    if (data.vertexData !== undefined) s.vertexData = data.vertexData;
    if (data.vertexStride !== undefined) s.vertexStride = data.vertexStride;
    if (data.maxVertex !== undefined) s.maxVertex = data.maxVertex;
    if (data.indexType !== undefined) s.indexType = data.indexType;
    if (data.indexData !== undefined) s.indexData = data.indexData;
    if (data.transformData !== undefined) s.transformData = data.transformData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexFormat() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexFormat(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set vertexData(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get vertexStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set vertexStride(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxVertex() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxVertex(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(44, LE);
  }
  
  set indexType(value: VkIndexType) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get indexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set indexData(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get transformData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set transformData(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export class VkAccelerationStructureGeometryAabbsDataKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryAabbsDataKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureGeometryAabbsDataKHR(new Uint8Array(VkAccelerationStructureGeometryAabbsDataKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    data: VkDeviceOrHostAddressConstKHR;
    stride: VkDeviceSize;
  }) {
    const s = VkAccelerationStructureGeometryAabbsDataKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.data !== undefined) s.data = data.data;
    if (data.stride !== undefined) s.stride = data.stride;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get stride() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set stride(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkAccelerationStructureGeometryInstancesDataKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryInstancesDataKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureGeometryInstancesDataKHR(new Uint8Array(VkAccelerationStructureGeometryInstancesDataKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    arrayOfPointers: VkBool32;
    data: VkDeviceOrHostAddressConstKHR;
  }) {
    const s = VkAccelerationStructureGeometryInstancesDataKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.arrayOfPointers !== undefined) s.arrayOfPointers = data.arrayOfPointers;
    if (data.data !== undefined) s.data = data.data;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get arrayOfPointers() {
    return this.#view.getUint32(16, LE);
  }
  
  set arrayOfPointers(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export class VkAccelerationStructureGeometryKHR implements IVkStructure {
  static size = 192;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureGeometryKHR(new Uint8Array(VkAccelerationStructureGeometryKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    geometryType: VkGeometryTypeKHR;
    geometry: VkAccelerationStructureGeometryDataKHR;
    flags?: VkGeometryFlagsKHR;
  }) {
    const s = VkAccelerationStructureGeometryKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.geometryType !== undefined) s.geometryType = data.geometryType;
    if (data.geometry !== undefined) s.geometry = data.geometry;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get geometryType() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryType(value: VkGeometryTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometry() {
    throw new Error(`Unknown type: {"union":[{"struct":["u32","buffer","u32",{"union":["u64","buffer"]},"u64","u32","u32",{"union":["u64","buffer"]},{"union":["u64","buffer"]}]},{"struct":["u32","buffer",{"union":["u64","buffer"]},"u64"]},{"struct":["u32","buffer","u32",{"union":["u64","buffer"]}]}]}`);
  }
  
  set geometry(value: VkAccelerationStructureGeometryDataKHR) {
    throw new Error(`Unknown type: {"union":[{"struct":["u32","buffer","u32",{"union":["u64","buffer"]},"u64","u32","u32",{"union":["u64","buffer"]},{"union":["u64","buffer"]}]},{"struct":["u32","buffer",{"union":["u64","buffer"]},"u64"]},{"struct":["u32","buffer","u32",{"union":["u64","buffer"]}]}]}`);
  }
  
  get flags() {
    return this.#view.getUint32(128, LE);
  }
  
  set flags(value: VkGeometryFlagsKHR) {
    this.#view.setUint32(128, Number(value), LE);
  }
}

export class VkAccelerationStructureBuildGeometryInfoKHR implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureBuildGeometryInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureBuildGeometryInfoKHR(new Uint8Array(VkAccelerationStructureBuildGeometryInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkAccelerationStructureTypeKHR;
    flags?: VkBuildAccelerationStructureFlagsKHR;
    mode: VkBuildAccelerationStructureModeKHR;
    srcAccelerationStructure?: VkAccelerationStructureKHR;
    dstAccelerationStructure?: VkAccelerationStructureKHR;
    geometryCount?: number;
    pGeometries?: Deno.PointerValue;
    ppGeometries?: Deno.PointerValue;
    scratchData: VkDeviceOrHostAddressKHR;
  }) {
    const s = VkAccelerationStructureBuildGeometryInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.mode !== undefined) s.mode = data.mode;
    if (data.srcAccelerationStructure !== undefined) s.srcAccelerationStructure = data.srcAccelerationStructure;
    if (data.dstAccelerationStructure !== undefined) s.dstAccelerationStructure = data.dstAccelerationStructure;
    if (data.geometryCount !== undefined) s.geometryCount = data.geometryCount;
    if (data.pGeometries !== undefined) s.pGeometries = data.pGeometries;
    if (data.ppGeometries !== undefined) s.ppGeometries = data.ppGeometries;
    if (data.scratchData !== undefined) s.scratchData = data.scratchData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkAccelerationStructureTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkBuildAccelerationStructureFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(24, LE);
  }
  
  set mode(value: VkBuildAccelerationStructureModeKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get srcAccelerationStructure() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set srcAccelerationStructure(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccelerationStructure() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccelerationStructure(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get geometryCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set geometryCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pGeometries() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pGeometries(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get ppGeometries() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set ppGeometries(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get scratchData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set scratchData(value: VkDeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export class VkAccelerationStructureBuildRangeInfoKHR implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureBuildRangeInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureBuildRangeInfoKHR(new Uint8Array(VkAccelerationStructureBuildRangeInfoKHR.size));
  }
  
  static create(data: {
    primitiveCount: number;
    primitiveOffset: number;
    firstVertex: number;
    transformOffset: number;
  }) {
    const s = VkAccelerationStructureBuildRangeInfoKHR.alloc();
    if (data.primitiveCount !== undefined) s.primitiveCount = data.primitiveCount;
    if (data.primitiveOffset !== undefined) s.primitiveOffset = data.primitiveOffset;
    if (data.firstVertex !== undefined) s.firstVertex = data.firstVertex;
    if (data.transformOffset !== undefined) s.transformOffset = data.transformOffset;
    return s;
  }
  
  get primitiveCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set primitiveCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get primitiveOffset() {
    return this.#view.getUint32(4, LE);
  }
  
  set primitiveOffset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstVertex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get transformOffset() {
    return this.#view.getUint32(12, LE);
  }
  
  set transformOffset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export class VkAccelerationStructureCreateInfoKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureCreateInfoKHR(new Uint8Array(VkAccelerationStructureCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    createFlags?: VkAccelerationStructureCreateFlagsKHR;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    size: VkDeviceSize;
    type: VkAccelerationStructureTypeKHR;
    deviceAddress?: VkDeviceAddress;
  }) {
    const s = VkAccelerationStructureCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.createFlags !== undefined) s.createFlags = data.createFlags;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    if (data.type !== undefined) s.type = data.type;
    if (data.deviceAddress !== undefined) s.deviceAddress = data.deviceAddress;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get createFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set createFlags(value: VkAccelerationStructureCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(48, LE);
  }
  
  set type(value: VkAccelerationStructureTypeKHR) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set deviceAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkAabbPositionsKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAabbPositionsKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAabbPositionsKHR(new Uint8Array(VkAabbPositionsKHR.size));
  }
  
  static create(data: {
    minX: number;
    minY: number;
    minZ: number;
    maxX: number;
    maxY: number;
    maxZ: number;
  }) {
    const s = VkAabbPositionsKHR.alloc();
    if (data.minX !== undefined) s.minX = data.minX;
    if (data.minY !== undefined) s.minY = data.minY;
    if (data.minZ !== undefined) s.minZ = data.minZ;
    if (data.maxX !== undefined) s.maxX = data.maxX;
    if (data.maxY !== undefined) s.maxY = data.maxY;
    if (data.maxZ !== undefined) s.maxZ = data.maxZ;
    return s;
  }
  
  get minX() {
    return this.#view.getFloat32(0, LE);
  }
  
  set minX(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get minY() {
    return this.#view.getFloat32(4, LE);
  }
  
  set minY(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get minZ() {
    return this.#view.getFloat32(8, LE);
  }
  
  set minZ(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get maxX() {
    return this.#view.getFloat32(12, LE);
  }
  
  set maxX(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get maxY() {
    return this.#view.getFloat32(16, LE);
  }
  
  set maxY(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxZ() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxZ(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
}

export class VkTransformMatrixKHR implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTransformMatrixKHR(new Uint8Array(VkTransformMatrixKHR.size));
  }
  
  static create(data: {
    matrix: number;
  }) {
    const s = VkTransformMatrixKHR.alloc();
    if (data.matrix !== undefined) s.matrix = data.matrix;
    return s;
  }
  
  get matrix() {
    return this.#view.getFloat32(0, LE);
  }
  
  set matrix(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
}

export class VkAccelerationStructureInstanceKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureInstanceKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureInstanceKHR(new Uint8Array(VkAccelerationStructureInstanceKHR.size));
  }
  
  static create(data: {
    transform: VkTransformMatrixKHR;
    instanceCustomIndex: number;
    mask: number;
    instanceShaderBindingTableRecordOffset: number;
    flags?: VkGeometryInstanceFlagsKHR;
    accelerationStructureReference: Deno.PointerValue;
  }) {
    const s = VkAccelerationStructureInstanceKHR.alloc();
    if (data.transform !== undefined) s.transform = data.transform;
    if (data.instanceCustomIndex !== undefined) s.instanceCustomIndex = data.instanceCustomIndex;
    if (data.mask !== undefined) s.mask = data.mask;
    if (data.instanceShaderBindingTableRecordOffset !== undefined) s.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.accelerationStructureReference !== undefined) s.accelerationStructureReference = data.accelerationStructureReference;
    return s;
  }
  
  get transform() {
    return new VkTransformMatrixKHR(this.#data.subarray(0, 0 + VkTransformMatrixKHR.size));
  }
  
  set transform(value: VkTransformMatrixKHR) {
    if (value[BUFFER].byteLength < VkTransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(8, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(12, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkGeometryInstanceFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkAccelerationStructureDeviceAddressInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureDeviceAddressInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureDeviceAddressInfoKHR(new Uint8Array(VkAccelerationStructureDeviceAddressInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructure: VkAccelerationStructureKHR;
  }) {
    const s = VkAccelerationStructureDeviceAddressInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructure !== undefined) s.accelerationStructure = data.accelerationStructure;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAccelerationStructureVersionInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureVersionInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureVersionInfoKHR(new Uint8Array(VkAccelerationStructureVersionInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pVersionData: Deno.PointerValue;
  }) {
    const s = VkAccelerationStructureVersionInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pVersionData !== undefined) s.pVersionData = data.pVersionData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pVersionData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pVersionData(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkCopyAccelerationStructureInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyAccelerationStructureInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyAccelerationStructureInfoKHR(new Uint8Array(VkCopyAccelerationStructureInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkAccelerationStructureKHR;
    dst: VkAccelerationStructureKHR;
    mode: VkCopyAccelerationStructureModeKHR;
  }) {
    const s = VkCopyAccelerationStructureInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkCopyAccelerationStructureToMemoryInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyAccelerationStructureToMemoryInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyAccelerationStructureToMemoryInfoKHR(new Uint8Array(VkCopyAccelerationStructureToMemoryInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkAccelerationStructureKHR;
    dst: VkDeviceOrHostAddressKHR;
    mode: VkCopyAccelerationStructureModeKHR;
  }) {
    const s = VkCopyAccelerationStructureToMemoryInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dst() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set dst(value: VkDeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkCopyMemoryToAccelerationStructureInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMemoryToAccelerationStructureInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMemoryToAccelerationStructureInfoKHR(new Uint8Array(VkCopyMemoryToAccelerationStructureInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkDeviceOrHostAddressConstKHR;
    dst: VkAccelerationStructureKHR;
    mode: VkCopyAccelerationStructureModeKHR;
  }) {
    const s = VkCopyMemoryToAccelerationStructureInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set src(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkRayTracingPipelineInterfaceCreateInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRayTracingPipelineInterfaceCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRayTracingPipelineInterfaceCreateInfoKHR(new Uint8Array(VkRayTracingPipelineInterfaceCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxPipelineRayPayloadSize: number;
    maxPipelineRayHitAttributeSize: number;
  }) {
    const s = VkRayTracingPipelineInterfaceCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxPipelineRayPayloadSize !== undefined) s.maxPipelineRayPayloadSize = data.maxPipelineRayPayloadSize;
    if (data.maxPipelineRayHitAttributeSize !== undefined) s.maxPipelineRayHitAttributeSize = data.maxPipelineRayHitAttributeSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxPipelineRayPayloadSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPipelineRayPayloadSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxPipelineRayHitAttributeSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxPipelineRayHitAttributeSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPipelineLibraryCreateInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineLibraryCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineLibraryCreateInfoKHR(new Uint8Array(VkPipelineLibraryCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    libraryCount?: number;
    pLibraries: Deno.PointerValue;
  }) {
    const s = VkPipelineLibraryCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.libraryCount !== undefined) s.libraryCount = data.libraryCount;
    if (data.pLibraries !== undefined) s.pLibraries = data.pLibraries;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get libraryCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set libraryCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pLibraries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pLibraries(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceExtendedDynamicStateFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(new Uint8Array(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    extendedDynamicState: VkBool32;
  }) {
    const s = VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.extendedDynamicState !== undefined) s.extendedDynamicState = data.extendedDynamicState;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get extendedDynamicState() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceExtendedDynamicState2FeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(new Uint8Array(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    extendedDynamicState2: VkBool32;
    extendedDynamicState2LogicOp: VkBool32;
    extendedDynamicState2PatchControlPoints: VkBool32;
  }) {
    const s = VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.extendedDynamicState2 !== undefined) s.extendedDynamicState2 = data.extendedDynamicState2;
    if (data.extendedDynamicState2LogicOp !== undefined) s.extendedDynamicState2LogicOp = data.extendedDynamicState2LogicOp;
    if (data.extendedDynamicState2PatchControlPoints !== undefined) s.extendedDynamicState2PatchControlPoints = data.extendedDynamicState2PatchControlPoints;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get extendedDynamicState2() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState2(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get extendedDynamicState2LogicOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set extendedDynamicState2LogicOp(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extendedDynamicState2PatchControlPoints() {
    return this.#view.getUint32(24, LE);
  }
  
  set extendedDynamicState2PatchControlPoints(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceExtendedDynamicState3FeaturesEXT implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(new Uint8Array(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    extendedDynamicState3TessellationDomainOrigin: VkBool32;
    extendedDynamicState3DepthClampEnable: VkBool32;
    extendedDynamicState3PolygonMode: VkBool32;
    extendedDynamicState3RasterizationSamples: VkBool32;
    extendedDynamicState3SampleMask: VkBool32;
    extendedDynamicState3AlphaToCoverageEnable: VkBool32;
    extendedDynamicState3AlphaToOneEnable: VkBool32;
    extendedDynamicState3LogicOpEnable: VkBool32;
    extendedDynamicState3ColorBlendEnable: VkBool32;
    extendedDynamicState3ColorBlendEquation: VkBool32;
    extendedDynamicState3ColorWriteMask: VkBool32;
    extendedDynamicState3RasterizationStream: VkBool32;
    extendedDynamicState3ConservativeRasterizationMode: VkBool32;
    extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32;
    extendedDynamicState3DepthClipEnable: VkBool32;
    extendedDynamicState3SampleLocationsEnable: VkBool32;
    extendedDynamicState3ColorBlendAdvanced: VkBool32;
    extendedDynamicState3ProvokingVertexMode: VkBool32;
    extendedDynamicState3LineRasterizationMode: VkBool32;
    extendedDynamicState3LineStippleEnable: VkBool32;
    extendedDynamicState3DepthClipNegativeOneToOne: VkBool32;
    extendedDynamicState3ViewportWScalingEnable: VkBool32;
    extendedDynamicState3ViewportSwizzle: VkBool32;
    extendedDynamicState3CoverageToColorEnable: VkBool32;
    extendedDynamicState3CoverageToColorLocation: VkBool32;
    extendedDynamicState3CoverageModulationMode: VkBool32;
    extendedDynamicState3CoverageModulationTableEnable: VkBool32;
    extendedDynamicState3CoverageModulationTable: VkBool32;
    extendedDynamicState3CoverageReductionMode: VkBool32;
    extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32;
    extendedDynamicState3ShadingRateImageEnable: VkBool32;
  }) {
    const s = VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.extendedDynamicState3TessellationDomainOrigin !== undefined) s.extendedDynamicState3TessellationDomainOrigin = data.extendedDynamicState3TessellationDomainOrigin;
    if (data.extendedDynamicState3DepthClampEnable !== undefined) s.extendedDynamicState3DepthClampEnable = data.extendedDynamicState3DepthClampEnable;
    if (data.extendedDynamicState3PolygonMode !== undefined) s.extendedDynamicState3PolygonMode = data.extendedDynamicState3PolygonMode;
    if (data.extendedDynamicState3RasterizationSamples !== undefined) s.extendedDynamicState3RasterizationSamples = data.extendedDynamicState3RasterizationSamples;
    if (data.extendedDynamicState3SampleMask !== undefined) s.extendedDynamicState3SampleMask = data.extendedDynamicState3SampleMask;
    if (data.extendedDynamicState3AlphaToCoverageEnable !== undefined) s.extendedDynamicState3AlphaToCoverageEnable = data.extendedDynamicState3AlphaToCoverageEnable;
    if (data.extendedDynamicState3AlphaToOneEnable !== undefined) s.extendedDynamicState3AlphaToOneEnable = data.extendedDynamicState3AlphaToOneEnable;
    if (data.extendedDynamicState3LogicOpEnable !== undefined) s.extendedDynamicState3LogicOpEnable = data.extendedDynamicState3LogicOpEnable;
    if (data.extendedDynamicState3ColorBlendEnable !== undefined) s.extendedDynamicState3ColorBlendEnable = data.extendedDynamicState3ColorBlendEnable;
    if (data.extendedDynamicState3ColorBlendEquation !== undefined) s.extendedDynamicState3ColorBlendEquation = data.extendedDynamicState3ColorBlendEquation;
    if (data.extendedDynamicState3ColorWriteMask !== undefined) s.extendedDynamicState3ColorWriteMask = data.extendedDynamicState3ColorWriteMask;
    if (data.extendedDynamicState3RasterizationStream !== undefined) s.extendedDynamicState3RasterizationStream = data.extendedDynamicState3RasterizationStream;
    if (data.extendedDynamicState3ConservativeRasterizationMode !== undefined) s.extendedDynamicState3ConservativeRasterizationMode = data.extendedDynamicState3ConservativeRasterizationMode;
    if (data.extendedDynamicState3ExtraPrimitiveOverestimationSize !== undefined) s.extendedDynamicState3ExtraPrimitiveOverestimationSize = data.extendedDynamicState3ExtraPrimitiveOverestimationSize;
    if (data.extendedDynamicState3DepthClipEnable !== undefined) s.extendedDynamicState3DepthClipEnable = data.extendedDynamicState3DepthClipEnable;
    if (data.extendedDynamicState3SampleLocationsEnable !== undefined) s.extendedDynamicState3SampleLocationsEnable = data.extendedDynamicState3SampleLocationsEnable;
    if (data.extendedDynamicState3ColorBlendAdvanced !== undefined) s.extendedDynamicState3ColorBlendAdvanced = data.extendedDynamicState3ColorBlendAdvanced;
    if (data.extendedDynamicState3ProvokingVertexMode !== undefined) s.extendedDynamicState3ProvokingVertexMode = data.extendedDynamicState3ProvokingVertexMode;
    if (data.extendedDynamicState3LineRasterizationMode !== undefined) s.extendedDynamicState3LineRasterizationMode = data.extendedDynamicState3LineRasterizationMode;
    if (data.extendedDynamicState3LineStippleEnable !== undefined) s.extendedDynamicState3LineStippleEnable = data.extendedDynamicState3LineStippleEnable;
    if (data.extendedDynamicState3DepthClipNegativeOneToOne !== undefined) s.extendedDynamicState3DepthClipNegativeOneToOne = data.extendedDynamicState3DepthClipNegativeOneToOne;
    if (data.extendedDynamicState3ViewportWScalingEnable !== undefined) s.extendedDynamicState3ViewportWScalingEnable = data.extendedDynamicState3ViewportWScalingEnable;
    if (data.extendedDynamicState3ViewportSwizzle !== undefined) s.extendedDynamicState3ViewportSwizzle = data.extendedDynamicState3ViewportSwizzle;
    if (data.extendedDynamicState3CoverageToColorEnable !== undefined) s.extendedDynamicState3CoverageToColorEnable = data.extendedDynamicState3CoverageToColorEnable;
    if (data.extendedDynamicState3CoverageToColorLocation !== undefined) s.extendedDynamicState3CoverageToColorLocation = data.extendedDynamicState3CoverageToColorLocation;
    if (data.extendedDynamicState3CoverageModulationMode !== undefined) s.extendedDynamicState3CoverageModulationMode = data.extendedDynamicState3CoverageModulationMode;
    if (data.extendedDynamicState3CoverageModulationTableEnable !== undefined) s.extendedDynamicState3CoverageModulationTableEnable = data.extendedDynamicState3CoverageModulationTableEnable;
    if (data.extendedDynamicState3CoverageModulationTable !== undefined) s.extendedDynamicState3CoverageModulationTable = data.extendedDynamicState3CoverageModulationTable;
    if (data.extendedDynamicState3CoverageReductionMode !== undefined) s.extendedDynamicState3CoverageReductionMode = data.extendedDynamicState3CoverageReductionMode;
    if (data.extendedDynamicState3RepresentativeFragmentTestEnable !== undefined) s.extendedDynamicState3RepresentativeFragmentTestEnable = data.extendedDynamicState3RepresentativeFragmentTestEnable;
    if (data.extendedDynamicState3ShadingRateImageEnable !== undefined) s.extendedDynamicState3ShadingRateImageEnable = data.extendedDynamicState3ShadingRateImageEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get extendedDynamicState3TessellationDomainOrigin() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState3TessellationDomainOrigin(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClampEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set extendedDynamicState3DepthClampEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extendedDynamicState3PolygonMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set extendedDynamicState3PolygonMode(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get extendedDynamicState3RasterizationSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set extendedDynamicState3RasterizationSamples(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get extendedDynamicState3SampleMask() {
    return this.#view.getUint32(32, LE);
  }
  
  set extendedDynamicState3SampleMask(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get extendedDynamicState3AlphaToCoverageEnable() {
    return this.#view.getUint32(36, LE);
  }
  
  set extendedDynamicState3AlphaToCoverageEnable(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get extendedDynamicState3AlphaToOneEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set extendedDynamicState3AlphaToOneEnable(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get extendedDynamicState3LogicOpEnable() {
    return this.#view.getUint32(44, LE);
  }
  
  set extendedDynamicState3LogicOpEnable(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendEnable() {
    return this.#view.getUint32(48, LE);
  }
  
  set extendedDynamicState3ColorBlendEnable(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendEquation() {
    return this.#view.getUint32(52, LE);
  }
  
  set extendedDynamicState3ColorBlendEquation(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get extendedDynamicState3ColorWriteMask() {
    return this.#view.getUint32(56, LE);
  }
  
  set extendedDynamicState3ColorWriteMask(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get extendedDynamicState3RasterizationStream() {
    return this.#view.getUint32(60, LE);
  }
  
  set extendedDynamicState3RasterizationStream(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get extendedDynamicState3ConservativeRasterizationMode() {
    return this.#view.getUint32(64, LE);
  }
  
  set extendedDynamicState3ConservativeRasterizationMode(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get extendedDynamicState3ExtraPrimitiveOverestimationSize() {
    return this.#view.getUint32(68, LE);
  }
  
  set extendedDynamicState3ExtraPrimitiveOverestimationSize(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClipEnable() {
    return this.#view.getUint32(72, LE);
  }
  
  set extendedDynamicState3DepthClipEnable(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get extendedDynamicState3SampleLocationsEnable() {
    return this.#view.getUint32(76, LE);
  }
  
  set extendedDynamicState3SampleLocationsEnable(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendAdvanced() {
    return this.#view.getUint32(80, LE);
  }
  
  set extendedDynamicState3ColorBlendAdvanced(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get extendedDynamicState3ProvokingVertexMode() {
    return this.#view.getUint32(84, LE);
  }
  
  set extendedDynamicState3ProvokingVertexMode(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get extendedDynamicState3LineRasterizationMode() {
    return this.#view.getUint32(88, LE);
  }
  
  set extendedDynamicState3LineRasterizationMode(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get extendedDynamicState3LineStippleEnable() {
    return this.#view.getUint32(92, LE);
  }
  
  set extendedDynamicState3LineStippleEnable(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClipNegativeOneToOne() {
    return this.#view.getUint32(96, LE);
  }
  
  set extendedDynamicState3DepthClipNegativeOneToOne(value: VkBool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get extendedDynamicState3ViewportWScalingEnable() {
    return this.#view.getUint32(100, LE);
  }
  
  set extendedDynamicState3ViewportWScalingEnable(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get extendedDynamicState3ViewportSwizzle() {
    return this.#view.getUint32(104, LE);
  }
  
  set extendedDynamicState3ViewportSwizzle(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageToColorEnable() {
    return this.#view.getUint32(108, LE);
  }
  
  set extendedDynamicState3CoverageToColorEnable(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageToColorLocation() {
    return this.#view.getUint32(112, LE);
  }
  
  set extendedDynamicState3CoverageToColorLocation(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationMode() {
    return this.#view.getUint32(116, LE);
  }
  
  set extendedDynamicState3CoverageModulationMode(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationTableEnable() {
    return this.#view.getUint32(120, LE);
  }
  
  set extendedDynamicState3CoverageModulationTableEnable(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationTable() {
    return this.#view.getUint32(124, LE);
  }
  
  set extendedDynamicState3CoverageModulationTable(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageReductionMode() {
    return this.#view.getUint32(128, LE);
  }
  
  set extendedDynamicState3CoverageReductionMode(value: VkBool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get extendedDynamicState3RepresentativeFragmentTestEnable() {
    return this.#view.getUint32(132, LE);
  }
  
  set extendedDynamicState3RepresentativeFragmentTestEnable(value: VkBool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get extendedDynamicState3ShadingRateImageEnable() {
    return this.#view.getUint32(136, LE);
  }
  
  set extendedDynamicState3ShadingRateImageEnable(value: VkBool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
}

export class VkPhysicalDeviceExtendedDynamicState3PropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(new Uint8Array(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dynamicPrimitiveTopologyUnrestricted: VkBool32;
  }) {
    const s = VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dynamicPrimitiveTopologyUnrestricted !== undefined) s.dynamicPrimitiveTopologyUnrestricted = data.dynamicPrimitiveTopologyUnrestricted;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dynamicPrimitiveTopologyUnrestricted() {
    return this.#view.getUint32(16, LE);
  }
  
  set dynamicPrimitiveTopologyUnrestricted(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkColorBlendEquationEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkColorBlendEquationEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkColorBlendEquationEXT(new Uint8Array(VkColorBlendEquationEXT.size));
  }
  
  static create(data: {
    srcColorBlendFactor: VkBlendFactor;
    dstColorBlendFactor: VkBlendFactor;
    colorBlendOp: VkBlendOp;
    srcAlphaBlendFactor: VkBlendFactor;
    dstAlphaBlendFactor: VkBlendFactor;
    alphaBlendOp: VkBlendOp;
  }) {
    const s = VkColorBlendEquationEXT.alloc();
    if (data.srcColorBlendFactor !== undefined) s.srcColorBlendFactor = data.srcColorBlendFactor;
    if (data.dstColorBlendFactor !== undefined) s.dstColorBlendFactor = data.dstColorBlendFactor;
    if (data.colorBlendOp !== undefined) s.colorBlendOp = data.colorBlendOp;
    if (data.srcAlphaBlendFactor !== undefined) s.srcAlphaBlendFactor = data.srcAlphaBlendFactor;
    if (data.dstAlphaBlendFactor !== undefined) s.dstAlphaBlendFactor = data.dstAlphaBlendFactor;
    if (data.alphaBlendOp !== undefined) s.alphaBlendOp = data.alphaBlendOp;
    return s;
  }
  
  get srcColorBlendFactor() {
    return this.#view.getUint32(0, LE);
  }
  
  set srcColorBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstColorBlendFactor() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstColorBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get colorBlendOp() {
    return this.#view.getUint32(8, LE);
  }
  
  set colorBlendOp(value: VkBlendOp) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get srcAlphaBlendFactor() {
    return this.#view.getUint32(12, LE);
  }
  
  set srcAlphaBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get dstAlphaBlendFactor() {
    return this.#view.getUint32(16, LE);
  }
  
  set dstAlphaBlendFactor(value: VkBlendFactor) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get alphaBlendOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set alphaBlendOp(value: VkBlendOp) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkColorBlendAdvancedEXT implements IVkStructure {
  static size = 20;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkColorBlendAdvancedEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkColorBlendAdvancedEXT(new Uint8Array(VkColorBlendAdvancedEXT.size));
  }
  
  static create(data: {
    advancedBlendOp: VkBlendOp;
    srcPremultiplied: VkBool32;
    dstPremultiplied: VkBool32;
    blendOverlap: VkBlendOverlapEXT;
    clampResults: VkBool32;
  }) {
    const s = VkColorBlendAdvancedEXT.alloc();
    if (data.advancedBlendOp !== undefined) s.advancedBlendOp = data.advancedBlendOp;
    if (data.srcPremultiplied !== undefined) s.srcPremultiplied = data.srcPremultiplied;
    if (data.dstPremultiplied !== undefined) s.dstPremultiplied = data.dstPremultiplied;
    if (data.blendOverlap !== undefined) s.blendOverlap = data.blendOverlap;
    if (data.clampResults !== undefined) s.clampResults = data.clampResults;
    return s;
  }
  
  get advancedBlendOp() {
    return this.#view.getUint32(0, LE);
  }
  
  set advancedBlendOp(value: VkBlendOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get srcPremultiplied() {
    return this.#view.getUint32(4, LE);
  }
  
  set srcPremultiplied(value: VkBool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dstPremultiplied() {
    return this.#view.getUint32(8, LE);
  }
  
  set dstPremultiplied(value: VkBool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get blendOverlap() {
    return this.#view.getUint32(12, LE);
  }
  
  set blendOverlap(value: VkBlendOverlapEXT) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get clampResults() {
    return this.#view.getUint32(16, LE);
  }
  
  set clampResults(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkRenderPassTransformBeginInfoQCOM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassTransformBeginInfoQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassTransformBeginInfoQCOM(new Uint8Array(VkRenderPassTransformBeginInfoQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    transform: VkSurfaceTransformFlagBitsKHR;
  }) {
    const s = VkRenderPassTransformBeginInfoQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.transform !== undefined) s.transform = data.transform;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCopyCommandTransformInfoQCOM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyCommandTransformInfoQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyCommandTransformInfoQCOM(new Uint8Array(VkCopyCommandTransformInfoQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    transform: VkSurfaceTransformFlagBitsKHR;
  }) {
    const s = VkCopyCommandTransformInfoQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.transform !== undefined) s.transform = data.transform;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCommandBufferInheritanceRenderPassTransformInfoQCOM implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferInheritanceRenderPassTransformInfoQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferInheritanceRenderPassTransformInfoQCOM(new Uint8Array(VkCommandBufferInheritanceRenderPassTransformInfoQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    transform: VkSurfaceTransformFlagBitsKHR;
    renderArea: VkRect2D;
  }) {
    const s = VkCommandBufferInheritanceRenderPassTransformInfoQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.transform !== undefined) s.transform = data.transform;
    if (data.renderArea !== undefined) s.renderArea = data.renderArea;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: VkSurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderArea() {
    return new VkRect2D(this.#data.subarray(32, 32 + VkRect2D.size));
  }
  
  set renderArea(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkPhysicalDeviceDiagnosticsConfigFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDiagnosticsConfigFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDiagnosticsConfigFeaturesNV(new Uint8Array(VkPhysicalDeviceDiagnosticsConfigFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    diagnosticsConfig: VkBool32;
  }) {
    const s = VkPhysicalDeviceDiagnosticsConfigFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.diagnosticsConfig !== undefined) s.diagnosticsConfig = data.diagnosticsConfig;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get diagnosticsConfig() {
    return this.#view.getUint32(16, LE);
  }
  
  set diagnosticsConfig(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceDiagnosticsConfigCreateInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceDiagnosticsConfigCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceDiagnosticsConfigCreateInfoNV(new Uint8Array(VkDeviceDiagnosticsConfigCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDeviceDiagnosticsConfigFlagsNV;
  }) {
    const s = VkDeviceDiagnosticsConfigCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceDiagnosticsConfigFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(new Uint8Array(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderZeroInitializeWorkgroupMemory: VkBool32;
  }) {
    const s = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderZeroInitializeWorkgroupMemory !== undefined) s.shaderZeroInitializeWorkgroupMemory = data.shaderZeroInitializeWorkgroupMemory;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderZeroInitializeWorkgroupMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderZeroInitializeWorkgroupMemory(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(new Uint8Array(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderSubgroupUniformControlFlow: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderSubgroupUniformControlFlow !== undefined) s.shaderSubgroupUniformControlFlow = data.shaderSubgroupUniformControlFlow;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderSubgroupUniformControlFlow() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupUniformControlFlow(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceRobustness2FeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRobustness2FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRobustness2FeaturesEXT(new Uint8Array(VkPhysicalDeviceRobustness2FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    robustBufferAccess2: VkBool32;
    robustImageAccess2: VkBool32;
    nullDescriptor: VkBool32;
  }) {
    const s = VkPhysicalDeviceRobustness2FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.robustBufferAccess2 !== undefined) s.robustBufferAccess2 = data.robustBufferAccess2;
    if (data.robustImageAccess2 !== undefined) s.robustImageAccess2 = data.robustImageAccess2;
    if (data.nullDescriptor !== undefined) s.nullDescriptor = data.nullDescriptor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get robustBufferAccess2() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustBufferAccess2(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get robustImageAccess2() {
    return this.#view.getUint32(20, LE);
  }
  
  set robustImageAccess2(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get nullDescriptor() {
    return this.#view.getUint32(24, LE);
  }
  
  set nullDescriptor(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceRobustness2PropertiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRobustness2PropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRobustness2PropertiesEXT(new Uint8Array(VkPhysicalDeviceRobustness2PropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    robustStorageBufferAccessSizeAlignment: VkDeviceSize;
    robustUniformBufferAccessSizeAlignment: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceRobustness2PropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.robustStorageBufferAccessSizeAlignment !== undefined) s.robustStorageBufferAccessSizeAlignment = data.robustStorageBufferAccessSizeAlignment;
    if (data.robustUniformBufferAccessSizeAlignment !== undefined) s.robustUniformBufferAccessSizeAlignment = data.robustUniformBufferAccessSizeAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get robustStorageBufferAccessSizeAlignment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set robustStorageBufferAccessSizeAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get robustUniformBufferAccessSizeAlignment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set robustUniformBufferAccessSizeAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceImageRobustnessFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageRobustnessFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageRobustnessFeatures(new Uint8Array(VkPhysicalDeviceImageRobustnessFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    robustImageAccess: VkBool32;
  }) {
    const s = VkPhysicalDeviceImageRobustnessFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.robustImageAccess !== undefined) s.robustImageAccess = data.robustImageAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get robustImageAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustImageAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(new Uint8Array(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    workgroupMemoryExplicitLayout: VkBool32;
    workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32;
    workgroupMemoryExplicitLayout8BitAccess: VkBool32;
    workgroupMemoryExplicitLayout16BitAccess: VkBool32;
  }) {
    const s = VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.workgroupMemoryExplicitLayout !== undefined) s.workgroupMemoryExplicitLayout = data.workgroupMemoryExplicitLayout;
    if (data.workgroupMemoryExplicitLayoutScalarBlockLayout !== undefined) s.workgroupMemoryExplicitLayoutScalarBlockLayout = data.workgroupMemoryExplicitLayoutScalarBlockLayout;
    if (data.workgroupMemoryExplicitLayout8BitAccess !== undefined) s.workgroupMemoryExplicitLayout8BitAccess = data.workgroupMemoryExplicitLayout8BitAccess;
    if (data.workgroupMemoryExplicitLayout16BitAccess !== undefined) s.workgroupMemoryExplicitLayout16BitAccess = data.workgroupMemoryExplicitLayout16BitAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get workgroupMemoryExplicitLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set workgroupMemoryExplicitLayout(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayoutScalarBlockLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set workgroupMemoryExplicitLayoutScalarBlockLayout(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayout8BitAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set workgroupMemoryExplicitLayout8BitAccess(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayout16BitAccess() {
    return this.#view.getUint32(28, LE);
  }
  
  set workgroupMemoryExplicitLayout16BitAccess(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDevicePortabilitySubsetFeaturesKHR implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePortabilitySubsetFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePortabilitySubsetFeaturesKHR(new Uint8Array(VkPhysicalDevicePortabilitySubsetFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    constantAlphaColorBlendFactors: VkBool32;
    events: VkBool32;
    imageViewFormatReinterpretation: VkBool32;
    imageViewFormatSwizzle: VkBool32;
    imageView2DOn3DImage: VkBool32;
    multisampleArrayImage: VkBool32;
    mutableComparisonSamplers: VkBool32;
    pointPolygons: VkBool32;
    samplerMipLodBias: VkBool32;
    separateStencilMaskRef: VkBool32;
    shaderSampleRateInterpolationFunctions: VkBool32;
    tessellationIsolines: VkBool32;
    tessellationPointMode: VkBool32;
    triangleFans: VkBool32;
    vertexAttributeAccessBeyondStride: VkBool32;
  }) {
    const s = VkPhysicalDevicePortabilitySubsetFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.constantAlphaColorBlendFactors !== undefined) s.constantAlphaColorBlendFactors = data.constantAlphaColorBlendFactors;
    if (data.events !== undefined) s.events = data.events;
    if (data.imageViewFormatReinterpretation !== undefined) s.imageViewFormatReinterpretation = data.imageViewFormatReinterpretation;
    if (data.imageViewFormatSwizzle !== undefined) s.imageViewFormatSwizzle = data.imageViewFormatSwizzle;
    if (data.imageView2DOn3DImage !== undefined) s.imageView2DOn3DImage = data.imageView2DOn3DImage;
    if (data.multisampleArrayImage !== undefined) s.multisampleArrayImage = data.multisampleArrayImage;
    if (data.mutableComparisonSamplers !== undefined) s.mutableComparisonSamplers = data.mutableComparisonSamplers;
    if (data.pointPolygons !== undefined) s.pointPolygons = data.pointPolygons;
    if (data.samplerMipLodBias !== undefined) s.samplerMipLodBias = data.samplerMipLodBias;
    if (data.separateStencilMaskRef !== undefined) s.separateStencilMaskRef = data.separateStencilMaskRef;
    if (data.shaderSampleRateInterpolationFunctions !== undefined) s.shaderSampleRateInterpolationFunctions = data.shaderSampleRateInterpolationFunctions;
    if (data.tessellationIsolines !== undefined) s.tessellationIsolines = data.tessellationIsolines;
    if (data.tessellationPointMode !== undefined) s.tessellationPointMode = data.tessellationPointMode;
    if (data.triangleFans !== undefined) s.triangleFans = data.triangleFans;
    if (data.vertexAttributeAccessBeyondStride !== undefined) s.vertexAttributeAccessBeyondStride = data.vertexAttributeAccessBeyondStride;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get constantAlphaColorBlendFactors() {
    return this.#view.getUint32(16, LE);
  }
  
  set constantAlphaColorBlendFactors(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get events() {
    return this.#view.getUint32(20, LE);
  }
  
  set events(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get imageViewFormatReinterpretation() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageViewFormatReinterpretation(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get imageViewFormatSwizzle() {
    return this.#view.getUint32(28, LE);
  }
  
  set imageViewFormatSwizzle(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get imageView2DOn3DImage() {
    return this.#view.getUint32(32, LE);
  }
  
  set imageView2DOn3DImage(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multisampleArrayImage() {
    return this.#view.getUint32(36, LE);
  }
  
  set multisampleArrayImage(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get mutableComparisonSamplers() {
    return this.#view.getUint32(40, LE);
  }
  
  set mutableComparisonSamplers(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pointPolygons() {
    return this.#view.getUint32(44, LE);
  }
  
  set pointPolygons(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get samplerMipLodBias() {
    return this.#view.getUint32(48, LE);
  }
  
  set samplerMipLodBias(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get separateStencilMaskRef() {
    return this.#view.getUint32(52, LE);
  }
  
  set separateStencilMaskRef(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderSampleRateInterpolationFunctions() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderSampleRateInterpolationFunctions(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get tessellationIsolines() {
    return this.#view.getUint32(60, LE);
  }
  
  set tessellationIsolines(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get tessellationPointMode() {
    return this.#view.getUint32(64, LE);
  }
  
  set tessellationPointMode(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get triangleFans() {
    return this.#view.getUint32(68, LE);
  }
  
  set triangleFans(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get vertexAttributeAccessBeyondStride() {
    return this.#view.getUint32(72, LE);
  }
  
  set vertexAttributeAccessBeyondStride(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
}

export class VkPhysicalDevicePortabilitySubsetPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePortabilitySubsetPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePortabilitySubsetPropertiesKHR(new Uint8Array(VkPhysicalDevicePortabilitySubsetPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minVertexInputBindingStrideAlignment: number;
  }) {
    const s = VkPhysicalDevicePortabilitySubsetPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minVertexInputBindingStrideAlignment !== undefined) s.minVertexInputBindingStrideAlignment = data.minVertexInputBindingStrideAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minVertexInputBindingStrideAlignment() {
    return this.#view.getUint32(16, LE);
  }
  
  set minVertexInputBindingStrideAlignment(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevice4444FormatsFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevice4444FormatsFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevice4444FormatsFeaturesEXT(new Uint8Array(VkPhysicalDevice4444FormatsFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    formatA4R4G4B4: VkBool32;
    formatA4B4G4R4: VkBool32;
  }) {
    const s = VkPhysicalDevice4444FormatsFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.formatA4R4G4B4 !== undefined) s.formatA4R4G4B4 = data.formatA4R4G4B4;
    if (data.formatA4B4G4R4 !== undefined) s.formatA4B4G4R4 = data.formatA4B4G4R4;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get formatA4R4G4B4() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatA4R4G4B4(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get formatA4B4G4R4() {
    return this.#view.getUint32(20, LE);
  }
  
  set formatA4B4G4R4(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceSubpassShadingFeaturesHUAWEI implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(new Uint8Array(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subpassShading: VkBool32;
  }) {
    const s = VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subpassShading !== undefined) s.subpassShading = data.subpassShading;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subpassShading() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassShading(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkBufferCopy2 implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCopy2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCopy2(new Uint8Array(VkBufferCopy2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcOffset: VkDeviceSize;
    dstOffset: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkBufferCopy2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COPY_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dstOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImageCopy2 implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCopy2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCopy2(new Uint8Array(VkImageCopy2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D;
    extent: VkExtent3D;
  }) {
    const s = VkImageCopy2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COPY_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.extent !== undefined) s.extent = data.extent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(16, 16 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffset() {
    return new VkOffset3D(this.#data.subarray(36, 36 + VkOffset3D.size));
  }
  
  set srcOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffset() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(84, 84 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 84);
  }
}

export class VkImageBlit2 implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageBlit2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageBlit2(new Uint8Array(VkImageBlit2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcSubresource: VkImageSubresourceLayers;
    srcOffsets: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffsets: VkOffset3D;
  }) {
    const s = VkImageBlit2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_BLIT_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffsets !== undefined) s.srcOffsets = data.srcOffsets;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffsets !== undefined) s.dstOffsets = data.dstOffsets;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(16, 16 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffsets() {
    return new VkOffset3D(this.#data.subarray(36, 36 + VkOffset3D.size));
  }
  
  set srcOffsets(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffsets() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffsets(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export class VkBufferImageCopy2 implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferImageCopy2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferImageCopy2(new Uint8Array(VkBufferImageCopy2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    bufferOffset: VkDeviceSize;
    bufferRowLength: number;
    bufferImageHeight: number;
    imageSubresource: VkImageSubresourceLayers;
    imageOffset: VkOffset3D;
    imageExtent: VkExtent3D;
  }) {
    const s = VkBufferImageCopy2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.bufferOffset !== undefined) s.bufferOffset = data.bufferOffset;
    if (data.bufferRowLength !== undefined) s.bufferRowLength = data.bufferRowLength;
    if (data.bufferImageHeight !== undefined) s.bufferImageHeight = data.bufferImageHeight;
    if (data.imageSubresource !== undefined) s.imageSubresource = data.imageSubresource;
    if (data.imageOffset !== undefined) s.imageOffset = data.imageOffset;
    if (data.imageExtent !== undefined) s.imageExtent = data.imageExtent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get bufferOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set bufferOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(28, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get imageSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(32, 32 + VkImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get imageOffset() {
    return new VkOffset3D(this.#data.subarray(48, 48 + VkOffset3D.size));
  }
  
  set imageOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get imageExtent() {
    return new VkExtent3D(this.#data.subarray(60, 60 + VkExtent3D.size));
  }
  
  set imageExtent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
}

export class VkImageResolve2 implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageResolve2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageResolve2(new Uint8Array(VkImageResolve2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D;
    extent: VkExtent3D;
  }) {
    const s = VkImageResolve2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcSubresource !== undefined) s.srcSubresource = data.srcSubresource;
    if (data.srcOffset !== undefined) s.srcOffset = data.srcOffset;
    if (data.dstSubresource !== undefined) s.dstSubresource = data.dstSubresource;
    if (data.dstOffset !== undefined) s.dstOffset = data.dstOffset;
    if (data.extent !== undefined) s.extent = data.extent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(16, 16 + VkImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffset() {
    return new VkOffset3D(this.#data.subarray(36, 36 + VkOffset3D.size));
  }
  
  set srcOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get dstSubresource() {
    return new VkImageSubresourceLayers(this.#data.subarray(48, 48 + VkImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: VkImageSubresourceLayers) {
    if (value[BUFFER].byteLength < VkImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get dstOffset() {
    return new VkOffset3D(this.#data.subarray(72, 72 + VkOffset3D.size));
  }
  
  set dstOffset(value: VkOffset3D) {
    if (value[BUFFER].byteLength < VkOffset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get extent() {
    return new VkExtent3D(this.#data.subarray(84, 84 + VkExtent3D.size));
  }
  
  set extent(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 84);
  }
}

export class VkCopyBufferInfo2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyBufferInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyBufferInfo2(new Uint8Array(VkCopyBufferInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcBuffer: VkBuffer;
    dstBuffer: VkBuffer;
    regionCount: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkCopyBufferInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcBuffer !== undefined) s.srcBuffer = data.srcBuffer;
    if (data.dstBuffer !== undefined) s.dstBuffer = data.dstBuffer;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcBuffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dstBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstBuffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkCopyImageInfo2 implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyImageInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyImageInfo2(new Uint8Array(VkCopyImageInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcImage: VkImage;
    srcImageLayout: VkImageLayout;
    dstImage: VkImage;
    dstImageLayout: VkImageLayout;
    regionCount: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkCopyImageInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcImage !== undefined) s.srcImage = data.srcImage;
    if (data.srcImageLayout !== undefined) s.srcImageLayout = data.srcImageLayout;
    if (data.dstImage !== undefined) s.dstImage = data.dstImage;
    if (data.dstImageLayout !== undefined) s.dstImageLayout = data.dstImageLayout;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: VkImage) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: VkImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkBlitImageInfo2 implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBlitImageInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBlitImageInfo2(new Uint8Array(VkBlitImageInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcImage: VkImage;
    srcImageLayout: VkImageLayout;
    dstImage: VkImage;
    dstImageLayout: VkImageLayout;
    regionCount: number;
    pRegions: Deno.PointerValue;
    filter: VkFilter;
  }) {
    const s = VkBlitImageInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcImage !== undefined) s.srcImage = data.srcImage;
    if (data.srcImageLayout !== undefined) s.srcImageLayout = data.srcImageLayout;
    if (data.dstImage !== undefined) s.dstImage = data.dstImage;
    if (data.dstImageLayout !== undefined) s.dstImageLayout = data.dstImageLayout;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    if (data.filter !== undefined) s.filter = data.filter;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: VkImage) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: VkImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get filter() {
    return this.#view.getUint32(56, LE);
  }
  
  set filter(value: VkFilter) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkCopyBufferToImageInfo2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyBufferToImageInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyBufferToImageInfo2(new Uint8Array(VkCopyBufferToImageInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcBuffer: VkBuffer;
    dstImage: VkImage;
    dstImageLayout: VkImageLayout;
    regionCount: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkCopyBufferToImageInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcBuffer !== undefined) s.srcBuffer = data.srcBuffer;
    if (data.dstImage !== undefined) s.dstImage = data.dstImage;
    if (data.dstImageLayout !== undefined) s.dstImageLayout = data.dstImageLayout;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcBuffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstImage(value: VkImage) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(32, LE);
  }
  
  set dstImageLayout(value: VkImageLayout) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkCopyImageToBufferInfo2 implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyImageToBufferInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyImageToBufferInfo2(new Uint8Array(VkCopyImageToBufferInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcImage: VkImage;
    srcImageLayout: VkImageLayout;
    dstBuffer: VkBuffer;
    regionCount: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkCopyImageToBufferInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcImage !== undefined) s.srcImage = data.srcImage;
    if (data.srcImageLayout !== undefined) s.srcImageLayout = data.srcImageLayout;
    if (data.dstBuffer !== undefined) s.dstBuffer = data.dstBuffer;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstBuffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstBuffer(value: VkBuffer) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkResolveImageInfo2 implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkResolveImageInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkResolveImageInfo2(new Uint8Array(VkResolveImageInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcImage: VkImage;
    srcImageLayout: VkImageLayout;
    dstImage: VkImage;
    dstImageLayout: VkImageLayout;
    regionCount: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkResolveImageInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcImage !== undefined) s.srcImage = data.srcImage;
    if (data.srcImageLayout !== undefined) s.srcImageLayout = data.srcImageLayout;
    if (data.dstImage !== undefined) s.dstImage = data.dstImage;
    if (data.dstImageLayout !== undefined) s.dstImageLayout = data.dstImageLayout;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: VkImage) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: VkImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(new Uint8Array(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderImageInt64Atomics: VkBool32;
    sparseImageInt64Atomics: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderImageInt64Atomics !== undefined) s.shaderImageInt64Atomics = data.shaderImageInt64Atomics;
    if (data.sparseImageInt64Atomics !== undefined) s.sparseImageInt64Atomics = data.sparseImageInt64Atomics;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderImageInt64Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderImageInt64Atomics(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sparseImageInt64Atomics() {
    return this.#view.getUint32(20, LE);
  }
  
  set sparseImageInt64Atomics(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkFragmentShadingRateAttachmentInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFragmentShadingRateAttachmentInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFragmentShadingRateAttachmentInfoKHR(new Uint8Array(VkFragmentShadingRateAttachmentInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pFragmentShadingRateAttachment?: Deno.PointerValue;
    shadingRateAttachmentTexelSize: VkExtent2D;
  }) {
    const s = VkFragmentShadingRateAttachmentInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pFragmentShadingRateAttachment !== undefined) s.pFragmentShadingRateAttachment = data.pFragmentShadingRateAttachment;
    if (data.shadingRateAttachmentTexelSize !== undefined) s.shadingRateAttachmentTexelSize = data.shadingRateAttachmentTexelSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pFragmentShadingRateAttachment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pFragmentShadingRateAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get shadingRateAttachmentTexelSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set shadingRateAttachmentTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPipelineFragmentShadingRateStateCreateInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineFragmentShadingRateStateCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineFragmentShadingRateStateCreateInfoKHR(new Uint8Array(VkPipelineFragmentShadingRateStateCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentSize: VkExtent2D;
    combinerOps: VkFragmentShadingRateCombinerOpKHR;
  }) {
    const s = VkPipelineFragmentShadingRateStateCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentSize !== undefined) s.fragmentSize = data.fragmentSize;
    if (data.combinerOps !== undefined) s.combinerOps = data.combinerOps;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentSize() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set fragmentSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get combinerOps() {
    return this.#view.getUint32(24, LE);
  }
  
  set combinerOps(value: VkFragmentShadingRateCombinerOpKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShadingRateFeaturesKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShadingRateFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShadingRateFeaturesKHR(new Uint8Array(VkPhysicalDeviceFragmentShadingRateFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineFragmentShadingRate: VkBool32;
    primitiveFragmentShadingRate: VkBool32;
    attachmentFragmentShadingRate: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShadingRateFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineFragmentShadingRate !== undefined) s.pipelineFragmentShadingRate = data.pipelineFragmentShadingRate;
    if (data.primitiveFragmentShadingRate !== undefined) s.primitiveFragmentShadingRate = data.primitiveFragmentShadingRate;
    if (data.attachmentFragmentShadingRate !== undefined) s.attachmentFragmentShadingRate = data.attachmentFragmentShadingRate;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineFragmentShadingRate() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineFragmentShadingRate(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitiveFragmentShadingRate() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitiveFragmentShadingRate(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get attachmentFragmentShadingRate() {
    return this.#view.getUint32(24, LE);
  }
  
  set attachmentFragmentShadingRate(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShadingRatePropertiesKHR implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShadingRatePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShadingRatePropertiesKHR(new Uint8Array(VkPhysicalDeviceFragmentShadingRatePropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minFragmentShadingRateAttachmentTexelSize: VkExtent2D;
    maxFragmentShadingRateAttachmentTexelSize: VkExtent2D;
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: number;
    primitiveFragmentShadingRateWithMultipleViewports: VkBool32;
    layeredShadingRateAttachments: VkBool32;
    fragmentShadingRateNonTrivialCombinerOps: VkBool32;
    maxFragmentSize: VkExtent2D;
    maxFragmentSizeAspectRatio: number;
    maxFragmentShadingRateCoverageSamples: number;
    maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits;
    fragmentShadingRateWithShaderDepthStencilWrites: VkBool32;
    fragmentShadingRateWithSampleMask: VkBool32;
    fragmentShadingRateWithShaderSampleMask: VkBool32;
    fragmentShadingRateWithConservativeRasterization: VkBool32;
    fragmentShadingRateWithFragmentShaderInterlock: VkBool32;
    fragmentShadingRateWithCustomSampleLocations: VkBool32;
    fragmentShadingRateStrictMultiplyCombiner: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShadingRatePropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minFragmentShadingRateAttachmentTexelSize !== undefined) s.minFragmentShadingRateAttachmentTexelSize = data.minFragmentShadingRateAttachmentTexelSize;
    if (data.maxFragmentShadingRateAttachmentTexelSize !== undefined) s.maxFragmentShadingRateAttachmentTexelSize = data.maxFragmentShadingRateAttachmentTexelSize;
    if (data.maxFragmentShadingRateAttachmentTexelSizeAspectRatio !== undefined) s.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = data.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
    if (data.primitiveFragmentShadingRateWithMultipleViewports !== undefined) s.primitiveFragmentShadingRateWithMultipleViewports = data.primitiveFragmentShadingRateWithMultipleViewports;
    if (data.layeredShadingRateAttachments !== undefined) s.layeredShadingRateAttachments = data.layeredShadingRateAttachments;
    if (data.fragmentShadingRateNonTrivialCombinerOps !== undefined) s.fragmentShadingRateNonTrivialCombinerOps = data.fragmentShadingRateNonTrivialCombinerOps;
    if (data.maxFragmentSize !== undefined) s.maxFragmentSize = data.maxFragmentSize;
    if (data.maxFragmentSizeAspectRatio !== undefined) s.maxFragmentSizeAspectRatio = data.maxFragmentSizeAspectRatio;
    if (data.maxFragmentShadingRateCoverageSamples !== undefined) s.maxFragmentShadingRateCoverageSamples = data.maxFragmentShadingRateCoverageSamples;
    if (data.maxFragmentShadingRateRasterizationSamples !== undefined) s.maxFragmentShadingRateRasterizationSamples = data.maxFragmentShadingRateRasterizationSamples;
    if (data.fragmentShadingRateWithShaderDepthStencilWrites !== undefined) s.fragmentShadingRateWithShaderDepthStencilWrites = data.fragmentShadingRateWithShaderDepthStencilWrites;
    if (data.fragmentShadingRateWithSampleMask !== undefined) s.fragmentShadingRateWithSampleMask = data.fragmentShadingRateWithSampleMask;
    if (data.fragmentShadingRateWithShaderSampleMask !== undefined) s.fragmentShadingRateWithShaderSampleMask = data.fragmentShadingRateWithShaderSampleMask;
    if (data.fragmentShadingRateWithConservativeRasterization !== undefined) s.fragmentShadingRateWithConservativeRasterization = data.fragmentShadingRateWithConservativeRasterization;
    if (data.fragmentShadingRateWithFragmentShaderInterlock !== undefined) s.fragmentShadingRateWithFragmentShaderInterlock = data.fragmentShadingRateWithFragmentShaderInterlock;
    if (data.fragmentShadingRateWithCustomSampleLocations !== undefined) s.fragmentShadingRateWithCustomSampleLocations = data.fragmentShadingRateWithCustomSampleLocations;
    if (data.fragmentShadingRateStrictMultiplyCombiner !== undefined) s.fragmentShadingRateStrictMultiplyCombiner = data.fragmentShadingRateStrictMultiplyCombiner;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minFragmentShadingRateAttachmentTexelSize() {
    return new VkExtent2D(this.#data.subarray(16, 16 + VkExtent2D.size));
  }
  
  set minFragmentShadingRateAttachmentTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxFragmentShadingRateAttachmentTexelSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set maxFragmentShadingRateAttachmentTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxFragmentShadingRateAttachmentTexelSizeAspectRatio() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxFragmentShadingRateAttachmentTexelSizeAspectRatio(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get primitiveFragmentShadingRateWithMultipleViewports() {
    return this.#view.getUint32(36, LE);
  }
  
  set primitiveFragmentShadingRateWithMultipleViewports(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get layeredShadingRateAttachments() {
    return this.#view.getUint32(40, LE);
  }
  
  set layeredShadingRateAttachments(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get fragmentShadingRateNonTrivialCombinerOps() {
    return this.#view.getUint32(44, LE);
  }
  
  set fragmentShadingRateNonTrivialCombinerOps(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxFragmentSize() {
    return new VkExtent2D(this.#data.subarray(48, 48 + VkExtent2D.size));
  }
  
  set maxFragmentSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get maxFragmentSizeAspectRatio() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxFragmentSizeAspectRatio(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxFragmentShadingRateCoverageSamples() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxFragmentShadingRateCoverageSamples(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxFragmentShadingRateRasterizationSamples() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxFragmentShadingRateRasterizationSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get fragmentShadingRateWithShaderDepthStencilWrites() {
    return this.#view.getUint32(68, LE);
  }
  
  set fragmentShadingRateWithShaderDepthStencilWrites(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get fragmentShadingRateWithSampleMask() {
    return this.#view.getUint32(72, LE);
  }
  
  set fragmentShadingRateWithSampleMask(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get fragmentShadingRateWithShaderSampleMask() {
    return this.#view.getUint32(76, LE);
  }
  
  set fragmentShadingRateWithShaderSampleMask(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get fragmentShadingRateWithConservativeRasterization() {
    return this.#view.getUint32(80, LE);
  }
  
  set fragmentShadingRateWithConservativeRasterization(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get fragmentShadingRateWithFragmentShaderInterlock() {
    return this.#view.getUint32(84, LE);
  }
  
  set fragmentShadingRateWithFragmentShaderInterlock(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get fragmentShadingRateWithCustomSampleLocations() {
    return this.#view.getUint32(88, LE);
  }
  
  set fragmentShadingRateWithCustomSampleLocations(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get fragmentShadingRateStrictMultiplyCombiner() {
    return this.#view.getUint32(92, LE);
  }
  
  set fragmentShadingRateStrictMultiplyCombiner(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShadingRateKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShadingRateKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShadingRateKHR(new Uint8Array(VkPhysicalDeviceFragmentShadingRateKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampleCounts: VkSampleCountFlags;
    fragmentSize: VkExtent2D;
  }) {
    const s = VkPhysicalDeviceFragmentShadingRateKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampleCounts !== undefined) s.sampleCounts = data.sampleCounts;
    if (data.fragmentSize !== undefined) s.fragmentSize = data.fragmentSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampleCounts() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleCounts(value: VkSampleCountFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set fragmentSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkPhysicalDeviceShaderTerminateInvocationFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderTerminateInvocationFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderTerminateInvocationFeatures(new Uint8Array(VkPhysicalDeviceShaderTerminateInvocationFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderTerminateInvocation: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderTerminateInvocationFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderTerminateInvocation !== undefined) s.shaderTerminateInvocation = data.shaderTerminateInvocation;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderTerminateInvocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderTerminateInvocation(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(new Uint8Array(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentShadingRateEnums: VkBool32;
    supersampleFragmentShadingRates: VkBool32;
    noInvocationFragmentShadingRates: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentShadingRateEnums !== undefined) s.fragmentShadingRateEnums = data.fragmentShadingRateEnums;
    if (data.supersampleFragmentShadingRates !== undefined) s.supersampleFragmentShadingRates = data.supersampleFragmentShadingRates;
    if (data.noInvocationFragmentShadingRates !== undefined) s.noInvocationFragmentShadingRates = data.noInvocationFragmentShadingRates;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentShadingRateEnums() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShadingRateEnums(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supersampleFragmentShadingRates() {
    return this.#view.getUint32(20, LE);
  }
  
  set supersampleFragmentShadingRates(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get noInvocationFragmentShadingRates() {
    return this.#view.getUint32(24, LE);
  }
  
  set noInvocationFragmentShadingRates(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(new Uint8Array(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits;
  }) {
    const s = VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxFragmentShadingRateInvocationCount !== undefined) s.maxFragmentShadingRateInvocationCount = data.maxFragmentShadingRateInvocationCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxFragmentShadingRateInvocationCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxFragmentShadingRateInvocationCount(value: VkSampleCountFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineFragmentShadingRateEnumStateCreateInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineFragmentShadingRateEnumStateCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineFragmentShadingRateEnumStateCreateInfoNV(new Uint8Array(VkPipelineFragmentShadingRateEnumStateCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shadingRateType: VkFragmentShadingRateTypeNV;
    shadingRate: VkFragmentShadingRateNV;
    combinerOps: VkFragmentShadingRateCombinerOpKHR;
  }) {
    const s = VkPipelineFragmentShadingRateEnumStateCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shadingRateType !== undefined) s.shadingRateType = data.shadingRateType;
    if (data.shadingRate !== undefined) s.shadingRate = data.shadingRate;
    if (data.combinerOps !== undefined) s.combinerOps = data.combinerOps;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shadingRateType() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateType(value: VkFragmentShadingRateTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shadingRate() {
    return this.#view.getUint32(20, LE);
  }
  
  set shadingRate(value: VkFragmentShadingRateNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get combinerOps() {
    return this.#view.getUint32(24, LE);
  }
  
  set combinerOps(value: VkFragmentShadingRateCombinerOpKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkAccelerationStructureBuildSizesInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureBuildSizesInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureBuildSizesInfoKHR(new Uint8Array(VkAccelerationStructureBuildSizesInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructureSize: VkDeviceSize;
    updateScratchSize: VkDeviceSize;
    buildScratchSize: VkDeviceSize;
  }) {
    const s = VkAccelerationStructureBuildSizesInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructureSize !== undefined) s.accelerationStructureSize = data.accelerationStructureSize;
    if (data.updateScratchSize !== undefined) s.updateScratchSize = data.updateScratchSize;
    if (data.buildScratchSize !== undefined) s.buildScratchSize = data.buildScratchSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructureSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructureSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get updateScratchSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set updateScratchSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get buildScratchSize() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set buildScratchSize(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceImage2DViewOf3DFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(new Uint8Array(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image2DViewOf3D: VkBool32;
    sampler2DViewOf3D: VkBool32;
  }) {
    const s = VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image2DViewOf3D !== undefined) s.image2DViewOf3D = data.image2DViewOf3D;
    if (data.sampler2DViewOf3D !== undefined) s.sampler2DViewOf3D = data.sampler2DViewOf3D;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image2DViewOf3D() {
    return this.#view.getUint32(16, LE);
  }
  
  set image2DViewOf3D(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampler2DViewOf3D() {
    return this.#view.getUint32(20, LE);
  }
  
  set sampler2DViewOf3D(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(new Uint8Array(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mutableDescriptorType: VkBool32;
  }) {
    const s = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mutableDescriptorType !== undefined) s.mutableDescriptorType = data.mutableDescriptorType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mutableDescriptorType() {
    return this.#view.getUint32(16, LE);
  }
  
  set mutableDescriptorType(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMutableDescriptorTypeListEXT implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMutableDescriptorTypeListEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMutableDescriptorTypeListEXT(new Uint8Array(VkMutableDescriptorTypeListEXT.size));
  }
  
  static create(data: {
    descriptorTypeCount?: number;
    pDescriptorTypes: Deno.PointerValue;
  }) {
    const s = VkMutableDescriptorTypeListEXT.alloc();
    if (data.descriptorTypeCount !== undefined) s.descriptorTypeCount = data.descriptorTypeCount;
    if (data.pDescriptorTypes !== undefined) s.pDescriptorTypes = data.pDescriptorTypes;
    return s;
  }
  
  get descriptorTypeCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set descriptorTypeCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pDescriptorTypes() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pDescriptorTypes(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkMutableDescriptorTypeCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMutableDescriptorTypeCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMutableDescriptorTypeCreateInfoEXT(new Uint8Array(VkMutableDescriptorTypeCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mutableDescriptorTypeListCount?: number;
    pMutableDescriptorTypeLists: Deno.PointerValue;
  }) {
    const s = VkMutableDescriptorTypeCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mutableDescriptorTypeListCount !== undefined) s.mutableDescriptorTypeListCount = data.mutableDescriptorTypeListCount;
    if (data.pMutableDescriptorTypeLists !== undefined) s.pMutableDescriptorTypeLists = data.pMutableDescriptorTypeLists;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mutableDescriptorTypeListCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set mutableDescriptorTypeListCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pMutableDescriptorTypeLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMutableDescriptorTypeLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDepthClipControlFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDepthClipControlFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDepthClipControlFeaturesEXT(new Uint8Array(VkPhysicalDeviceDepthClipControlFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    depthClipControl: VkBool32;
  }) {
    const s = VkPhysicalDeviceDepthClipControlFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.depthClipControl !== undefined) s.depthClipControl = data.depthClipControl;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get depthClipControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClipControl(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineViewportDepthClipControlCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineViewportDepthClipControlCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineViewportDepthClipControlCreateInfoEXT(new Uint8Array(VkPipelineViewportDepthClipControlCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    negativeOneToOne: VkBool32;
  }) {
    const s = VkPipelineViewportDepthClipControlCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.negativeOneToOne !== undefined) s.negativeOneToOne = data.negativeOneToOne;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get negativeOneToOne() {
    return this.#view.getUint32(16, LE);
  }
  
  set negativeOneToOne(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(new Uint8Array(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexInputDynamicState: VkBool32;
  }) {
    const s = VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexInputDynamicState !== undefined) s.vertexInputDynamicState = data.vertexInputDynamicState;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexInputDynamicState() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexInputDynamicState(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceExternalMemoryRDMAFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(new Uint8Array(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    externalMemoryRDMA: VkBool32;
  }) {
    const s = VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.externalMemoryRDMA !== undefined) s.externalMemoryRDMA = data.externalMemoryRDMA;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get externalMemoryRDMA() {
    return this.#view.getUint32(16, LE);
  }
  
  set externalMemoryRDMA(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVertexInputBindingDescription2EXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVertexInputBindingDescription2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVertexInputBindingDescription2EXT(new Uint8Array(VkVertexInputBindingDescription2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    binding: number;
    stride: number;
    inputRate: VkVertexInputRate;
    divisor: number;
  }) {
    const s = VkVertexInputBindingDescription2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.stride !== undefined) s.stride = data.stride;
    if (data.inputRate !== undefined) s.inputRate = data.inputRate;
    if (data.divisor !== undefined) s.divisor = data.divisor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(16, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(20, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get inputRate() {
    return this.#view.getUint32(24, LE);
  }
  
  set inputRate(value: VkVertexInputRate) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get divisor() {
    return this.#view.getUint32(28, LE);
  }
  
  set divisor(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkVertexInputAttributeDescription2EXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVertexInputAttributeDescription2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVertexInputAttributeDescription2EXT(new Uint8Array(VkVertexInputAttributeDescription2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    location: number;
    binding: number;
    format: VkFormat;
    offset: number;
  }) {
    const s = VkVertexInputAttributeDescription2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.location !== undefined) s.location = data.location;
    if (data.binding !== undefined) s.binding = data.binding;
    if (data.format !== undefined) s.format = data.format;
    if (data.offset !== undefined) s.offset = data.offset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get location() {
    return this.#view.getUint32(16, LE);
  }
  
  set location(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(20, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(24, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(28, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceColorWriteEnableFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceColorWriteEnableFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceColorWriteEnableFeaturesEXT(new Uint8Array(VkPhysicalDeviceColorWriteEnableFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    colorWriteEnable: VkBool32;
  }) {
    const s = VkPhysicalDeviceColorWriteEnableFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.colorWriteEnable !== undefined) s.colorWriteEnable = data.colorWriteEnable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get colorWriteEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorWriteEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineColorWriteCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineColorWriteCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineColorWriteCreateInfoEXT(new Uint8Array(VkPipelineColorWriteCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachmentCount?: number;
    pColorWriteEnables: Deno.PointerValue;
  }) {
    const s = VkPipelineColorWriteCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachmentCount !== undefined) s.attachmentCount = data.attachmentCount;
    if (data.pColorWriteEnables !== undefined) s.pColorWriteEnables = data.pColorWriteEnables;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pColorWriteEnables() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorWriteEnables(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkMemoryBarrier2 implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryBarrier2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryBarrier2(new Uint8Array(VkMemoryBarrier2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcStageMask?: VkPipelineStageFlags2;
    srcAccessMask?: VkAccessFlags2;
    dstStageMask?: VkPipelineStageFlags2;
    dstAccessMask?: VkAccessFlags2;
  }) {
    const s = VkMemoryBarrier2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcStageMask !== undefined) s.srcStageMask = data.srcStageMask;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstStageMask !== undefined) s.dstStageMask = data.dstStageMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkImageMemoryBarrier2 implements IVkStructure {
  static size = 100;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageMemoryBarrier2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageMemoryBarrier2(new Uint8Array(VkImageMemoryBarrier2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcStageMask?: VkPipelineStageFlags2;
    srcAccessMask?: VkAccessFlags2;
    dstStageMask?: VkPipelineStageFlags2;
    dstAccessMask?: VkAccessFlags2;
    oldLayout: VkImageLayout;
    newLayout: VkImageLayout;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    image: VkImage;
    subresourceRange: VkImageSubresourceRange;
  }) {
    const s = VkImageMemoryBarrier2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcStageMask !== undefined) s.srcStageMask = data.srcStageMask;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstStageMask !== undefined) s.dstStageMask = data.dstStageMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.oldLayout !== undefined) s.oldLayout = data.oldLayout;
    if (data.newLayout !== undefined) s.newLayout = data.newLayout;
    if (data.srcQueueFamilyIndex !== undefined) s.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
    if (data.dstQueueFamilyIndex !== undefined) s.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
    if (data.image !== undefined) s.image = data.image;
    if (data.subresourceRange !== undefined) s.subresourceRange = data.subresourceRange;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get oldLayout() {
    return this.#view.getUint32(48, LE);
  }
  
  set oldLayout(value: VkImageLayout) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get newLayout() {
    return this.#view.getUint32(52, LE);
  }
  
  set newLayout(value: VkImageLayout) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(56, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(60, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get subresourceRange() {
    return new VkImageSubresourceRange(this.#data.subarray(80, 80 + VkImageSubresourceRange.size));
  }
  
  set subresourceRange(value: VkImageSubresourceRange) {
    if (value[BUFFER].byteLength < VkImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 80);
  }
}

export class VkBufferMemoryBarrier2 implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferMemoryBarrier2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferMemoryBarrier2(new Uint8Array(VkBufferMemoryBarrier2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    srcStageMask?: VkPipelineStageFlags2;
    srcAccessMask?: VkAccessFlags2;
    dstStageMask?: VkPipelineStageFlags2;
    dstAccessMask?: VkAccessFlags2;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    size: VkDeviceSize;
  }) {
    const s = VkBufferMemoryBarrier2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.srcStageMask !== undefined) s.srcStageMask = data.srcStageMask;
    if (data.srcAccessMask !== undefined) s.srcAccessMask = data.srcAccessMask;
    if (data.dstStageMask !== undefined) s.dstStageMask = data.dstStageMask;
    if (data.dstAccessMask !== undefined) s.dstAccessMask = data.dstAccessMask;
    if (data.srcQueueFamilyIndex !== undefined) s.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
    if (data.dstQueueFamilyIndex !== undefined) s.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: VkAccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(48, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(52, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
}

export class VkDependencyInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDependencyInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDependencyInfo(new Uint8Array(VkDependencyInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dependencyFlags?: VkDependencyFlags;
    memoryBarrierCount?: number;
    pMemoryBarriers: Deno.PointerValue;
    bufferMemoryBarrierCount?: number;
    pBufferMemoryBarriers: Deno.PointerValue;
    imageMemoryBarrierCount?: number;
    pImageMemoryBarriers: Deno.PointerValue;
  }) {
    const s = VkDependencyInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dependencyFlags !== undefined) s.dependencyFlags = data.dependencyFlags;
    if (data.memoryBarrierCount !== undefined) s.memoryBarrierCount = data.memoryBarrierCount;
    if (data.pMemoryBarriers !== undefined) s.pMemoryBarriers = data.pMemoryBarriers;
    if (data.bufferMemoryBarrierCount !== undefined) s.bufferMemoryBarrierCount = data.bufferMemoryBarrierCount;
    if (data.pBufferMemoryBarriers !== undefined) s.pBufferMemoryBarriers = data.pBufferMemoryBarriers;
    if (data.imageMemoryBarrierCount !== undefined) s.imageMemoryBarrierCount = data.imageMemoryBarrierCount;
    if (data.pImageMemoryBarriers !== undefined) s.pImageMemoryBarriers = data.pImageMemoryBarriers;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set dependencyFlags(value: VkDependencyFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryBarrierCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set memoryBarrierCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pMemoryBarriers() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMemoryBarriers(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferMemoryBarrierCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set bufferMemoryBarrierCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pBufferMemoryBarriers() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pBufferMemoryBarriers(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get imageMemoryBarrierCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageMemoryBarrierCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pImageMemoryBarriers() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pImageMemoryBarriers(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkSemaphoreSubmitInfo implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSemaphoreSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSemaphoreSubmitInfo(new Uint8Array(VkSemaphoreSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore: VkSemaphore;
    value: Deno.PointerValue;
    stageMask?: VkPipelineStageFlags2;
    deviceIndex: number;
  }) {
    const s = VkSemaphoreSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.value !== undefined) s.value = data.value;
    if (data.stageMask !== undefined) s.stageMask = data.stageMask;
    if (data.deviceIndex !== undefined) s.deviceIndex = data.deviceIndex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get value() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set value(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set stageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get deviceIndex() {
    return this.#view.getUint32(40, LE);
  }
  
  set deviceIndex(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkCommandBufferSubmitInfo implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferSubmitInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferSubmitInfo(new Uint8Array(VkCommandBufferSubmitInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    commandBuffer: VkCommandBuffer;
    deviceMask: number;
  }) {
    const s = VkCommandBufferSubmitInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.commandBuffer !== undefined) s.commandBuffer = data.commandBuffer;
    if (data.deviceMask !== undefined) s.deviceMask = data.deviceMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get commandBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set commandBuffer(value: VkCommandBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkSubmitInfo2 implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubmitInfo2.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubmitInfo2(new Uint8Array(VkSubmitInfo2.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkSubmitFlags;
    waitSemaphoreInfoCount?: number;
    pWaitSemaphoreInfos: Deno.PointerValue;
    commandBufferInfoCount?: number;
    pCommandBufferInfos: Deno.PointerValue;
    signalSemaphoreInfoCount?: number;
    pSignalSemaphoreInfos: Deno.PointerValue;
  }) {
    const s = VkSubmitInfo2.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.waitSemaphoreInfoCount !== undefined) s.waitSemaphoreInfoCount = data.waitSemaphoreInfoCount;
    if (data.pWaitSemaphoreInfos !== undefined) s.pWaitSemaphoreInfos = data.pWaitSemaphoreInfos;
    if (data.commandBufferInfoCount !== undefined) s.commandBufferInfoCount = data.commandBufferInfoCount;
    if (data.pCommandBufferInfos !== undefined) s.pCommandBufferInfos = data.pCommandBufferInfos;
    if (data.signalSemaphoreInfoCount !== undefined) s.signalSemaphoreInfoCount = data.signalSemaphoreInfoCount;
    if (data.pSignalSemaphoreInfos !== undefined) s.pSignalSemaphoreInfos = data.pSignalSemaphoreInfos;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkSubmitFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get waitSemaphoreInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set waitSemaphoreInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pWaitSemaphoreInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get commandBufferInfoCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set commandBufferInfoCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pCommandBufferInfos() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCommandBufferInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get signalSemaphoreInfoCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set signalSemaphoreInfoCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pSignalSemaphoreInfos() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pSignalSemaphoreInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkQueueFamilyCheckpointProperties2NV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyCheckpointProperties2NV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyCheckpointProperties2NV(new Uint8Array(VkQueueFamilyCheckpointProperties2NV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    checkpointExecutionStageMask: VkPipelineStageFlags2;
  }) {
    const s = VkQueueFamilyCheckpointProperties2NV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.checkpointExecutionStageMask !== undefined) s.checkpointExecutionStageMask = data.checkpointExecutionStageMask;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get checkpointExecutionStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set checkpointExecutionStageMask(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkCheckpointData2NV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCheckpointData2NV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCheckpointData2NV(new Uint8Array(VkCheckpointData2NV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stage: VkPipelineStageFlags2;
    pCheckpointMarker: Deno.PointerValue;
  }) {
    const s = VkCheckpointData2NV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stage !== undefined) s.stage = data.stage;
    if (data.pCheckpointMarker !== undefined) s.pCheckpointMarker = data.pCheckpointMarker;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set stage(value: VkPipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pCheckpointMarker() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCheckpointMarker(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceSynchronization2Features implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSynchronization2Features.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSynchronization2Features(new Uint8Array(VkPhysicalDeviceSynchronization2Features.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    synchronization2: VkBool32;
  }) {
    const s = VkPhysicalDeviceSynchronization2Features.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.synchronization2 !== undefined) s.synchronization2 = data.synchronization2;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get synchronization2() {
    return this.#view.getUint32(16, LE);
  }
  
  set synchronization2(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(new Uint8Array(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    primitivesGeneratedQuery: VkBool32;
    primitivesGeneratedQueryWithRasterizerDiscard: VkBool32;
    primitivesGeneratedQueryWithNonZeroStreams: VkBool32;
  }) {
    const s = VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.primitivesGeneratedQuery !== undefined) s.primitivesGeneratedQuery = data.primitivesGeneratedQuery;
    if (data.primitivesGeneratedQueryWithRasterizerDiscard !== undefined) s.primitivesGeneratedQueryWithRasterizerDiscard = data.primitivesGeneratedQueryWithRasterizerDiscard;
    if (data.primitivesGeneratedQueryWithNonZeroStreams !== undefined) s.primitivesGeneratedQueryWithNonZeroStreams = data.primitivesGeneratedQueryWithNonZeroStreams;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get primitivesGeneratedQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set primitivesGeneratedQuery(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitivesGeneratedQueryWithRasterizerDiscard() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitivesGeneratedQueryWithRasterizerDiscard(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primitivesGeneratedQueryWithNonZeroStreams() {
    return this.#view.getUint32(24, LE);
  }
  
  set primitivesGeneratedQueryWithNonZeroStreams(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceLegacyDitheringFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceLegacyDitheringFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceLegacyDitheringFeaturesEXT(new Uint8Array(VkPhysicalDeviceLegacyDitheringFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    legacyDithering: VkBool32;
  }) {
    const s = VkPhysicalDeviceLegacyDitheringFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.legacyDithering !== undefined) s.legacyDithering = data.legacyDithering;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get legacyDithering() {
    return this.#view.getUint32(16, LE);
  }
  
  set legacyDithering(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(new Uint8Array(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    multisampledRenderToSingleSampled: VkBool32;
  }) {
    const s = VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.multisampledRenderToSingleSampled !== undefined) s.multisampledRenderToSingleSampled = data.multisampledRenderToSingleSampled;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get multisampledRenderToSingleSampled() {
    return this.#view.getUint32(16, LE);
  }
  
  set multisampledRenderToSingleSampled(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkSubpassResolvePerformanceQueryEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubpassResolvePerformanceQueryEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubpassResolvePerformanceQueryEXT(new Uint8Array(VkSubpassResolvePerformanceQueryEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    optimal: VkBool32;
  }) {
    const s = VkSubpassResolvePerformanceQueryEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.optimal !== undefined) s.optimal = data.optimal;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get optimal() {
    return this.#view.getUint32(16, LE);
  }
  
  set optimal(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMultisampledRenderToSingleSampledInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMultisampledRenderToSingleSampledInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMultisampledRenderToSingleSampledInfoEXT(new Uint8Array(VkMultisampledRenderToSingleSampledInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    multisampledRenderToSingleSampledEnable: VkBool32;
    rasterizationSamples: VkSampleCountFlagBits;
  }) {
    const s = VkMultisampledRenderToSingleSampledInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.multisampledRenderToSingleSampledEnable !== undefined) s.multisampledRenderToSingleSampledEnable = data.multisampledRenderToSingleSampledEnable;
    if (data.rasterizationSamples !== undefined) s.rasterizationSamples = data.rasterizationSamples;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get multisampledRenderToSingleSampledEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set multisampledRenderToSingleSampledEnable(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDevicePipelineProtectedAccessFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(new Uint8Array(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineProtectedAccess: VkBool32;
  }) {
    const s = VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineProtectedAccess !== undefined) s.pipelineProtectedAccess = data.pipelineProtectedAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineProtectedAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineProtectedAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkQueueFamilyVideoPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyVideoPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyVideoPropertiesKHR(new Uint8Array(VkQueueFamilyVideoPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    videoCodecOperations: VkVideoCodecOperationFlagsKHR;
  }) {
    const s = VkQueueFamilyVideoPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.videoCodecOperations !== undefined) s.videoCodecOperations = data.videoCodecOperations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get videoCodecOperations() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoCodecOperations(value: VkVideoCodecOperationFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkQueueFamilyQueryResultStatusPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkQueueFamilyQueryResultStatusPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkQueueFamilyQueryResultStatusPropertiesKHR(new Uint8Array(VkQueueFamilyQueryResultStatusPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    queryResultStatusSupport: VkBool32;
  }) {
    const s = VkQueueFamilyQueryResultStatusPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.queryResultStatusSupport !== undefined) s.queryResultStatusSupport = data.queryResultStatusSupport;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get queryResultStatusSupport() {
    return this.#view.getUint32(16, LE);
  }
  
  set queryResultStatusSupport(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoProfileListInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoProfileListInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoProfileListInfoKHR(new Uint8Array(VkVideoProfileListInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    profileCount?: number;
    pProfiles: Deno.PointerValue;
  }) {
    const s = VkVideoProfileListInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.profileCount !== undefined) s.profileCount = data.profileCount;
    if (data.pProfiles !== undefined) s.pProfiles = data.pProfiles;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get profileCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set profileCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pProfiles() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pProfiles(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceVideoFormatInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceVideoFormatInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceVideoFormatInfoKHR(new Uint8Array(VkPhysicalDeviceVideoFormatInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageUsage: VkImageUsageFlags;
  }) {
    const s = VkPhysicalDeviceVideoFormatInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageUsage !== undefined) s.imageUsage = data.imageUsage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageUsage() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageUsage(value: VkImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoFormatPropertiesKHR implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoFormatPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoFormatPropertiesKHR(new Uint8Array(VkVideoFormatPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    componentMapping: VkComponentMapping;
    imageCreateFlags: VkImageCreateFlags;
    imageType: VkImageType;
    imageTiling: VkImageTiling;
    imageUsageFlags: VkImageUsageFlags;
  }) {
    const s = VkVideoFormatPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.componentMapping !== undefined) s.componentMapping = data.componentMapping;
    if (data.imageCreateFlags !== undefined) s.imageCreateFlags = data.imageCreateFlags;
    if (data.imageType !== undefined) s.imageType = data.imageType;
    if (data.imageTiling !== undefined) s.imageTiling = data.imageTiling;
    if (data.imageUsageFlags !== undefined) s.imageUsageFlags = data.imageUsageFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get componentMapping() {
    return new VkComponentMapping(this.#data.subarray(32, 32 + VkComponentMapping.size));
  }
  
  set componentMapping(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get imageCreateFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageCreateFlags(value: VkImageCreateFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get imageType() {
    return this.#view.getUint32(52, LE);
  }
  
  set imageType(value: VkImageType) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get imageTiling() {
    return this.#view.getUint32(56, LE);
  }
  
  set imageTiling(value: VkImageTiling) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get imageUsageFlags() {
    return this.#view.getUint32(60, LE);
  }
  
  set imageUsageFlags(value: VkImageUsageFlags) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export class VkVideoProfileInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoProfileInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoProfileInfoKHR(new Uint8Array(VkVideoProfileInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    videoCodecOperation: VkVideoCodecOperationFlagBitsKHR;
    chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR;
    lumaBitDepth: VkVideoComponentBitDepthFlagsKHR;
    chromaBitDepth?: VkVideoComponentBitDepthFlagsKHR;
  }) {
    const s = VkVideoProfileInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.videoCodecOperation !== undefined) s.videoCodecOperation = data.videoCodecOperation;
    if (data.chromaSubsampling !== undefined) s.chromaSubsampling = data.chromaSubsampling;
    if (data.lumaBitDepth !== undefined) s.lumaBitDepth = data.lumaBitDepth;
    if (data.chromaBitDepth !== undefined) s.chromaBitDepth = data.chromaBitDepth;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get videoCodecOperation() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoCodecOperation(value: VkVideoCodecOperationFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get chromaSubsampling() {
    return this.#view.getUint32(20, LE);
  }
  
  set chromaSubsampling(value: VkVideoChromaSubsamplingFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get lumaBitDepth() {
    return this.#view.getUint32(24, LE);
  }
  
  set lumaBitDepth(value: VkVideoComponentBitDepthFlagsKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get chromaBitDepth() {
    return this.#view.getUint32(28, LE);
  }
  
  set chromaBitDepth(value: VkVideoComponentBitDepthFlagsKHR) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkVideoCapabilitiesKHR implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoCapabilitiesKHR(new Uint8Array(VkVideoCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoCapabilityFlagsKHR;
    minBitstreamBufferOffsetAlignment: VkDeviceSize;
    minBitstreamBufferSizeAlignment: VkDeviceSize;
    pictureAccessGranularity: VkExtent2D;
    minCodedExtent: VkExtent2D;
    maxCodedExtent: VkExtent2D;
    maxDpbSlots: number;
    maxActiveReferencePictures: number;
    stdHeaderVersion: VkExtensionProperties;
  }) {
    const s = VkVideoCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.minBitstreamBufferOffsetAlignment !== undefined) s.minBitstreamBufferOffsetAlignment = data.minBitstreamBufferOffsetAlignment;
    if (data.minBitstreamBufferSizeAlignment !== undefined) s.minBitstreamBufferSizeAlignment = data.minBitstreamBufferSizeAlignment;
    if (data.pictureAccessGranularity !== undefined) s.pictureAccessGranularity = data.pictureAccessGranularity;
    if (data.minCodedExtent !== undefined) s.minCodedExtent = data.minCodedExtent;
    if (data.maxCodedExtent !== undefined) s.maxCodedExtent = data.maxCodedExtent;
    if (data.maxDpbSlots !== undefined) s.maxDpbSlots = data.maxDpbSlots;
    if (data.maxActiveReferencePictures !== undefined) s.maxActiveReferencePictures = data.maxActiveReferencePictures;
    if (data.stdHeaderVersion !== undefined) s.stdHeaderVersion = data.stdHeaderVersion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get minBitstreamBufferOffsetAlignment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set minBitstreamBufferOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get minBitstreamBufferSizeAlignment() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set minBitstreamBufferSizeAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pictureAccessGranularity() {
    return new VkExtent2D(this.#data.subarray(40, 40 + VkExtent2D.size));
  }
  
  set pictureAccessGranularity(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get minCodedExtent() {
    return new VkExtent2D(this.#data.subarray(48, 48 + VkExtent2D.size));
  }
  
  set minCodedExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get maxCodedExtent() {
    return new VkExtent2D(this.#data.subarray(56, 56 + VkExtent2D.size));
  }
  
  set maxCodedExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get maxDpbSlots() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxDpbSlots(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxActiveReferencePictures() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxActiveReferencePictures(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get stdHeaderVersion() {
    return new VkExtensionProperties(this.#data.subarray(72, 72 + VkExtensionProperties.size));
  }
  
  set stdHeaderVersion(value: VkExtensionProperties) {
    if (value[BUFFER].byteLength < VkExtensionProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export class VkVideoSessionMemoryRequirementsKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoSessionMemoryRequirementsKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoSessionMemoryRequirementsKHR(new Uint8Array(VkVideoSessionMemoryRequirementsKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryBindIndex: number;
    memoryRequirements: VkMemoryRequirements;
  }) {
    const s = VkVideoSessionMemoryRequirementsKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryBindIndex !== undefined) s.memoryBindIndex = data.memoryBindIndex;
    if (data.memoryRequirements !== undefined) s.memoryRequirements = data.memoryRequirements;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryBindIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryBindIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryRequirements() {
    return new VkMemoryRequirements(this.#data.subarray(24, 24 + VkMemoryRequirements.size));
  }
  
  set memoryRequirements(value: VkMemoryRequirements) {
    if (value[BUFFER].byteLength < VkMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkBindVideoSessionMemoryInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBindVideoSessionMemoryInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBindVideoSessionMemoryInfoKHR(new Uint8Array(VkBindVideoSessionMemoryInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryBindIndex: number;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
    memorySize: VkDeviceSize;
  }) {
    const s = VkBindVideoSessionMemoryInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryBindIndex !== undefined) s.memoryBindIndex = data.memoryBindIndex;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.memoryOffset !== undefined) s.memoryOffset = data.memoryOffset;
    if (data.memorySize !== undefined) s.memorySize = data.memorySize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryBindIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryBindIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get memorySize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set memorySize(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoPictureResourceInfoKHR implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoPictureResourceInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoPictureResourceInfoKHR(new Uint8Array(VkVideoPictureResourceInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    codedOffset: VkOffset2D;
    codedExtent: VkExtent2D;
    baseArrayLayer: number;
    imageViewBinding: VkImageView;
  }) {
    const s = VkVideoPictureResourceInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.codedOffset !== undefined) s.codedOffset = data.codedOffset;
    if (data.codedExtent !== undefined) s.codedExtent = data.codedExtent;
    if (data.baseArrayLayer !== undefined) s.baseArrayLayer = data.baseArrayLayer;
    if (data.imageViewBinding !== undefined) s.imageViewBinding = data.imageViewBinding;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get codedOffset() {
    return new VkOffset2D(this.#data.subarray(16, 16 + VkOffset2D.size));
  }
  
  set codedOffset(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get codedExtent() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set codedExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(32, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get imageViewBinding() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set imageViewBinding(value: VkImageView) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoReferenceSlotInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoReferenceSlotInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoReferenceSlotInfoKHR(new Uint8Array(VkVideoReferenceSlotInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    slotIndex: number;
    pPictureResource?: Deno.PointerValue;
  }) {
    const s = VkVideoReferenceSlotInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.slotIndex !== undefined) s.slotIndex = data.slotIndex;
    if (data.pPictureResource !== undefined) s.pPictureResource = data.pPictureResource;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt32(16, LE);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt32(16, Number(value), LE);
  }
  
  get pPictureResource() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPictureResource(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVideoDecodeCapabilitiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeCapabilitiesKHR(new Uint8Array(VkVideoDecodeCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoDecodeCapabilityFlagsKHR;
  }) {
    const s = VkVideoDecodeCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoDecodeCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoDecodeUsageInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeUsageInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeUsageInfoKHR(new Uint8Array(VkVideoDecodeUsageInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    videoUsageHints?: VkVideoDecodeUsageFlagsKHR;
  }) {
    const s = VkVideoDecodeUsageInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.videoUsageHints !== undefined) s.videoUsageHints = data.videoUsageHints;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get videoUsageHints() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoUsageHints(value: VkVideoDecodeUsageFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoDecodeInfoKHR implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeInfoKHR(new Uint8Array(VkVideoDecodeInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoDecodeFlagsKHR;
    srcBuffer: VkBuffer;
    srcBufferOffset: VkDeviceSize;
    srcBufferRange: VkDeviceSize;
    dstPictureResource: VkVideoPictureResourceInfoKHR;
    pSetupReferenceSlot?: Deno.PointerValue;
    referenceSlotCount?: number;
    pReferenceSlots: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.srcBuffer !== undefined) s.srcBuffer = data.srcBuffer;
    if (data.srcBufferOffset !== undefined) s.srcBufferOffset = data.srcBufferOffset;
    if (data.srcBufferRange !== undefined) s.srcBufferRange = data.srcBufferRange;
    if (data.dstPictureResource !== undefined) s.dstPictureResource = data.dstPictureResource;
    if (data.pSetupReferenceSlot !== undefined) s.pSetupReferenceSlot = data.pSetupReferenceSlot;
    if (data.referenceSlotCount !== undefined) s.referenceSlotCount = data.referenceSlotCount;
    if (data.pReferenceSlots !== undefined) s.pReferenceSlots = data.pReferenceSlots;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoDecodeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcBuffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get srcBufferOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set srcBufferOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get srcBufferRange() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set srcBufferRange(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get dstPictureResource() {
    return new VkVideoPictureResourceInfoKHR(this.#data.subarray(48, 48 + VkVideoPictureResourceInfoKHR.size));
  }
  
  set dstPictureResource(value: VkVideoPictureResourceInfoKHR) {
    if (value[BUFFER].byteLength < VkVideoPictureResourceInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get pSetupReferenceSlot() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pSetupReferenceSlot(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(104, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set pReferenceSlots(value: Deno.PointerValue) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
}

export class VkVideoDecodeH264ProfileInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264ProfileInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264ProfileInfoEXT(new Uint8Array(VkVideoDecodeH264ProfileInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdProfileIdc: StdVideoH264ProfileIdc;
    pictureLayout?: VkVideoDecodeH264PictureLayoutFlagBitsEXT;
  }) {
    const s = VkVideoDecodeH264ProfileInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdProfileIdc !== undefined) s.stdProfileIdc = data.stdProfileIdc;
    if (data.pictureLayout !== undefined) s.pictureLayout = data.pictureLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pictureLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set pictureLayout(value: VkVideoDecodeH264PictureLayoutFlagBitsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkVideoDecodeH264CapabilitiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264CapabilitiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264CapabilitiesEXT(new Uint8Array(VkVideoDecodeH264CapabilitiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxLevelIdc: StdVideoH264LevelIdc;
    fieldOffsetGranularity: VkOffset2D;
  }) {
    const s = VkVideoDecodeH264CapabilitiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxLevelIdc !== undefined) s.maxLevelIdc = data.maxLevelIdc;
    if (data.fieldOffsetGranularity !== undefined) s.fieldOffsetGranularity = data.fieldOffsetGranularity;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxLevelIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxLevelIdc(value: StdVideoH264LevelIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fieldOffsetGranularity() {
    return new VkOffset2D(this.#data.subarray(24, 24 + VkOffset2D.size));
  }
  
  set fieldOffsetGranularity(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkVideoDecodeH264SessionParametersAddInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264SessionParametersAddInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264SessionParametersAddInfoEXT(new Uint8Array(VkVideoDecodeH264SessionParametersAddInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdSPSCount?: number;
    pStdSPSs: Deno.PointerValue;
    stdPPSCount?: number;
    pStdPPSs: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH264SessionParametersAddInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdSPSCount !== undefined) s.stdSPSCount = data.stdSPSCount;
    if (data.pStdSPSs !== undefined) s.pStdSPSs = data.pStdSPSs;
    if (data.stdPPSCount !== undefined) s.stdPPSCount = data.stdPPSCount;
    if (data.pStdPPSs !== undefined) s.pStdPPSs = data.pStdPPSs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdSPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdPPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoDecodeH264SessionParametersCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264SessionParametersCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264SessionParametersCreateInfoEXT(new Uint8Array(VkVideoDecodeH264SessionParametersCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxStdSPSCount: number;
    maxStdPPSCount: number;
    pParametersAddInfo?: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH264SessionParametersCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxStdSPSCount !== undefined) s.maxStdSPSCount = data.maxStdSPSCount;
    if (data.maxStdPPSCount !== undefined) s.maxStdPPSCount = data.maxStdPPSCount;
    if (data.pParametersAddInfo !== undefined) s.pParametersAddInfo = data.pParametersAddInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pParametersAddInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVideoDecodeH264PictureInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264PictureInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264PictureInfoEXT(new Uint8Array(VkVideoDecodeH264PictureInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pStdPictureInfo: Deno.PointerValue;
    sliceCount: number;
    pSliceOffsets: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH264PictureInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pStdPictureInfo !== undefined) s.pStdPictureInfo = data.pStdPictureInfo;
    if (data.sliceCount !== undefined) s.sliceCount = data.sliceCount;
    if (data.pSliceOffsets !== undefined) s.pSliceOffsets = data.pSliceOffsets;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pStdPictureInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdPictureInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get sliceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set sliceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSliceOffsets() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceOffsets(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoDecodeH264DpbSlotInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH264DpbSlotInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH264DpbSlotInfoEXT(new Uint8Array(VkVideoDecodeH264DpbSlotInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pStdReferenceInfo: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH264DpbSlotInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pStdReferenceInfo !== undefined) s.pStdReferenceInfo = data.pStdReferenceInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdReferenceInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkVideoDecodeH265ProfileInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265ProfileInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265ProfileInfoEXT(new Uint8Array(VkVideoDecodeH265ProfileInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdProfileIdc: StdVideoH265ProfileIdc;
  }) {
    const s = VkVideoDecodeH265ProfileInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdProfileIdc !== undefined) s.stdProfileIdc = data.stdProfileIdc;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoDecodeH265CapabilitiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265CapabilitiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265CapabilitiesEXT(new Uint8Array(VkVideoDecodeH265CapabilitiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxLevelIdc: StdVideoH265LevelIdc;
  }) {
    const s = VkVideoDecodeH265CapabilitiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxLevelIdc !== undefined) s.maxLevelIdc = data.maxLevelIdc;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxLevelIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxLevelIdc(value: StdVideoH265LevelIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoDecodeH265SessionParametersAddInfoEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265SessionParametersAddInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265SessionParametersAddInfoEXT(new Uint8Array(VkVideoDecodeH265SessionParametersAddInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdVPSCount?: number;
    pStdVPSs: Deno.PointerValue;
    stdSPSCount?: number;
    pStdSPSs: Deno.PointerValue;
    stdPPSCount?: number;
    pStdPPSs: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH265SessionParametersAddInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdVPSCount !== undefined) s.stdVPSCount = data.stdVPSCount;
    if (data.pStdVPSs !== undefined) s.pStdVPSs = data.pStdVPSs;
    if (data.stdSPSCount !== undefined) s.stdSPSCount = data.stdSPSCount;
    if (data.pStdSPSs !== undefined) s.pStdSPSs = data.pStdSPSs;
    if (data.stdPPSCount !== undefined) s.stdPPSCount = data.stdPPSCount;
    if (data.pStdPPSs !== undefined) s.pStdPPSs = data.pStdPPSs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdVPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdVPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdSPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pStdPPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkVideoDecodeH265SessionParametersCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265SessionParametersCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265SessionParametersCreateInfoEXT(new Uint8Array(VkVideoDecodeH265SessionParametersCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxStdVPSCount: number;
    maxStdSPSCount: number;
    maxStdPPSCount: number;
    pParametersAddInfo?: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH265SessionParametersCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxStdVPSCount !== undefined) s.maxStdVPSCount = data.maxStdVPSCount;
    if (data.maxStdSPSCount !== undefined) s.maxStdSPSCount = data.maxStdSPSCount;
    if (data.maxStdPPSCount !== undefined) s.maxStdPPSCount = data.maxStdPPSCount;
    if (data.pParametersAddInfo !== undefined) s.pParametersAddInfo = data.pParametersAddInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxStdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pParametersAddInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoDecodeH265PictureInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265PictureInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265PictureInfoEXT(new Uint8Array(VkVideoDecodeH265PictureInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pStdPictureInfo: Deno.PointerValue;
    sliceCount: number;
    pSliceOffsets: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH265PictureInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pStdPictureInfo !== undefined) s.pStdPictureInfo = data.pStdPictureInfo;
    if (data.sliceCount !== undefined) s.sliceCount = data.sliceCount;
    if (data.pSliceOffsets !== undefined) s.pSliceOffsets = data.pSliceOffsets;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pStdPictureInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdPictureInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get sliceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set sliceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSliceOffsets() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceOffsets(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoDecodeH265DpbSlotInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoDecodeH265DpbSlotInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoDecodeH265DpbSlotInfoEXT(new Uint8Array(VkVideoDecodeH265DpbSlotInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pStdReferenceInfo: Deno.PointerValue;
  }) {
    const s = VkVideoDecodeH265DpbSlotInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pStdReferenceInfo !== undefined) s.pStdReferenceInfo = data.pStdReferenceInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdReferenceInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkVideoSessionCreateInfoKHR implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoSessionCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoSessionCreateInfoKHR(new Uint8Array(VkVideoSessionCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    queueFamilyIndex: number;
    flags?: VkVideoSessionCreateFlagsKHR;
    pVideoProfile: Deno.PointerValue;
    pictureFormat: VkFormat;
    maxCodedExtent: VkExtent2D;
    referencePictureFormat: VkFormat;
    maxDpbSlots: number;
    maxActiveReferencePictures: number;
    pStdHeaderVersion: Deno.PointerValue;
  }) {
    const s = VkVideoSessionCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.queueFamilyIndex !== undefined) s.queueFamilyIndex = data.queueFamilyIndex;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.pVideoProfile !== undefined) s.pVideoProfile = data.pVideoProfile;
    if (data.pictureFormat !== undefined) s.pictureFormat = data.pictureFormat;
    if (data.maxCodedExtent !== undefined) s.maxCodedExtent = data.maxCodedExtent;
    if (data.referencePictureFormat !== undefined) s.referencePictureFormat = data.referencePictureFormat;
    if (data.maxDpbSlots !== undefined) s.maxDpbSlots = data.maxDpbSlots;
    if (data.maxActiveReferencePictures !== undefined) s.maxActiveReferencePictures = data.maxActiveReferencePictures;
    if (data.pStdHeaderVersion !== undefined) s.pStdHeaderVersion = data.pStdHeaderVersion;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkVideoSessionCreateFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pVideoProfile() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVideoProfile(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pictureFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set pictureFormat(value: VkFormat) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxCodedExtent() {
    return new VkExtent2D(this.#data.subarray(40, 40 + VkExtent2D.size));
  }
  
  set maxCodedExtent(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get referencePictureFormat() {
    return this.#view.getUint32(48, LE);
  }
  
  set referencePictureFormat(value: VkFormat) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxDpbSlots() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxDpbSlots(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxActiveReferencePictures() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxActiveReferencePictures(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pStdHeaderVersion() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pStdHeaderVersion(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkVideoSessionParametersCreateInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoSessionParametersCreateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoSessionParametersCreateInfoKHR(new Uint8Array(VkVideoSessionParametersCreateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoSessionParametersCreateFlagsKHR;
    videoSessionParametersTemplate?: VkVideoSessionParametersKHR;
    videoSession: VkVideoSessionKHR;
  }) {
    const s = VkVideoSessionParametersCreateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.videoSessionParametersTemplate !== undefined) s.videoSessionParametersTemplate = data.videoSessionParametersTemplate;
    if (data.videoSession !== undefined) s.videoSession = data.videoSession;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoSessionParametersCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoSessionParametersTemplate() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set videoSessionParametersTemplate(value: VkVideoSessionParametersKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get videoSession() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set videoSession(value: VkVideoSessionKHR) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoSessionParametersUpdateInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoSessionParametersUpdateInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoSessionParametersUpdateInfoKHR(new Uint8Array(VkVideoSessionParametersUpdateInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    updateSequenceCount: number;
  }) {
    const s = VkVideoSessionParametersUpdateInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.updateSequenceCount !== undefined) s.updateSequenceCount = data.updateSequenceCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get updateSequenceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set updateSequenceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoBeginCodingInfoKHR implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoBeginCodingInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoBeginCodingInfoKHR(new Uint8Array(VkVideoBeginCodingInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoBeginCodingFlagsKHR;
    videoSession: VkVideoSessionKHR;
    videoSessionParameters?: VkVideoSessionParametersKHR;
    referenceSlotCount?: number;
    pReferenceSlots: Deno.PointerValue;
  }) {
    const s = VkVideoBeginCodingInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.videoSession !== undefined) s.videoSession = data.videoSession;
    if (data.videoSessionParameters !== undefined) s.videoSessionParameters = data.videoSessionParameters;
    if (data.referenceSlotCount !== undefined) s.referenceSlotCount = data.referenceSlotCount;
    if (data.pReferenceSlots !== undefined) s.pReferenceSlots = data.pReferenceSlots;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoBeginCodingFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoSession() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set videoSession(value: VkVideoSessionKHR) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get videoSessionParameters() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set videoSessionParameters(value: VkVideoSessionParametersKHR) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pReferenceSlots(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkVideoEndCodingInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEndCodingInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEndCodingInfoKHR(new Uint8Array(VkVideoEndCodingInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoEndCodingFlagsKHR;
  }) {
    const s = VkVideoEndCodingInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEndCodingFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoCodingControlInfoKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoCodingControlInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoCodingControlInfoKHR(new Uint8Array(VkVideoCodingControlInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoCodingControlFlagsKHR;
  }) {
    const s = VkVideoCodingControlInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoCodingControlFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoEncodeUsageInfoKHR implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeUsageInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeUsageInfoKHR(new Uint8Array(VkVideoEncodeUsageInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    videoUsageHints?: VkVideoEncodeUsageFlagsKHR;
    videoContentHints?: VkVideoEncodeContentFlagsKHR;
    tuningMode?: VkVideoEncodeTuningModeKHR;
  }) {
    const s = VkVideoEncodeUsageInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.videoUsageHints !== undefined) s.videoUsageHints = data.videoUsageHints;
    if (data.videoContentHints !== undefined) s.videoContentHints = data.videoContentHints;
    if (data.tuningMode !== undefined) s.tuningMode = data.tuningMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get videoUsageHints() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoUsageHints(value: VkVideoEncodeUsageFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoContentHints() {
    return this.#view.getUint32(20, LE);
  }
  
  set videoContentHints(value: VkVideoEncodeContentFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tuningMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set tuningMode(value: VkVideoEncodeTuningModeKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkVideoEncodeInfoKHR implements IVkStructure {
  static size = 144;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeInfoKHR(new Uint8Array(VkVideoEncodeInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoEncodeFlagsKHR;
    qualityLevel: number;
    dstBitstreamBuffer: VkBuffer;
    dstBitstreamBufferOffset: VkDeviceSize;
    dstBitstreamBufferMaxRange: VkDeviceSize;
    srcPictureResource: VkVideoPictureResourceInfoKHR;
    pSetupReferenceSlot?: Deno.PointerValue;
    referenceSlotCount?: number;
    pReferenceSlots: Deno.PointerValue;
    precedingExternallyEncodedBytes: number;
  }) {
    const s = VkVideoEncodeInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.qualityLevel !== undefined) s.qualityLevel = data.qualityLevel;
    if (data.dstBitstreamBuffer !== undefined) s.dstBitstreamBuffer = data.dstBitstreamBuffer;
    if (data.dstBitstreamBufferOffset !== undefined) s.dstBitstreamBufferOffset = data.dstBitstreamBufferOffset;
    if (data.dstBitstreamBufferMaxRange !== undefined) s.dstBitstreamBufferMaxRange = data.dstBitstreamBufferMaxRange;
    if (data.srcPictureResource !== undefined) s.srcPictureResource = data.srcPictureResource;
    if (data.pSetupReferenceSlot !== undefined) s.pSetupReferenceSlot = data.pSetupReferenceSlot;
    if (data.referenceSlotCount !== undefined) s.referenceSlotCount = data.referenceSlotCount;
    if (data.pReferenceSlots !== undefined) s.pReferenceSlots = data.pReferenceSlots;
    if (data.precedingExternallyEncodedBytes !== undefined) s.precedingExternallyEncodedBytes = data.precedingExternallyEncodedBytes;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEncodeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get qualityLevel() {
    return this.#view.getUint32(20, LE);
  }
  
  set qualityLevel(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dstBitstreamBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstBitstreamBuffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstBitstreamBufferOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstBitstreamBufferOffset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstBitstreamBufferMaxRange() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstBitstreamBufferMaxRange(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get srcPictureResource() {
    return new VkVideoPictureResourceInfoKHR(this.#data.subarray(48, 48 + VkVideoPictureResourceInfoKHR.size));
  }
  
  set srcPictureResource(value: VkVideoPictureResourceInfoKHR) {
    if (value[BUFFER].byteLength < VkVideoPictureResourceInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get pSetupReferenceSlot() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pSetupReferenceSlot(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(104, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set pReferenceSlots(value: Deno.PointerValue) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
  
  get precedingExternallyEncodedBytes() {
    return this.#view.getUint32(120, LE);
  }
  
  set precedingExternallyEncodedBytes(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
}

export class VkVideoEncodeRateControlInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeRateControlInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeRateControlInfoKHR(new Uint8Array(VkVideoEncodeRateControlInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkVideoEncodeRateControlFlagsKHR;
    rateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR;
    layerCount: number;
    pLayerConfigs: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeRateControlInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.rateControlMode !== undefined) s.rateControlMode = data.rateControlMode;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    if (data.pLayerConfigs !== undefined) s.pLayerConfigs = data.pLayerConfigs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEncodeRateControlFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rateControlMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set rateControlMode(value: VkVideoEncodeRateControlModeFlagBitsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint8(24);
  }
  
  set layerCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pLayerConfigs() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pLayerConfigs(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeRateControlLayerInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeRateControlLayerInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeRateControlLayerInfoKHR(new Uint8Array(VkVideoEncodeRateControlLayerInfoKHR.size));
  }
  
  static create(data: {
    pNext: Deno.PointerValue;
    averageBitrate: number;
    maxBitrate: number;
    frameRateNumerator: number;
    frameRateDenominator: number;
    virtualBufferSizeInMs: number;
    initialVirtualBufferSizeInMs: number;
  }) {
    const s = VkVideoEncodeRateControlLayerInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.averageBitrate !== undefined) s.averageBitrate = data.averageBitrate;
    if (data.maxBitrate !== undefined) s.maxBitrate = data.maxBitrate;
    if (data.frameRateNumerator !== undefined) s.frameRateNumerator = data.frameRateNumerator;
    if (data.frameRateDenominator !== undefined) s.frameRateDenominator = data.frameRateDenominator;
    if (data.virtualBufferSizeInMs !== undefined) s.virtualBufferSizeInMs = data.virtualBufferSizeInMs;
    if (data.initialVirtualBufferSizeInMs !== undefined) s.initialVirtualBufferSizeInMs = data.initialVirtualBufferSizeInMs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get averageBitrate() {
    return this.#view.getUint32(16, LE);
  }
  
  set averageBitrate(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxBitrate() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxBitrate(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get frameRateNumerator() {
    return this.#view.getUint32(24, LE);
  }
  
  set frameRateNumerator(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get frameRateDenominator() {
    return this.#view.getUint32(28, LE);
  }
  
  set frameRateDenominator(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get virtualBufferSizeInMs() {
    return this.#view.getUint32(32, LE);
  }
  
  set virtualBufferSizeInMs(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get initialVirtualBufferSizeInMs() {
    return this.#view.getUint32(36, LE);
  }
  
  set initialVirtualBufferSizeInMs(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export class VkVideoEncodeCapabilitiesKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeCapabilitiesKHR(new Uint8Array(VkVideoEncodeCapabilitiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoEncodeCapabilityFlagsKHR;
    rateControlModes: VkVideoEncodeRateControlModeFlagsKHR;
    rateControlLayerCount: number;
    qualityLevelCount: number;
    inputImageDataFillAlignment: VkExtent2D;
  }) {
    const s = VkVideoEncodeCapabilitiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.rateControlModes !== undefined) s.rateControlModes = data.rateControlModes;
    if (data.rateControlLayerCount !== undefined) s.rateControlLayerCount = data.rateControlLayerCount;
    if (data.qualityLevelCount !== undefined) s.qualityLevelCount = data.qualityLevelCount;
    if (data.inputImageDataFillAlignment !== undefined) s.inputImageDataFillAlignment = data.inputImageDataFillAlignment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEncodeCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rateControlModes() {
    return this.#view.getUint32(20, LE);
  }
  
  set rateControlModes(value: VkVideoEncodeRateControlModeFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rateControlLayerCount() {
    return this.#view.getUint8(24);
  }
  
  set rateControlLayerCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get qualityLevelCount() {
    return this.#view.getUint8(25);
  }
  
  set qualityLevelCount(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get inputImageDataFillAlignment() {
    return new VkExtent2D(this.#data.subarray(32, 32 + VkExtent2D.size));
  }
  
  set inputImageDataFillAlignment(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkVideoEncodeH264CapabilitiesEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264CapabilitiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264CapabilitiesEXT(new Uint8Array(VkVideoEncodeH264CapabilitiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoEncodeH264CapabilityFlagsEXT;
    inputModeFlags: VkVideoEncodeH264InputModeFlagsEXT;
    outputModeFlags: VkVideoEncodeH264OutputModeFlagsEXT;
    maxPPictureL0ReferenceCount: number;
    maxBPictureL0ReferenceCount: number;
    maxL1ReferenceCount: number;
    motionVectorsOverPicBoundariesFlag: VkBool32;
    maxBytesPerPicDenom: number;
    maxBitsPerMbDenom: number;
    log2MaxMvLengthHorizontal: number;
    log2MaxMvLengthVertical: number;
  }) {
    const s = VkVideoEncodeH264CapabilitiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.inputModeFlags !== undefined) s.inputModeFlags = data.inputModeFlags;
    if (data.outputModeFlags !== undefined) s.outputModeFlags = data.outputModeFlags;
    if (data.maxPPictureL0ReferenceCount !== undefined) s.maxPPictureL0ReferenceCount = data.maxPPictureL0ReferenceCount;
    if (data.maxBPictureL0ReferenceCount !== undefined) s.maxBPictureL0ReferenceCount = data.maxBPictureL0ReferenceCount;
    if (data.maxL1ReferenceCount !== undefined) s.maxL1ReferenceCount = data.maxL1ReferenceCount;
    if (data.motionVectorsOverPicBoundariesFlag !== undefined) s.motionVectorsOverPicBoundariesFlag = data.motionVectorsOverPicBoundariesFlag;
    if (data.maxBytesPerPicDenom !== undefined) s.maxBytesPerPicDenom = data.maxBytesPerPicDenom;
    if (data.maxBitsPerMbDenom !== undefined) s.maxBitsPerMbDenom = data.maxBitsPerMbDenom;
    if (data.log2MaxMvLengthHorizontal !== undefined) s.log2MaxMvLengthHorizontal = data.log2MaxMvLengthHorizontal;
    if (data.log2MaxMvLengthVertical !== undefined) s.log2MaxMvLengthVertical = data.log2MaxMvLengthVertical;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEncodeH264CapabilityFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inputModeFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set inputModeFlags(value: VkVideoEncodeH264InputModeFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get outputModeFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set outputModeFlags(value: VkVideoEncodeH264OutputModeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxPPictureL0ReferenceCount() {
    return this.#view.getUint8(28);
  }
  
  set maxPPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(28, Number(value));
  }
  
  get maxBPictureL0ReferenceCount() {
    return this.#view.getUint8(29);
  }
  
  set maxBPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(29, Number(value));
  }
  
  get maxL1ReferenceCount() {
    return this.#view.getUint8(30);
  }
  
  set maxL1ReferenceCount(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get motionVectorsOverPicBoundariesFlag() {
    return this.#view.getUint32(32, LE);
  }
  
  set motionVectorsOverPicBoundariesFlag(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxBytesPerPicDenom() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxBytesPerPicDenom(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxBitsPerMbDenom() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxBitsPerMbDenom(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get log2MaxMvLengthHorizontal() {
    return this.#view.getUint32(44, LE);
  }
  
  set log2MaxMvLengthHorizontal(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get log2MaxMvLengthVertical() {
    return this.#view.getUint32(48, LE);
  }
  
  set log2MaxMvLengthVertical(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkVideoEncodeH264SessionParametersAddInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264SessionParametersAddInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264SessionParametersAddInfoEXT(new Uint8Array(VkVideoEncodeH264SessionParametersAddInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdSPSCount: number;
    pStdSPSs?: Deno.PointerValue;
    stdPPSCount: number;
    pStdPPSs?: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264SessionParametersAddInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdSPSCount !== undefined) s.stdSPSCount = data.stdSPSCount;
    if (data.pStdSPSs !== undefined) s.pStdSPSs = data.pStdSPSs;
    if (data.stdPPSCount !== undefined) s.stdPPSCount = data.stdPPSCount;
    if (data.pStdPPSs !== undefined) s.pStdPPSs = data.pStdPPSs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdSPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdPPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264SessionParametersCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264SessionParametersCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264SessionParametersCreateInfoEXT(new Uint8Array(VkVideoEncodeH264SessionParametersCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxStdSPSCount: number;
    maxStdPPSCount: number;
    pParametersAddInfo?: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264SessionParametersCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxStdSPSCount !== undefined) s.maxStdSPSCount = data.maxStdSPSCount;
    if (data.maxStdPPSCount !== undefined) s.maxStdPPSCount = data.maxStdPPSCount;
    if (data.pParametersAddInfo !== undefined) s.pParametersAddInfo = data.pParametersAddInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pParametersAddInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264DpbSlotInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264DpbSlotInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264DpbSlotInfoEXT(new Uint8Array(VkVideoEncodeH264DpbSlotInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    slotIndex: number;
    pStdReferenceInfo: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264DpbSlotInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.slotIndex !== undefined) s.slotIndex = data.slotIndex;
    if (data.pStdReferenceInfo !== undefined) s.pStdReferenceInfo = data.pStdReferenceInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt8(16);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt8(16, Number(value));
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdReferenceInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264VclFrameInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264VclFrameInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264VclFrameInfoEXT(new Uint8Array(VkVideoEncodeH264VclFrameInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pReferenceFinalLists?: Deno.PointerValue;
    naluSliceEntryCount: number;
    pNaluSliceEntries: Deno.PointerValue;
    pCurrentPictureInfo: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264VclFrameInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pReferenceFinalLists !== undefined) s.pReferenceFinalLists = data.pReferenceFinalLists;
    if (data.naluSliceEntryCount !== undefined) s.naluSliceEntryCount = data.naluSliceEntryCount;
    if (data.pNaluSliceEntries !== undefined) s.pNaluSliceEntries = data.pNaluSliceEntries;
    if (data.pCurrentPictureInfo !== undefined) s.pCurrentPictureInfo = data.pCurrentPictureInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceFinalLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get naluSliceEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set naluSliceEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pNaluSliceEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pNaluSliceEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pCurrentPictureInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCurrentPictureInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264ReferenceListsInfoEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264ReferenceListsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264ReferenceListsInfoEXT(new Uint8Array(VkVideoEncodeH264ReferenceListsInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    referenceList0EntryCount?: number;
    pReferenceList0Entries: Deno.PointerValue;
    referenceList1EntryCount?: number;
    pReferenceList1Entries: Deno.PointerValue;
    pMemMgmtCtrlOperations: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264ReferenceListsInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.referenceList0EntryCount !== undefined) s.referenceList0EntryCount = data.referenceList0EntryCount;
    if (data.pReferenceList0Entries !== undefined) s.pReferenceList0Entries = data.pReferenceList0Entries;
    if (data.referenceList1EntryCount !== undefined) s.referenceList1EntryCount = data.referenceList1EntryCount;
    if (data.pReferenceList1Entries !== undefined) s.pReferenceList1Entries = data.pReferenceList1Entries;
    if (data.pMemMgmtCtrlOperations !== undefined) s.pMemMgmtCtrlOperations = data.pMemMgmtCtrlOperations;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get referenceList0EntryCount() {
    return this.#view.getUint8(16);
  }
  
  set referenceList0EntryCount(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pReferenceList0Entries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceList0Entries(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get referenceList1EntryCount() {
    return this.#view.getUint8(32);
  }
  
  set referenceList1EntryCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pReferenceList1Entries() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pReferenceList1Entries(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pMemMgmtCtrlOperations() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pMemMgmtCtrlOperations(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264EmitPictureParametersInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264EmitPictureParametersInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264EmitPictureParametersInfoEXT(new Uint8Array(VkVideoEncodeH264EmitPictureParametersInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    spsId: number;
    emitSpsEnable: VkBool32;
    ppsIdEntryCount: number;
    ppsIdEntries: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264EmitPictureParametersInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.spsId !== undefined) s.spsId = data.spsId;
    if (data.emitSpsEnable !== undefined) s.emitSpsEnable = data.emitSpsEnable;
    if (data.ppsIdEntryCount !== undefined) s.ppsIdEntryCount = data.ppsIdEntryCount;
    if (data.ppsIdEntries !== undefined) s.ppsIdEntries = data.ppsIdEntries;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get spsId() {
    return this.#view.getUint8(16);
  }
  
  set spsId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get emitSpsEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set emitSpsEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get ppsIdEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set ppsIdEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ppsIdEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set ppsIdEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264ProfileInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264ProfileInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264ProfileInfoEXT(new Uint8Array(VkVideoEncodeH264ProfileInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdProfileIdc: StdVideoH264ProfileIdc;
  }) {
    const s = VkVideoEncodeH264ProfileInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdProfileIdc !== undefined) s.stdProfileIdc = data.stdProfileIdc;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoEncodeH264NaluSliceInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264NaluSliceInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264NaluSliceInfoEXT(new Uint8Array(VkVideoEncodeH264NaluSliceInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mbCount: number;
    pReferenceFinalLists?: Deno.PointerValue;
    pSliceHeaderStd: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH264NaluSliceInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mbCount !== undefined) s.mbCount = data.mbCount;
    if (data.pReferenceFinalLists !== undefined) s.pReferenceFinalLists = data.pReferenceFinalLists;
    if (data.pSliceHeaderStd !== undefined) s.pSliceHeaderStd = data.pSliceHeaderStd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mbCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set mbCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceFinalLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pSliceHeaderStd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceHeaderStd(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeH264RateControlInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264RateControlInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264RateControlInfoEXT(new Uint8Array(VkVideoEncodeH264RateControlInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    gopFrameCount: number;
    idrPeriod: number;
    consecutiveBFrameCount: number;
    rateControlStructure: VkVideoEncodeH264RateControlStructureEXT;
    temporalLayerCount: number;
  }) {
    const s = VkVideoEncodeH264RateControlInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.gopFrameCount !== undefined) s.gopFrameCount = data.gopFrameCount;
    if (data.idrPeriod !== undefined) s.idrPeriod = data.idrPeriod;
    if (data.consecutiveBFrameCount !== undefined) s.consecutiveBFrameCount = data.consecutiveBFrameCount;
    if (data.rateControlStructure !== undefined) s.rateControlStructure = data.rateControlStructure;
    if (data.temporalLayerCount !== undefined) s.temporalLayerCount = data.temporalLayerCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get gopFrameCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set gopFrameCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get idrPeriod() {
    return this.#view.getUint32(20, LE);
  }
  
  set idrPeriod(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get consecutiveBFrameCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set consecutiveBFrameCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rateControlStructure() {
    return this.#view.getUint32(28, LE);
  }
  
  set rateControlStructure(value: VkVideoEncodeH264RateControlStructureEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get temporalLayerCount() {
    return this.#view.getUint8(32);
  }
  
  set temporalLayerCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export class VkVideoEncodeH264QpEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264QpEXT(new Uint8Array(VkVideoEncodeH264QpEXT.size));
  }
  
  static create(data: {
    qpI: number;
    qpP: number;
    qpB: number;
  }) {
    const s = VkVideoEncodeH264QpEXT.alloc();
    if (data.qpI !== undefined) s.qpI = data.qpI;
    if (data.qpP !== undefined) s.qpP = data.qpP;
    if (data.qpB !== undefined) s.qpB = data.qpB;
    return s;
  }
  
  get qpI() {
    return this.#view.getInt32(0, LE);
  }
  
  set qpI(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get qpP() {
    return this.#view.getInt32(4, LE);
  }
  
  set qpP(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get qpB() {
    return this.#view.getInt32(8, LE);
  }
  
  set qpB(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export class VkVideoEncodeH264FrameSizeEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264FrameSizeEXT(new Uint8Array(VkVideoEncodeH264FrameSizeEXT.size));
  }
  
  static create(data: {
    frameISize: number;
    framePSize: number;
    frameBSize: number;
  }) {
    const s = VkVideoEncodeH264FrameSizeEXT.alloc();
    if (data.frameISize !== undefined) s.frameISize = data.frameISize;
    if (data.framePSize !== undefined) s.framePSize = data.framePSize;
    if (data.frameBSize !== undefined) s.frameBSize = data.frameBSize;
    return s;
  }
  
  get frameISize() {
    return this.#view.getUint32(0, LE);
  }
  
  set frameISize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get framePSize() {
    return this.#view.getUint32(4, LE);
  }
  
  set framePSize(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get frameBSize() {
    return this.#view.getUint32(8, LE);
  }
  
  set frameBSize(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkVideoEncodeH264RateControlLayerInfoEXT implements IVkStructure {
  static size = 108;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH264RateControlLayerInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH264RateControlLayerInfoEXT(new Uint8Array(VkVideoEncodeH264RateControlLayerInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    temporalLayerId: number;
    useInitialRcQp: VkBool32;
    initialRcQp: VkVideoEncodeH264QpEXT;
    useMinQp: VkBool32;
    minQp: VkVideoEncodeH264QpEXT;
    useMaxQp: VkBool32;
    maxQp: VkVideoEncodeH264QpEXT;
    useMaxFrameSize: VkBool32;
    maxFrameSize: VkVideoEncodeH264FrameSizeEXT;
  }) {
    const s = VkVideoEncodeH264RateControlLayerInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.temporalLayerId !== undefined) s.temporalLayerId = data.temporalLayerId;
    if (data.useInitialRcQp !== undefined) s.useInitialRcQp = data.useInitialRcQp;
    if (data.initialRcQp !== undefined) s.initialRcQp = data.initialRcQp;
    if (data.useMinQp !== undefined) s.useMinQp = data.useMinQp;
    if (data.minQp !== undefined) s.minQp = data.minQp;
    if (data.useMaxQp !== undefined) s.useMaxQp = data.useMaxQp;
    if (data.maxQp !== undefined) s.maxQp = data.maxQp;
    if (data.useMaxFrameSize !== undefined) s.useMaxFrameSize = data.useMaxFrameSize;
    if (data.maxFrameSize !== undefined) s.maxFrameSize = data.maxFrameSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get temporalLayerId() {
    return this.#view.getUint8(16);
  }
  
  set temporalLayerId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get useInitialRcQp() {
    return this.#view.getUint32(20, LE);
  }
  
  set useInitialRcQp(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get initialRcQp() {
    return new VkVideoEncodeH264QpEXT(this.#data.subarray(24, 24 + VkVideoEncodeH264QpEXT.size));
  }
  
  set initialRcQp(value: VkVideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get useMinQp() {
    return this.#view.getUint32(36, LE);
  }
  
  set useMinQp(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minQp() {
    return new VkVideoEncodeH264QpEXT(this.#data.subarray(48, 48 + VkVideoEncodeH264QpEXT.size));
  }
  
  set minQp(value: VkVideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get useMaxQp() {
    return this.#view.getUint32(60, LE);
  }
  
  set useMaxQp(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxQp() {
    return new VkVideoEncodeH264QpEXT(this.#data.subarray(72, 72 + VkVideoEncodeH264QpEXT.size));
  }
  
  set maxQp(value: VkVideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get useMaxFrameSize() {
    return this.#view.getUint32(84, LE);
  }
  
  set useMaxFrameSize(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxFrameSize() {
    return new VkVideoEncodeH264FrameSizeEXT(this.#data.subarray(96, 96 + VkVideoEncodeH264FrameSizeEXT.size));
  }
  
  set maxFrameSize(value: VkVideoEncodeH264FrameSizeEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH264FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 96);
  }
}

export class VkVideoEncodeH265CapabilitiesEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265CapabilitiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265CapabilitiesEXT(new Uint8Array(VkVideoEncodeH265CapabilitiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkVideoEncodeH265CapabilityFlagsEXT;
    inputModeFlags: VkVideoEncodeH265InputModeFlagsEXT;
    outputModeFlags: VkVideoEncodeH265OutputModeFlagsEXT;
    ctbSizes: VkVideoEncodeH265CtbSizeFlagsEXT;
    transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsEXT;
    maxPPictureL0ReferenceCount: number;
    maxBPictureL0ReferenceCount: number;
    maxL1ReferenceCount: number;
    maxSubLayersCount: number;
    minLog2MinLumaCodingBlockSizeMinus3: number;
    maxLog2MinLumaCodingBlockSizeMinus3: number;
    minLog2MinLumaTransformBlockSizeMinus2: number;
    maxLog2MinLumaTransformBlockSizeMinus2: number;
    minMaxTransformHierarchyDepthInter: number;
    maxMaxTransformHierarchyDepthInter: number;
    minMaxTransformHierarchyDepthIntra: number;
    maxMaxTransformHierarchyDepthIntra: number;
    maxDiffCuQpDeltaDepth: number;
    minMaxNumMergeCand: number;
    maxMaxNumMergeCand: number;
  }) {
    const s = VkVideoEncodeH265CapabilitiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.inputModeFlags !== undefined) s.inputModeFlags = data.inputModeFlags;
    if (data.outputModeFlags !== undefined) s.outputModeFlags = data.outputModeFlags;
    if (data.ctbSizes !== undefined) s.ctbSizes = data.ctbSizes;
    if (data.transformBlockSizes !== undefined) s.transformBlockSizes = data.transformBlockSizes;
    if (data.maxPPictureL0ReferenceCount !== undefined) s.maxPPictureL0ReferenceCount = data.maxPPictureL0ReferenceCount;
    if (data.maxBPictureL0ReferenceCount !== undefined) s.maxBPictureL0ReferenceCount = data.maxBPictureL0ReferenceCount;
    if (data.maxL1ReferenceCount !== undefined) s.maxL1ReferenceCount = data.maxL1ReferenceCount;
    if (data.maxSubLayersCount !== undefined) s.maxSubLayersCount = data.maxSubLayersCount;
    if (data.minLog2MinLumaCodingBlockSizeMinus3 !== undefined) s.minLog2MinLumaCodingBlockSizeMinus3 = data.minLog2MinLumaCodingBlockSizeMinus3;
    if (data.maxLog2MinLumaCodingBlockSizeMinus3 !== undefined) s.maxLog2MinLumaCodingBlockSizeMinus3 = data.maxLog2MinLumaCodingBlockSizeMinus3;
    if (data.minLog2MinLumaTransformBlockSizeMinus2 !== undefined) s.minLog2MinLumaTransformBlockSizeMinus2 = data.minLog2MinLumaTransformBlockSizeMinus2;
    if (data.maxLog2MinLumaTransformBlockSizeMinus2 !== undefined) s.maxLog2MinLumaTransformBlockSizeMinus2 = data.maxLog2MinLumaTransformBlockSizeMinus2;
    if (data.minMaxTransformHierarchyDepthInter !== undefined) s.minMaxTransformHierarchyDepthInter = data.minMaxTransformHierarchyDepthInter;
    if (data.maxMaxTransformHierarchyDepthInter !== undefined) s.maxMaxTransformHierarchyDepthInter = data.maxMaxTransformHierarchyDepthInter;
    if (data.minMaxTransformHierarchyDepthIntra !== undefined) s.minMaxTransformHierarchyDepthIntra = data.minMaxTransformHierarchyDepthIntra;
    if (data.maxMaxTransformHierarchyDepthIntra !== undefined) s.maxMaxTransformHierarchyDepthIntra = data.maxMaxTransformHierarchyDepthIntra;
    if (data.maxDiffCuQpDeltaDepth !== undefined) s.maxDiffCuQpDeltaDepth = data.maxDiffCuQpDeltaDepth;
    if (data.minMaxNumMergeCand !== undefined) s.minMaxNumMergeCand = data.minMaxNumMergeCand;
    if (data.maxMaxNumMergeCand !== undefined) s.maxMaxNumMergeCand = data.maxMaxNumMergeCand;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkVideoEncodeH265CapabilityFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inputModeFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set inputModeFlags(value: VkVideoEncodeH265InputModeFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get outputModeFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set outputModeFlags(value: VkVideoEncodeH265OutputModeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ctbSizes() {
    return this.#view.getUint32(28, LE);
  }
  
  set ctbSizes(value: VkVideoEncodeH265CtbSizeFlagsEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get transformBlockSizes() {
    return this.#view.getUint32(32, LE);
  }
  
  set transformBlockSizes(value: VkVideoEncodeH265TransformBlockSizeFlagsEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxPPictureL0ReferenceCount() {
    return this.#view.getUint8(36);
  }
  
  set maxPPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(36, Number(value));
  }
  
  get maxBPictureL0ReferenceCount() {
    return this.#view.getUint8(37);
  }
  
  set maxBPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(37, Number(value));
  }
  
  get maxL1ReferenceCount() {
    return this.#view.getUint8(38);
  }
  
  set maxL1ReferenceCount(value: number) {
    this.#view.setUint8(38, Number(value));
  }
  
  get maxSubLayersCount() {
    return this.#view.getUint8(39);
  }
  
  set maxSubLayersCount(value: number) {
    this.#view.setUint8(39, Number(value));
  }
  
  get minLog2MinLumaCodingBlockSizeMinus3() {
    return this.#view.getUint8(40);
  }
  
  set minLog2MinLumaCodingBlockSizeMinus3(value: number) {
    this.#view.setUint8(40, Number(value));
  }
  
  get maxLog2MinLumaCodingBlockSizeMinus3() {
    return this.#view.getUint8(41);
  }
  
  set maxLog2MinLumaCodingBlockSizeMinus3(value: number) {
    this.#view.setUint8(41, Number(value));
  }
  
  get minLog2MinLumaTransformBlockSizeMinus2() {
    return this.#view.getUint8(42);
  }
  
  set minLog2MinLumaTransformBlockSizeMinus2(value: number) {
    this.#view.setUint8(42, Number(value));
  }
  
  get maxLog2MinLumaTransformBlockSizeMinus2() {
    return this.#view.getUint8(43);
  }
  
  set maxLog2MinLumaTransformBlockSizeMinus2(value: number) {
    this.#view.setUint8(43, Number(value));
  }
  
  get minMaxTransformHierarchyDepthInter() {
    return this.#view.getUint8(44);
  }
  
  set minMaxTransformHierarchyDepthInter(value: number) {
    this.#view.setUint8(44, Number(value));
  }
  
  get maxMaxTransformHierarchyDepthInter() {
    return this.#view.getUint8(45);
  }
  
  set maxMaxTransformHierarchyDepthInter(value: number) {
    this.#view.setUint8(45, Number(value));
  }
  
  get minMaxTransformHierarchyDepthIntra() {
    return this.#view.getUint8(46);
  }
  
  set minMaxTransformHierarchyDepthIntra(value: number) {
    this.#view.setUint8(46, Number(value));
  }
  
  get maxMaxTransformHierarchyDepthIntra() {
    return this.#view.getUint8(47);
  }
  
  set maxMaxTransformHierarchyDepthIntra(value: number) {
    this.#view.setUint8(47, Number(value));
  }
  
  get maxDiffCuQpDeltaDepth() {
    return this.#view.getUint8(48);
  }
  
  set maxDiffCuQpDeltaDepth(value: number) {
    this.#view.setUint8(48, Number(value));
  }
  
  get minMaxNumMergeCand() {
    return this.#view.getUint8(49);
  }
  
  set minMaxNumMergeCand(value: number) {
    this.#view.setUint8(49, Number(value));
  }
  
  get maxMaxNumMergeCand() {
    return this.#view.getUint8(50);
  }
  
  set maxMaxNumMergeCand(value: number) {
    this.#view.setUint8(50, Number(value));
  }
}

export class VkVideoEncodeH265SessionParametersAddInfoEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265SessionParametersAddInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265SessionParametersAddInfoEXT(new Uint8Array(VkVideoEncodeH265SessionParametersAddInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdVPSCount: number;
    pStdVPSs?: Deno.PointerValue;
    stdSPSCount: number;
    pStdSPSs?: Deno.PointerValue;
    stdPPSCount: number;
    pStdPPSs?: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265SessionParametersAddInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdVPSCount !== undefined) s.stdVPSCount = data.stdVPSCount;
    if (data.pStdVPSs !== undefined) s.pStdVPSs = data.pStdVPSs;
    if (data.stdSPSCount !== undefined) s.stdSPSCount = data.stdSPSCount;
    if (data.pStdSPSs !== undefined) s.pStdSPSs = data.pStdSPSs;
    if (data.stdPPSCount !== undefined) s.stdPPSCount = data.stdPPSCount;
    if (data.pStdPPSs !== undefined) s.pStdPPSs = data.pStdPPSs;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdVPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdVPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdSPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pStdPPSs(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265SessionParametersCreateInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265SessionParametersCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265SessionParametersCreateInfoEXT(new Uint8Array(VkVideoEncodeH265SessionParametersCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxStdVPSCount: number;
    maxStdSPSCount: number;
    maxStdPPSCount: number;
    pParametersAddInfo?: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265SessionParametersCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxStdVPSCount !== undefined) s.maxStdVPSCount = data.maxStdVPSCount;
    if (data.maxStdSPSCount !== undefined) s.maxStdSPSCount = data.maxStdSPSCount;
    if (data.maxStdPPSCount !== undefined) s.maxStdPPSCount = data.maxStdPPSCount;
    if (data.pParametersAddInfo !== undefined) s.pParametersAddInfo = data.pParametersAddInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxStdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pParametersAddInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265VclFrameInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265VclFrameInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265VclFrameInfoEXT(new Uint8Array(VkVideoEncodeH265VclFrameInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pReferenceFinalLists?: Deno.PointerValue;
    naluSliceSegmentEntryCount: number;
    pNaluSliceSegmentEntries: Deno.PointerValue;
    pCurrentPictureInfo: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265VclFrameInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pReferenceFinalLists !== undefined) s.pReferenceFinalLists = data.pReferenceFinalLists;
    if (data.naluSliceSegmentEntryCount !== undefined) s.naluSliceSegmentEntryCount = data.naluSliceSegmentEntryCount;
    if (data.pNaluSliceSegmentEntries !== undefined) s.pNaluSliceSegmentEntries = data.pNaluSliceSegmentEntries;
    if (data.pCurrentPictureInfo !== undefined) s.pCurrentPictureInfo = data.pCurrentPictureInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceFinalLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get naluSliceSegmentEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set naluSliceSegmentEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pNaluSliceSegmentEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pNaluSliceSegmentEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pCurrentPictureInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCurrentPictureInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265EmitPictureParametersInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265EmitPictureParametersInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265EmitPictureParametersInfoEXT(new Uint8Array(VkVideoEncodeH265EmitPictureParametersInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vpsId: number;
    spsId: number;
    emitVpsEnable: VkBool32;
    emitSpsEnable: VkBool32;
    ppsIdEntryCount?: number;
    ppsIdEntries: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265EmitPictureParametersInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vpsId !== undefined) s.vpsId = data.vpsId;
    if (data.spsId !== undefined) s.spsId = data.spsId;
    if (data.emitVpsEnable !== undefined) s.emitVpsEnable = data.emitVpsEnable;
    if (data.emitSpsEnable !== undefined) s.emitSpsEnable = data.emitSpsEnable;
    if (data.ppsIdEntryCount !== undefined) s.ppsIdEntryCount = data.ppsIdEntryCount;
    if (data.ppsIdEntries !== undefined) s.ppsIdEntries = data.ppsIdEntries;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vpsId() {
    return this.#view.getUint8(16);
  }
  
  set vpsId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get spsId() {
    return this.#view.getUint8(17);
  }
  
  set spsId(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get emitVpsEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set emitVpsEnable(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get emitSpsEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set emitSpsEnable(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ppsIdEntryCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set ppsIdEntryCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get ppsIdEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set ppsIdEntries(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265NaluSliceSegmentInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265NaluSliceSegmentInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265NaluSliceSegmentInfoEXT(new Uint8Array(VkVideoEncodeH265NaluSliceSegmentInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    ctbCount: number;
    pReferenceFinalLists?: Deno.PointerValue;
    pSliceSegmentHeaderStd: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265NaluSliceSegmentInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.ctbCount !== undefined) s.ctbCount = data.ctbCount;
    if (data.pReferenceFinalLists !== undefined) s.pReferenceFinalLists = data.pReferenceFinalLists;
    if (data.pSliceSegmentHeaderStd !== undefined) s.pSliceSegmentHeaderStd = data.pSliceSegmentHeaderStd;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get ctbCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set ctbCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceFinalLists(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pSliceSegmentHeaderStd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceSegmentHeaderStd(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265RateControlInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265RateControlInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265RateControlInfoEXT(new Uint8Array(VkVideoEncodeH265RateControlInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    gopFrameCount: number;
    idrPeriod: number;
    consecutiveBFrameCount: number;
    rateControlStructure: VkVideoEncodeH265RateControlStructureEXT;
    subLayerCount: number;
  }) {
    const s = VkVideoEncodeH265RateControlInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.gopFrameCount !== undefined) s.gopFrameCount = data.gopFrameCount;
    if (data.idrPeriod !== undefined) s.idrPeriod = data.idrPeriod;
    if (data.consecutiveBFrameCount !== undefined) s.consecutiveBFrameCount = data.consecutiveBFrameCount;
    if (data.rateControlStructure !== undefined) s.rateControlStructure = data.rateControlStructure;
    if (data.subLayerCount !== undefined) s.subLayerCount = data.subLayerCount;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get gopFrameCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set gopFrameCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get idrPeriod() {
    return this.#view.getUint32(20, LE);
  }
  
  set idrPeriod(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get consecutiveBFrameCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set consecutiveBFrameCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rateControlStructure() {
    return this.#view.getUint32(28, LE);
  }
  
  set rateControlStructure(value: VkVideoEncodeH265RateControlStructureEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get subLayerCount() {
    return this.#view.getUint8(32);
  }
  
  set subLayerCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export class VkVideoEncodeH265QpEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265QpEXT(new Uint8Array(VkVideoEncodeH265QpEXT.size));
  }
  
  static create(data: {
    qpI: number;
    qpP: number;
    qpB: number;
  }) {
    const s = VkVideoEncodeH265QpEXT.alloc();
    if (data.qpI !== undefined) s.qpI = data.qpI;
    if (data.qpP !== undefined) s.qpP = data.qpP;
    if (data.qpB !== undefined) s.qpB = data.qpB;
    return s;
  }
  
  get qpI() {
    return this.#view.getInt32(0, LE);
  }
  
  set qpI(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get qpP() {
    return this.#view.getInt32(4, LE);
  }
  
  set qpP(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get qpB() {
    return this.#view.getInt32(8, LE);
  }
  
  set qpB(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export class VkVideoEncodeH265FrameSizeEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265FrameSizeEXT(new Uint8Array(VkVideoEncodeH265FrameSizeEXT.size));
  }
  
  static create(data: {
    frameISize: number;
    framePSize: number;
    frameBSize: number;
  }) {
    const s = VkVideoEncodeH265FrameSizeEXT.alloc();
    if (data.frameISize !== undefined) s.frameISize = data.frameISize;
    if (data.framePSize !== undefined) s.framePSize = data.framePSize;
    if (data.frameBSize !== undefined) s.frameBSize = data.frameBSize;
    return s;
  }
  
  get frameISize() {
    return this.#view.getUint32(0, LE);
  }
  
  set frameISize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get framePSize() {
    return this.#view.getUint32(4, LE);
  }
  
  set framePSize(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get frameBSize() {
    return this.#view.getUint32(8, LE);
  }
  
  set frameBSize(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkVideoEncodeH265RateControlLayerInfoEXT implements IVkStructure {
  static size = 108;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265RateControlLayerInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265RateControlLayerInfoEXT(new Uint8Array(VkVideoEncodeH265RateControlLayerInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    temporalId: number;
    useInitialRcQp: VkBool32;
    initialRcQp: VkVideoEncodeH265QpEXT;
    useMinQp: VkBool32;
    minQp: VkVideoEncodeH265QpEXT;
    useMaxQp: VkBool32;
    maxQp: VkVideoEncodeH265QpEXT;
    useMaxFrameSize: VkBool32;
    maxFrameSize: VkVideoEncodeH265FrameSizeEXT;
  }) {
    const s = VkVideoEncodeH265RateControlLayerInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.temporalId !== undefined) s.temporalId = data.temporalId;
    if (data.useInitialRcQp !== undefined) s.useInitialRcQp = data.useInitialRcQp;
    if (data.initialRcQp !== undefined) s.initialRcQp = data.initialRcQp;
    if (data.useMinQp !== undefined) s.useMinQp = data.useMinQp;
    if (data.minQp !== undefined) s.minQp = data.minQp;
    if (data.useMaxQp !== undefined) s.useMaxQp = data.useMaxQp;
    if (data.maxQp !== undefined) s.maxQp = data.maxQp;
    if (data.useMaxFrameSize !== undefined) s.useMaxFrameSize = data.useMaxFrameSize;
    if (data.maxFrameSize !== undefined) s.maxFrameSize = data.maxFrameSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get temporalId() {
    return this.#view.getUint8(16);
  }
  
  set temporalId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get useInitialRcQp() {
    return this.#view.getUint32(20, LE);
  }
  
  set useInitialRcQp(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get initialRcQp() {
    return new VkVideoEncodeH265QpEXT(this.#data.subarray(24, 24 + VkVideoEncodeH265QpEXT.size));
  }
  
  set initialRcQp(value: VkVideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get useMinQp() {
    return this.#view.getUint32(36, LE);
  }
  
  set useMinQp(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minQp() {
    return new VkVideoEncodeH265QpEXT(this.#data.subarray(48, 48 + VkVideoEncodeH265QpEXT.size));
  }
  
  set minQp(value: VkVideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get useMaxQp() {
    return this.#view.getUint32(60, LE);
  }
  
  set useMaxQp(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxQp() {
    return new VkVideoEncodeH265QpEXT(this.#data.subarray(72, 72 + VkVideoEncodeH265QpEXT.size));
  }
  
  set maxQp(value: VkVideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
  
  get useMaxFrameSize() {
    return this.#view.getUint32(84, LE);
  }
  
  set useMaxFrameSize(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxFrameSize() {
    return new VkVideoEncodeH265FrameSizeEXT(this.#data.subarray(96, 96 + VkVideoEncodeH265FrameSizeEXT.size));
  }
  
  set maxFrameSize(value: VkVideoEncodeH265FrameSizeEXT) {
    if (value[BUFFER].byteLength < VkVideoEncodeH265FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 96);
  }
}

export class VkVideoEncodeH265ProfileInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265ProfileInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265ProfileInfoEXT(new Uint8Array(VkVideoEncodeH265ProfileInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    stdProfileIdc: StdVideoH265ProfileIdc;
  }) {
    const s = VkVideoEncodeH265ProfileInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.stdProfileIdc !== undefined) s.stdProfileIdc = data.stdProfileIdc;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkVideoEncodeH265DpbSlotInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265DpbSlotInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265DpbSlotInfoEXT(new Uint8Array(VkVideoEncodeH265DpbSlotInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    slotIndex: number;
    pStdReferenceInfo: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265DpbSlotInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.slotIndex !== undefined) s.slotIndex = data.slotIndex;
    if (data.pStdReferenceInfo !== undefined) s.pStdReferenceInfo = data.pStdReferenceInfo;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt8(16);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt8(16, Number(value));
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdReferenceInfo(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkVideoEncodeH265ReferenceListsInfoEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkVideoEncodeH265ReferenceListsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkVideoEncodeH265ReferenceListsInfoEXT(new Uint8Array(VkVideoEncodeH265ReferenceListsInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    referenceList0EntryCount?: number;
    pReferenceList0Entries: Deno.PointerValue;
    referenceList1EntryCount?: number;
    pReferenceList1Entries: Deno.PointerValue;
    pReferenceModifications: Deno.PointerValue;
  }) {
    const s = VkVideoEncodeH265ReferenceListsInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.referenceList0EntryCount !== undefined) s.referenceList0EntryCount = data.referenceList0EntryCount;
    if (data.pReferenceList0Entries !== undefined) s.pReferenceList0Entries = data.pReferenceList0Entries;
    if (data.referenceList1EntryCount !== undefined) s.referenceList1EntryCount = data.referenceList1EntryCount;
    if (data.pReferenceList1Entries !== undefined) s.pReferenceList1Entries = data.pReferenceList1Entries;
    if (data.pReferenceModifications !== undefined) s.pReferenceModifications = data.pReferenceModifications;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get referenceList0EntryCount() {
    return this.#view.getUint8(16);
  }
  
  set referenceList0EntryCount(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pReferenceList0Entries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceList0Entries(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get referenceList1EntryCount() {
    return this.#view.getUint8(32);
  }
  
  set referenceList1EntryCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pReferenceList1Entries() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pReferenceList1Entries(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pReferenceModifications() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pReferenceModifications(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceInheritedViewportScissorFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceInheritedViewportScissorFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceInheritedViewportScissorFeaturesNV(new Uint8Array(VkPhysicalDeviceInheritedViewportScissorFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    inheritedViewportScissor2D: VkBool32;
  }) {
    const s = VkPhysicalDeviceInheritedViewportScissorFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.inheritedViewportScissor2D !== undefined) s.inheritedViewportScissor2D = data.inheritedViewportScissor2D;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get inheritedViewportScissor2D() {
    return this.#view.getUint32(16, LE);
  }
  
  set inheritedViewportScissor2D(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCommandBufferInheritanceViewportScissorInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferInheritanceViewportScissorInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferInheritanceViewportScissorInfoNV(new Uint8Array(VkCommandBufferInheritanceViewportScissorInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    viewportScissor2D: VkBool32;
    viewportDepthCount: number;
    pViewportDepths: Deno.PointerValue;
  }) {
    const s = VkCommandBufferInheritanceViewportScissorInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.viewportScissor2D !== undefined) s.viewportScissor2D = data.viewportScissor2D;
    if (data.viewportDepthCount !== undefined) s.viewportDepthCount = data.viewportDepthCount;
    if (data.pViewportDepths !== undefined) s.pViewportDepths = data.pViewportDepths;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get viewportScissor2D() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewportScissor2D(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportDepthCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportDepthCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportDepths() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportDepths(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(new Uint8Array(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    ycbcr2plane444Formats: VkBool32;
  }) {
    const s = VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.ycbcr2plane444Formats !== undefined) s.ycbcr2plane444Formats = data.ycbcr2plane444Formats;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get ycbcr2plane444Formats() {
    return this.#view.getUint32(16, LE);
  }
  
  set ycbcr2plane444Formats(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceProvokingVertexFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProvokingVertexFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProvokingVertexFeaturesEXT(new Uint8Array(VkPhysicalDeviceProvokingVertexFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    provokingVertexLast: VkBool32;
    transformFeedbackPreservesProvokingVertex: VkBool32;
  }) {
    const s = VkPhysicalDeviceProvokingVertexFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.provokingVertexLast !== undefined) s.provokingVertexLast = data.provokingVertexLast;
    if (data.transformFeedbackPreservesProvokingVertex !== undefined) s.transformFeedbackPreservesProvokingVertex = data.transformFeedbackPreservesProvokingVertex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get provokingVertexLast() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexLast(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transformFeedbackPreservesProvokingVertex() {
    return this.#view.getUint32(20, LE);
  }
  
  set transformFeedbackPreservesProvokingVertex(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceProvokingVertexPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceProvokingVertexPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceProvokingVertexPropertiesEXT(new Uint8Array(VkPhysicalDeviceProvokingVertexPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    provokingVertexModePerPipeline: VkBool32;
    transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32;
  }) {
    const s = VkPhysicalDeviceProvokingVertexPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.provokingVertexModePerPipeline !== undefined) s.provokingVertexModePerPipeline = data.provokingVertexModePerPipeline;
    if (data.transformFeedbackPreservesTriangleFanProvokingVertex !== undefined) s.transformFeedbackPreservesTriangleFanProvokingVertex = data.transformFeedbackPreservesTriangleFanProvokingVertex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get provokingVertexModePerPipeline() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexModePerPipeline(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transformFeedbackPreservesTriangleFanProvokingVertex() {
    return this.#view.getUint32(20, LE);
  }
  
  set transformFeedbackPreservesTriangleFanProvokingVertex(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPipelineRasterizationProvokingVertexStateCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(new Uint8Array(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    provokingVertexMode: VkProvokingVertexModeEXT;
  }) {
    const s = VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.provokingVertexMode !== undefined) s.provokingVertexMode = data.provokingVertexMode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get provokingVertexMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexMode(value: VkProvokingVertexModeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCuModuleCreateInfoNVX implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCuModuleCreateInfoNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCuModuleCreateInfoNVX(new Uint8Array(VkCuModuleCreateInfoNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dataSize: Deno.PointerValue;
    pData: Deno.PointerValue;
  }) {
    const s = VkCuModuleCreateInfoNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dataSize !== undefined) s.dataSize = data.dataSize;
    if (data.pData !== undefined) s.pData = data.pData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkCuFunctionCreateInfoNVX implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCuFunctionCreateInfoNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCuFunctionCreateInfoNVX(new Uint8Array(VkCuFunctionCreateInfoNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    module: VkCuModuleNVX;
    pName: Deno.PointerValue;
  }) {
    const s = VkCuFunctionCreateInfoNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.module !== undefined) s.module = data.module;
    if (data.pName !== undefined) s.pName = data.pName;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get module() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set module(value: VkCuModuleNVX) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pName() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pName(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkCuLaunchInfoNVX implements IVkStructure {
  static size = 88;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCuLaunchInfoNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCuLaunchInfoNVX(new Uint8Array(VkCuLaunchInfoNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vk_function: VkCuFunctionNVX;
    gridDimX: number;
    gridDimY: number;
    gridDimZ: number;
    blockDimX: number;
    blockDimY: number;
    blockDimZ: number;
    sharedMemBytes: number;
    paramCount?: Deno.PointerValue;
    pParams: Deno.PointerValue;
    extraCount?: Deno.PointerValue;
    pExtras: Deno.PointerValue;
  }) {
    const s = VkCuLaunchInfoNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vk_function !== undefined) s.vk_function = data.vk_function;
    if (data.gridDimX !== undefined) s.gridDimX = data.gridDimX;
    if (data.gridDimY !== undefined) s.gridDimY = data.gridDimY;
    if (data.gridDimZ !== undefined) s.gridDimZ = data.gridDimZ;
    if (data.blockDimX !== undefined) s.blockDimX = data.blockDimX;
    if (data.blockDimY !== undefined) s.blockDimY = data.blockDimY;
    if (data.blockDimZ !== undefined) s.blockDimZ = data.blockDimZ;
    if (data.sharedMemBytes !== undefined) s.sharedMemBytes = data.sharedMemBytes;
    if (data.paramCount !== undefined) s.paramCount = data.paramCount;
    if (data.pParams !== undefined) s.pParams = data.pParams;
    if (data.extraCount !== undefined) s.extraCount = data.extraCount;
    if (data.pExtras !== undefined) s.pExtras = data.pExtras;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vk_function() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set vk_function(value: VkCuFunctionNVX) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get gridDimX() {
    return this.#view.getUint32(24, LE);
  }
  
  set gridDimX(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get gridDimY() {
    return this.#view.getUint32(28, LE);
  }
  
  set gridDimY(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get gridDimZ() {
    return this.#view.getUint32(32, LE);
  }
  
  set gridDimZ(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get blockDimX() {
    return this.#view.getUint32(36, LE);
  }
  
  set blockDimX(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get blockDimY() {
    return this.#view.getUint32(40, LE);
  }
  
  set blockDimY(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get blockDimZ() {
    return this.#view.getUint32(44, LE);
  }
  
  set blockDimZ(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get sharedMemBytes() {
    return this.#view.getUint32(48, LE);
  }
  
  set sharedMemBytes(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get paramCount() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set paramCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pParams() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pParams(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get extraCount() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set extraCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get pExtras() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pExtras(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorBufferFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorBufferFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorBufferFeaturesEXT(new Uint8Array(VkPhysicalDeviceDescriptorBufferFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorBuffer: VkBool32;
    descriptorBufferCaptureReplay: VkBool32;
    descriptorBufferImageLayoutIgnored: VkBool32;
    descriptorBufferPushDescriptors: VkBool32;
  }) {
    const s = VkPhysicalDeviceDescriptorBufferFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorBuffer !== undefined) s.descriptorBuffer = data.descriptorBuffer;
    if (data.descriptorBufferCaptureReplay !== undefined) s.descriptorBufferCaptureReplay = data.descriptorBufferCaptureReplay;
    if (data.descriptorBufferImageLayoutIgnored !== undefined) s.descriptorBufferImageLayoutIgnored = data.descriptorBufferImageLayoutIgnored;
    if (data.descriptorBufferPushDescriptors !== undefined) s.descriptorBufferPushDescriptors = data.descriptorBufferPushDescriptors;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorBuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorBuffer(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorBufferCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorBufferCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get descriptorBufferImageLayoutIgnored() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorBufferImageLayoutIgnored(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get descriptorBufferPushDescriptors() {
    return this.#view.getUint32(28, LE);
  }
  
  set descriptorBufferPushDescriptors(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorBufferPropertiesEXT implements IVkStructure {
  static size = 256;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorBufferPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorBufferPropertiesEXT(new Uint8Array(VkPhysicalDeviceDescriptorBufferPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    combinedImageSamplerDescriptorSingleArray: VkBool32;
    bufferlessPushDescriptors: VkBool32;
    allowSamplerImageViewPostSubmitCreation: VkBool32;
    descriptorBufferOffsetAlignment: VkDeviceSize;
    maxDescriptorBufferBindings: number;
    maxResourceDescriptorBufferBindings: number;
    maxSamplerDescriptorBufferBindings: number;
    maxEmbeddedImmutableSamplerBindings: number;
    maxEmbeddedImmutableSamplers: number;
    bufferCaptureReplayDescriptorDataSize: Deno.PointerValue;
    imageCaptureReplayDescriptorDataSize: Deno.PointerValue;
    imageViewCaptureReplayDescriptorDataSize: Deno.PointerValue;
    samplerCaptureReplayDescriptorDataSize: Deno.PointerValue;
    accelerationStructureCaptureReplayDescriptorDataSize: Deno.PointerValue;
    samplerDescriptorSize: Deno.PointerValue;
    combinedImageSamplerDescriptorSize: Deno.PointerValue;
    sampledImageDescriptorSize: Deno.PointerValue;
    storageImageDescriptorSize: Deno.PointerValue;
    uniformTexelBufferDescriptorSize: Deno.PointerValue;
    robustUniformTexelBufferDescriptorSize: Deno.PointerValue;
    storageTexelBufferDescriptorSize: Deno.PointerValue;
    robustStorageTexelBufferDescriptorSize: Deno.PointerValue;
    uniformBufferDescriptorSize: Deno.PointerValue;
    robustUniformBufferDescriptorSize: Deno.PointerValue;
    storageBufferDescriptorSize: Deno.PointerValue;
    robustStorageBufferDescriptorSize: Deno.PointerValue;
    inputAttachmentDescriptorSize: Deno.PointerValue;
    accelerationStructureDescriptorSize: Deno.PointerValue;
    maxSamplerDescriptorBufferRange: VkDeviceSize;
    maxResourceDescriptorBufferRange: VkDeviceSize;
    samplerDescriptorBufferAddressSpaceSize: VkDeviceSize;
    resourceDescriptorBufferAddressSpaceSize: VkDeviceSize;
    descriptorBufferAddressSpaceSize: VkDeviceSize;
  }) {
    const s = VkPhysicalDeviceDescriptorBufferPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.combinedImageSamplerDescriptorSingleArray !== undefined) s.combinedImageSamplerDescriptorSingleArray = data.combinedImageSamplerDescriptorSingleArray;
    if (data.bufferlessPushDescriptors !== undefined) s.bufferlessPushDescriptors = data.bufferlessPushDescriptors;
    if (data.allowSamplerImageViewPostSubmitCreation !== undefined) s.allowSamplerImageViewPostSubmitCreation = data.allowSamplerImageViewPostSubmitCreation;
    if (data.descriptorBufferOffsetAlignment !== undefined) s.descriptorBufferOffsetAlignment = data.descriptorBufferOffsetAlignment;
    if (data.maxDescriptorBufferBindings !== undefined) s.maxDescriptorBufferBindings = data.maxDescriptorBufferBindings;
    if (data.maxResourceDescriptorBufferBindings !== undefined) s.maxResourceDescriptorBufferBindings = data.maxResourceDescriptorBufferBindings;
    if (data.maxSamplerDescriptorBufferBindings !== undefined) s.maxSamplerDescriptorBufferBindings = data.maxSamplerDescriptorBufferBindings;
    if (data.maxEmbeddedImmutableSamplerBindings !== undefined) s.maxEmbeddedImmutableSamplerBindings = data.maxEmbeddedImmutableSamplerBindings;
    if (data.maxEmbeddedImmutableSamplers !== undefined) s.maxEmbeddedImmutableSamplers = data.maxEmbeddedImmutableSamplers;
    if (data.bufferCaptureReplayDescriptorDataSize !== undefined) s.bufferCaptureReplayDescriptorDataSize = data.bufferCaptureReplayDescriptorDataSize;
    if (data.imageCaptureReplayDescriptorDataSize !== undefined) s.imageCaptureReplayDescriptorDataSize = data.imageCaptureReplayDescriptorDataSize;
    if (data.imageViewCaptureReplayDescriptorDataSize !== undefined) s.imageViewCaptureReplayDescriptorDataSize = data.imageViewCaptureReplayDescriptorDataSize;
    if (data.samplerCaptureReplayDescriptorDataSize !== undefined) s.samplerCaptureReplayDescriptorDataSize = data.samplerCaptureReplayDescriptorDataSize;
    if (data.accelerationStructureCaptureReplayDescriptorDataSize !== undefined) s.accelerationStructureCaptureReplayDescriptorDataSize = data.accelerationStructureCaptureReplayDescriptorDataSize;
    if (data.samplerDescriptorSize !== undefined) s.samplerDescriptorSize = data.samplerDescriptorSize;
    if (data.combinedImageSamplerDescriptorSize !== undefined) s.combinedImageSamplerDescriptorSize = data.combinedImageSamplerDescriptorSize;
    if (data.sampledImageDescriptorSize !== undefined) s.sampledImageDescriptorSize = data.sampledImageDescriptorSize;
    if (data.storageImageDescriptorSize !== undefined) s.storageImageDescriptorSize = data.storageImageDescriptorSize;
    if (data.uniformTexelBufferDescriptorSize !== undefined) s.uniformTexelBufferDescriptorSize = data.uniformTexelBufferDescriptorSize;
    if (data.robustUniformTexelBufferDescriptorSize !== undefined) s.robustUniformTexelBufferDescriptorSize = data.robustUniformTexelBufferDescriptorSize;
    if (data.storageTexelBufferDescriptorSize !== undefined) s.storageTexelBufferDescriptorSize = data.storageTexelBufferDescriptorSize;
    if (data.robustStorageTexelBufferDescriptorSize !== undefined) s.robustStorageTexelBufferDescriptorSize = data.robustStorageTexelBufferDescriptorSize;
    if (data.uniformBufferDescriptorSize !== undefined) s.uniformBufferDescriptorSize = data.uniformBufferDescriptorSize;
    if (data.robustUniformBufferDescriptorSize !== undefined) s.robustUniformBufferDescriptorSize = data.robustUniformBufferDescriptorSize;
    if (data.storageBufferDescriptorSize !== undefined) s.storageBufferDescriptorSize = data.storageBufferDescriptorSize;
    if (data.robustStorageBufferDescriptorSize !== undefined) s.robustStorageBufferDescriptorSize = data.robustStorageBufferDescriptorSize;
    if (data.inputAttachmentDescriptorSize !== undefined) s.inputAttachmentDescriptorSize = data.inputAttachmentDescriptorSize;
    if (data.accelerationStructureDescriptorSize !== undefined) s.accelerationStructureDescriptorSize = data.accelerationStructureDescriptorSize;
    if (data.maxSamplerDescriptorBufferRange !== undefined) s.maxSamplerDescriptorBufferRange = data.maxSamplerDescriptorBufferRange;
    if (data.maxResourceDescriptorBufferRange !== undefined) s.maxResourceDescriptorBufferRange = data.maxResourceDescriptorBufferRange;
    if (data.samplerDescriptorBufferAddressSpaceSize !== undefined) s.samplerDescriptorBufferAddressSpaceSize = data.samplerDescriptorBufferAddressSpaceSize;
    if (data.resourceDescriptorBufferAddressSpaceSize !== undefined) s.resourceDescriptorBufferAddressSpaceSize = data.resourceDescriptorBufferAddressSpaceSize;
    if (data.descriptorBufferAddressSpaceSize !== undefined) s.descriptorBufferAddressSpaceSize = data.descriptorBufferAddressSpaceSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get combinedImageSamplerDescriptorSingleArray() {
    return this.#view.getUint32(16, LE);
  }
  
  set combinedImageSamplerDescriptorSingleArray(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferlessPushDescriptors() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferlessPushDescriptors(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get allowSamplerImageViewPostSubmitCreation() {
    return this.#view.getUint32(24, LE);
  }
  
  set allowSamplerImageViewPostSubmitCreation(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get descriptorBufferOffsetAlignment() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set descriptorBufferOffsetAlignment(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxDescriptorBufferBindings() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxDescriptorBufferBindings(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxResourceDescriptorBufferBindings() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxResourceDescriptorBufferBindings(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxSamplerDescriptorBufferBindings() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxSamplerDescriptorBufferBindings(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxEmbeddedImmutableSamplerBindings() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxEmbeddedImmutableSamplerBindings(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxEmbeddedImmutableSamplers() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxEmbeddedImmutableSamplers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get bufferCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set bufferCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get imageCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set imageCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get imageViewCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set imageViewCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get samplerCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set samplerCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get accelerationStructureCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set accelerationStructureCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get samplerDescriptorSize() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set samplerDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
  
  get combinedImageSamplerDescriptorSize() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set combinedImageSamplerDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
  
  get sampledImageDescriptorSize() {
    return this.#view.getBigUint64(120, LE);
  }
  
  set sampledImageDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(120, BigInt(value), LE);
  }
  
  get storageImageDescriptorSize() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set storageImageDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(128, BigInt(value), LE);
  }
  
  get uniformTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(136, LE);
  }
  
  set uniformTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(136, BigInt(value), LE);
  }
  
  get robustUniformTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set robustUniformTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(144, BigInt(value), LE);
  }
  
  get storageTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(152, LE);
  }
  
  set storageTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(152, BigInt(value), LE);
  }
  
  get robustStorageTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(160, LE);
  }
  
  set robustStorageTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(160, BigInt(value), LE);
  }
  
  get uniformBufferDescriptorSize() {
    return this.#view.getBigUint64(168, LE);
  }
  
  set uniformBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(168, BigInt(value), LE);
  }
  
  get robustUniformBufferDescriptorSize() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set robustUniformBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
  
  get storageBufferDescriptorSize() {
    return this.#view.getBigUint64(184, LE);
  }
  
  set storageBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(184, BigInt(value), LE);
  }
  
  get robustStorageBufferDescriptorSize() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set robustStorageBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(192, BigInt(value), LE);
  }
  
  get inputAttachmentDescriptorSize() {
    return this.#view.getBigUint64(200, LE);
  }
  
  set inputAttachmentDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(200, BigInt(value), LE);
  }
  
  get accelerationStructureDescriptorSize() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set accelerationStructureDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(208, BigInt(value), LE);
  }
  
  get maxSamplerDescriptorBufferRange() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set maxSamplerDescriptorBufferRange(value: VkDeviceSize) {
    this.#view.setBigUint64(216, BigInt(value), LE);
  }
  
  get maxResourceDescriptorBufferRange() {
    return this.#view.getBigUint64(224, LE);
  }
  
  set maxResourceDescriptorBufferRange(value: VkDeviceSize) {
    this.#view.setBigUint64(224, BigInt(value), LE);
  }
  
  get samplerDescriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(232, LE);
  }
  
  set samplerDescriptorBufferAddressSpaceSize(value: VkDeviceSize) {
    this.#view.setBigUint64(232, BigInt(value), LE);
  }
  
  get resourceDescriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(240, LE);
  }
  
  set resourceDescriptorBufferAddressSpaceSize(value: VkDeviceSize) {
    this.#view.setBigUint64(240, BigInt(value), LE);
  }
  
  get descriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(248, LE);
  }
  
  set descriptorBufferAddressSpaceSize(value: VkDeviceSize) {
    this.#view.setBigUint64(248, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(new Uint8Array(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    combinedImageSamplerDensityMapDescriptorSize: Deno.PointerValue;
  }) {
    const s = VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.combinedImageSamplerDensityMapDescriptorSize !== undefined) s.combinedImageSamplerDensityMapDescriptorSize = data.combinedImageSamplerDensityMapDescriptorSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get combinedImageSamplerDensityMapDescriptorSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set combinedImageSamplerDensityMapDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDescriptorAddressInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorAddressInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorAddressInfoEXT(new Uint8Array(VkDescriptorAddressInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    address: VkDeviceAddress;
    range: VkDeviceSize;
    format: VkFormat;
  }) {
    const s = VkDescriptorAddressInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.address !== undefined) s.address = data.address;
    if (data.range !== undefined) s.range = data.range;
    if (data.format !== undefined) s.format = data.format;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get address() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set address(value: VkDeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set range(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(32, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkDescriptorBufferBindingInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorBufferBindingInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorBufferBindingInfoEXT(new Uint8Array(VkDescriptorBufferBindingInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    address: VkDeviceAddress;
    usage: VkBufferUsageFlags;
  }) {
    const s = VkDescriptorBufferBindingInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.address !== undefined) s.address = data.address;
    if (data.usage !== undefined) s.usage = data.usage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get address() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set address(value: VkDeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(24, LE);
  }
  
  set usage(value: VkBufferUsageFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkDescriptorBufferBindingPushDescriptorBufferHandleEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(new Uint8Array(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
  }) {
    const s = VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDescriptorGetInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorGetInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorGetInfoEXT(new Uint8Array(VkDescriptorGetInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkDescriptorType;
    data: VkDescriptorDataEXT;
  }) {
    const s = VkDescriptorGetInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.data !== undefined) s.data = data.data;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkDescriptorType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","u64"]}`);
  }
  
  set data(value: VkDescriptorDataEXT) {
    throw new Error(`Unknown type: {"union":["buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","u64"]}`);
  }
}

export class VkBufferCaptureDescriptorDataInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCaptureDescriptorDataInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCaptureDescriptorDataInfoEXT(new Uint8Array(VkBufferCaptureDescriptorDataInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    buffer: VkBuffer;
  }) {
    const s = VkBufferCaptureDescriptorDataInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkImageCaptureDescriptorDataInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCaptureDescriptorDataInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCaptureDescriptorDataInfoEXT(new Uint8Array(VkImageCaptureDescriptorDataInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image: VkImage;
  }) {
    const s = VkImageCaptureDescriptorDataInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkImageViewCaptureDescriptorDataInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewCaptureDescriptorDataInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewCaptureDescriptorDataInfoEXT(new Uint8Array(VkImageViewCaptureDescriptorDataInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageView: VkImageView;
  }) {
    const s = VkImageViewCaptureDescriptorDataInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkSamplerCaptureDescriptorDataInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSamplerCaptureDescriptorDataInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSamplerCaptureDescriptorDataInfoEXT(new Uint8Array(VkSamplerCaptureDescriptorDataInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    sampler: VkSampler;
  }) {
    const s = VkSamplerCaptureDescriptorDataInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.sampler !== undefined) s.sampler = data.sampler;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get sampler() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set sampler(value: VkSampler) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAccelerationStructureCaptureDescriptorDataInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureCaptureDescriptorDataInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureCaptureDescriptorDataInfoEXT(new Uint8Array(VkAccelerationStructureCaptureDescriptorDataInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    accelerationStructure?: VkAccelerationStructureKHR;
    accelerationStructureNV?: VkAccelerationStructureNV;
  }) {
    const s = VkAccelerationStructureCaptureDescriptorDataInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.accelerationStructure !== undefined) s.accelerationStructure = data.accelerationStructure;
    if (data.accelerationStructureNV !== undefined) s.accelerationStructureNV = data.accelerationStructureNV;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: VkAccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get accelerationStructureNV() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureNV(value: VkAccelerationStructureNV) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkOpaqueCaptureDescriptorDataCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpaqueCaptureDescriptorDataCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpaqueCaptureDescriptorDataCreateInfoEXT(new Uint8Array(VkOpaqueCaptureDescriptorDataCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    opaqueCaptureDescriptorData: Deno.PointerValue;
  }) {
    const s = VkOpaqueCaptureDescriptorDataCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.opaqueCaptureDescriptorData !== undefined) s.opaqueCaptureDescriptorData = data.opaqueCaptureDescriptorData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get opaqueCaptureDescriptorData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureDescriptorData(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceShaderIntegerDotProductFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderIntegerDotProductFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderIntegerDotProductFeatures(new Uint8Array(VkPhysicalDeviceShaderIntegerDotProductFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderIntegerDotProduct: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderIntegerDotProductFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderIntegerDotProduct !== undefined) s.shaderIntegerDotProduct = data.shaderIntegerDotProduct;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderIntegerDotProduct() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderIntegerDotProduct(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderIntegerDotProductProperties implements IVkStructure {
  static size = 136;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderIntegerDotProductProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderIntegerDotProductProperties(new Uint8Array(VkPhysicalDeviceShaderIntegerDotProductProperties.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    integerDotProduct8BitUnsignedAccelerated: VkBool32;
    integerDotProduct8BitSignedAccelerated: VkBool32;
    integerDotProduct8BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32;
    integerDotProduct4x8BitPackedSignedAccelerated: VkBool32;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProduct16BitUnsignedAccelerated: VkBool32;
    integerDotProduct16BitSignedAccelerated: VkBool32;
    integerDotProduct16BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct32BitUnsignedAccelerated: VkBool32;
    integerDotProduct32BitSignedAccelerated: VkBool32;
    integerDotProduct32BitMixedSignednessAccelerated: VkBool32;
    integerDotProduct64BitUnsignedAccelerated: VkBool32;
    integerDotProduct64BitSignedAccelerated: VkBool32;
    integerDotProduct64BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderIntegerDotProductProperties.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.integerDotProduct8BitUnsignedAccelerated !== undefined) s.integerDotProduct8BitUnsignedAccelerated = data.integerDotProduct8BitUnsignedAccelerated;
    if (data.integerDotProduct8BitSignedAccelerated !== undefined) s.integerDotProduct8BitSignedAccelerated = data.integerDotProduct8BitSignedAccelerated;
    if (data.integerDotProduct8BitMixedSignednessAccelerated !== undefined) s.integerDotProduct8BitMixedSignednessAccelerated = data.integerDotProduct8BitMixedSignednessAccelerated;
    if (data.integerDotProduct4x8BitPackedUnsignedAccelerated !== undefined) s.integerDotProduct4x8BitPackedUnsignedAccelerated = data.integerDotProduct4x8BitPackedUnsignedAccelerated;
    if (data.integerDotProduct4x8BitPackedSignedAccelerated !== undefined) s.integerDotProduct4x8BitPackedSignedAccelerated = data.integerDotProduct4x8BitPackedSignedAccelerated;
    if (data.integerDotProduct4x8BitPackedMixedSignednessAccelerated !== undefined) s.integerDotProduct4x8BitPackedMixedSignednessAccelerated = data.integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    if (data.integerDotProduct16BitUnsignedAccelerated !== undefined) s.integerDotProduct16BitUnsignedAccelerated = data.integerDotProduct16BitUnsignedAccelerated;
    if (data.integerDotProduct16BitSignedAccelerated !== undefined) s.integerDotProduct16BitSignedAccelerated = data.integerDotProduct16BitSignedAccelerated;
    if (data.integerDotProduct16BitMixedSignednessAccelerated !== undefined) s.integerDotProduct16BitMixedSignednessAccelerated = data.integerDotProduct16BitMixedSignednessAccelerated;
    if (data.integerDotProduct32BitUnsignedAccelerated !== undefined) s.integerDotProduct32BitUnsignedAccelerated = data.integerDotProduct32BitUnsignedAccelerated;
    if (data.integerDotProduct32BitSignedAccelerated !== undefined) s.integerDotProduct32BitSignedAccelerated = data.integerDotProduct32BitSignedAccelerated;
    if (data.integerDotProduct32BitMixedSignednessAccelerated !== undefined) s.integerDotProduct32BitMixedSignednessAccelerated = data.integerDotProduct32BitMixedSignednessAccelerated;
    if (data.integerDotProduct64BitUnsignedAccelerated !== undefined) s.integerDotProduct64BitUnsignedAccelerated = data.integerDotProduct64BitUnsignedAccelerated;
    if (data.integerDotProduct64BitSignedAccelerated !== undefined) s.integerDotProduct64BitSignedAccelerated = data.integerDotProduct64BitSignedAccelerated;
    if (data.integerDotProduct64BitMixedSignednessAccelerated !== undefined) s.integerDotProduct64BitMixedSignednessAccelerated = data.integerDotProduct64BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitSignedAccelerated = data.integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitSignedAccelerated = data.integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitSignedAccelerated = data.integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitSignedAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitSignedAccelerated = data.integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    if (data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated !== undefined) s.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get integerDotProduct8BitUnsignedAccelerated() {
    return this.#view.getUint32(16, LE);
  }
  
  set integerDotProduct8BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get integerDotProduct8BitSignedAccelerated() {
    return this.#view.getUint32(20, LE);
  }
  
  set integerDotProduct8BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get integerDotProduct8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(24, LE);
  }
  
  set integerDotProduct8BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(28, LE);
  }
  
  set integerDotProduct4x8BitPackedUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(32, LE);
  }
  
  set integerDotProduct4x8BitPackedSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(36, LE);
  }
  
  set integerDotProduct4x8BitPackedMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get integerDotProduct16BitUnsignedAccelerated() {
    return this.#view.getUint32(40, LE);
  }
  
  set integerDotProduct16BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get integerDotProduct16BitSignedAccelerated() {
    return this.#view.getUint32(44, LE);
  }
  
  set integerDotProduct16BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get integerDotProduct16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(48, LE);
  }
  
  set integerDotProduct16BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get integerDotProduct32BitUnsignedAccelerated() {
    return this.#view.getUint32(52, LE);
  }
  
  set integerDotProduct32BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get integerDotProduct32BitSignedAccelerated() {
    return this.#view.getUint32(56, LE);
  }
  
  set integerDotProduct32BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get integerDotProduct32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(60, LE);
  }
  
  set integerDotProduct32BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get integerDotProduct64BitUnsignedAccelerated() {
    return this.#view.getUint32(64, LE);
  }
  
  set integerDotProduct64BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get integerDotProduct64BitSignedAccelerated() {
    return this.#view.getUint32(68, LE);
  }
  
  set integerDotProduct64BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get integerDotProduct64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(72, LE);
  }
  
  set integerDotProduct64BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
    return this.#view.getUint32(76, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
    return this.#view.getUint32(80, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(84, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(88, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(92, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(96, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
    return this.#view.getUint32(100, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
    return this.#view.getUint32(104, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(108, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
    return this.#view.getUint32(112, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
    return this.#view.getUint32(116, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(120, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
    return this.#view.getUint32(124, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitUnsignedAccelerated(value: VkBool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
    return this.#view.getUint32(128, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitSignedAccelerated(value: VkBool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(132, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated(value: VkBool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
}

export class VkPhysicalDeviceDrmPropertiesEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDrmPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDrmPropertiesEXT(new Uint8Array(VkPhysicalDeviceDrmPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    hasPrimary: VkBool32;
    hasRender: VkBool32;
    primaryMajor: Deno.PointerValue;
    primaryMinor: Deno.PointerValue;
    renderMajor: Deno.PointerValue;
    renderMinor: Deno.PointerValue;
  }) {
    const s = VkPhysicalDeviceDrmPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.hasPrimary !== undefined) s.hasPrimary = data.hasPrimary;
    if (data.hasRender !== undefined) s.hasRender = data.hasRender;
    if (data.primaryMajor !== undefined) s.primaryMajor = data.primaryMajor;
    if (data.primaryMinor !== undefined) s.primaryMinor = data.primaryMinor;
    if (data.renderMajor !== undefined) s.renderMajor = data.renderMajor;
    if (data.renderMinor !== undefined) s.renderMinor = data.renderMinor;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get hasPrimary() {
    return this.#view.getUint32(16, LE);
  }
  
  set hasPrimary(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get hasRender() {
    return this.#view.getUint32(20, LE);
  }
  
  set hasRender(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primaryMajor() {
    return this.#view.getBigInt64(24, LE);
  }
  
  set primaryMajor(value: Deno.PointerValue) {
    this.#view.setBigInt64(24, BigInt(value), LE);
  }
  
  get primaryMinor() {
    return this.#view.getBigInt64(32, LE);
  }
  
  set primaryMinor(value: Deno.PointerValue) {
    this.#view.setBigInt64(32, BigInt(value), LE);
  }
  
  get renderMajor() {
    return this.#view.getBigInt64(40, LE);
  }
  
  set renderMajor(value: Deno.PointerValue) {
    this.#view.setBigInt64(40, BigInt(value), LE);
  }
  
  get renderMinor() {
    return this.#view.getBigInt64(48, LE);
  }
  
  set renderMinor(value: Deno.PointerValue) {
    this.#view.setBigInt64(48, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(new Uint8Array(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    fragmentShaderBarycentric: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.fragmentShaderBarycentric !== undefined) s.fragmentShaderBarycentric = data.fragmentShaderBarycentric;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get fragmentShaderBarycentric() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShaderBarycentric(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(new Uint8Array(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    triStripVertexOrderIndependentOfProvokingVertex: VkBool32;
  }) {
    const s = VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.triStripVertexOrderIndependentOfProvokingVertex !== undefined) s.triStripVertexOrderIndependentOfProvokingVertex = data.triStripVertexOrderIndependentOfProvokingVertex;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get triStripVertexOrderIndependentOfProvokingVertex() {
    return this.#view.getUint32(16, LE);
  }
  
  set triStripVertexOrderIndependentOfProvokingVertex(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingMotionBlurFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(new Uint8Array(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayTracingMotionBlur: VkBool32;
    rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32;
  }) {
    const s = VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayTracingMotionBlur !== undefined) s.rayTracingMotionBlur = data.rayTracingMotionBlur;
    if (data.rayTracingMotionBlurPipelineTraceRaysIndirect !== undefined) s.rayTracingMotionBlurPipelineTraceRaysIndirect = data.rayTracingMotionBlurPipelineTraceRaysIndirect;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayTracingMotionBlur() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingMotionBlur(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingMotionBlurPipelineTraceRaysIndirect() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingMotionBlurPipelineTraceRaysIndirect(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkAccelerationStructureGeometryMotionTrianglesDataNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryMotionTrianglesDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureGeometryMotionTrianglesDataNV(new Uint8Array(VkAccelerationStructureGeometryMotionTrianglesDataNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    vertexData: VkDeviceOrHostAddressConstKHR;
  }) {
    const s = VkAccelerationStructureGeometryMotionTrianglesDataNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.vertexData !== undefined) s.vertexData = data.vertexData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vertexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set vertexData(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export class VkAccelerationStructureMotionInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureMotionInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureMotionInfoNV(new Uint8Array(VkAccelerationStructureMotionInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxInstances: number;
    flags?: VkAccelerationStructureMotionInfoFlagsNV;
  }) {
    const s = VkAccelerationStructureMotionInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxInstances !== undefined) s.maxInstances = data.maxInstances;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxInstances() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInstances(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkAccelerationStructureMotionInfoFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkSRTDataNV implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSRTDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSRTDataNV(new Uint8Array(VkSRTDataNV.size));
  }
  
  static create(data: {
    sx: number;
    a: number;
    b: number;
    pvx: number;
    sy: number;
    c: number;
    pvy: number;
    sz: number;
    pvz: number;
    qx: number;
    qy: number;
    qz: number;
    qw: number;
    tx: number;
    ty: number;
    tz: number;
  }) {
    const s = VkSRTDataNV.alloc();
    if (data.sx !== undefined) s.sx = data.sx;
    if (data.a !== undefined) s.a = data.a;
    if (data.b !== undefined) s.b = data.b;
    if (data.pvx !== undefined) s.pvx = data.pvx;
    if (data.sy !== undefined) s.sy = data.sy;
    if (data.c !== undefined) s.c = data.c;
    if (data.pvy !== undefined) s.pvy = data.pvy;
    if (data.sz !== undefined) s.sz = data.sz;
    if (data.pvz !== undefined) s.pvz = data.pvz;
    if (data.qx !== undefined) s.qx = data.qx;
    if (data.qy !== undefined) s.qy = data.qy;
    if (data.qz !== undefined) s.qz = data.qz;
    if (data.qw !== undefined) s.qw = data.qw;
    if (data.tx !== undefined) s.tx = data.tx;
    if (data.ty !== undefined) s.ty = data.ty;
    if (data.tz !== undefined) s.tz = data.tz;
    return s;
  }
  
  get sx() {
    return this.#view.getFloat32(0, LE);
  }
  
  set sx(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get a() {
    return this.#view.getFloat32(4, LE);
  }
  
  set a(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get b() {
    return this.#view.getFloat32(8, LE);
  }
  
  set b(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get pvx() {
    return this.#view.getFloat32(12, LE);
  }
  
  set pvx(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get sy() {
    return this.#view.getFloat32(16, LE);
  }
  
  set sy(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get c() {
    return this.#view.getFloat32(20, LE);
  }
  
  set c(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
  
  get pvy() {
    return this.#view.getFloat32(24, LE);
  }
  
  set pvy(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
  
  get sz() {
    return this.#view.getFloat32(28, LE);
  }
  
  set sz(value: number) {
    this.#view.setFloat32(28, Number(value), LE);
  }
  
  get pvz() {
    return this.#view.getFloat32(32, LE);
  }
  
  set pvz(value: number) {
    this.#view.setFloat32(32, Number(value), LE);
  }
  
  get qx() {
    return this.#view.getFloat32(36, LE);
  }
  
  set qx(value: number) {
    this.#view.setFloat32(36, Number(value), LE);
  }
  
  get qy() {
    return this.#view.getFloat32(40, LE);
  }
  
  set qy(value: number) {
    this.#view.setFloat32(40, Number(value), LE);
  }
  
  get qz() {
    return this.#view.getFloat32(44, LE);
  }
  
  set qz(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get qw() {
    return this.#view.getFloat32(48, LE);
  }
  
  set qw(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get tx() {
    return this.#view.getFloat32(52, LE);
  }
  
  set tx(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get ty() {
    return this.#view.getFloat32(56, LE);
  }
  
  set ty(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
  
  get tz() {
    return this.#view.getFloat32(60, LE);
  }
  
  set tz(value: number) {
    this.#view.setFloat32(60, Number(value), LE);
  }
}

export class VkAccelerationStructureSRTMotionInstanceNV implements IVkStructure {
  static size = 192;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureSRTMotionInstanceNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureSRTMotionInstanceNV(new Uint8Array(VkAccelerationStructureSRTMotionInstanceNV.size));
  }
  
  static create(data: {
    transformT0: VkSRTDataNV;
    transformT1: VkSRTDataNV;
    instanceCustomIndex: number;
    mask: number;
    instanceShaderBindingTableRecordOffset: number;
    flags?: VkGeometryInstanceFlagsKHR;
    accelerationStructureReference: Deno.PointerValue;
  }) {
    const s = VkAccelerationStructureSRTMotionInstanceNV.alloc();
    if (data.transformT0 !== undefined) s.transformT0 = data.transformT0;
    if (data.transformT1 !== undefined) s.transformT1 = data.transformT1;
    if (data.instanceCustomIndex !== undefined) s.instanceCustomIndex = data.instanceCustomIndex;
    if (data.mask !== undefined) s.mask = data.mask;
    if (data.instanceShaderBindingTableRecordOffset !== undefined) s.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.accelerationStructureReference !== undefined) s.accelerationStructureReference = data.accelerationStructureReference;
    return s;
  }
  
  get transformT0() {
    return new VkSRTDataNV(this.#data.subarray(0, 0 + VkSRTDataNV.size));
  }
  
  set transformT0(value: VkSRTDataNV) {
    if (value[BUFFER].byteLength < VkSRTDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get transformT1() {
    return new VkSRTDataNV(this.#data.subarray(64, 64 + VkSRTDataNV.size));
  }
  
  set transformT1(value: VkSRTDataNV) {
    if (value[BUFFER].byteLength < VkSRTDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 64);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(128, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(132, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(136, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(140, LE);
  }
  
  set flags(value: VkGeometryInstanceFlagsKHR) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(144, BigInt(value), LE);
  }
}

export class VkAccelerationStructureMatrixMotionInstanceNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureMatrixMotionInstanceNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureMatrixMotionInstanceNV(new Uint8Array(VkAccelerationStructureMatrixMotionInstanceNV.size));
  }
  
  static create(data: {
    transformT0: VkTransformMatrixKHR;
    transformT1: VkTransformMatrixKHR;
    instanceCustomIndex: number;
    mask: number;
    instanceShaderBindingTableRecordOffset: number;
    flags?: VkGeometryInstanceFlagsKHR;
    accelerationStructureReference: Deno.PointerValue;
  }) {
    const s = VkAccelerationStructureMatrixMotionInstanceNV.alloc();
    if (data.transformT0 !== undefined) s.transformT0 = data.transformT0;
    if (data.transformT1 !== undefined) s.transformT1 = data.transformT1;
    if (data.instanceCustomIndex !== undefined) s.instanceCustomIndex = data.instanceCustomIndex;
    if (data.mask !== undefined) s.mask = data.mask;
    if (data.instanceShaderBindingTableRecordOffset !== undefined) s.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.accelerationStructureReference !== undefined) s.accelerationStructureReference = data.accelerationStructureReference;
    return s;
  }
  
  get transformT0() {
    return new VkTransformMatrixKHR(this.#data.subarray(0, 0 + VkTransformMatrixKHR.size));
  }
  
  set transformT0(value: VkTransformMatrixKHR) {
    if (value[BUFFER].byteLength < VkTransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get transformT1() {
    return new VkTransformMatrixKHR(this.#data.subarray(4, 4 + VkTransformMatrixKHR.size));
  }
  
  set transformT1(value: VkTransformMatrixKHR) {
    if (value[BUFFER].byteLength < VkTransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(12, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(16, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkGeometryInstanceFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkAccelerationStructureMotionInstanceNV implements IVkStructure {
  static size = 384;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureMotionInstanceNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureMotionInstanceNV(new Uint8Array(VkAccelerationStructureMotionInstanceNV.size));
  }
  
  static create(data: {
    type: VkAccelerationStructureMotionInstanceTypeNV;
    flags?: VkAccelerationStructureMotionInstanceFlagsNV;
    data: VkAccelerationStructureMotionInstanceDataNV;
  }) {
    const s = VkAccelerationStructureMotionInstanceNV.alloc();
    if (data.type !== undefined) s.type = data.type;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.data !== undefined) s.data = data.data;
    return s;
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: VkAccelerationStructureMotionInstanceTypeNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(4, LE);
  }
  
  set flags(value: VkAccelerationStructureMotionInstanceFlagsNV) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":[{"struct":[{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32"]},{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},"u32","u32","u32","u32","u64"]}]}`);
  }
  
  set data(value: VkAccelerationStructureMotionInstanceDataNV) {
    throw new Error(`Unknown type: {"union":[{"struct":[{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32"]},{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},"u32","u32","u32","u32","u64"]}]}`);
  }
}

export class VkMemoryGetRemoteAddressInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMemoryGetRemoteAddressInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMemoryGetRemoteAddressInfoNV(new Uint8Array(VkMemoryGetRemoteAddressInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  }) {
    const s = VkMemoryGetRemoteAddressInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.handleType !== undefined) s.handleType = data.handleType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: VkExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkImportMemoryBufferCollectionFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMemoryBufferCollectionFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMemoryBufferCollectionFUCHSIA(new Uint8Array(VkImportMemoryBufferCollectionFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    collection: VkBufferCollectionFUCHSIA;
    index: number;
  }) {
    const s = VkImportMemoryBufferCollectionFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.collection !== undefined) s.collection = data.collection;
    if (data.index !== undefined) s.index = data.index;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: VkBufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkBufferCollectionImageCreateInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCollectionImageCreateInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCollectionImageCreateInfoFUCHSIA(new Uint8Array(VkBufferCollectionImageCreateInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    collection: VkBufferCollectionFUCHSIA;
    index: number;
  }) {
    const s = VkBufferCollectionImageCreateInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.collection !== undefined) s.collection = data.collection;
    if (data.index !== undefined) s.index = data.index;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: VkBufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkBufferCollectionBufferCreateInfoFUCHSIA implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCollectionBufferCreateInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCollectionBufferCreateInfoFUCHSIA(new Uint8Array(VkBufferCollectionBufferCreateInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    collection: VkBufferCollectionFUCHSIA;
    index: number;
  }) {
    const s = VkBufferCollectionBufferCreateInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.collection !== undefined) s.collection = data.collection;
    if (data.index !== undefined) s.index = data.index;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: VkBufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkBufferCollectionCreateInfoFUCHSIA implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCollectionCreateInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCollectionCreateInfoFUCHSIA(new Uint8Array(VkBufferCollectionCreateInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    collectionToken: Deno.PointerValue;
  }) {
    const s = VkBufferCollectionCreateInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.collectionToken !== undefined) s.collectionToken = data.collectionToken;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get collectionToken() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collectionToken(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkBufferCollectionPropertiesFUCHSIA implements IVkStructure {
  static size = 120;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCollectionPropertiesFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCollectionPropertiesFUCHSIA(new Uint8Array(VkBufferCollectionPropertiesFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memoryTypeBits: number;
    bufferCount: number;
    createInfoIndex: number;
    sysmemPixelFormat: Deno.PointerValue;
    formatFeatures: VkFormatFeatureFlags;
    sysmemColorSpaceIndex: VkSysmemColorSpaceFUCHSIA;
    samplerYcbcrConversionComponents: VkComponentMapping;
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion;
    suggestedYcbcrRange: VkSamplerYcbcrRange;
    suggestedXChromaOffset: VkChromaLocation;
    suggestedYChromaOffset: VkChromaLocation;
  }) {
    const s = VkBufferCollectionPropertiesFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memoryTypeBits !== undefined) s.memoryTypeBits = data.memoryTypeBits;
    if (data.bufferCount !== undefined) s.bufferCount = data.bufferCount;
    if (data.createInfoIndex !== undefined) s.createInfoIndex = data.createInfoIndex;
    if (data.sysmemPixelFormat !== undefined) s.sysmemPixelFormat = data.sysmemPixelFormat;
    if (data.formatFeatures !== undefined) s.formatFeatures = data.formatFeatures;
    if (data.sysmemColorSpaceIndex !== undefined) s.sysmemColorSpaceIndex = data.sysmemColorSpaceIndex;
    if (data.samplerYcbcrConversionComponents !== undefined) s.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
    if (data.suggestedYcbcrModel !== undefined) s.suggestedYcbcrModel = data.suggestedYcbcrModel;
    if (data.suggestedYcbcrRange !== undefined) s.suggestedYcbcrRange = data.suggestedYcbcrRange;
    if (data.suggestedXChromaOffset !== undefined) s.suggestedXChromaOffset = data.suggestedXChromaOffset;
    if (data.suggestedYChromaOffset !== undefined) s.suggestedYChromaOffset = data.suggestedYChromaOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get createInfoIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set createInfoIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sysmemPixelFormat() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set sysmemPixelFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getUint32(40, LE);
  }
  
  set formatFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get sysmemColorSpaceIndex() {
    return new VkSysmemColorSpaceFUCHSIA(this.#data.subarray(48, 48 + VkSysmemColorSpaceFUCHSIA.size));
  }
  
  set sysmemColorSpaceIndex(value: VkSysmemColorSpaceFUCHSIA) {
    if (value[BUFFER].byteLength < VkSysmemColorSpaceFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get samplerYcbcrConversionComponents() {
    return new VkComponentMapping(this.#data.subarray(80, 80 + VkComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 80);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(96, LE);
  }
  
  set suggestedYcbcrModel(value: VkSamplerYcbcrModelConversion) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(100, LE);
  }
  
  set suggestedYcbcrRange(value: VkSamplerYcbcrRange) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(104, LE);
  }
  
  set suggestedXChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(108, LE);
  }
  
  set suggestedYChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(108, Number(value), LE);
  }
}

export class VkBufferConstraintsInfoFUCHSIA implements IVkStructure {
  static size = 168;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferConstraintsInfoFUCHSIA(new Uint8Array(VkBufferConstraintsInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    createInfo: VkBufferCreateInfo;
    requiredFormatFeatures?: VkFormatFeatureFlags;
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA;
  }) {
    const s = VkBufferConstraintsInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.createInfo !== undefined) s.createInfo = data.createInfo;
    if (data.requiredFormatFeatures !== undefined) s.requiredFormatFeatures = data.requiredFormatFeatures;
    if (data.bufferCollectionConstraints !== undefined) s.bufferCollectionConstraints = data.bufferCollectionConstraints;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get createInfo() {
    return new VkBufferCreateInfo(this.#data.subarray(56, 56 + VkBufferCreateInfo.size));
  }
  
  set createInfo(value: VkBufferCreateInfo) {
    if (value[BUFFER].byteLength < VkBufferCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get requiredFormatFeatures() {
    return this.#view.getUint32(112, LE);
  }
  
  set requiredFormatFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get bufferCollectionConstraints() {
    return new VkBufferCollectionConstraintsInfoFUCHSIA(this.#data.subarray(120, 120 + VkBufferCollectionConstraintsInfoFUCHSIA.size));
  }
  
  set bufferCollectionConstraints(value: VkBufferCollectionConstraintsInfoFUCHSIA) {
    if (value[BUFFER].byteLength < VkBufferCollectionConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 120);
  }
}

export class VkSysmemColorSpaceFUCHSIA implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSysmemColorSpaceFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSysmemColorSpaceFUCHSIA(new Uint8Array(VkSysmemColorSpaceFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    colorSpace: number;
  }) {
    const s = VkSysmemColorSpaceFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.colorSpace !== undefined) s.colorSpace = data.colorSpace;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get colorSpace() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorSpace(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImageFormatConstraintsInfoFUCHSIA implements IVkStructure {
  static size = 288;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageFormatConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageFormatConstraintsInfoFUCHSIA(new Uint8Array(VkImageFormatConstraintsInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageCreateInfo: VkImageCreateInfo;
    requiredFormatFeatures: VkFormatFeatureFlags;
    flags?: VkImageFormatConstraintsFlagsFUCHSIA;
    sysmemPixelFormat?: Deno.PointerValue;
    colorSpaceCount: number;
    pColorSpaces: Deno.PointerValue;
  }) {
    const s = VkImageFormatConstraintsInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageCreateInfo !== undefined) s.imageCreateInfo = data.imageCreateInfo;
    if (data.requiredFormatFeatures !== undefined) s.requiredFormatFeatures = data.requiredFormatFeatures;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.sysmemPixelFormat !== undefined) s.sysmemPixelFormat = data.sysmemPixelFormat;
    if (data.colorSpaceCount !== undefined) s.colorSpaceCount = data.colorSpaceCount;
    if (data.pColorSpaces !== undefined) s.pColorSpaces = data.pColorSpaces;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageCreateInfo() {
    return new VkImageCreateInfo(this.#data.subarray(96, 96 + VkImageCreateInfo.size));
  }
  
  set imageCreateInfo(value: VkImageCreateInfo) {
    if (value[BUFFER].byteLength < VkImageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 96);
  }
  
  get requiredFormatFeatures() {
    return this.#view.getUint32(192, LE);
  }
  
  set requiredFormatFeatures(value: VkFormatFeatureFlags) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(196, LE);
  }
  
  set flags(value: VkImageFormatConstraintsFlagsFUCHSIA) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get sysmemPixelFormat() {
    return this.#view.getBigUint64(200, LE);
  }
  
  set sysmemPixelFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(200, BigInt(value), LE);
  }
  
  get colorSpaceCount() {
    return this.#view.getUint32(208, LE);
  }
  
  set colorSpaceCount(value: number) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get pColorSpaces() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set pColorSpaces(value: Deno.PointerValue) {
    this.#view.setBigUint64(216, BigInt(value), LE);
  }
}

export class VkImageConstraintsInfoFUCHSIA implements IVkStructure {
  static size = 120;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageConstraintsInfoFUCHSIA(new Uint8Array(VkImageConstraintsInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    formatConstraintsCount: number;
    pFormatConstraints: Deno.PointerValue;
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA;
    flags?: VkImageConstraintsInfoFlagsFUCHSIA;
  }) {
    const s = VkImageConstraintsInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.formatConstraintsCount !== undefined) s.formatConstraintsCount = data.formatConstraintsCount;
    if (data.pFormatConstraints !== undefined) s.pFormatConstraints = data.pFormatConstraints;
    if (data.bufferCollectionConstraints !== undefined) s.bufferCollectionConstraints = data.bufferCollectionConstraints;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get formatConstraintsCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatConstraintsCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pFormatConstraints() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFormatConstraints(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferCollectionConstraints() {
    return new VkBufferCollectionConstraintsInfoFUCHSIA(this.#data.subarray(40, 40 + VkBufferCollectionConstraintsInfoFUCHSIA.size));
  }
  
  set bufferCollectionConstraints(value: VkBufferCollectionConstraintsInfoFUCHSIA) {
    if (value[BUFFER].byteLength < VkBufferCollectionConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get flags() {
    return this.#view.getUint32(80, LE);
  }
  
  set flags(value: VkImageConstraintsInfoFlagsFUCHSIA) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export class VkBufferCollectionConstraintsInfoFUCHSIA implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkBufferCollectionConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkBufferCollectionConstraintsInfoFUCHSIA(new Uint8Array(VkBufferCollectionConstraintsInfoFUCHSIA.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minBufferCount: number;
    maxBufferCount: number;
    minBufferCountForCamping: number;
    minBufferCountForDedicatedSlack: number;
    minBufferCountForSharedSlack: number;
  }) {
    const s = VkBufferCollectionConstraintsInfoFUCHSIA.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minBufferCount !== undefined) s.minBufferCount = data.minBufferCount;
    if (data.maxBufferCount !== undefined) s.maxBufferCount = data.maxBufferCount;
    if (data.minBufferCountForCamping !== undefined) s.minBufferCountForCamping = data.minBufferCountForCamping;
    if (data.minBufferCountForDedicatedSlack !== undefined) s.minBufferCountForDedicatedSlack = data.minBufferCountForDedicatedSlack;
    if (data.minBufferCountForSharedSlack !== undefined) s.minBufferCountForSharedSlack = data.minBufferCountForSharedSlack;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minBufferCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set minBufferCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxBufferCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxBufferCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get minBufferCountForCamping() {
    return this.#view.getUint32(24, LE);
  }
  
  set minBufferCountForCamping(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get minBufferCountForDedicatedSlack() {
    return this.#view.getUint32(28, LE);
  }
  
  set minBufferCountForDedicatedSlack(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get minBufferCountForSharedSlack() {
    return this.#view.getUint32(32, LE);
  }
  
  set minBufferCountForSharedSlack(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(new Uint8Array(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    formatRgba10x6WithoutYCbCrSampler: VkBool32;
  }) {
    const s = VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.formatRgba10x6WithoutYCbCrSampler !== undefined) s.formatRgba10x6WithoutYCbCrSampler = data.formatRgba10x6WithoutYCbCrSampler;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get formatRgba10x6WithoutYCbCrSampler() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatRgba10x6WithoutYCbCrSampler(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkFormatProperties3 implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkFormatProperties3.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkFormatProperties3(new Uint8Array(VkFormatProperties3.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    linearTilingFeatures?: VkFormatFeatureFlags2;
    optimalTilingFeatures?: VkFormatFeatureFlags2;
    bufferFeatures?: VkFormatFeatureFlags2;
  }) {
    const s = VkFormatProperties3.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.linearTilingFeatures !== undefined) s.linearTilingFeatures = data.linearTilingFeatures;
    if (data.optimalTilingFeatures !== undefined) s.optimalTilingFeatures = data.optimalTilingFeatures;
    if (data.bufferFeatures !== undefined) s.bufferFeatures = data.bufferFeatures;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get linearTilingFeatures() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set linearTilingFeatures(value: VkFormatFeatureFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get optimalTilingFeatures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set optimalTilingFeatures(value: VkFormatFeatureFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferFeatures() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set bufferFeatures(value: VkFormatFeatureFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkDrmFormatModifierPropertiesList2EXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrmFormatModifierPropertiesList2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrmFormatModifierPropertiesList2EXT(new Uint8Array(VkDrmFormatModifierPropertiesList2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    drmFormatModifierCount?: number;
    pDrmFormatModifierProperties?: Deno.PointerValue;
  }) {
    const s = VkDrmFormatModifierPropertiesList2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.drmFormatModifierCount !== undefined) s.drmFormatModifierCount = data.drmFormatModifierCount;
    if (data.pDrmFormatModifierProperties !== undefined) s.pDrmFormatModifierProperties = data.pDrmFormatModifierProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifierProperties() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifierProperties(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDrmFormatModifierProperties2EXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDrmFormatModifierProperties2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDrmFormatModifierProperties2EXT(new Uint8Array(VkDrmFormatModifierProperties2EXT.size));
  }
  
  static create(data: {
    drmFormatModifier: Deno.PointerValue;
    drmFormatModifierPlaneCount: number;
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags2;
  }) {
    const s = VkDrmFormatModifierProperties2EXT.alloc();
    if (data.drmFormatModifier !== undefined) s.drmFormatModifier = data.drmFormatModifier;
    if (data.drmFormatModifierPlaneCount !== undefined) s.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
    if (data.drmFormatModifierTilingFeatures !== undefined) s.drmFormatModifierTilingFeatures = data.drmFormatModifierTilingFeatures;
    return s;
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get drmFormatModifierTilingFeatures() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifierTilingFeatures(value: VkFormatFeatureFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkAndroidHardwareBufferFormatProperties2ANDROID implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAndroidHardwareBufferFormatProperties2ANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAndroidHardwareBufferFormatProperties2ANDROID(new Uint8Array(VkAndroidHardwareBufferFormatProperties2ANDROID.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
    externalFormat: Deno.PointerValue;
    formatFeatures: VkFormatFeatureFlags2;
    samplerYcbcrConversionComponents: VkComponentMapping;
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion;
    suggestedYcbcrRange: VkSamplerYcbcrRange;
    suggestedXChromaOffset: VkChromaLocation;
    suggestedYChromaOffset: VkChromaLocation;
  }) {
    const s = VkAndroidHardwareBufferFormatProperties2ANDROID.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    if (data.externalFormat !== undefined) s.externalFormat = data.externalFormat;
    if (data.formatFeatures !== undefined) s.formatFeatures = data.formatFeatures;
    if (data.samplerYcbcrConversionComponents !== undefined) s.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
    if (data.suggestedYcbcrModel !== undefined) s.suggestedYcbcrModel = data.suggestedYcbcrModel;
    if (data.suggestedYcbcrRange !== undefined) s.suggestedYcbcrRange = data.suggestedYcbcrRange;
    if (data.suggestedXChromaOffset !== undefined) s.suggestedXChromaOffset = data.suggestedXChromaOffset;
    if (data.suggestedYChromaOffset !== undefined) s.suggestedYChromaOffset = data.suggestedYChromaOffset;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set formatFeatures(value: VkFormatFeatureFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get samplerYcbcrConversionComponents() {
    return new VkComponentMapping(this.#data.subarray(48, 48 + VkComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: VkComponentMapping) {
    if (value[BUFFER].byteLength < VkComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(64, LE);
  }
  
  set suggestedYcbcrModel(value: VkSamplerYcbcrModelConversion) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(68, LE);
  }
  
  set suggestedYcbcrRange(value: VkSamplerYcbcrRange) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(72, LE);
  }
  
  set suggestedXChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(76, LE);
  }
  
  set suggestedYChromaOffset(value: VkChromaLocation) {
    this.#view.setUint32(76, Number(value), LE);
  }
}

export class VkPipelineRenderingCreateInfo implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRenderingCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRenderingCreateInfo(new Uint8Array(VkPipelineRenderingCreateInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachmentFormats: Deno.PointerValue;
    depthAttachmentFormat: VkFormat;
    stencilAttachmentFormat: VkFormat;
  }) {
    const s = VkPipelineRenderingCreateInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.viewMask !== undefined) s.viewMask = data.viewMask;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachmentFormats !== undefined) s.pColorAttachmentFormats = data.pColorAttachmentFormats;
    if (data.depthAttachmentFormat !== undefined) s.depthAttachmentFormat = data.depthAttachmentFormat;
    if (data.stencilAttachmentFormat !== undefined) s.stencilAttachmentFormat = data.stencilAttachmentFormat;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pColorAttachmentFormats() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorAttachmentFormats(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get depthAttachmentFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthAttachmentFormat(value: VkFormat) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilAttachmentFormat() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilAttachmentFormat(value: VkFormat) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export class VkRenderingInfo implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderingInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderingInfo(new Uint8Array(VkRenderingInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkRenderingFlags;
    renderArea: VkRect2D;
    layerCount: number;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachments: Deno.PointerValue;
    pDepthAttachment?: Deno.PointerValue;
    pStencilAttachment?: Deno.PointerValue;
  }) {
    const s = VkRenderingInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.renderArea !== undefined) s.renderArea = data.renderArea;
    if (data.layerCount !== undefined) s.layerCount = data.layerCount;
    if (data.viewMask !== undefined) s.viewMask = data.viewMask;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachments !== undefined) s.pColorAttachments = data.pColorAttachments;
    if (data.pDepthAttachment !== undefined) s.pDepthAttachment = data.pDepthAttachment;
    if (data.pStencilAttachment !== undefined) s.pStencilAttachment = data.pStencilAttachment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkRenderingFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderArea() {
    return new VkRect2D(this.#data.subarray(32, 32 + VkRect2D.size));
  }
  
  set renderArea(value: VkRect2D) {
    if (value[BUFFER].byteLength < VkRect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get layerCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(52, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pColorAttachments(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get pDepthAttachment() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pDepthAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get pStencilAttachment() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pStencilAttachment(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
}

export class VkRenderingAttachmentInfo implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderingAttachmentInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderingAttachmentInfo(new Uint8Array(VkRenderingAttachmentInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageView?: VkImageView;
    imageLayout: VkImageLayout;
    resolveMode?: VkResolveModeFlagBits;
    resolveImageView?: VkImageView;
    resolveImageLayout: VkImageLayout;
    loadOp: VkAttachmentLoadOp;
    storeOp: VkAttachmentStoreOp;
    clearValue: VkClearValue;
  }) {
    const s = VkRenderingAttachmentInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.imageLayout !== undefined) s.imageLayout = data.imageLayout;
    if (data.resolveMode !== undefined) s.resolveMode = data.resolveMode;
    if (data.resolveImageView !== undefined) s.resolveImageView = data.resolveImageView;
    if (data.resolveImageLayout !== undefined) s.resolveImageLayout = data.resolveImageLayout;
    if (data.loadOp !== undefined) s.loadOp = data.loadOp;
    if (data.storeOp !== undefined) s.storeOp = data.storeOp;
    if (data.clearValue !== undefined) s.clearValue = data.clearValue;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get resolveMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set resolveMode(value: VkResolveModeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get resolveImageView() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set resolveImageView(value: VkImageView) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get resolveImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set resolveImageLayout(value: VkImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(44, LE);
  }
  
  set loadOp(value: VkAttachmentLoadOp) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(48, LE);
  }
  
  set storeOp(value: VkAttachmentStoreOp) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get clearValue() {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
  
  set clearValue(value: VkClearValue) {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
}

export class VkRenderingFragmentShadingRateAttachmentInfoKHR implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderingFragmentShadingRateAttachmentInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderingFragmentShadingRateAttachmentInfoKHR(new Uint8Array(VkRenderingFragmentShadingRateAttachmentInfoKHR.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageView?: VkImageView;
    imageLayout: VkImageLayout;
    shadingRateAttachmentTexelSize: VkExtent2D;
  }) {
    const s = VkRenderingFragmentShadingRateAttachmentInfoKHR.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.imageLayout !== undefined) s.imageLayout = data.imageLayout;
    if (data.shadingRateAttachmentTexelSize !== undefined) s.shadingRateAttachmentTexelSize = data.shadingRateAttachmentTexelSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shadingRateAttachmentTexelSize() {
    return new VkExtent2D(this.#data.subarray(32, 32 + VkExtent2D.size));
  }
  
  set shadingRateAttachmentTexelSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
}

export class VkRenderingFragmentDensityMapAttachmentInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderingFragmentDensityMapAttachmentInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderingFragmentDensityMapAttachmentInfoEXT(new Uint8Array(VkRenderingFragmentDensityMapAttachmentInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageView: VkImageView;
    imageLayout: VkImageLayout;
  }) {
    const s = VkRenderingFragmentDensityMapAttachmentInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.imageLayout !== undefined) s.imageLayout = data.imageLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: VkImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceDynamicRenderingFeatures implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDynamicRenderingFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDynamicRenderingFeatures(new Uint8Array(VkPhysicalDeviceDynamicRenderingFeatures.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    dynamicRendering: VkBool32;
  }) {
    const s = VkPhysicalDeviceDynamicRenderingFeatures.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.dynamicRendering !== undefined) s.dynamicRendering = data.dynamicRendering;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get dynamicRendering() {
    return this.#view.getUint32(16, LE);
  }
  
  set dynamicRendering(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkCommandBufferInheritanceRenderingInfo implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCommandBufferInheritanceRenderingInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCommandBufferInheritanceRenderingInfo(new Uint8Array(VkCommandBufferInheritanceRenderingInfo.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkRenderingFlags;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachmentFormats: Deno.PointerValue;
    depthAttachmentFormat: VkFormat;
    stencilAttachmentFormat: VkFormat;
    rasterizationSamples?: VkSampleCountFlagBits;
  }) {
    const s = VkCommandBufferInheritanceRenderingInfo.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.viewMask !== undefined) s.viewMask = data.viewMask;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachmentFormats !== undefined) s.pColorAttachmentFormats = data.pColorAttachmentFormats;
    if (data.depthAttachmentFormat !== undefined) s.depthAttachmentFormat = data.depthAttachmentFormat;
    if (data.stencilAttachmentFormat !== undefined) s.stencilAttachmentFormat = data.stencilAttachmentFormat;
    if (data.rasterizationSamples !== undefined) s.rasterizationSamples = data.rasterizationSamples;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkRenderingFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pColorAttachmentFormats() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pColorAttachmentFormats(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get depthAttachmentFormat() {
    return this.#view.getUint32(40, LE);
  }
  
  set depthAttachmentFormat(value: VkFormat) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get stencilAttachmentFormat() {
    return this.#view.getUint32(44, LE);
  }
  
  set stencilAttachmentFormat(value: VkFormat) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(48, LE);
  }
  
  set rasterizationSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkAttachmentSampleCountInfoAMD implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAttachmentSampleCountInfoAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAttachmentSampleCountInfoAMD(new Uint8Array(VkAttachmentSampleCountInfoAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    colorAttachmentCount?: number;
    pColorAttachmentSamples: Deno.PointerValue;
    depthStencilAttachmentSamples?: VkSampleCountFlagBits;
  }) {
    const s = VkAttachmentSampleCountInfoAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.colorAttachmentCount !== undefined) s.colorAttachmentCount = data.colorAttachmentCount;
    if (data.pColorAttachmentSamples !== undefined) s.pColorAttachmentSamples = data.pColorAttachmentSamples;
    if (data.depthStencilAttachmentSamples !== undefined) s.depthStencilAttachmentSamples = data.depthStencilAttachmentSamples;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pColorAttachmentSamples() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorAttachmentSamples(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get depthStencilAttachmentSamples() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthStencilAttachmentSamples(value: VkSampleCountFlagBits) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkMultiviewPerViewAttributesInfoNVX implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMultiviewPerViewAttributesInfoNVX.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMultiviewPerViewAttributesInfoNVX(new Uint8Array(VkMultiviewPerViewAttributesInfoNVX.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    perViewAttributes: VkBool32;
    perViewAttributesPositionXOnly: VkBool32;
  }) {
    const s = VkMultiviewPerViewAttributesInfoNVX.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.perViewAttributes !== undefined) s.perViewAttributes = data.perViewAttributes;
    if (data.perViewAttributesPositionXOnly !== undefined) s.perViewAttributesPositionXOnly = data.perViewAttributesPositionXOnly;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get perViewAttributes() {
    return this.#view.getUint32(16, LE);
  }
  
  set perViewAttributes(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get perViewAttributesPositionXOnly() {
    return this.#view.getUint32(20, LE);
  }
  
  set perViewAttributesPositionXOnly(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceImageViewMinLodFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageViewMinLodFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageViewMinLodFeaturesEXT(new Uint8Array(VkPhysicalDeviceImageViewMinLodFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minLod: VkBool32;
  }) {
    const s = VkPhysicalDeviceImageViewMinLodFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minLod !== undefined) s.minLod = data.minLod;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minLod() {
    return this.#view.getUint32(16, LE);
  }
  
  set minLod(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImageViewMinLodCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewMinLodCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewMinLodCreateInfoEXT(new Uint8Array(VkImageViewMinLodCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    minLod: number;
  }) {
    const s = VkImageViewMinLodCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.minLod !== undefined) s.minLod = data.minLod;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get minLod() {
    return this.#view.getFloat32(16, LE);
  }
  
  set minLod(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(new Uint8Array(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rasterizationOrderColorAttachmentAccess: VkBool32;
    rasterizationOrderDepthAttachmentAccess: VkBool32;
    rasterizationOrderStencilAttachmentAccess: VkBool32;
  }) {
    const s = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rasterizationOrderColorAttachmentAccess !== undefined) s.rasterizationOrderColorAttachmentAccess = data.rasterizationOrderColorAttachmentAccess;
    if (data.rasterizationOrderDepthAttachmentAccess !== undefined) s.rasterizationOrderDepthAttachmentAccess = data.rasterizationOrderDepthAttachmentAccess;
    if (data.rasterizationOrderStencilAttachmentAccess !== undefined) s.rasterizationOrderStencilAttachmentAccess = data.rasterizationOrderStencilAttachmentAccess;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rasterizationOrderColorAttachmentAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set rasterizationOrderColorAttachmentAccess(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationOrderDepthAttachmentAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationOrderDepthAttachmentAccess(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rasterizationOrderStencilAttachmentAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set rasterizationOrderStencilAttachmentAccess(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceLinearColorAttachmentFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceLinearColorAttachmentFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceLinearColorAttachmentFeaturesNV(new Uint8Array(VkPhysicalDeviceLinearColorAttachmentFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    linearColorAttachment: VkBool32;
  }) {
    const s = VkPhysicalDeviceLinearColorAttachmentFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.linearColorAttachment !== undefined) s.linearColorAttachment = data.linearColorAttachment;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get linearColorAttachment() {
    return this.#view.getUint32(16, LE);
  }
  
  set linearColorAttachment(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(new Uint8Array(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    graphicsPipelineLibrary: VkBool32;
  }) {
    const s = VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.graphicsPipelineLibrary !== undefined) s.graphicsPipelineLibrary = data.graphicsPipelineLibrary;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get graphicsPipelineLibrary() {
    return this.#view.getUint32(16, LE);
  }
  
  set graphicsPipelineLibrary(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(new Uint8Array(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    graphicsPipelineLibraryFastLinking: VkBool32;
    graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32;
  }) {
    const s = VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.graphicsPipelineLibraryFastLinking !== undefined) s.graphicsPipelineLibraryFastLinking = data.graphicsPipelineLibraryFastLinking;
    if (data.graphicsPipelineLibraryIndependentInterpolationDecoration !== undefined) s.graphicsPipelineLibraryIndependentInterpolationDecoration = data.graphicsPipelineLibraryIndependentInterpolationDecoration;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get graphicsPipelineLibraryFastLinking() {
    return this.#view.getUint32(16, LE);
  }
  
  set graphicsPipelineLibraryFastLinking(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get graphicsPipelineLibraryIndependentInterpolationDecoration() {
    return this.#view.getUint32(20, LE);
  }
  
  set graphicsPipelineLibraryIndependentInterpolationDecoration(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkGraphicsPipelineLibraryCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkGraphicsPipelineLibraryCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkGraphicsPipelineLibraryCreateInfoEXT(new Uint8Array(VkGraphicsPipelineLibraryCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkGraphicsPipelineLibraryFlagsEXT;
  }) {
    const s = VkGraphicsPipelineLibraryCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkGraphicsPipelineLibraryFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(new Uint8Array(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorSetHostMapping: VkBool32;
  }) {
    const s = VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorSetHostMapping !== undefined) s.descriptorSetHostMapping = data.descriptorSetHostMapping;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorSetHostMapping() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorSetHostMapping(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDescriptorSetBindingReferenceVALVE implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetBindingReferenceVALVE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetBindingReferenceVALVE(new Uint8Array(VkDescriptorSetBindingReferenceVALVE.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorSetLayout: VkDescriptorSetLayout;
    binding: number;
  }) {
    const s = VkDescriptorSetBindingReferenceVALVE.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorSetLayout !== undefined) s.descriptorSetLayout = data.descriptorSetLayout;
    if (data.binding !== undefined) s.binding = data.binding;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorSetLayout() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorSetLayout(value: VkDescriptorSetLayout) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(24, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkDescriptorSetLayoutHostMappingInfoVALVE implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorSetLayoutHostMappingInfoVALVE.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDescriptorSetLayoutHostMappingInfoVALVE(new Uint8Array(VkDescriptorSetLayoutHostMappingInfoVALVE.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    descriptorOffset: Deno.PointerValue;
    descriptorSize: number;
  }) {
    const s = VkDescriptorSetLayoutHostMappingInfoVALVE.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.descriptorOffset !== undefined) s.descriptorOffset = data.descriptorOffset;
    if (data.descriptorSize !== undefined) s.descriptorSize = data.descriptorSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get descriptorOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorOffset(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get descriptorSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(new Uint8Array(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderModuleIdentifier: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderModuleIdentifier !== undefined) s.shaderModuleIdentifier = data.shaderModuleIdentifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderModuleIdentifier() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderModuleIdentifier(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(new Uint8Array(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderModuleIdentifierAlgorithmUUID: number;
  }) {
    const s = VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderModuleIdentifierAlgorithmUUID !== undefined) s.shaderModuleIdentifierAlgorithmUUID = data.shaderModuleIdentifierAlgorithmUUID;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderModuleIdentifierAlgorithmUUID() {
    return this.#view.getUint8(16);
  }
  
  set shaderModuleIdentifierAlgorithmUUID(value: number) {
    this.#view.setUint8(16, Number(value));
  }
}

export class VkPipelineShaderStageModuleIdentifierCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineShaderStageModuleIdentifierCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineShaderStageModuleIdentifierCreateInfoEXT(new Uint8Array(VkPipelineShaderStageModuleIdentifierCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    identifierSize?: number;
    pIdentifier: Deno.PointerValue;
  }) {
    const s = VkPipelineShaderStageModuleIdentifierCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.identifierSize !== undefined) s.identifierSize = data.identifierSize;
    if (data.pIdentifier !== undefined) s.pIdentifier = data.pIdentifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get identifierSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set identifierSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pIdentifier() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pIdentifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkShaderModuleIdentifierEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkShaderModuleIdentifierEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkShaderModuleIdentifierEXT(new Uint8Array(VkShaderModuleIdentifierEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    identifierSize: number;
    identifier: number;
  }) {
    const s = VkShaderModuleIdentifierEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.identifierSize !== undefined) s.identifierSize = data.identifierSize;
    if (data.identifier !== undefined) s.identifier = data.identifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get identifierSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set identifierSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get identifier() {
    return this.#view.getUint8(20);
  }
  
  set identifier(value: number) {
    this.#view.setUint8(20, Number(value));
  }
}

export class VkImageCompressionControlEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCompressionControlEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCompressionControlEXT(new Uint8Array(VkImageCompressionControlEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags: VkImageCompressionFlagsEXT;
    compressionControlPlaneCount?: number;
    pFixedRateFlags: Deno.PointerValue;
  }) {
    const s = VkImageCompressionControlEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.compressionControlPlaneCount !== undefined) s.compressionControlPlaneCount = data.compressionControlPlaneCount;
    if (data.pFixedRateFlags !== undefined) s.pFixedRateFlags = data.pFixedRateFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkImageCompressionFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compressionControlPlaneCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set compressionControlPlaneCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pFixedRateFlags() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFixedRateFlags(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceImageCompressionControlFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageCompressionControlFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageCompressionControlFeaturesEXT(new Uint8Array(VkPhysicalDeviceImageCompressionControlFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageCompressionControl: VkBool32;
  }) {
    const s = VkPhysicalDeviceImageCompressionControlFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageCompressionControl !== undefined) s.imageCompressionControl = data.imageCompressionControl;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageCompressionControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionControl(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImageCompressionPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageCompressionPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageCompressionPropertiesEXT(new Uint8Array(VkImageCompressionPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageCompressionFlags: VkImageCompressionFlagsEXT;
    imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT;
  }) {
    const s = VkImageCompressionPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageCompressionFlags !== undefined) s.imageCompressionFlags = data.imageCompressionFlags;
    if (data.imageCompressionFixedRateFlags !== undefined) s.imageCompressionFixedRateFlags = data.imageCompressionFixedRateFlags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageCompressionFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionFlags(value: VkImageCompressionFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imageCompressionFixedRateFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set imageCompressionFixedRateFlags(value: VkImageCompressionFixedRateFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(new Uint8Array(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageCompressionControlSwapchain: VkBool32;
  }) {
    const s = VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageCompressionControlSwapchain !== undefined) s.imageCompressionControlSwapchain = data.imageCompressionControlSwapchain;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageCompressionControlSwapchain() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionControlSwapchain(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkImageSubresource2EXT implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageSubresource2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageSubresource2EXT(new Uint8Array(VkImageSubresource2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    imageSubresource: VkImageSubresource;
  }) {
    const s = VkImageSubresource2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.imageSubresource !== undefined) s.imageSubresource = data.imageSubresource;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get imageSubresource() {
    return new VkImageSubresource(this.#data.subarray(24, 24 + VkImageSubresource.size));
  }
  
  set imageSubresource(value: VkImageSubresource) {
    if (value[BUFFER].byteLength < VkImageSubresource.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export class VkSubresourceLayout2EXT implements IVkStructure {
  static size = 80;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkSubresourceLayout2EXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkSubresourceLayout2EXT(new Uint8Array(VkSubresourceLayout2EXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subresourceLayout: VkSubresourceLayout;
  }) {
    const s = VkSubresourceLayout2EXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subresourceLayout !== undefined) s.subresourceLayout = data.subresourceLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subresourceLayout() {
    return new VkSubresourceLayout(this.#data.subarray(40, 40 + VkSubresourceLayout.size));
  }
  
  set subresourceLayout(value: VkSubresourceLayout) {
    if (value[BUFFER].byteLength < VkSubresourceLayout.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
}

export class VkRenderPassCreationControlEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassCreationControlEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassCreationControlEXT(new Uint8Array(VkRenderPassCreationControlEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    disallowMerging: VkBool32;
  }) {
    const s = VkRenderPassCreationControlEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.disallowMerging !== undefined) s.disallowMerging = data.disallowMerging;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get disallowMerging() {
    return this.#view.getUint32(16, LE);
  }
  
  set disallowMerging(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkRenderPassCreationFeedbackInfoEXT implements IVkStructure {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassCreationFeedbackInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassCreationFeedbackInfoEXT(new Uint8Array(VkRenderPassCreationFeedbackInfoEXT.size));
  }
  
  static create(data: {
    postMergeSubpassCount: number;
  }) {
    const s = VkRenderPassCreationFeedbackInfoEXT.alloc();
    if (data.postMergeSubpassCount !== undefined) s.postMergeSubpassCount = data.postMergeSubpassCount;
    return s;
  }
  
  get postMergeSubpassCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set postMergeSubpassCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export class VkRenderPassCreationFeedbackCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassCreationFeedbackCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassCreationFeedbackCreateInfoEXT(new Uint8Array(VkRenderPassCreationFeedbackCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pRenderPassFeedback: Deno.PointerValue;
  }) {
    const s = VkRenderPassCreationFeedbackCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pRenderPassFeedback !== undefined) s.pRenderPassFeedback = data.pRenderPassFeedback;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pRenderPassFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pRenderPassFeedback(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkRenderPassSubpassFeedbackInfoEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassSubpassFeedbackInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassSubpassFeedbackInfoEXT(new Uint8Array(VkRenderPassSubpassFeedbackInfoEXT.size));
  }
  
  static create(data: {
    subpassMergeStatus: VkSubpassMergeStatusEXT;
    description: number;
    postMergeIndex: number;
  }) {
    const s = VkRenderPassSubpassFeedbackInfoEXT.alloc();
    if (data.subpassMergeStatus !== undefined) s.subpassMergeStatus = data.subpassMergeStatus;
    if (data.description !== undefined) s.description = data.description;
    if (data.postMergeIndex !== undefined) s.postMergeIndex = data.postMergeIndex;
    return s;
  }
  
  get subpassMergeStatus() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpassMergeStatus(value: VkSubpassMergeStatusEXT) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get description() {
    return this.#view.getUint8(4);
  }
  
  set description(value: number) {
    this.#view.setUint8(4, Number(value));
  }
  
  get postMergeIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set postMergeIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkRenderPassSubpassFeedbackCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkRenderPassSubpassFeedbackCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkRenderPassSubpassFeedbackCreateInfoEXT(new Uint8Array(VkRenderPassSubpassFeedbackCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pSubpassFeedback: Deno.PointerValue;
  }) {
    const s = VkRenderPassSubpassFeedbackCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pSubpassFeedback !== undefined) s.pSubpassFeedback = data.pSubpassFeedback;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pSubpassFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pSubpassFeedback(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(new Uint8Array(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    subpassMergeFeedback: VkBool32;
  }) {
    const s = VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.subpassMergeFeedback !== undefined) s.subpassMergeFeedback = data.subpassMergeFeedback;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get subpassMergeFeedback() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassMergeFeedback(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkMicromapBuildInfoEXT implements IVkStructure {
  static size = 96;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapBuildInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapBuildInfoEXT(new Uint8Array(VkMicromapBuildInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    type: VkMicromapTypeEXT;
    flags?: VkBuildMicromapFlagsEXT;
    mode: VkBuildMicromapModeEXT;
    dstMicromap?: VkMicromapEXT;
    usageCountsCount?: number;
    pUsageCounts?: Deno.PointerValue;
    ppUsageCounts?: Deno.PointerValue;
    data: VkDeviceOrHostAddressConstKHR;
    scratchData: VkDeviceOrHostAddressKHR;
    triangleArray: VkDeviceOrHostAddressConstKHR;
    triangleArrayStride: VkDeviceSize;
  }) {
    const s = VkMicromapBuildInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.type !== undefined) s.type = data.type;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.mode !== undefined) s.mode = data.mode;
    if (data.dstMicromap !== undefined) s.dstMicromap = data.dstMicromap;
    if (data.usageCountsCount !== undefined) s.usageCountsCount = data.usageCountsCount;
    if (data.pUsageCounts !== undefined) s.pUsageCounts = data.pUsageCounts;
    if (data.ppUsageCounts !== undefined) s.ppUsageCounts = data.ppUsageCounts;
    if (data.data !== undefined) s.data = data.data;
    if (data.scratchData !== undefined) s.scratchData = data.scratchData;
    if (data.triangleArray !== undefined) s.triangleArray = data.triangleArray;
    if (data.triangleArrayStride !== undefined) s.triangleArrayStride = data.triangleArrayStride;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: VkMicromapTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VkBuildMicromapFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(24, LE);
  }
  
  set mode(value: VkBuildMicromapModeEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstMicromap() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstMicromap(value: VkMicromapEXT) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get usageCountsCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set usageCountsCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pUsageCounts() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pUsageCounts(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get ppUsageCounts() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppUsageCounts(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get scratchData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set scratchData(value: VkDeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get triangleArray() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set triangleArray(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get triangleArrayStride() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set triangleArrayStride(value: VkDeviceSize) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export class VkMicromapCreateInfoEXT implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapCreateInfoEXT(new Uint8Array(VkMicromapCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    createFlags?: VkMicromapCreateFlagsEXT;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    size: VkDeviceSize;
    type: VkMicromapTypeEXT;
    deviceAddress?: VkDeviceAddress;
  }) {
    const s = VkMicromapCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.createFlags !== undefined) s.createFlags = data.createFlags;
    if (data.buffer !== undefined) s.buffer = data.buffer;
    if (data.offset !== undefined) s.offset = data.offset;
    if (data.size !== undefined) s.size = data.size;
    if (data.type !== undefined) s.type = data.type;
    if (data.deviceAddress !== undefined) s.deviceAddress = data.deviceAddress;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get createFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set createFlags(value: VkMicromapCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: VkBuffer) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(48, LE);
  }
  
  set type(value: VkMicromapTypeEXT) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set deviceAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export class VkMicromapVersionInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapVersionInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapVersionInfoEXT(new Uint8Array(VkMicromapVersionInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pVersionData: Deno.PointerValue;
  }) {
    const s = VkMicromapVersionInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pVersionData !== undefined) s.pVersionData = data.pVersionData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pVersionData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pVersionData(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkCopyMicromapInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMicromapInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMicromapInfoEXT(new Uint8Array(VkCopyMicromapInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkMicromapEXT;
    dst: VkMicromapEXT;
    mode: VkCopyMicromapModeEXT;
  }) {
    const s = VkCopyMicromapInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: VkMicromapEXT) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: VkMicromapEXT) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkCopyMicromapToMemoryInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMicromapToMemoryInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMicromapToMemoryInfoEXT(new Uint8Array(VkCopyMicromapToMemoryInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkMicromapEXT;
    dst: VkDeviceOrHostAddressKHR;
    mode: VkCopyMicromapModeEXT;
  }) {
    const s = VkCopyMicromapToMemoryInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: VkMicromapEXT) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dst() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set dst(value: VkDeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkCopyMemoryToMicromapInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkCopyMemoryToMicromapInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkCopyMemoryToMicromapInfoEXT(new Uint8Array(VkCopyMemoryToMicromapInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    src: VkDeviceOrHostAddressConstKHR;
    dst: VkMicromapEXT;
    mode: VkCopyMicromapModeEXT;
  }) {
    const s = VkCopyMemoryToMicromapInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.src !== undefined) s.src = data.src;
    if (data.dst !== undefined) s.dst = data.dst;
    if (data.mode !== undefined) s.mode = data.mode;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get src() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set src(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: VkMicromapEXT) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: VkCopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkMicromapBuildSizesInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapBuildSizesInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapBuildSizesInfoEXT(new Uint8Array(VkMicromapBuildSizesInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    micromapSize: VkDeviceSize;
    buildScratchSize: VkDeviceSize;
    discardable: VkBool32;
  }) {
    const s = VkMicromapBuildSizesInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.micromapSize !== undefined) s.micromapSize = data.micromapSize;
    if (data.buildScratchSize !== undefined) s.buildScratchSize = data.buildScratchSize;
    if (data.discardable !== undefined) s.discardable = data.discardable;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get micromapSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set micromapSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get buildScratchSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buildScratchSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get discardable() {
    return this.#view.getUint32(32, LE);
  }
  
  set discardable(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkMicromapUsageEXT implements IVkStructure {
  static size = 12;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapUsageEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapUsageEXT(new Uint8Array(VkMicromapUsageEXT.size));
  }
  
  static create(data: {
    count: number;
    subdivisionLevel: number;
    format: number;
  }) {
    const s = VkMicromapUsageEXT.alloc();
    if (data.count !== undefined) s.count = data.count;
    if (data.subdivisionLevel !== undefined) s.subdivisionLevel = data.subdivisionLevel;
    if (data.format !== undefined) s.format = data.format;
    return s;
  }
  
  get count() {
    return this.#view.getUint32(0, LE);
  }
  
  set count(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get subdivisionLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set subdivisionLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(8, LE);
  }
  
  set format(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export class VkMicromapTriangleEXT implements IVkStructure {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkMicromapTriangleEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkMicromapTriangleEXT(new Uint8Array(VkMicromapTriangleEXT.size));
  }
  
  static create(data: {
    dataOffset: number;
    subdivisionLevel: number;
    format: number;
  }) {
    const s = VkMicromapTriangleEXT.alloc();
    if (data.dataOffset !== undefined) s.dataOffset = data.dataOffset;
    if (data.subdivisionLevel !== undefined) s.subdivisionLevel = data.subdivisionLevel;
    if (data.format !== undefined) s.format = data.format;
    return s;
  }
  
  get dataOffset() {
    return this.#view.getUint32(0, LE);
  }
  
  set dataOffset(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get subdivisionLevel() {
    return this.#view.getUint16(4, LE);
  }
  
  set subdivisionLevel(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint16(6, LE);
  }
  
  set format(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export class VkPhysicalDeviceOpacityMicromapFeaturesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceOpacityMicromapFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceOpacityMicromapFeaturesEXT(new Uint8Array(VkPhysicalDeviceOpacityMicromapFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    micromap: VkBool32;
    micromapCaptureReplay: VkBool32;
    micromapHostCommands: VkBool32;
  }) {
    const s = VkPhysicalDeviceOpacityMicromapFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.micromap !== undefined) s.micromap = data.micromap;
    if (data.micromapCaptureReplay !== undefined) s.micromapCaptureReplay = data.micromapCaptureReplay;
    if (data.micromapHostCommands !== undefined) s.micromapHostCommands = data.micromapHostCommands;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get micromap() {
    return this.#view.getUint32(16, LE);
  }
  
  set micromap(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get micromapCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set micromapCaptureReplay(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get micromapHostCommands() {
    return this.#view.getUint32(24, LE);
  }
  
  set micromapHostCommands(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceOpacityMicromapPropertiesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceOpacityMicromapPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceOpacityMicromapPropertiesEXT(new Uint8Array(VkPhysicalDeviceOpacityMicromapPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxOpacity2StateSubdivisionLevel: number;
    maxOpacity4StateSubdivisionLevel: number;
  }) {
    const s = VkPhysicalDeviceOpacityMicromapPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxOpacity2StateSubdivisionLevel !== undefined) s.maxOpacity2StateSubdivisionLevel = data.maxOpacity2StateSubdivisionLevel;
    if (data.maxOpacity4StateSubdivisionLevel !== undefined) s.maxOpacity4StateSubdivisionLevel = data.maxOpacity4StateSubdivisionLevel;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxOpacity2StateSubdivisionLevel() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxOpacity2StateSubdivisionLevel(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxOpacity4StateSubdivisionLevel() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxOpacity4StateSubdivisionLevel(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkAccelerationStructureTrianglesOpacityMicromapEXT implements IVkStructure {
  static size = 72;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureTrianglesOpacityMicromapEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAccelerationStructureTrianglesOpacityMicromapEXT(new Uint8Array(VkAccelerationStructureTrianglesOpacityMicromapEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    indexType: VkIndexType;
    indexBuffer: VkDeviceOrHostAddressConstKHR;
    indexStride: VkDeviceSize;
    baseTriangle: number;
    usageCountsCount?: number;
    pUsageCounts?: Deno.PointerValue;
    ppUsageCounts?: Deno.PointerValue;
    micromap: VkMicromapEXT;
  }) {
    const s = VkAccelerationStructureTrianglesOpacityMicromapEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.indexType !== undefined) s.indexType = data.indexType;
    if (data.indexBuffer !== undefined) s.indexBuffer = data.indexBuffer;
    if (data.indexStride !== undefined) s.indexStride = data.indexStride;
    if (data.baseTriangle !== undefined) s.baseTriangle = data.baseTriangle;
    if (data.usageCountsCount !== undefined) s.usageCountsCount = data.usageCountsCount;
    if (data.pUsageCounts !== undefined) s.pUsageCounts = data.pUsageCounts;
    if (data.ppUsageCounts !== undefined) s.ppUsageCounts = data.ppUsageCounts;
    if (data.micromap !== undefined) s.micromap = data.micromap;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(16, LE);
  }
  
  set indexType(value: VkIndexType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get indexBuffer() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set indexBuffer(value: VkDeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get indexStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indexStride(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get baseTriangle() {
    return this.#view.getUint32(40, LE);
  }
  
  set baseTriangle(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get usageCountsCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set usageCountsCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pUsageCounts() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pUsageCounts(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get ppUsageCounts() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppUsageCounts(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get micromap() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set micromap(value: VkMicromapEXT) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
}

export class VkPipelinePropertiesIdentifierEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelinePropertiesIdentifierEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelinePropertiesIdentifierEXT(new Uint8Array(VkPipelinePropertiesIdentifierEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineIdentifier: number;
  }) {
    const s = VkPipelinePropertiesIdentifierEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineIdentifier !== undefined) s.pipelineIdentifier = data.pipelineIdentifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineIdentifier() {
    return this.#view.getUint8(16);
  }
  
  set pipelineIdentifier(value: number) {
    this.#view.setUint8(16, Number(value));
  }
}

export class VkPhysicalDevicePipelinePropertiesFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelinePropertiesFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelinePropertiesFeaturesEXT(new Uint8Array(VkPhysicalDevicePipelinePropertiesFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelinePropertiesIdentifier: VkBool32;
  }) {
    const s = VkPhysicalDevicePipelinePropertiesFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelinePropertiesIdentifier !== undefined) s.pipelinePropertiesIdentifier = data.pipelinePropertiesIdentifier;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelinePropertiesIdentifier() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelinePropertiesIdentifier(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(new Uint8Array(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderEarlyAndLateFragmentTests: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderEarlyAndLateFragmentTests !== undefined) s.shaderEarlyAndLateFragmentTests = data.shaderEarlyAndLateFragmentTests;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderEarlyAndLateFragmentTests() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderEarlyAndLateFragmentTests(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExportMetalObjectCreateInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalObjectCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalObjectCreateInfoEXT(new Uint8Array(VkExportMetalObjectCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    exportObjectType?: VkExportMetalObjectTypeFlagBitsEXT;
  }) {
    const s = VkExportMetalObjectCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.exportObjectType !== undefined) s.exportObjectType = data.exportObjectType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get exportObjectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportObjectType(value: VkExportMetalObjectTypeFlagBitsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkExportMetalObjectsInfoEXT implements IVkStructure {
  static size = 16;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalObjectsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalObjectsInfoEXT(new Uint8Array(VkExportMetalObjectsInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
  }) {
    const s = VkExportMetalObjectsInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export class VkExportMetalDeviceInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalDeviceInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalDeviceInfoEXT(new Uint8Array(VkExportMetalDeviceInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mtlDevice: MTLDevice_id;
  }) {
    const s = VkExportMetalDeviceInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mtlDevice !== undefined) s.mtlDevice = data.mtlDevice;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mtlDevice() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlDevice(value: MTLDevice_id) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkExportMetalCommandQueueInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalCommandQueueInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalCommandQueueInfoEXT(new Uint8Array(VkExportMetalCommandQueueInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    queue: VkQueue;
    mtlCommandQueue: MTLCommandQueue_id;
  }) {
    const s = VkExportMetalCommandQueueInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.queue !== undefined) s.queue = data.queue;
    if (data.mtlCommandQueue !== undefined) s.mtlCommandQueue = data.mtlCommandQueue;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get queue() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set queue(value: VkQueue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get mtlCommandQueue() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlCommandQueue(value: MTLCommandQueue_id) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkExportMetalBufferInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalBufferInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalBufferInfoEXT(new Uint8Array(VkExportMetalBufferInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    memory: VkDeviceMemory;
    mtlBuffer: MTLBuffer_id;
  }) {
    const s = VkExportMetalBufferInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.memory !== undefined) s.memory = data.memory;
    if (data.mtlBuffer !== undefined) s.mtlBuffer = data.mtlBuffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: VkDeviceMemory) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get mtlBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlBuffer(value: MTLBuffer_id) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkImportMetalBufferInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMetalBufferInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMetalBufferInfoEXT(new Uint8Array(VkImportMetalBufferInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mtlBuffer: MTLBuffer_id;
  }) {
    const s = VkImportMetalBufferInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mtlBuffer !== undefined) s.mtlBuffer = data.mtlBuffer;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mtlBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlBuffer(value: MTLBuffer_id) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkExportMetalTextureInfoEXT implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalTextureInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalTextureInfoEXT(new Uint8Array(VkExportMetalTextureInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image?: VkImage;
    imageView?: VkImageView;
    bufferView?: VkBufferView;
    plane: VkImageAspectFlagBits;
    mtlTexture: MTLTexture_id;
  }) {
    const s = VkExportMetalTextureInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    if (data.imageView !== undefined) s.imageView = data.imageView;
    if (data.bufferView !== undefined) s.bufferView = data.bufferView;
    if (data.plane !== undefined) s.plane = data.plane;
    if (data.mtlTexture !== undefined) s.mtlTexture = data.mtlTexture;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set imageView(value: VkImageView) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferView() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set bufferView(value: VkBufferView) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get plane() {
    return this.#view.getUint32(40, LE);
  }
  
  set plane(value: VkImageAspectFlagBits) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get mtlTexture() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set mtlTexture(value: MTLTexture_id) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export class VkImportMetalTextureInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMetalTextureInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMetalTextureInfoEXT(new Uint8Array(VkImportMetalTextureInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    plane: VkImageAspectFlagBits;
    mtlTexture: MTLTexture_id;
  }) {
    const s = VkImportMetalTextureInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.plane !== undefined) s.plane = data.plane;
    if (data.mtlTexture !== undefined) s.mtlTexture = data.mtlTexture;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get plane() {
    return this.#view.getUint32(16, LE);
  }
  
  set plane(value: VkImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get mtlTexture() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlTexture(value: MTLTexture_id) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkExportMetalIOSurfaceInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalIOSurfaceInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalIOSurfaceInfoEXT(new Uint8Array(VkExportMetalIOSurfaceInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    image: VkImage;
    ioSurface: IOSurfaceRef;
  }) {
    const s = VkExportMetalIOSurfaceInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.image !== undefined) s.image = data.image;
    if (data.ioSurface !== undefined) s.ioSurface = data.ioSurface;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: VkImage) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get ioSurface() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set ioSurface(value: IOSurfaceRef) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkImportMetalIOSurfaceInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMetalIOSurfaceInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMetalIOSurfaceInfoEXT(new Uint8Array(VkImportMetalIOSurfaceInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    ioSurface?: IOSurfaceRef;
  }) {
    const s = VkImportMetalIOSurfaceInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.ioSurface !== undefined) s.ioSurface = data.ioSurface;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get ioSurface() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set ioSurface(value: IOSurfaceRef) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkExportMetalSharedEventInfoEXT implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkExportMetalSharedEventInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkExportMetalSharedEventInfoEXT(new Uint8Array(VkExportMetalSharedEventInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    semaphore?: VkSemaphore;
    event?: VkEvent;
    mtlSharedEvent: MTLSharedEvent_id;
  }) {
    const s = VkExportMetalSharedEventInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.semaphore !== undefined) s.semaphore = data.semaphore;
    if (data.event !== undefined) s.event = data.event;
    if (data.mtlSharedEvent !== undefined) s.mtlSharedEvent = data.mtlSharedEvent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: VkSemaphore) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get event() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set event(value: VkEvent) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get mtlSharedEvent() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set mtlSharedEvent(value: MTLSharedEvent_id) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkImportMetalSharedEventInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImportMetalSharedEventInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImportMetalSharedEventInfoEXT(new Uint8Array(VkImportMetalSharedEventInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    mtlSharedEvent: MTLSharedEvent_id;
  }) {
    const s = VkImportMetalSharedEventInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.mtlSharedEvent !== undefined) s.mtlSharedEvent = data.mtlSharedEvent;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get mtlSharedEvent() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlSharedEvent(value: MTLSharedEvent_id) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(new Uint8Array(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    nonSeamlessCubeMap: VkBool32;
  }) {
    const s = VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.nonSeamlessCubeMap !== undefined) s.nonSeamlessCubeMap = data.nonSeamlessCubeMap;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get nonSeamlessCubeMap() {
    return this.#view.getUint32(16, LE);
  }
  
  set nonSeamlessCubeMap(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDevicePipelineRobustnessFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelineRobustnessFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelineRobustnessFeaturesEXT(new Uint8Array(VkPhysicalDevicePipelineRobustnessFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    pipelineRobustness: VkBool32;
  }) {
    const s = VkPhysicalDevicePipelineRobustnessFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.pipelineRobustness !== undefined) s.pipelineRobustness = data.pipelineRobustness;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get pipelineRobustness() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineRobustness(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPipelineRobustnessCreateInfoEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineRobustnessCreateInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPipelineRobustnessCreateInfoEXT(new Uint8Array(VkPipelineRobustnessCreateInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    storageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    uniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    vertexInputs: VkPipelineRobustnessBufferBehaviorEXT;
    images: VkPipelineRobustnessImageBehaviorEXT;
  }) {
    const s = VkPipelineRobustnessCreateInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.storageBuffers !== undefined) s.storageBuffers = data.storageBuffers;
    if (data.uniformBuffers !== undefined) s.uniformBuffers = data.uniformBuffers;
    if (data.vertexInputs !== undefined) s.vertexInputs = data.vertexInputs;
    if (data.images !== undefined) s.images = data.images;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get storageBuffers() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffers(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformBuffers(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vertexInputs() {
    return this.#view.getUint32(24, LE);
  }
  
  set vertexInputs(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get images() {
    return this.#view.getUint32(28, LE);
  }
  
  set images(value: VkPipelineRobustnessImageBehaviorEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDevicePipelineRobustnessPropertiesEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDevicePipelineRobustnessPropertiesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDevicePipelineRobustnessPropertiesEXT(new Uint8Array(VkPhysicalDevicePipelineRobustnessPropertiesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehaviorEXT;
    defaultRobustnessImages: VkPipelineRobustnessImageBehaviorEXT;
  }) {
    const s = VkPhysicalDevicePipelineRobustnessPropertiesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.defaultRobustnessStorageBuffers !== undefined) s.defaultRobustnessStorageBuffers = data.defaultRobustnessStorageBuffers;
    if (data.defaultRobustnessUniformBuffers !== undefined) s.defaultRobustnessUniformBuffers = data.defaultRobustnessUniformBuffers;
    if (data.defaultRobustnessVertexInputs !== undefined) s.defaultRobustnessVertexInputs = data.defaultRobustnessVertexInputs;
    if (data.defaultRobustnessImages !== undefined) s.defaultRobustnessImages = data.defaultRobustnessImages;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get defaultRobustnessStorageBuffers() {
    return this.#view.getUint32(16, LE);
  }
  
  set defaultRobustnessStorageBuffers(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get defaultRobustnessUniformBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set defaultRobustnessUniformBuffers(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get defaultRobustnessVertexInputs() {
    return this.#view.getUint32(24, LE);
  }
  
  set defaultRobustnessVertexInputs(value: VkPipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get defaultRobustnessImages() {
    return this.#view.getUint32(28, LE);
  }
  
  set defaultRobustnessImages(value: VkPipelineRobustnessImageBehaviorEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkImageViewSampleWeightCreateInfoQCOM implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkImageViewSampleWeightCreateInfoQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkImageViewSampleWeightCreateInfoQCOM(new Uint8Array(VkImageViewSampleWeightCreateInfoQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    filterCenter: VkOffset2D;
    filterSize: VkExtent2D;
    numPhases: number;
  }) {
    const s = VkImageViewSampleWeightCreateInfoQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.filterCenter !== undefined) s.filterCenter = data.filterCenter;
    if (data.filterSize !== undefined) s.filterSize = data.filterSize;
    if (data.numPhases !== undefined) s.numPhases = data.numPhases;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get filterCenter() {
    return new VkOffset2D(this.#data.subarray(16, 16 + VkOffset2D.size));
  }
  
  set filterCenter(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get filterSize() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set filterSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get numPhases() {
    return this.#view.getUint32(32, LE);
  }
  
  set numPhases(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkPhysicalDeviceImageProcessingFeaturesQCOM implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageProcessingFeaturesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageProcessingFeaturesQCOM(new Uint8Array(VkPhysicalDeviceImageProcessingFeaturesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    textureSampleWeighted: VkBool32;
    textureBoxFilter: VkBool32;
    textureBlockMatch: VkBool32;
  }) {
    const s = VkPhysicalDeviceImageProcessingFeaturesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.textureSampleWeighted !== undefined) s.textureSampleWeighted = data.textureSampleWeighted;
    if (data.textureBoxFilter !== undefined) s.textureBoxFilter = data.textureBoxFilter;
    if (data.textureBlockMatch !== undefined) s.textureBlockMatch = data.textureBlockMatch;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get textureSampleWeighted() {
    return this.#view.getUint32(16, LE);
  }
  
  set textureSampleWeighted(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get textureBoxFilter() {
    return this.#view.getUint32(20, LE);
  }
  
  set textureBoxFilter(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get textureBlockMatch() {
    return this.#view.getUint32(24, LE);
  }
  
  set textureBlockMatch(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export class VkPhysicalDeviceImageProcessingPropertiesQCOM implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceImageProcessingPropertiesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceImageProcessingPropertiesQCOM(new Uint8Array(VkPhysicalDeviceImageProcessingPropertiesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    maxWeightFilterPhases?: number;
    maxWeightFilterDimension?: VkExtent2D;
    maxBlockMatchRegion?: VkExtent2D;
    maxBoxFilterBlockSize?: VkExtent2D;
  }) {
    const s = VkPhysicalDeviceImageProcessingPropertiesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.maxWeightFilterPhases !== undefined) s.maxWeightFilterPhases = data.maxWeightFilterPhases;
    if (data.maxWeightFilterDimension !== undefined) s.maxWeightFilterDimension = data.maxWeightFilterDimension;
    if (data.maxBlockMatchRegion !== undefined) s.maxBlockMatchRegion = data.maxBlockMatchRegion;
    if (data.maxBoxFilterBlockSize !== undefined) s.maxBoxFilterBlockSize = data.maxBoxFilterBlockSize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get maxWeightFilterPhases() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxWeightFilterPhases(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxWeightFilterDimension() {
    return new VkExtent2D(this.#data.subarray(24, 24 + VkExtent2D.size));
  }
  
  set maxWeightFilterDimension(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxBlockMatchRegion() {
    return new VkExtent2D(this.#data.subarray(32, 32 + VkExtent2D.size));
  }
  
  set maxBlockMatchRegion(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get maxBoxFilterBlockSize() {
    return new VkExtent2D(this.#data.subarray(40, 40 + VkExtent2D.size));
  }
  
  set maxBoxFilterBlockSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
}

export class VkPhysicalDeviceTilePropertiesFeaturesQCOM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceTilePropertiesFeaturesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceTilePropertiesFeaturesQCOM(new Uint8Array(VkPhysicalDeviceTilePropertiesFeaturesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    tileProperties: VkBool32;
  }) {
    const s = VkPhysicalDeviceTilePropertiesFeaturesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.tileProperties !== undefined) s.tileProperties = data.tileProperties;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get tileProperties() {
    return this.#view.getUint32(16, LE);
  }
  
  set tileProperties(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkTilePropertiesQCOM implements IVkStructure {
  static size = 60;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkTilePropertiesQCOM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkTilePropertiesQCOM(new Uint8Array(VkTilePropertiesQCOM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    tileSize: VkExtent3D;
    apronSize: VkExtent2D;
    origin: VkOffset2D;
  }) {
    const s = VkTilePropertiesQCOM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.tileSize !== undefined) s.tileSize = data.tileSize;
    if (data.apronSize !== undefined) s.apronSize = data.apronSize;
    if (data.origin !== undefined) s.origin = data.origin;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get tileSize() {
    return new VkExtent3D(this.#data.subarray(24, 24 + VkExtent3D.size));
  }
  
  set tileSize(value: VkExtent3D) {
    if (value[BUFFER].byteLength < VkExtent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get apronSize() {
    return new VkExtent2D(this.#data.subarray(40, 40 + VkExtent2D.size));
  }
  
  set apronSize(value: VkExtent2D) {
    if (value[BUFFER].byteLength < VkExtent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get origin() {
    return new VkOffset2D(this.#data.subarray(48, 48 + VkOffset2D.size));
  }
  
  set origin(value: VkOffset2D) {
    if (value[BUFFER].byteLength < VkOffset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export class VkPhysicalDeviceAmigoProfilingFeaturesSEC implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceAmigoProfilingFeaturesSEC.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceAmigoProfilingFeaturesSEC(new Uint8Array(VkPhysicalDeviceAmigoProfilingFeaturesSEC.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    amigoProfiling: VkBool32;
  }) {
    const s = VkPhysicalDeviceAmigoProfilingFeaturesSEC.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.amigoProfiling !== undefined) s.amigoProfiling = data.amigoProfiling;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get amigoProfiling() {
    return this.#view.getUint32(16, LE);
  }
  
  set amigoProfiling(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkAmigoProfilingSubmitInfoSEC implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAmigoProfilingSubmitInfoSEC.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkAmigoProfilingSubmitInfoSEC(new Uint8Array(VkAmigoProfilingSubmitInfoSEC.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    firstDrawTimestamp: Deno.PointerValue;
    swapBufferTimestamp: Deno.PointerValue;
  }) {
    const s = VkAmigoProfilingSubmitInfoSEC.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.firstDrawTimestamp !== undefined) s.firstDrawTimestamp = data.firstDrawTimestamp;
    if (data.swapBufferTimestamp !== undefined) s.swapBufferTimestamp = data.swapBufferTimestamp;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get firstDrawTimestamp() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set firstDrawTimestamp(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get swapBufferTimestamp() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set swapBufferTimestamp(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(new Uint8Array(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    attachmentFeedbackLoopLayout: VkBool32;
  }) {
    const s = VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.attachmentFeedbackLoopLayout !== undefined) s.attachmentFeedbackLoopLayout = data.attachmentFeedbackLoopLayout;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get attachmentFeedbackLoopLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentFeedbackLoopLayout(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceDepthClampZeroOneFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(new Uint8Array(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    depthClampZeroOne: VkBool32;
  }) {
    const s = VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.depthClampZeroOne !== undefined) s.depthClampZeroOne = data.depthClampZeroOne;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get depthClampZeroOne() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClampZeroOne(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceAddressBindingReportFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceAddressBindingReportFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceAddressBindingReportFeaturesEXT(new Uint8Array(VkPhysicalDeviceAddressBindingReportFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    reportAddressBinding: VkBool32;
  }) {
    const s = VkPhysicalDeviceAddressBindingReportFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.reportAddressBinding !== undefined) s.reportAddressBinding = data.reportAddressBinding;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get reportAddressBinding() {
    return this.#view.getUint32(16, LE);
  }
  
  set reportAddressBinding(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkDeviceAddressBindingCallbackDataEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceAddressBindingCallbackDataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceAddressBindingCallbackDataEXT(new Uint8Array(VkDeviceAddressBindingCallbackDataEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkDeviceAddressBindingFlagsEXT;
    baseAddress: VkDeviceAddress;
    size: VkDeviceSize;
    bindingType: VkDeviceAddressBindingTypeEXT;
  }) {
    const s = VkDeviceAddressBindingCallbackDataEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.baseAddress !== undefined) s.baseAddress = data.baseAddress;
    if (data.size !== undefined) s.size = data.size;
    if (data.bindingType !== undefined) s.bindingType = data.bindingType;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkDeviceAddressBindingFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get baseAddress() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set baseAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: VkDeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get bindingType() {
    return this.#view.getUint32(40, LE);
  }
  
  set bindingType(value: VkDeviceAddressBindingTypeEXT) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export class VkPhysicalDeviceOpticalFlowFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceOpticalFlowFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceOpticalFlowFeaturesNV(new Uint8Array(VkPhysicalDeviceOpticalFlowFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    opticalFlow: VkBool32;
  }) {
    const s = VkPhysicalDeviceOpticalFlowFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.opticalFlow !== undefined) s.opticalFlow = data.opticalFlow;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get opticalFlow() {
    return this.#view.getUint32(16, LE);
  }
  
  set opticalFlow(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceOpticalFlowPropertiesNV implements IVkStructure {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceOpticalFlowPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceOpticalFlowPropertiesNV(new Uint8Array(VkPhysicalDeviceOpticalFlowPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV;
    supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV;
    hintSupported: VkBool32;
    costSupported: VkBool32;
    bidirectionalFlowSupported: VkBool32;
    globalFlowSupported: VkBool32;
    minWidth: number;
    minHeight: number;
    maxWidth: number;
    maxHeight: number;
    maxNumRegionsOfInterest: number;
  }) {
    const s = VkPhysicalDeviceOpticalFlowPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.supportedOutputGridSizes !== undefined) s.supportedOutputGridSizes = data.supportedOutputGridSizes;
    if (data.supportedHintGridSizes !== undefined) s.supportedHintGridSizes = data.supportedHintGridSizes;
    if (data.hintSupported !== undefined) s.hintSupported = data.hintSupported;
    if (data.costSupported !== undefined) s.costSupported = data.costSupported;
    if (data.bidirectionalFlowSupported !== undefined) s.bidirectionalFlowSupported = data.bidirectionalFlowSupported;
    if (data.globalFlowSupported !== undefined) s.globalFlowSupported = data.globalFlowSupported;
    if (data.minWidth !== undefined) s.minWidth = data.minWidth;
    if (data.minHeight !== undefined) s.minHeight = data.minHeight;
    if (data.maxWidth !== undefined) s.maxWidth = data.maxWidth;
    if (data.maxHeight !== undefined) s.maxHeight = data.maxHeight;
    if (data.maxNumRegionsOfInterest !== undefined) s.maxNumRegionsOfInterest = data.maxNumRegionsOfInterest;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get supportedOutputGridSizes() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedOutputGridSizes(value: VkOpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedHintGridSizes() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedHintGridSizes(value: VkOpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get hintSupported() {
    return this.#view.getUint32(24, LE);
  }
  
  set hintSupported(value: VkBool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get costSupported() {
    return this.#view.getUint32(28, LE);
  }
  
  set costSupported(value: VkBool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get bidirectionalFlowSupported() {
    return this.#view.getUint32(32, LE);
  }
  
  set bidirectionalFlowSupported(value: VkBool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get globalFlowSupported() {
    return this.#view.getUint32(36, LE);
  }
  
  set globalFlowSupported(value: VkBool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minWidth() {
    return this.#view.getUint32(40, LE);
  }
  
  set minWidth(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minHeight() {
    return this.#view.getUint32(44, LE);
  }
  
  set minHeight(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxWidth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxWidth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxHeight() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxHeight(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxNumRegionsOfInterest() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxNumRegionsOfInterest(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export class VkOpticalFlowImageFormatInfoNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpticalFlowImageFormatInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpticalFlowImageFormatInfoNV(new Uint8Array(VkOpticalFlowImageFormatInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    usage: VkOpticalFlowUsageFlagsNV;
  }) {
    const s = VkOpticalFlowImageFormatInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.usage !== undefined) s.usage = data.usage;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: VkOpticalFlowUsageFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkOpticalFlowImageFormatPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpticalFlowImageFormatPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpticalFlowImageFormatPropertiesNV(new Uint8Array(VkOpticalFlowImageFormatPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    format: VkFormat;
  }) {
    const s = VkOpticalFlowImageFormatPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.format !== undefined) s.format = data.format;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: VkFormat) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkOpticalFlowSessionCreateInfoNV implements IVkStructure {
  static size = 56;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpticalFlowSessionCreateInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpticalFlowSessionCreateInfoNV(new Uint8Array(VkOpticalFlowSessionCreateInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    width: number;
    height: number;
    imageFormat: VkFormat;
    flowVectorFormat: VkFormat;
    costFormat?: VkFormat;
    outputGridSize: VkOpticalFlowGridSizeFlagsNV;
    hintGridSize?: VkOpticalFlowGridSizeFlagsNV;
    performanceLevel?: VkOpticalFlowPerformanceLevelNV;
    flags?: VkOpticalFlowSessionCreateFlagsNV;
  }) {
    const s = VkOpticalFlowSessionCreateInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.width !== undefined) s.width = data.width;
    if (data.height !== undefined) s.height = data.height;
    if (data.imageFormat !== undefined) s.imageFormat = data.imageFormat;
    if (data.flowVectorFormat !== undefined) s.flowVectorFormat = data.flowVectorFormat;
    if (data.costFormat !== undefined) s.costFormat = data.costFormat;
    if (data.outputGridSize !== undefined) s.outputGridSize = data.outputGridSize;
    if (data.hintGridSize !== undefined) s.hintGridSize = data.hintGridSize;
    if (data.performanceLevel !== undefined) s.performanceLevel = data.performanceLevel;
    if (data.flags !== undefined) s.flags = data.flags;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(16, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(20, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get imageFormat() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageFormat(value: VkFormat) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get flowVectorFormat() {
    return this.#view.getUint32(28, LE);
  }
  
  set flowVectorFormat(value: VkFormat) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get costFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set costFormat(value: VkFormat) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get outputGridSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set outputGridSize(value: VkOpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get hintGridSize() {
    return this.#view.getUint32(40, LE);
  }
  
  set hintGridSize(value: VkOpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get performanceLevel() {
    return this.#view.getUint32(44, LE);
  }
  
  set performanceLevel(value: VkOpticalFlowPerformanceLevelNV) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(48, LE);
  }
  
  set flags(value: VkOpticalFlowSessionCreateFlagsNV) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export class VkOpticalFlowSessionCreatePrivateDataInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpticalFlowSessionCreatePrivateDataInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpticalFlowSessionCreatePrivateDataInfoNV(new Uint8Array(VkOpticalFlowSessionCreatePrivateDataInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    id: number;
    size: number;
    pPrivateData: Deno.PointerValue;
  }) {
    const s = VkOpticalFlowSessionCreatePrivateDataInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.id !== undefined) s.id = data.id;
    if (data.size !== undefined) s.size = data.size;
    if (data.pPrivateData !== undefined) s.pPrivateData = data.pPrivateData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get id() {
    return this.#view.getUint32(16, LE);
  }
  
  set id(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(20, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pPrivateData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPrivateData(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkOpticalFlowExecuteInfoNV implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkOpticalFlowExecuteInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkOpticalFlowExecuteInfoNV(new Uint8Array(VkOpticalFlowExecuteInfoNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    flags?: VkOpticalFlowExecuteFlagsNV;
    regionCount?: number;
    pRegions: Deno.PointerValue;
  }) {
    const s = VkOpticalFlowExecuteInfoNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.flags !== undefined) s.flags = data.flags;
    if (data.regionCount !== undefined) s.regionCount = data.regionCount;
    if (data.pRegions !== undefined) s.pRegions = data.pRegions;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VkOpticalFlowExecuteFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pRegions(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceFaultFeaturesEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceFaultFeaturesEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceFaultFeaturesEXT(new Uint8Array(VkPhysicalDeviceFaultFeaturesEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    deviceFault: VkBool32;
    deviceFaultVendorBinary: VkBool32;
  }) {
    const s = VkPhysicalDeviceFaultFeaturesEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.deviceFault !== undefined) s.deviceFault = data.deviceFault;
    if (data.deviceFaultVendorBinary !== undefined) s.deviceFaultVendorBinary = data.deviceFaultVendorBinary;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get deviceFault() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceFault(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceFaultVendorBinary() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceFaultVendorBinary(value: VkBool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export class VkDeviceFaultAddressInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceFaultAddressInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceFaultAddressInfoEXT(new Uint8Array(VkDeviceFaultAddressInfoEXT.size));
  }
  
  static create(data: {
    addressType: VkDeviceFaultAddressTypeEXT;
    reportedAddress: VkDeviceAddress;
    addressPrecision: VkDeviceSize;
  }) {
    const s = VkDeviceFaultAddressInfoEXT.alloc();
    if (data.addressType !== undefined) s.addressType = data.addressType;
    if (data.reportedAddress !== undefined) s.reportedAddress = data.reportedAddress;
    if (data.addressPrecision !== undefined) s.addressPrecision = data.addressPrecision;
    return s;
  }
  
  get addressType() {
    return this.#view.getUint32(0, LE);
  }
  
  set addressType(value: VkDeviceFaultAddressTypeEXT) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get reportedAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set reportedAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get addressPrecision() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set addressPrecision(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDeviceFaultVendorInfoEXT implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceFaultVendorInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceFaultVendorInfoEXT(new Uint8Array(VkDeviceFaultVendorInfoEXT.size));
  }
  
  static create(data: {
    description: number;
    vendorFaultCode: Deno.PointerValue;
    vendorFaultData: Deno.PointerValue;
  }) {
    const s = VkDeviceFaultVendorInfoEXT.alloc();
    if (data.description !== undefined) s.description = data.description;
    if (data.vendorFaultCode !== undefined) s.vendorFaultCode = data.vendorFaultCode;
    if (data.vendorFaultData !== undefined) s.vendorFaultData = data.vendorFaultData;
    return s;
  }
  
  get description() {
    return this.#view.getUint8(0);
  }
  
  set description(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get vendorFaultCode() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set vendorFaultCode(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get vendorFaultData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set vendorFaultData(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export class VkDeviceFaultCountsEXT implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceFaultCountsEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceFaultCountsEXT(new Uint8Array(VkDeviceFaultCountsEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    addressInfoCount?: number;
    vendorInfoCount?: number;
    vendorBinarySize?: VkDeviceSize;
  }) {
    const s = VkDeviceFaultCountsEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.addressInfoCount !== undefined) s.addressInfoCount = data.addressInfoCount;
    if (data.vendorInfoCount !== undefined) s.vendorInfoCount = data.vendorInfoCount;
    if (data.vendorBinarySize !== undefined) s.vendorBinarySize = data.vendorBinarySize;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get addressInfoCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set addressInfoCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vendorInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set vendorInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vendorBinarySize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set vendorBinarySize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export class VkDeviceFaultInfoEXT implements IVkStructure {
  static size = 48;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceFaultInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceFaultInfoEXT(new Uint8Array(VkDeviceFaultInfoEXT.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    description: number;
    pAddressInfos?: Deno.PointerValue;
    pVendorInfos?: Deno.PointerValue;
    pVendorBinaryData?: Deno.PointerValue;
  }) {
    const s = VkDeviceFaultInfoEXT.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.description !== undefined) s.description = data.description;
    if (data.pAddressInfos !== undefined) s.pAddressInfos = data.pAddressInfos;
    if (data.pVendorInfos !== undefined) s.pVendorInfos = data.pVendorInfos;
    if (data.pVendorBinaryData !== undefined) s.pVendorBinaryData = data.pVendorBinaryData;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get description() {
    return this.#view.getUint8(16);
  }
  
  set description(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pAddressInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAddressInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pVendorInfos() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pVendorInfos(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pVendorBinaryData() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pVendorBinaryData(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export class VkDeviceFaultVendorBinaryHeaderVersionOneEXT implements IVkStructure {
  static size = 36;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceFaultVendorBinaryHeaderVersionOneEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDeviceFaultVendorBinaryHeaderVersionOneEXT(new Uint8Array(VkDeviceFaultVendorBinaryHeaderVersionOneEXT.size));
  }
  
  static create(data: {
    headerSize: number;
    headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT;
    vendorID: number;
    deviceID: number;
    driverVersion: number;
    pipelineCacheUUID: number;
    applicationNameOffset: number;
    applicationVersion: number;
    engineNameOffset: number;
  }) {
    const s = VkDeviceFaultVendorBinaryHeaderVersionOneEXT.alloc();
    if (data.headerSize !== undefined) s.headerSize = data.headerSize;
    if (data.headerVersion !== undefined) s.headerVersion = data.headerVersion;
    if (data.vendorID !== undefined) s.vendorID = data.vendorID;
    if (data.deviceID !== undefined) s.deviceID = data.deviceID;
    if (data.driverVersion !== undefined) s.driverVersion = data.driverVersion;
    if (data.pipelineCacheUUID !== undefined) s.pipelineCacheUUID = data.pipelineCacheUUID;
    if (data.applicationNameOffset !== undefined) s.applicationNameOffset = data.applicationNameOffset;
    if (data.applicationVersion !== undefined) s.applicationVersion = data.applicationVersion;
    if (data.engineNameOffset !== undefined) s.engineNameOffset = data.engineNameOffset;
    return s;
  }
  
  get headerSize() {
    return this.#view.getUint32(0, LE);
  }
  
  set headerSize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get headerVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set headerVersion(value: VkDeviceFaultVendorBinaryHeaderVersionEXT) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get driverVersion() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverVersion(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineCacheUUID() {
    return this.#view.getUint8(20);
  }
  
  set pipelineCacheUUID(value: number) {
    this.#view.setUint8(20, Number(value));
  }
  
  get applicationNameOffset() {
    return this.#view.getUint32(24, LE);
  }
  
  set applicationNameOffset(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get applicationVersion() {
    return this.#view.getUint32(28, LE);
  }
  
  set applicationVersion(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get engineNameOffset() {
    return this.#view.getUint32(32, LE);
  }
  
  set engineNameOffset(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export class VkDecompressMemoryRegionNV implements IVkStructure {
  static size = 40;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDecompressMemoryRegionNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkDecompressMemoryRegionNV(new Uint8Array(VkDecompressMemoryRegionNV.size));
  }
  
  static create(data: {
    srcAddress: VkDeviceAddress;
    dstAddress: VkDeviceAddress;
    compressedSize: VkDeviceSize;
    decompressedSize: VkDeviceSize;
    decompressionMethod: VkMemoryDecompressionMethodFlagsNV;
  }) {
    const s = VkDecompressMemoryRegionNV.alloc();
    if (data.srcAddress !== undefined) s.srcAddress = data.srcAddress;
    if (data.dstAddress !== undefined) s.dstAddress = data.dstAddress;
    if (data.compressedSize !== undefined) s.compressedSize = data.compressedSize;
    if (data.decompressedSize !== undefined) s.decompressedSize = data.decompressedSize;
    if (data.decompressionMethod !== undefined) s.decompressionMethod = data.decompressionMethod;
    return s;
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstAddress(value: VkDeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get compressedSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set compressedSize(value: VkDeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get decompressedSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set decompressedSize(value: VkDeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get decompressionMethod() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set decompressionMethod(value: VkMemoryDecompressionMethodFlagsNV) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export class VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM implements IVkStructure {
  static size = 32;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(new Uint8Array(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderCoreMask: Deno.PointerValue;
    shaderCoreCount: number;
    shaderWarpsPerCore: number;
  }) {
    const s = VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderCoreMask !== undefined) s.shaderCoreMask = data.shaderCoreMask;
    if (data.shaderCoreCount !== undefined) s.shaderCoreCount = data.shaderCoreCount;
    if (data.shaderWarpsPerCore !== undefined) s.shaderWarpsPerCore = data.shaderWarpsPerCore;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderCoreMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set shaderCoreMask(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get shaderCoreCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderCoreCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderWarpsPerCore() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderWarpsPerCore(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export class VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(new Uint8Array(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    shaderCoreBuiltins: VkBool32;
  }) {
    const s = VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.shaderCoreBuiltins !== undefined) s.shaderCoreBuiltins = data.shaderCoreBuiltins;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get shaderCoreBuiltins() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderCoreBuiltins(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(new Uint8Array(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayTracingInvocationReorder: VkBool32;
  }) {
    const s = VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayTracingInvocationReorder !== undefined) s.rayTracingInvocationReorder = data.rayTracingInvocationReorder;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayTracingInvocationReorder() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingInvocationReorder(value: VkBool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export class VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV implements IVkStructure {
  static size = 24;
  
  #data: Uint8Array;
  #view: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
  
  static alloc() {
    return new VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(new Uint8Array(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.size));
  }
  
  static create(data: {
    pNext?: Deno.PointerValue;
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV;
  }) {
    const s = VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.alloc();
    s.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
    if (data.pNext !== undefined) s.pNext = data.pNext;
    if (data.rayTracingInvocationReorderReorderingHint !== undefined) s.rayTracingInvocationReorderReorderingHint = data.rayTracingInvocationReorderReorderingHint;
    return s;
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: VkStructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rayTracingInvocationReorderReorderingHint() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingInvocationReorderReorderingHint(value: VkRayTracingInvocationReorderModeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

/// Unions

/** // Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared. */
export class VkClearColorValue {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkClearColorValue.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/** // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared. */
export class VkClearValue {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkClearValue.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/** // Union of all the possible return types a counter result could return */
export class VkPerformanceCounterResultKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceCounterResultKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkPerformanceValueDataINTEL {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPerformanceValueDataINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkPipelineExecutableStatisticValueKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkPipelineExecutableStatisticValueKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkDeviceOrHostAddressKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceOrHostAddressKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkDeviceOrHostAddressConstKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDeviceOrHostAddressConstKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkAccelerationStructureGeometryDataKHR {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureGeometryDataKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkDescriptorDataEXT {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkDescriptorDataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class VkAccelerationStructureMotionInstanceDataNV {
  static size = 192;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < VkAccelerationStructureMotionInstanceDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/// FFI Library
const lib = Deno.dlopen("vulkan-1", {
  "vkCreateInstance": {
    "parameters": [
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyInstance": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumeratePhysicalDevices": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceProcAddr": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "function"
  },
  "vkGetInstanceProcAddr": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "function"
  },
  "vkGetPhysicalDeviceProperties": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceQueueFamilyProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceMemoryProperties": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFeatures": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceImageFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateDevice": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDevice": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumerateInstanceVersion": {
    "parameters": [
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateInstanceLayerProperties": {
    "parameters": [
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateInstanceExtensionProperties": {
    "parameters": [
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateDeviceLayerProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateDeviceExtensionProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceQueue": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueSubmit": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkQueueWaitIdle": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkDeviceWaitIdle": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkAllocateMemory": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkMapMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkUnmapMemory": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "void"
  },
  "vkFlushMappedMemoryRanges": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkInvalidateMappedMemoryRanges": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceMemoryCommitment": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetBufferMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindBufferMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetImageMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindImageMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetImageSparseMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceSparseImageFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueBindSparse": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCreateFence": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyFence": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetFences": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetFenceStatus": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkWaitForFences": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "u64"
    ],
    "result": "u32"
  },
  "vkCreateSemaphore": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySemaphore": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateEvent": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetEventStatus": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkSetEvent": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkResetEvent": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCreateQueryPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetQueryPoolResults": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "usize",
      "buffer",
      "u64",
      "u32"
    ],
    "result": "u32"
  },
  "vkResetQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCreateBuffer": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateBufferView": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyBufferView": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateImage": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyImage": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageSubresourceLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateImageView": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyImageView": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateShaderModule": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyShaderModule": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreatePipelineCache": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipelineCache": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPipelineCacheData": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkMergePipelineCaches": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateGraphicsPipelines": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateComputePipelines": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipeline": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreatePipelineLayout": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipelineLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateSampler": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySampler": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateDescriptorSetLayout": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorSetLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateDescriptorPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetDescriptorPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkAllocateDescriptorSets": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeDescriptorSets": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkUpdateDescriptorSets": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateFramebuffer": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyFramebuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateRenderPass": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyRenderPass": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetRenderAreaGranularity": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateCommandPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkAllocateCommandBuffers": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeCommandBuffers": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkBeginCommandBuffer": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEndCommandBuffer": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkResetCommandBuffer": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkCmdBindPipeline": {
    "parameters": [
      "pointer",
      "u32",
      "pointer"
    ],
    "result": "void"
  },
  "vkCmdSetViewport": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetScissor": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetLineWidth": {
    "parameters": [
      "pointer",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBias": {
    "parameters": [
      "pointer",
      "f32",
      "f32",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetBlendConstants": {
    "parameters": [
      "pointer",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBounds": {
    "parameters": [
      "pointer",
      "f32",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilCompareMask": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilWriteMask": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilReference": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBindDescriptorSets": {
    "parameters": [
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBindIndexBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBindVertexBuffers": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdDraw": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexed": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "i32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexedIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatch": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatchIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "void"
  },
  "vkCmdCopyBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBlitImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdCopyBufferToImage": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImageToBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdUpdateBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdFillBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdClearColorImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdClearDepthStencilImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdClearAttachments": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResolveImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdResetEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdWaitEvents": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdPipelineBarrier": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBeginQuery": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdEndQuery": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdResetQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdWriteTimestamp": {
    "parameters": [
      "pointer",
      "u32",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdCopyQueryPoolResults": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "pointer",
      "u64",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdPushConstants": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBeginRenderPass": {
    "parameters": [
      "pointer",
      "buffer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdNextSubpass": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdEndRenderPass": {
    "parameters": [
      "pointer"
    ],
    "result": "void"
  },
  "vkCmdExecuteCommands": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateSwapchainKHR": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceFeatures2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceProperties2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFormatProperties2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceImageFormatProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceQueueFamilyProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceMemoryProperties2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceSparseImageFormatProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkTrimCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalBufferProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalSemaphoreProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalFenceProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumeratePhysicalDeviceGroups": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceGroupPeerMemoryFeatures": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindBufferMemory2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkBindImageMemory2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdSetDeviceMask": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatchBase": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCreateDescriptorUpdateTemplate": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorUpdateTemplate": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkUpdateDescriptorSetWithTemplate": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetBufferMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageSparseMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceBufferMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceImageMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceImageSparseMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateSamplerYcbcrConversion": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySamplerYcbcrConversion": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceQueue2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDescriptorSetLayoutSupport": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateRenderPass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdBeginRenderPass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdNextSubpass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdEndRenderPass2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetSemaphoreCounterValue": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkWaitSemaphores": {
    "parameters": [
      "pointer",
      "buffer",
      "u64"
    ],
    "result": "u32"
  },
  "vkSignalSemaphore": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdDrawIndirectCount": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexedIndirectCount": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkGetBufferOpaqueCaptureAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetBufferDeviceAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetDeviceMemoryOpaqueCaptureAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetPhysicalDeviceToolProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdSetCullMode": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetFrontFace": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetPrimitiveTopology": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetViewportWithCount": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetScissorWithCount": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBindVertexBuffers2": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetDepthTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthWriteEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthCompareOp": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBoundsTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilOp": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetRasterizerDiscardEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBiasEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetPrimitiveRestartEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCreatePrivateDataSlot": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPrivateDataSlot": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkSetPrivateData": {
    "parameters": [
      "pointer",
      "u32",
      "u64",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetPrivateData": {
    "parameters": [
      "pointer",
      "u32",
      "u64",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyBuffer2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBlitImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyBufferToImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImageToBuffer2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResolveImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetEvent2": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResetEvent2": {
    "parameters": [
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "void"
  },
  "vkCmdWaitEvents2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdPipelineBarrier2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueSubmit2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCmdWriteTimestamp2": {
    "parameters": [
      "pointer",
      "u64",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBeginRendering": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdEndRendering": {
    "parameters": [
      "pointer"
    ],
    "result": "void"
  },
} as const).symbols;

/// Commands

export function vkCreateInstance(
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pInstance: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateInstance(
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pInstance === null ? null : pInstance instanceof Uint8Array ? pInstance : pInstance[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyInstance(
  instance: VkInstance,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyInstance(
    instance,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkEnumeratePhysicalDevices(
  instance: VkInstance,
  pPhysicalDeviceCount: IVkStructure | Uint8Array | null,
  pPhysicalDevices: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumeratePhysicalDevices(
    instance,
    pPhysicalDeviceCount === null ? null : pPhysicalDeviceCount instanceof Uint8Array ? pPhysicalDeviceCount : pPhysicalDeviceCount[BUFFER],
    pPhysicalDevices === null ? null : pPhysicalDevices instanceof Uint8Array ? pPhysicalDevices : pPhysicalDevices[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetDeviceProcAddr(
  device: VkDevice,
  pName: IVkStructure | Uint8Array,
) : Deno.PointerValue {
  const ret = lib.vkGetDeviceProcAddr(
    device,
    pName === null ? null : pName instanceof Uint8Array ? pName : pName[BUFFER],
  );
  return ret;
}

export function vkGetInstanceProcAddr(
  instance: VkInstance,
  pName: IVkStructure | Uint8Array,
) : Deno.PointerValue {
  const ret = lib.vkGetInstanceProcAddr(
    instance,
    pName === null ? null : pName instanceof Uint8Array ? pName : pName[BUFFER],
  );
  return ret;
}

export function vkGetPhysicalDeviceProperties(
  physicalDevice: VkPhysicalDevice,
  pProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceProperties(
    physicalDevice,
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceQueueFamilyProperties(
  physicalDevice: VkPhysicalDevice,
  pQueueFamilyPropertyCount: IVkStructure | Uint8Array | null,
  pQueueFamilyProperties: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice,
    pQueueFamilyPropertyCount === null ? null : pQueueFamilyPropertyCount instanceof Uint8Array ? pQueueFamilyPropertyCount : pQueueFamilyPropertyCount[BUFFER],
    pQueueFamilyProperties === null ? null : pQueueFamilyProperties instanceof Uint8Array ? pQueueFamilyProperties : pQueueFamilyProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceMemoryProperties(
  physicalDevice: VkPhysicalDevice,
  pMemoryProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceMemoryProperties(
    physicalDevice,
    pMemoryProperties === null ? null : pMemoryProperties instanceof Uint8Array ? pMemoryProperties : pMemoryProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceFeatures(
  physicalDevice: VkPhysicalDevice,
  pFeatures: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceFeatures(
    physicalDevice,
    pFeatures === null ? null : pFeatures instanceof Uint8Array ? pFeatures : pFeatures[BUFFER],
  );
}

export function vkGetPhysicalDeviceFormatProperties(
  physicalDevice: VkPhysicalDevice,
  format: VkFormat,
  pFormatProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceFormatProperties(
    physicalDevice,
    format,
    pFormatProperties === null ? null : pFormatProperties instanceof Uint8Array ? pFormatProperties : pFormatProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceImageFormatProperties(
  physicalDevice: VkPhysicalDevice,
  format: VkFormat,
  type: VkImageType,
  tiling: VkImageTiling,
  usage: VkImageUsageFlags,
  flags: VkImageCreateFlags,
  pImageFormatProperties: IVkStructure | Uint8Array,
) {
  const ret = lib.vkGetPhysicalDeviceImageFormatProperties(
    physicalDevice,
    format,
    type,
    tiling,
    usage,
    flags,
    pImageFormatProperties === null ? null : pImageFormatProperties instanceof Uint8Array ? pImageFormatProperties : pImageFormatProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateDevice(
  physicalDevice: VkPhysicalDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pDevice: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateDevice(
    physicalDevice,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pDevice === null ? null : pDevice instanceof Uint8Array ? pDevice : pDevice[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyDevice(
  device: VkDevice,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyDevice(
    device,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkEnumerateInstanceVersion(
  pApiVersion: IVkStructure | Uint8Array,
) {
  const ret = lib.vkEnumerateInstanceVersion(
    pApiVersion === null ? null : pApiVersion instanceof Uint8Array ? pApiVersion : pApiVersion[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkEnumerateInstanceLayerProperties(
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumerateInstanceLayerProperties(
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkEnumerateInstanceExtensionProperties(
  pLayerName: IVkStructure | Uint8Array | null,
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumerateInstanceExtensionProperties(
    pLayerName === null ? null : pLayerName instanceof Uint8Array ? pLayerName : pLayerName[BUFFER],
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkEnumerateDeviceLayerProperties(
  physicalDevice: VkPhysicalDevice,
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumerateDeviceLayerProperties(
    physicalDevice,
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkEnumerateDeviceExtensionProperties(
  physicalDevice: VkPhysicalDevice,
  pLayerName: IVkStructure | Uint8Array | null,
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumerateDeviceExtensionProperties(
    physicalDevice,
    pLayerName === null ? null : pLayerName instanceof Uint8Array ? pLayerName : pLayerName[BUFFER],
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetDeviceQueue(
  device: VkDevice,
  queueFamilyIndex: number,
  queueIndex: number,
  pQueue: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceQueue(
    device,
    queueFamilyIndex,
    queueIndex,
    pQueue === null ? null : pQueue instanceof Uint8Array ? pQueue : pQueue[BUFFER],
  );
}

export function vkQueueSubmit(
  queue: VkQueue,
  submitCount: number,
  pSubmits: IVkStructure | Uint8Array,
  fence: VkFence,
) {
  const ret = lib.vkQueueSubmit(
    queue,
    submitCount,
    pSubmits === null ? null : pSubmits instanceof Uint8Array ? pSubmits : pSubmits[BUFFER],
    fence,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkQueueWaitIdle(
  queue: VkQueue,
) {
  const ret = lib.vkQueueWaitIdle(
    queue,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDeviceWaitIdle(
  device: VkDevice,
) {
  const ret = lib.vkDeviceWaitIdle(
    device,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkAllocateMemory(
  device: VkDevice,
  pAllocateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pMemory: IVkStructure | Uint8Array,
) {
  const ret = lib.vkAllocateMemory(
    device,
    pAllocateInfo === null ? null : pAllocateInfo instanceof Uint8Array ? pAllocateInfo : pAllocateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pMemory === null ? null : pMemory instanceof Uint8Array ? pMemory : pMemory[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkFreeMemory(
  device: VkDevice,
  memory: VkDeviceMemory,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkFreeMemory(
    device,
    memory,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkMapMemory(
  device: VkDevice,
  memory: VkDeviceMemory,
  offset: VkDeviceSize,
  size: VkDeviceSize,
  flags: VkMemoryMapFlags,
  ppData: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkMapMemory(
    device,
    memory,
    offset,
    size,
    flags,
    ppData === null ? null : ppData instanceof Uint8Array ? ppData : ppData[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkUnmapMemory(
  device: VkDevice,
  memory: VkDeviceMemory,
) : void {
  lib.vkUnmapMemory(
    device,
    memory,
  );
}

export function vkFlushMappedMemoryRanges(
  device: VkDevice,
  memoryRangeCount: number,
  pMemoryRanges: IVkStructure | Uint8Array,
) {
  const ret = lib.vkFlushMappedMemoryRanges(
    device,
    memoryRangeCount,
    pMemoryRanges === null ? null : pMemoryRanges instanceof Uint8Array ? pMemoryRanges : pMemoryRanges[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkInvalidateMappedMemoryRanges(
  device: VkDevice,
  memoryRangeCount: number,
  pMemoryRanges: IVkStructure | Uint8Array,
) {
  const ret = lib.vkInvalidateMappedMemoryRanges(
    device,
    memoryRangeCount,
    pMemoryRanges === null ? null : pMemoryRanges instanceof Uint8Array ? pMemoryRanges : pMemoryRanges[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetDeviceMemoryCommitment(
  device: VkDevice,
  memory: VkDeviceMemory,
  pCommittedMemoryInBytes: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceMemoryCommitment(
    device,
    memory,
    pCommittedMemoryInBytes === null ? null : pCommittedMemoryInBytes instanceof Uint8Array ? pCommittedMemoryInBytes : pCommittedMemoryInBytes[BUFFER],
  );
}

export function vkGetBufferMemoryRequirements(
  device: VkDevice,
  buffer: VkBuffer,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetBufferMemoryRequirements(
    device,
    buffer,
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkBindBufferMemory(
  device: VkDevice,
  buffer: VkBuffer,
  memory: VkDeviceMemory,
  memoryOffset: VkDeviceSize,
) {
  const ret = lib.vkBindBufferMemory(
    device,
    buffer,
    memory,
    memoryOffset,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetImageMemoryRequirements(
  device: VkDevice,
  image: VkImage,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetImageMemoryRequirements(
    device,
    image,
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkBindImageMemory(
  device: VkDevice,
  image: VkImage,
  memory: VkDeviceMemory,
  memoryOffset: VkDeviceSize,
) {
  const ret = lib.vkBindImageMemory(
    device,
    image,
    memory,
    memoryOffset,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetImageSparseMemoryRequirements(
  device: VkDevice,
  image: VkImage,
  pSparseMemoryRequirementCount: IVkStructure | Uint8Array | null,
  pSparseMemoryRequirements: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetImageSparseMemoryRequirements(
    device,
    image,
    pSparseMemoryRequirementCount === null ? null : pSparseMemoryRequirementCount instanceof Uint8Array ? pSparseMemoryRequirementCount : pSparseMemoryRequirementCount[BUFFER],
    pSparseMemoryRequirements === null ? null : pSparseMemoryRequirements instanceof Uint8Array ? pSparseMemoryRequirements : pSparseMemoryRequirements[BUFFER],
  );
}

export function vkGetPhysicalDeviceSparseImageFormatProperties(
  physicalDevice: VkPhysicalDevice,
  format: VkFormat,
  type: VkImageType,
  samples: VkSampleCountFlagBits,
  usage: VkImageUsageFlags,
  tiling: VkImageTiling,
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetPhysicalDeviceSparseImageFormatProperties(
    physicalDevice,
    format,
    type,
    samples,
    usage,
    tiling,
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
}

export function vkQueueBindSparse(
  queue: VkQueue,
  bindInfoCount: number,
  pBindInfo: IVkStructure | Uint8Array,
  fence: VkFence,
) {
  const ret = lib.vkQueueBindSparse(
    queue,
    bindInfoCount,
    pBindInfo === null ? null : pBindInfo instanceof Uint8Array ? pBindInfo : pBindInfo[BUFFER],
    fence,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateFence(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pFence: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateFence(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pFence === null ? null : pFence instanceof Uint8Array ? pFence : pFence[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyFence(
  device: VkDevice,
  fence: VkFence,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyFence(
    device,
    fence,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkResetFences(
  device: VkDevice,
  fenceCount: number,
  pFences: IVkStructure | Uint8Array,
) {
  const ret = lib.vkResetFences(
    device,
    fenceCount,
    pFences === null ? null : pFences instanceof Uint8Array ? pFences : pFences[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetFenceStatus(
  device: VkDevice,
  fence: VkFence,
) {
  const ret = lib.vkGetFenceStatus(
    device,
    fence,
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_NOT_READY) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkWaitForFences(
  device: VkDevice,
  fenceCount: number,
  pFences: IVkStructure | Uint8Array,
  waitAll: VkBool32,
  timeout: Deno.PointerValue,
) {
  const ret = lib.vkWaitForFences(
    device,
    fenceCount,
    pFences === null ? null : pFences instanceof Uint8Array ? pFences : pFences[BUFFER],
    waitAll,
    timeout,
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_TIMEOUT) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateSemaphore(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pSemaphore: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateSemaphore(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pSemaphore === null ? null : pSemaphore instanceof Uint8Array ? pSemaphore : pSemaphore[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroySemaphore(
  device: VkDevice,
  semaphore: VkSemaphore,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroySemaphore(
    device,
    semaphore,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateEvent(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pEvent: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateEvent(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pEvent === null ? null : pEvent instanceof Uint8Array ? pEvent : pEvent[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyEvent(
  device: VkDevice,
  event: VkEvent,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyEvent(
    device,
    event,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetEventStatus(
  device: VkDevice,
  event: VkEvent,
) {
  const ret = lib.vkGetEventStatus(
    device,
    event,
  );
  if (ret === VkResult.VK_EVENT_SET || ret === VkResult.VK_EVENT_RESET) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkSetEvent(
  device: VkDevice,
  event: VkEvent,
) {
  const ret = lib.vkSetEvent(
    device,
    event,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkResetEvent(
  device: VkDevice,
  event: VkEvent,
) {
  const ret = lib.vkResetEvent(
    device,
    event,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateQueryPool(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pQueryPool: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateQueryPool(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pQueryPool === null ? null : pQueryPool instanceof Uint8Array ? pQueryPool : pQueryPool[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyQueryPool(
  device: VkDevice,
  queryPool: VkQueryPool,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyQueryPool(
    device,
    queryPool,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetQueryPoolResults(
  device: VkDevice,
  queryPool: VkQueryPool,
  firstQuery: number,
  queryCount: number,
  dataSize: Deno.PointerValue,
  pData: IVkStructure | Uint8Array,
  stride: VkDeviceSize,
  flags: VkQueryResultFlags,
) {
  const ret = lib.vkGetQueryPoolResults(
    device,
    queryPool,
    firstQuery,
    queryCount,
    dataSize,
    pData === null ? null : pData instanceof Uint8Array ? pData : pData[BUFFER],
    stride,
    flags,
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_NOT_READY) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkResetQueryPool(
  device: VkDevice,
  queryPool: VkQueryPool,
  firstQuery: number,
  queryCount: number,
) : void {
  lib.vkResetQueryPool(
    device,
    queryPool,
    firstQuery,
    queryCount,
  );
}

export function vkCreateBuffer(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pBuffer: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateBuffer(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pBuffer === null ? null : pBuffer instanceof Uint8Array ? pBuffer : pBuffer[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyBuffer(
  device: VkDevice,
  buffer: VkBuffer,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyBuffer(
    device,
    buffer,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateBufferView(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pView: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateBufferView(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pView === null ? null : pView instanceof Uint8Array ? pView : pView[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyBufferView(
  device: VkDevice,
  bufferView: VkBufferView,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyBufferView(
    device,
    bufferView,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateImage(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pImage: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateImage(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pImage === null ? null : pImage instanceof Uint8Array ? pImage : pImage[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyImage(
  device: VkDevice,
  image: VkImage,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyImage(
    device,
    image,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetImageSubresourceLayout(
  device: VkDevice,
  image: VkImage,
  pSubresource: IVkStructure | Uint8Array,
  pLayout: IVkStructure | Uint8Array,
) : void {
  lib.vkGetImageSubresourceLayout(
    device,
    image,
    pSubresource === null ? null : pSubresource instanceof Uint8Array ? pSubresource : pSubresource[BUFFER],
    pLayout === null ? null : pLayout instanceof Uint8Array ? pLayout : pLayout[BUFFER],
  );
}

export function vkCreateImageView(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pView: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateImageView(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pView === null ? null : pView instanceof Uint8Array ? pView : pView[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyImageView(
  device: VkDevice,
  imageView: VkImageView,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyImageView(
    device,
    imageView,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateShaderModule(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pShaderModule: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateShaderModule(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pShaderModule === null ? null : pShaderModule instanceof Uint8Array ? pShaderModule : pShaderModule[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyShaderModule(
  device: VkDevice,
  shaderModule: VkShaderModule,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyShaderModule(
    device,
    shaderModule,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreatePipelineCache(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pPipelineCache: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreatePipelineCache(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pPipelineCache === null ? null : pPipelineCache instanceof Uint8Array ? pPipelineCache : pPipelineCache[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyPipelineCache(
  device: VkDevice,
  pipelineCache: VkPipelineCache,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyPipelineCache(
    device,
    pipelineCache,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetPipelineCacheData(
  device: VkDevice,
  pipelineCache: VkPipelineCache,
  pDataSize: IVkStructure | Uint8Array | null,
  pData: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkGetPipelineCacheData(
    device,
    pipelineCache,
    pDataSize === null ? null : pDataSize instanceof Uint8Array ? pDataSize : pDataSize[BUFFER],
    pData === null ? null : pData instanceof Uint8Array ? pData : pData[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkMergePipelineCaches(
  device: VkDevice,
  dstCache: VkPipelineCache,
  srcCacheCount: number,
  pSrcCaches: IVkStructure | Uint8Array,
) {
  const ret = lib.vkMergePipelineCaches(
    device,
    dstCache,
    srcCacheCount,
    pSrcCaches === null ? null : pSrcCaches instanceof Uint8Array ? pSrcCaches : pSrcCaches[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateGraphicsPipelines(
  device: VkDevice,
  pipelineCache: VkPipelineCache,
  createInfoCount: number,
  pCreateInfos: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pPipelines: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateGraphicsPipelines(
    device,
    pipelineCache,
    createInfoCount,
    pCreateInfos === null ? null : pCreateInfos instanceof Uint8Array ? pCreateInfos : pCreateInfos[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pPipelines === null ? null : pPipelines instanceof Uint8Array ? pPipelines : pPipelines[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_PIPELINE_COMPILE_REQUIRED_EXT) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCreateComputePipelines(
  device: VkDevice,
  pipelineCache: VkPipelineCache,
  createInfoCount: number,
  pCreateInfos: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pPipelines: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateComputePipelines(
    device,
    pipelineCache,
    createInfoCount,
    pCreateInfos === null ? null : pCreateInfos instanceof Uint8Array ? pCreateInfos : pCreateInfos[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pPipelines === null ? null : pPipelines instanceof Uint8Array ? pPipelines : pPipelines[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_PIPELINE_COMPILE_REQUIRED_EXT) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyPipeline(
  device: VkDevice,
  pipeline: VkPipeline,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyPipeline(
    device,
    pipeline,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreatePipelineLayout(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pPipelineLayout: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreatePipelineLayout(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pPipelineLayout === null ? null : pPipelineLayout instanceof Uint8Array ? pPipelineLayout : pPipelineLayout[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyPipelineLayout(
  device: VkDevice,
  pipelineLayout: VkPipelineLayout,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyPipelineLayout(
    device,
    pipelineLayout,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateSampler(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pSampler: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateSampler(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pSampler === null ? null : pSampler instanceof Uint8Array ? pSampler : pSampler[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroySampler(
  device: VkDevice,
  sampler: VkSampler,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroySampler(
    device,
    sampler,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateDescriptorSetLayout(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pSetLayout: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateDescriptorSetLayout(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pSetLayout === null ? null : pSetLayout instanceof Uint8Array ? pSetLayout : pSetLayout[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyDescriptorSetLayout(
  device: VkDevice,
  descriptorSetLayout: VkDescriptorSetLayout,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyDescriptorSetLayout(
    device,
    descriptorSetLayout,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateDescriptorPool(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pDescriptorPool: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateDescriptorPool(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pDescriptorPool === null ? null : pDescriptorPool instanceof Uint8Array ? pDescriptorPool : pDescriptorPool[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyDescriptorPool(
  device: VkDevice,
  descriptorPool: VkDescriptorPool,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyDescriptorPool(
    device,
    descriptorPool,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkResetDescriptorPool(
  device: VkDevice,
  descriptorPool: VkDescriptorPool,
  flags: VkDescriptorPoolResetFlags,
) {
  const ret = lib.vkResetDescriptorPool(
    device,
    descriptorPool,
    flags,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkAllocateDescriptorSets(
  device: VkDevice,
  pAllocateInfo: IVkStructure | Uint8Array,
  pDescriptorSets: IVkStructure | Uint8Array,
) {
  const ret = lib.vkAllocateDescriptorSets(
    device,
    pAllocateInfo === null ? null : pAllocateInfo instanceof Uint8Array ? pAllocateInfo : pAllocateInfo[BUFFER],
    pDescriptorSets === null ? null : pDescriptorSets instanceof Uint8Array ? pDescriptorSets : pDescriptorSets[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkFreeDescriptorSets(
  device: VkDevice,
  descriptorPool: VkDescriptorPool,
  descriptorSetCount: number,
  pDescriptorSets: IVkStructure | Uint8Array,
) {
  const ret = lib.vkFreeDescriptorSets(
    device,
    descriptorPool,
    descriptorSetCount,
    pDescriptorSets === null ? null : pDescriptorSets instanceof Uint8Array ? pDescriptorSets : pDescriptorSets[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkUpdateDescriptorSets(
  device: VkDevice,
  descriptorWriteCount: number,
  pDescriptorWrites: IVkStructure | Uint8Array,
  descriptorCopyCount: number,
  pDescriptorCopies: IVkStructure | Uint8Array,
) : void {
  lib.vkUpdateDescriptorSets(
    device,
    descriptorWriteCount,
    pDescriptorWrites === null ? null : pDescriptorWrites instanceof Uint8Array ? pDescriptorWrites : pDescriptorWrites[BUFFER],
    descriptorCopyCount,
    pDescriptorCopies === null ? null : pDescriptorCopies instanceof Uint8Array ? pDescriptorCopies : pDescriptorCopies[BUFFER],
  );
}

export function vkCreateFramebuffer(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pFramebuffer: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateFramebuffer(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pFramebuffer === null ? null : pFramebuffer instanceof Uint8Array ? pFramebuffer : pFramebuffer[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyFramebuffer(
  device: VkDevice,
  framebuffer: VkFramebuffer,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyFramebuffer(
    device,
    framebuffer,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkCreateRenderPass(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pRenderPass: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateRenderPass(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pRenderPass === null ? null : pRenderPass instanceof Uint8Array ? pRenderPass : pRenderPass[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyRenderPass(
  device: VkDevice,
  renderPass: VkRenderPass,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyRenderPass(
    device,
    renderPass,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetRenderAreaGranularity(
  device: VkDevice,
  renderPass: VkRenderPass,
  pGranularity: IVkStructure | Uint8Array,
) : void {
  lib.vkGetRenderAreaGranularity(
    device,
    renderPass,
    pGranularity === null ? null : pGranularity instanceof Uint8Array ? pGranularity : pGranularity[BUFFER],
  );
}

export function vkCreateCommandPool(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pCommandPool: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateCommandPool(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pCommandPool === null ? null : pCommandPool instanceof Uint8Array ? pCommandPool : pCommandPool[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyCommandPool(
  device: VkDevice,
  commandPool: VkCommandPool,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyCommandPool(
    device,
    commandPool,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkResetCommandPool(
  device: VkDevice,
  commandPool: VkCommandPool,
  flags: VkCommandPoolResetFlags,
) {
  const ret = lib.vkResetCommandPool(
    device,
    commandPool,
    flags,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkAllocateCommandBuffers(
  device: VkDevice,
  pAllocateInfo: IVkStructure | Uint8Array,
  pCommandBuffers: IVkStructure | Uint8Array,
) {
  const ret = lib.vkAllocateCommandBuffers(
    device,
    pAllocateInfo === null ? null : pAllocateInfo instanceof Uint8Array ? pAllocateInfo : pAllocateInfo[BUFFER],
    pCommandBuffers === null ? null : pCommandBuffers instanceof Uint8Array ? pCommandBuffers : pCommandBuffers[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkFreeCommandBuffers(
  device: VkDevice,
  commandPool: VkCommandPool,
  commandBufferCount: number,
  pCommandBuffers: IVkStructure | Uint8Array,
) : void {
  lib.vkFreeCommandBuffers(
    device,
    commandPool,
    commandBufferCount,
    pCommandBuffers === null ? null : pCommandBuffers instanceof Uint8Array ? pCommandBuffers : pCommandBuffers[BUFFER],
  );
}

export function vkBeginCommandBuffer(
  commandBuffer: VkCommandBuffer,
  pBeginInfo: IVkStructure | Uint8Array,
) {
  const ret = lib.vkBeginCommandBuffer(
    commandBuffer,
    pBeginInfo === null ? null : pBeginInfo instanceof Uint8Array ? pBeginInfo : pBeginInfo[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkEndCommandBuffer(
  commandBuffer: VkCommandBuffer,
) {
  const ret = lib.vkEndCommandBuffer(
    commandBuffer,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkResetCommandBuffer(
  commandBuffer: VkCommandBuffer,
  flags: VkCommandBufferResetFlags,
) {
  const ret = lib.vkResetCommandBuffer(
    commandBuffer,
    flags,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdBindPipeline(
  commandBuffer: VkCommandBuffer,
  pipelineBindPoint: VkPipelineBindPoint,
  pipeline: VkPipeline,
) : void {
  lib.vkCmdBindPipeline(
    commandBuffer,
    pipelineBindPoint,
    pipeline,
  );
}

export function vkCmdSetViewport(
  commandBuffer: VkCommandBuffer,
  firstViewport: number,
  viewportCount: number,
  pViewports: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdSetViewport(
    commandBuffer,
    firstViewport,
    viewportCount,
    pViewports === null ? null : pViewports instanceof Uint8Array ? pViewports : pViewports[BUFFER],
  );
}

export function vkCmdSetScissor(
  commandBuffer: VkCommandBuffer,
  firstScissor: number,
  scissorCount: number,
  pScissors: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdSetScissor(
    commandBuffer,
    firstScissor,
    scissorCount,
    pScissors === null ? null : pScissors instanceof Uint8Array ? pScissors : pScissors[BUFFER],
  );
}

export function vkCmdSetLineWidth(
  commandBuffer: VkCommandBuffer,
  lineWidth: number,
) : void {
  lib.vkCmdSetLineWidth(
    commandBuffer,
    lineWidth,
  );
}

export function vkCmdSetDepthBias(
  commandBuffer: VkCommandBuffer,
  depthBiasConstantFactor: number,
  depthBiasClamp: number,
  depthBiasSlopeFactor: number,
) : void {
  lib.vkCmdSetDepthBias(
    commandBuffer,
    depthBiasConstantFactor,
    depthBiasClamp,
    depthBiasSlopeFactor,
  );
}

export function vkCmdSetBlendConstants(
  commandBuffer: VkCommandBuffer,
  blendConstants: number,
) : void {
  lib.vkCmdSetBlendConstants(
    commandBuffer,
    blendConstants,
  );
}

export function vkCmdSetDepthBounds(
  commandBuffer: VkCommandBuffer,
  minDepthBounds: number,
  maxDepthBounds: number,
) : void {
  lib.vkCmdSetDepthBounds(
    commandBuffer,
    minDepthBounds,
    maxDepthBounds,
  );
}

export function vkCmdSetStencilCompareMask(
  commandBuffer: VkCommandBuffer,
  faceMask: VkStencilFaceFlags,
  compareMask: number,
) : void {
  lib.vkCmdSetStencilCompareMask(
    commandBuffer,
    faceMask,
    compareMask,
  );
}

export function vkCmdSetStencilWriteMask(
  commandBuffer: VkCommandBuffer,
  faceMask: VkStencilFaceFlags,
  writeMask: number,
) : void {
  lib.vkCmdSetStencilWriteMask(
    commandBuffer,
    faceMask,
    writeMask,
  );
}

export function vkCmdSetStencilReference(
  commandBuffer: VkCommandBuffer,
  faceMask: VkStencilFaceFlags,
  reference: number,
) : void {
  lib.vkCmdSetStencilReference(
    commandBuffer,
    faceMask,
    reference,
  );
}

export function vkCmdBindDescriptorSets(
  commandBuffer: VkCommandBuffer,
  pipelineBindPoint: VkPipelineBindPoint,
  layout: VkPipelineLayout,
  firstSet: number,
  descriptorSetCount: number,
  pDescriptorSets: IVkStructure | Uint8Array | null,
  dynamicOffsetCount: number,
  pDynamicOffsets: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdBindDescriptorSets(
    commandBuffer,
    pipelineBindPoint,
    layout,
    firstSet,
    descriptorSetCount,
    pDescriptorSets === null ? null : pDescriptorSets instanceof Uint8Array ? pDescriptorSets : pDescriptorSets[BUFFER],
    dynamicOffsetCount,
    pDynamicOffsets === null ? null : pDynamicOffsets instanceof Uint8Array ? pDynamicOffsets : pDynamicOffsets[BUFFER],
  );
}

export function vkCmdBindIndexBuffer(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
  indexType: VkIndexType,
) : void {
  lib.vkCmdBindIndexBuffer(
    commandBuffer,
    buffer,
    offset,
    indexType,
  );
}

export function vkCmdBindVertexBuffers(
  commandBuffer: VkCommandBuffer,
  firstBinding: number,
  bindingCount: number,
  pBuffers: IVkStructure | Uint8Array | null,
  pOffsets: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdBindVertexBuffers(
    commandBuffer,
    firstBinding,
    bindingCount,
    pBuffers === null ? null : pBuffers instanceof Uint8Array ? pBuffers : pBuffers[BUFFER],
    pOffsets === null ? null : pOffsets instanceof Uint8Array ? pOffsets : pOffsets[BUFFER],
  );
}

export function vkCmdDraw(
  commandBuffer: VkCommandBuffer,
  vertexCount: number,
  instanceCount: number,
  firstVertex: number,
  firstInstance: number,
) : void {
  lib.vkCmdDraw(
    commandBuffer,
    vertexCount,
    instanceCount,
    firstVertex,
    firstInstance,
  );
}

export function vkCmdDrawIndexed(
  commandBuffer: VkCommandBuffer,
  indexCount: number,
  instanceCount: number,
  firstIndex: number,
  vertexOffset: number,
  firstInstance: number,
) : void {
  lib.vkCmdDrawIndexed(
    commandBuffer,
    indexCount,
    instanceCount,
    firstIndex,
    vertexOffset,
    firstInstance,
  );
}

export function vkCmdDrawIndirect(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
  drawCount: number,
  stride: number,
) : void {
  lib.vkCmdDrawIndirect(
    commandBuffer,
    buffer,
    offset,
    drawCount,
    stride,
  );
}

export function vkCmdDrawIndexedIndirect(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
  drawCount: number,
  stride: number,
) : void {
  lib.vkCmdDrawIndexedIndirect(
    commandBuffer,
    buffer,
    offset,
    drawCount,
    stride,
  );
}

export function vkCmdDispatch(
  commandBuffer: VkCommandBuffer,
  groupCountX: number,
  groupCountY: number,
  groupCountZ: number,
) : void {
  lib.vkCmdDispatch(
    commandBuffer,
    groupCountX,
    groupCountY,
    groupCountZ,
  );
}

export function vkCmdDispatchIndirect(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
) : void {
  lib.vkCmdDispatchIndirect(
    commandBuffer,
    buffer,
    offset,
  );
}

export function vkCmdCopyBuffer(
  commandBuffer: VkCommandBuffer,
  srcBuffer: VkBuffer,
  dstBuffer: VkBuffer,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyBuffer(
    commandBuffer,
    srcBuffer,
    dstBuffer,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
  );
}

export function vkCmdCopyImage(
  commandBuffer: VkCommandBuffer,
  srcImage: VkImage,
  srcImageLayout: VkImageLayout,
  dstImage: VkImage,
  dstImageLayout: VkImageLayout,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
  );
}

export function vkCmdBlitImage(
  commandBuffer: VkCommandBuffer,
  srcImage: VkImage,
  srcImageLayout: VkImageLayout,
  dstImage: VkImage,
  dstImageLayout: VkImageLayout,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
  filter: VkFilter,
) : void {
  lib.vkCmdBlitImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
    filter,
  );
}

export function vkCmdCopyBufferToImage(
  commandBuffer: VkCommandBuffer,
  srcBuffer: VkBuffer,
  dstImage: VkImage,
  dstImageLayout: VkImageLayout,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyBufferToImage(
    commandBuffer,
    srcBuffer,
    dstImage,
    dstImageLayout,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
  );
}

export function vkCmdCopyImageToBuffer(
  commandBuffer: VkCommandBuffer,
  srcImage: VkImage,
  srcImageLayout: VkImageLayout,
  dstBuffer: VkBuffer,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyImageToBuffer(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstBuffer,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
  );
}

export function vkCmdUpdateBuffer(
  commandBuffer: VkCommandBuffer,
  dstBuffer: VkBuffer,
  dstOffset: VkDeviceSize,
  dataSize: VkDeviceSize,
  pData: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdUpdateBuffer(
    commandBuffer,
    dstBuffer,
    dstOffset,
    dataSize,
    pData === null ? null : pData instanceof Uint8Array ? pData : pData[BUFFER],
  );
}

/** transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification */
export function vkCmdFillBuffer(
  commandBuffer: VkCommandBuffer,
  dstBuffer: VkBuffer,
  dstOffset: VkDeviceSize,
  size: VkDeviceSize,
  data: number,
) : void {
  lib.vkCmdFillBuffer(
    commandBuffer,
    dstBuffer,
    dstOffset,
    size,
    data,
  );
}

export function vkCmdClearColorImage(
  commandBuffer: VkCommandBuffer,
  image: VkImage,
  imageLayout: VkImageLayout,
  pColor: IVkStructure | Uint8Array,
  rangeCount: number,
  pRanges: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdClearColorImage(
    commandBuffer,
    image,
    imageLayout,
    pColor === null ? null : pColor instanceof Uint8Array ? pColor : pColor[BUFFER],
    rangeCount,
    pRanges === null ? null : pRanges instanceof Uint8Array ? pRanges : pRanges[BUFFER],
  );
}

export function vkCmdClearDepthStencilImage(
  commandBuffer: VkCommandBuffer,
  image: VkImage,
  imageLayout: VkImageLayout,
  pDepthStencil: IVkStructure | Uint8Array,
  rangeCount: number,
  pRanges: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdClearDepthStencilImage(
    commandBuffer,
    image,
    imageLayout,
    pDepthStencil === null ? null : pDepthStencil instanceof Uint8Array ? pDepthStencil : pDepthStencil[BUFFER],
    rangeCount,
    pRanges === null ? null : pRanges instanceof Uint8Array ? pRanges : pRanges[BUFFER],
  );
}

export function vkCmdClearAttachments(
  commandBuffer: VkCommandBuffer,
  attachmentCount: number,
  pAttachments: IVkStructure | Uint8Array,
  rectCount: number,
  pRects: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdClearAttachments(
    commandBuffer,
    attachmentCount,
    pAttachments === null ? null : pAttachments instanceof Uint8Array ? pAttachments : pAttachments[BUFFER],
    rectCount,
    pRects === null ? null : pRects instanceof Uint8Array ? pRects : pRects[BUFFER],
  );
}

export function vkCmdResolveImage(
  commandBuffer: VkCommandBuffer,
  srcImage: VkImage,
  srcImageLayout: VkImageLayout,
  dstImage: VkImage,
  dstImageLayout: VkImageLayout,
  regionCount: number,
  pRegions: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdResolveImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    pRegions === null ? null : pRegions instanceof Uint8Array ? pRegions : pRegions[BUFFER],
  );
}

export function vkCmdSetEvent(
  commandBuffer: VkCommandBuffer,
  event: VkEvent,
  stageMask: VkPipelineStageFlags,
) : void {
  lib.vkCmdSetEvent(
    commandBuffer,
    event,
    stageMask,
  );
}

export function vkCmdResetEvent(
  commandBuffer: VkCommandBuffer,
  event: VkEvent,
  stageMask: VkPipelineStageFlags,
) : void {
  lib.vkCmdResetEvent(
    commandBuffer,
    event,
    stageMask,
  );
}

export function vkCmdWaitEvents(
  commandBuffer: VkCommandBuffer,
  eventCount: number,
  pEvents: IVkStructure | Uint8Array,
  srcStageMask: VkPipelineStageFlags,
  dstStageMask: VkPipelineStageFlags,
  memoryBarrierCount: number,
  pMemoryBarriers: IVkStructure | Uint8Array,
  bufferMemoryBarrierCount: number,
  pBufferMemoryBarriers: IVkStructure | Uint8Array,
  imageMemoryBarrierCount: number,
  pImageMemoryBarriers: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdWaitEvents(
    commandBuffer,
    eventCount,
    pEvents === null ? null : pEvents instanceof Uint8Array ? pEvents : pEvents[BUFFER],
    srcStageMask,
    dstStageMask,
    memoryBarrierCount,
    pMemoryBarriers === null ? null : pMemoryBarriers instanceof Uint8Array ? pMemoryBarriers : pMemoryBarriers[BUFFER],
    bufferMemoryBarrierCount,
    pBufferMemoryBarriers === null ? null : pBufferMemoryBarriers instanceof Uint8Array ? pBufferMemoryBarriers : pBufferMemoryBarriers[BUFFER],
    imageMemoryBarrierCount,
    pImageMemoryBarriers === null ? null : pImageMemoryBarriers instanceof Uint8Array ? pImageMemoryBarriers : pImageMemoryBarriers[BUFFER],
  );
}

export function vkCmdPipelineBarrier(
  commandBuffer: VkCommandBuffer,
  srcStageMask: VkPipelineStageFlags,
  dstStageMask: VkPipelineStageFlags,
  dependencyFlags: VkDependencyFlags,
  memoryBarrierCount: number,
  pMemoryBarriers: IVkStructure | Uint8Array,
  bufferMemoryBarrierCount: number,
  pBufferMemoryBarriers: IVkStructure | Uint8Array,
  imageMemoryBarrierCount: number,
  pImageMemoryBarriers: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdPipelineBarrier(
    commandBuffer,
    srcStageMask,
    dstStageMask,
    dependencyFlags,
    memoryBarrierCount,
    pMemoryBarriers === null ? null : pMemoryBarriers instanceof Uint8Array ? pMemoryBarriers : pMemoryBarriers[BUFFER],
    bufferMemoryBarrierCount,
    pBufferMemoryBarriers === null ? null : pBufferMemoryBarriers instanceof Uint8Array ? pBufferMemoryBarriers : pBufferMemoryBarriers[BUFFER],
    imageMemoryBarrierCount,
    pImageMemoryBarriers === null ? null : pImageMemoryBarriers instanceof Uint8Array ? pImageMemoryBarriers : pImageMemoryBarriers[BUFFER],
  );
}

export function vkCmdBeginQuery(
  commandBuffer: VkCommandBuffer,
  queryPool: VkQueryPool,
  query: number,
  flags: VkQueryControlFlags,
) : void {
  lib.vkCmdBeginQuery(
    commandBuffer,
    queryPool,
    query,
    flags,
  );
}

export function vkCmdEndQuery(
  commandBuffer: VkCommandBuffer,
  queryPool: VkQueryPool,
  query: number,
) : void {
  lib.vkCmdEndQuery(
    commandBuffer,
    queryPool,
    query,
  );
}

export function vkCmdResetQueryPool(
  commandBuffer: VkCommandBuffer,
  queryPool: VkQueryPool,
  firstQuery: number,
  queryCount: number,
) : void {
  lib.vkCmdResetQueryPool(
    commandBuffer,
    queryPool,
    firstQuery,
    queryCount,
  );
}

export function vkCmdWriteTimestamp(
  commandBuffer: VkCommandBuffer,
  pipelineStage: VkPipelineStageFlagBits,
  queryPool: VkQueryPool,
  query: number,
) : void {
  lib.vkCmdWriteTimestamp(
    commandBuffer,
    pipelineStage,
    queryPool,
    query,
  );
}

export function vkCmdCopyQueryPoolResults(
  commandBuffer: VkCommandBuffer,
  queryPool: VkQueryPool,
  firstQuery: number,
  queryCount: number,
  dstBuffer: VkBuffer,
  dstOffset: VkDeviceSize,
  stride: VkDeviceSize,
  flags: VkQueryResultFlags,
) : void {
  lib.vkCmdCopyQueryPoolResults(
    commandBuffer,
    queryPool,
    firstQuery,
    queryCount,
    dstBuffer,
    dstOffset,
    stride,
    flags,
  );
}

export function vkCmdPushConstants(
  commandBuffer: VkCommandBuffer,
  layout: VkPipelineLayout,
  stageFlags: VkShaderStageFlags,
  offset: number,
  size: number,
  pValues: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdPushConstants(
    commandBuffer,
    layout,
    stageFlags,
    offset,
    size,
    pValues === null ? null : pValues instanceof Uint8Array ? pValues : pValues[BUFFER],
  );
}

export function vkCmdBeginRenderPass(
  commandBuffer: VkCommandBuffer,
  pRenderPassBegin: IVkStructure | Uint8Array,
  contents: VkSubpassContents,
) : void {
  lib.vkCmdBeginRenderPass(
    commandBuffer,
    pRenderPassBegin === null ? null : pRenderPassBegin instanceof Uint8Array ? pRenderPassBegin : pRenderPassBegin[BUFFER],
    contents,
  );
}

export function vkCmdNextSubpass(
  commandBuffer: VkCommandBuffer,
  contents: VkSubpassContents,
) : void {
  lib.vkCmdNextSubpass(
    commandBuffer,
    contents,
  );
}

export function vkCmdEndRenderPass(
  commandBuffer: VkCommandBuffer,
) : void {
  lib.vkCmdEndRenderPass(
    commandBuffer,
  );
}

export function vkCmdExecuteCommands(
  commandBuffer: VkCommandBuffer,
  commandBufferCount: number,
  pCommandBuffers: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdExecuteCommands(
    commandBuffer,
    commandBufferCount,
    pCommandBuffers === null ? null : pCommandBuffers instanceof Uint8Array ? pCommandBuffers : pCommandBuffers[BUFFER],
  );
}

export function vkCreateSwapchainKHR(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pSwapchain: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateSwapchainKHR(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pSwapchain === null ? null : pSwapchain instanceof Uint8Array ? pSwapchain : pSwapchain[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetPhysicalDeviceFeatures2(
  physicalDevice: VkPhysicalDevice,
  pFeatures: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceFeatures2(
    physicalDevice,
    pFeatures === null ? null : pFeatures instanceof Uint8Array ? pFeatures : pFeatures[BUFFER],
  );
}

export function vkGetPhysicalDeviceProperties2(
  physicalDevice: VkPhysicalDevice,
  pProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceProperties2(
    physicalDevice,
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceFormatProperties2(
  physicalDevice: VkPhysicalDevice,
  format: VkFormat,
  pFormatProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceFormatProperties2(
    physicalDevice,
    format,
    pFormatProperties === null ? null : pFormatProperties instanceof Uint8Array ? pFormatProperties : pFormatProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceImageFormatProperties2(
  physicalDevice: VkPhysicalDevice,
  pImageFormatInfo: IVkStructure | Uint8Array,
  pImageFormatProperties: IVkStructure | Uint8Array,
) {
  const ret = lib.vkGetPhysicalDeviceImageFormatProperties2(
    physicalDevice,
    pImageFormatInfo === null ? null : pImageFormatInfo instanceof Uint8Array ? pImageFormatInfo : pImageFormatInfo[BUFFER],
    pImageFormatProperties === null ? null : pImageFormatProperties instanceof Uint8Array ? pImageFormatProperties : pImageFormatProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetPhysicalDeviceQueueFamilyProperties2(
  physicalDevice: VkPhysicalDevice,
  pQueueFamilyPropertyCount: IVkStructure | Uint8Array | null,
  pQueueFamilyProperties: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetPhysicalDeviceQueueFamilyProperties2(
    physicalDevice,
    pQueueFamilyPropertyCount === null ? null : pQueueFamilyPropertyCount instanceof Uint8Array ? pQueueFamilyPropertyCount : pQueueFamilyPropertyCount[BUFFER],
    pQueueFamilyProperties === null ? null : pQueueFamilyProperties instanceof Uint8Array ? pQueueFamilyProperties : pQueueFamilyProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceMemoryProperties2(
  physicalDevice: VkPhysicalDevice,
  pMemoryProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceMemoryProperties2(
    physicalDevice,
    pMemoryProperties === null ? null : pMemoryProperties instanceof Uint8Array ? pMemoryProperties : pMemoryProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceSparseImageFormatProperties2(
  physicalDevice: VkPhysicalDevice,
  pFormatInfo: IVkStructure | Uint8Array,
  pPropertyCount: IVkStructure | Uint8Array | null,
  pProperties: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetPhysicalDeviceSparseImageFormatProperties2(
    physicalDevice,
    pFormatInfo === null ? null : pFormatInfo instanceof Uint8Array ? pFormatInfo : pFormatInfo[BUFFER],
    pPropertyCount === null ? null : pPropertyCount instanceof Uint8Array ? pPropertyCount : pPropertyCount[BUFFER],
    pProperties === null ? null : pProperties instanceof Uint8Array ? pProperties : pProperties[BUFFER],
  );
}

export function vkTrimCommandPool(
  device: VkDevice,
  commandPool: VkCommandPool,
  flags: VkCommandPoolTrimFlags,
) : void {
  lib.vkTrimCommandPool(
    device,
    commandPool,
    flags,
  );
}

export function vkGetPhysicalDeviceExternalBufferProperties(
  physicalDevice: VkPhysicalDevice,
  pExternalBufferInfo: IVkStructure | Uint8Array,
  pExternalBufferProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceExternalBufferProperties(
    physicalDevice,
    pExternalBufferInfo === null ? null : pExternalBufferInfo instanceof Uint8Array ? pExternalBufferInfo : pExternalBufferInfo[BUFFER],
    pExternalBufferProperties === null ? null : pExternalBufferProperties instanceof Uint8Array ? pExternalBufferProperties : pExternalBufferProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceExternalSemaphoreProperties(
  physicalDevice: VkPhysicalDevice,
  pExternalSemaphoreInfo: IVkStructure | Uint8Array,
  pExternalSemaphoreProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceExternalSemaphoreProperties(
    physicalDevice,
    pExternalSemaphoreInfo === null ? null : pExternalSemaphoreInfo instanceof Uint8Array ? pExternalSemaphoreInfo : pExternalSemaphoreInfo[BUFFER],
    pExternalSemaphoreProperties === null ? null : pExternalSemaphoreProperties instanceof Uint8Array ? pExternalSemaphoreProperties : pExternalSemaphoreProperties[BUFFER],
  );
}

export function vkGetPhysicalDeviceExternalFenceProperties(
  physicalDevice: VkPhysicalDevice,
  pExternalFenceInfo: IVkStructure | Uint8Array,
  pExternalFenceProperties: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPhysicalDeviceExternalFenceProperties(
    physicalDevice,
    pExternalFenceInfo === null ? null : pExternalFenceInfo instanceof Uint8Array ? pExternalFenceInfo : pExternalFenceInfo[BUFFER],
    pExternalFenceProperties === null ? null : pExternalFenceProperties instanceof Uint8Array ? pExternalFenceProperties : pExternalFenceProperties[BUFFER],
  );
}

export function vkEnumeratePhysicalDeviceGroups(
  instance: VkInstance,
  pPhysicalDeviceGroupCount: IVkStructure | Uint8Array | null,
  pPhysicalDeviceGroupProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkEnumeratePhysicalDeviceGroups(
    instance,
    pPhysicalDeviceGroupCount === null ? null : pPhysicalDeviceGroupCount instanceof Uint8Array ? pPhysicalDeviceGroupCount : pPhysicalDeviceGroupCount[BUFFER],
    pPhysicalDeviceGroupProperties === null ? null : pPhysicalDeviceGroupProperties instanceof Uint8Array ? pPhysicalDeviceGroupProperties : pPhysicalDeviceGroupProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetDeviceGroupPeerMemoryFeatures(
  device: VkDevice,
  heapIndex: number,
  localDeviceIndex: number,
  remoteDeviceIndex: number,
  pPeerMemoryFeatures: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceGroupPeerMemoryFeatures(
    device,
    heapIndex,
    localDeviceIndex,
    remoteDeviceIndex,
    pPeerMemoryFeatures === null ? null : pPeerMemoryFeatures instanceof Uint8Array ? pPeerMemoryFeatures : pPeerMemoryFeatures[BUFFER],
  );
}

export function vkBindBufferMemory2(
  device: VkDevice,
  bindInfoCount: number,
  pBindInfos: IVkStructure | Uint8Array,
) {
  const ret = lib.vkBindBufferMemory2(
    device,
    bindInfoCount,
    pBindInfos === null ? null : pBindInfos instanceof Uint8Array ? pBindInfos : pBindInfos[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkBindImageMemory2(
  device: VkDevice,
  bindInfoCount: number,
  pBindInfos: IVkStructure | Uint8Array,
) {
  const ret = lib.vkBindImageMemory2(
    device,
    bindInfoCount,
    pBindInfos === null ? null : pBindInfos instanceof Uint8Array ? pBindInfos : pBindInfos[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdSetDeviceMask(
  commandBuffer: VkCommandBuffer,
  deviceMask: number,
) : void {
  lib.vkCmdSetDeviceMask(
    commandBuffer,
    deviceMask,
  );
}

export function vkCmdDispatchBase(
  commandBuffer: VkCommandBuffer,
  baseGroupX: number,
  baseGroupY: number,
  baseGroupZ: number,
  groupCountX: number,
  groupCountY: number,
  groupCountZ: number,
) : void {
  lib.vkCmdDispatchBase(
    commandBuffer,
    baseGroupX,
    baseGroupY,
    baseGroupZ,
    groupCountX,
    groupCountY,
    groupCountZ,
  );
}

export function vkCreateDescriptorUpdateTemplate(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pDescriptorUpdateTemplate: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateDescriptorUpdateTemplate(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pDescriptorUpdateTemplate === null ? null : pDescriptorUpdateTemplate instanceof Uint8Array ? pDescriptorUpdateTemplate : pDescriptorUpdateTemplate[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyDescriptorUpdateTemplate(
  device: VkDevice,
  descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyDescriptorUpdateTemplate(
    device,
    descriptorUpdateTemplate,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkUpdateDescriptorSetWithTemplate(
  device: VkDevice,
  descriptorSet: VkDescriptorSet,
  descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
  pData: IVkStructure | Uint8Array,
) : void {
  lib.vkUpdateDescriptorSetWithTemplate(
    device,
    descriptorSet,
    descriptorUpdateTemplate,
    pData === null ? null : pData instanceof Uint8Array ? pData : pData[BUFFER],
  );
}

export function vkGetBufferMemoryRequirements2(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetBufferMemoryRequirements2(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkGetImageMemoryRequirements2(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetImageMemoryRequirements2(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkGetImageSparseMemoryRequirements2(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pSparseMemoryRequirementCount: IVkStructure | Uint8Array | null,
  pSparseMemoryRequirements: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetImageSparseMemoryRequirements2(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pSparseMemoryRequirementCount === null ? null : pSparseMemoryRequirementCount instanceof Uint8Array ? pSparseMemoryRequirementCount : pSparseMemoryRequirementCount[BUFFER],
    pSparseMemoryRequirements === null ? null : pSparseMemoryRequirements instanceof Uint8Array ? pSparseMemoryRequirements : pSparseMemoryRequirements[BUFFER],
  );
}

export function vkGetDeviceBufferMemoryRequirements(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceBufferMemoryRequirements(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkGetDeviceImageMemoryRequirements(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pMemoryRequirements: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceImageMemoryRequirements(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pMemoryRequirements === null ? null : pMemoryRequirements instanceof Uint8Array ? pMemoryRequirements : pMemoryRequirements[BUFFER],
  );
}

export function vkGetDeviceImageSparseMemoryRequirements(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
  pSparseMemoryRequirementCount: IVkStructure | Uint8Array | null,
  pSparseMemoryRequirements: IVkStructure | Uint8Array | null,
) : void {
  lib.vkGetDeviceImageSparseMemoryRequirements(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
    pSparseMemoryRequirementCount === null ? null : pSparseMemoryRequirementCount instanceof Uint8Array ? pSparseMemoryRequirementCount : pSparseMemoryRequirementCount[BUFFER],
    pSparseMemoryRequirements === null ? null : pSparseMemoryRequirements instanceof Uint8Array ? pSparseMemoryRequirements : pSparseMemoryRequirements[BUFFER],
  );
}

export function vkCreateSamplerYcbcrConversion(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pYcbcrConversion: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateSamplerYcbcrConversion(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pYcbcrConversion === null ? null : pYcbcrConversion instanceof Uint8Array ? pYcbcrConversion : pYcbcrConversion[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroySamplerYcbcrConversion(
  device: VkDevice,
  ycbcrConversion: VkSamplerYcbcrConversion,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroySamplerYcbcrConversion(
    device,
    ycbcrConversion,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkGetDeviceQueue2(
  device: VkDevice,
  pQueueInfo: IVkStructure | Uint8Array,
  pQueue: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDeviceQueue2(
    device,
    pQueueInfo === null ? null : pQueueInfo instanceof Uint8Array ? pQueueInfo : pQueueInfo[BUFFER],
    pQueue === null ? null : pQueue instanceof Uint8Array ? pQueue : pQueue[BUFFER],
  );
}

export function vkGetDescriptorSetLayoutSupport(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pSupport: IVkStructure | Uint8Array,
) : void {
  lib.vkGetDescriptorSetLayoutSupport(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pSupport === null ? null : pSupport instanceof Uint8Array ? pSupport : pSupport[BUFFER],
  );
}

export function vkCreateRenderPass2(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pRenderPass: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreateRenderPass2(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pRenderPass === null ? null : pRenderPass instanceof Uint8Array ? pRenderPass : pRenderPass[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdBeginRenderPass2(
  commandBuffer: VkCommandBuffer,
  pRenderPassBegin: IVkStructure | Uint8Array,
  pSubpassBeginInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdBeginRenderPass2(
    commandBuffer,
    pRenderPassBegin === null ? null : pRenderPassBegin instanceof Uint8Array ? pRenderPassBegin : pRenderPassBegin[BUFFER],
    pSubpassBeginInfo === null ? null : pSubpassBeginInfo instanceof Uint8Array ? pSubpassBeginInfo : pSubpassBeginInfo[BUFFER],
  );
}

export function vkCmdNextSubpass2(
  commandBuffer: VkCommandBuffer,
  pSubpassBeginInfo: IVkStructure | Uint8Array,
  pSubpassEndInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdNextSubpass2(
    commandBuffer,
    pSubpassBeginInfo === null ? null : pSubpassBeginInfo instanceof Uint8Array ? pSubpassBeginInfo : pSubpassBeginInfo[BUFFER],
    pSubpassEndInfo === null ? null : pSubpassEndInfo instanceof Uint8Array ? pSubpassEndInfo : pSubpassEndInfo[BUFFER],
  );
}

export function vkCmdEndRenderPass2(
  commandBuffer: VkCommandBuffer,
  pSubpassEndInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdEndRenderPass2(
    commandBuffer,
    pSubpassEndInfo === null ? null : pSubpassEndInfo instanceof Uint8Array ? pSubpassEndInfo : pSubpassEndInfo[BUFFER],
  );
}

export function vkGetSemaphoreCounterValue(
  device: VkDevice,
  semaphore: VkSemaphore,
  pValue: IVkStructure | Uint8Array,
) {
  const ret = lib.vkGetSemaphoreCounterValue(
    device,
    semaphore,
    pValue === null ? null : pValue instanceof Uint8Array ? pValue : pValue[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkWaitSemaphores(
  device: VkDevice,
  pWaitInfo: IVkStructure | Uint8Array,
  timeout: Deno.PointerValue,
) {
  const ret = lib.vkWaitSemaphores(
    device,
    pWaitInfo === null ? null : pWaitInfo instanceof Uint8Array ? pWaitInfo : pWaitInfo[BUFFER],
    timeout,
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_TIMEOUT) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkSignalSemaphore(
  device: VkDevice,
  pSignalInfo: IVkStructure | Uint8Array,
) {
  const ret = lib.vkSignalSemaphore(
    device,
    pSignalInfo === null ? null : pSignalInfo instanceof Uint8Array ? pSignalInfo : pSignalInfo[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdDrawIndirectCount(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
  countBuffer: VkBuffer,
  countBufferOffset: VkDeviceSize,
  maxDrawCount: number,
  stride: number,
) : void {
  lib.vkCmdDrawIndirectCount(
    commandBuffer,
    buffer,
    offset,
    countBuffer,
    countBufferOffset,
    maxDrawCount,
    stride,
  );
}

export function vkCmdDrawIndexedIndirectCount(
  commandBuffer: VkCommandBuffer,
  buffer: VkBuffer,
  offset: VkDeviceSize,
  countBuffer: VkBuffer,
  countBufferOffset: VkDeviceSize,
  maxDrawCount: number,
  stride: number,
) : void {
  lib.vkCmdDrawIndexedIndirectCount(
    commandBuffer,
    buffer,
    offset,
    countBuffer,
    countBufferOffset,
    maxDrawCount,
    stride,
  );
}

export function vkGetBufferOpaqueCaptureAddress(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
) : Deno.PointerValue {
  const ret = lib.vkGetBufferOpaqueCaptureAddress(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
  );
  return ret;
}

export function vkGetBufferDeviceAddress(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
) : VkDeviceAddress {
  const ret = lib.vkGetBufferDeviceAddress(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
  );
  return ret;
}

export function vkGetDeviceMemoryOpaqueCaptureAddress(
  device: VkDevice,
  pInfo: IVkStructure | Uint8Array,
) : Deno.PointerValue {
  const ret = lib.vkGetDeviceMemoryOpaqueCaptureAddress(
    device,
    pInfo === null ? null : pInfo instanceof Uint8Array ? pInfo : pInfo[BUFFER],
  );
  return ret;
}

export function vkGetPhysicalDeviceToolProperties(
  physicalDevice: VkPhysicalDevice,
  pToolCount: IVkStructure | Uint8Array | null,
  pToolProperties: IVkStructure | Uint8Array | null,
) {
  const ret = lib.vkGetPhysicalDeviceToolProperties(
    physicalDevice,
    pToolCount === null ? null : pToolCount instanceof Uint8Array ? pToolCount : pToolCount[BUFFER],
    pToolProperties === null ? null : pToolProperties instanceof Uint8Array ? pToolProperties : pToolProperties[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS || ret === VkResult.VK_INCOMPLETE) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdSetCullMode(
  commandBuffer: VkCommandBuffer,
  cullMode: VkCullModeFlags,
) : void {
  lib.vkCmdSetCullMode(
    commandBuffer,
    cullMode,
  );
}

export function vkCmdSetFrontFace(
  commandBuffer: VkCommandBuffer,
  frontFace: VkFrontFace,
) : void {
  lib.vkCmdSetFrontFace(
    commandBuffer,
    frontFace,
  );
}

export function vkCmdSetPrimitiveTopology(
  commandBuffer: VkCommandBuffer,
  primitiveTopology: VkPrimitiveTopology,
) : void {
  lib.vkCmdSetPrimitiveTopology(
    commandBuffer,
    primitiveTopology,
  );
}

export function vkCmdSetViewportWithCount(
  commandBuffer: VkCommandBuffer,
  viewportCount: number,
  pViewports: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdSetViewportWithCount(
    commandBuffer,
    viewportCount,
    pViewports === null ? null : pViewports instanceof Uint8Array ? pViewports : pViewports[BUFFER],
  );
}

export function vkCmdSetScissorWithCount(
  commandBuffer: VkCommandBuffer,
  scissorCount: number,
  pScissors: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdSetScissorWithCount(
    commandBuffer,
    scissorCount,
    pScissors === null ? null : pScissors instanceof Uint8Array ? pScissors : pScissors[BUFFER],
  );
}

export function vkCmdBindVertexBuffers2(
  commandBuffer: VkCommandBuffer,
  firstBinding: number,
  bindingCount: number,
  pBuffers: IVkStructure | Uint8Array | null,
  pOffsets: IVkStructure | Uint8Array,
  pSizes: IVkStructure | Uint8Array | null,
  pStrides: IVkStructure | Uint8Array | null,
) : void {
  lib.vkCmdBindVertexBuffers2(
    commandBuffer,
    firstBinding,
    bindingCount,
    pBuffers === null ? null : pBuffers instanceof Uint8Array ? pBuffers : pBuffers[BUFFER],
    pOffsets === null ? null : pOffsets instanceof Uint8Array ? pOffsets : pOffsets[BUFFER],
    pSizes === null ? null : pSizes instanceof Uint8Array ? pSizes : pSizes[BUFFER],
    pStrides === null ? null : pStrides instanceof Uint8Array ? pStrides : pStrides[BUFFER],
  );
}

export function vkCmdSetDepthTestEnable(
  commandBuffer: VkCommandBuffer,
  depthTestEnable: VkBool32,
) : void {
  lib.vkCmdSetDepthTestEnable(
    commandBuffer,
    depthTestEnable,
  );
}

export function vkCmdSetDepthWriteEnable(
  commandBuffer: VkCommandBuffer,
  depthWriteEnable: VkBool32,
) : void {
  lib.vkCmdSetDepthWriteEnable(
    commandBuffer,
    depthWriteEnable,
  );
}

export function vkCmdSetDepthCompareOp(
  commandBuffer: VkCommandBuffer,
  depthCompareOp: VkCompareOp,
) : void {
  lib.vkCmdSetDepthCompareOp(
    commandBuffer,
    depthCompareOp,
  );
}

export function vkCmdSetDepthBoundsTestEnable(
  commandBuffer: VkCommandBuffer,
  depthBoundsTestEnable: VkBool32,
) : void {
  lib.vkCmdSetDepthBoundsTestEnable(
    commandBuffer,
    depthBoundsTestEnable,
  );
}

export function vkCmdSetStencilTestEnable(
  commandBuffer: VkCommandBuffer,
  stencilTestEnable: VkBool32,
) : void {
  lib.vkCmdSetStencilTestEnable(
    commandBuffer,
    stencilTestEnable,
  );
}

export function vkCmdSetStencilOp(
  commandBuffer: VkCommandBuffer,
  faceMask: VkStencilFaceFlags,
  failOp: VkStencilOp,
  passOp: VkStencilOp,
  depthFailOp: VkStencilOp,
  compareOp: VkCompareOp,
) : void {
  lib.vkCmdSetStencilOp(
    commandBuffer,
    faceMask,
    failOp,
    passOp,
    depthFailOp,
    compareOp,
  );
}

export function vkCmdSetRasterizerDiscardEnable(
  commandBuffer: VkCommandBuffer,
  rasterizerDiscardEnable: VkBool32,
) : void {
  lib.vkCmdSetRasterizerDiscardEnable(
    commandBuffer,
    rasterizerDiscardEnable,
  );
}

export function vkCmdSetDepthBiasEnable(
  commandBuffer: VkCommandBuffer,
  depthBiasEnable: VkBool32,
) : void {
  lib.vkCmdSetDepthBiasEnable(
    commandBuffer,
    depthBiasEnable,
  );
}

export function vkCmdSetPrimitiveRestartEnable(
  commandBuffer: VkCommandBuffer,
  primitiveRestartEnable: VkBool32,
) : void {
  lib.vkCmdSetPrimitiveRestartEnable(
    commandBuffer,
    primitiveRestartEnable,
  );
}

export function vkCreatePrivateDataSlot(
  device: VkDevice,
  pCreateInfo: IVkStructure | Uint8Array,
  pAllocator: IVkStructure | Uint8Array | null,
  pPrivateDataSlot: IVkStructure | Uint8Array,
) {
  const ret = lib.vkCreatePrivateDataSlot(
    device,
    pCreateInfo === null ? null : pCreateInfo instanceof Uint8Array ? pCreateInfo : pCreateInfo[BUFFER],
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
    pPrivateDataSlot === null ? null : pPrivateDataSlot instanceof Uint8Array ? pPrivateDataSlot : pPrivateDataSlot[BUFFER],
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkDestroyPrivateDataSlot(
  device: VkDevice,
  privateDataSlot: VkPrivateDataSlot,
  pAllocator: IVkStructure | Uint8Array | null,
) : void {
  lib.vkDestroyPrivateDataSlot(
    device,
    privateDataSlot,
    pAllocator === null ? null : pAllocator instanceof Uint8Array ? pAllocator : pAllocator[BUFFER],
  );
}

export function vkSetPrivateData(
  device: VkDevice,
  objectType: VkObjectType,
  objectHandle: Deno.PointerValue,
  privateDataSlot: VkPrivateDataSlot,
  data: Deno.PointerValue,
) {
  const ret = lib.vkSetPrivateData(
    device,
    objectType,
    objectHandle,
    privateDataSlot,
    data,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkGetPrivateData(
  device: VkDevice,
  objectType: VkObjectType,
  objectHandle: Deno.PointerValue,
  privateDataSlot: VkPrivateDataSlot,
  pData: IVkStructure | Uint8Array,
) : void {
  lib.vkGetPrivateData(
    device,
    objectType,
    objectHandle,
    privateDataSlot,
    pData === null ? null : pData instanceof Uint8Array ? pData : pData[BUFFER],
  );
}

export function vkCmdCopyBuffer2(
  commandBuffer: VkCommandBuffer,
  pCopyBufferInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyBuffer2(
    commandBuffer,
    pCopyBufferInfo === null ? null : pCopyBufferInfo instanceof Uint8Array ? pCopyBufferInfo : pCopyBufferInfo[BUFFER],
  );
}

export function vkCmdCopyImage2(
  commandBuffer: VkCommandBuffer,
  pCopyImageInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyImage2(
    commandBuffer,
    pCopyImageInfo === null ? null : pCopyImageInfo instanceof Uint8Array ? pCopyImageInfo : pCopyImageInfo[BUFFER],
  );
}

export function vkCmdBlitImage2(
  commandBuffer: VkCommandBuffer,
  pBlitImageInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdBlitImage2(
    commandBuffer,
    pBlitImageInfo === null ? null : pBlitImageInfo instanceof Uint8Array ? pBlitImageInfo : pBlitImageInfo[BUFFER],
  );
}

export function vkCmdCopyBufferToImage2(
  commandBuffer: VkCommandBuffer,
  pCopyBufferToImageInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyBufferToImage2(
    commandBuffer,
    pCopyBufferToImageInfo === null ? null : pCopyBufferToImageInfo instanceof Uint8Array ? pCopyBufferToImageInfo : pCopyBufferToImageInfo[BUFFER],
  );
}

export function vkCmdCopyImageToBuffer2(
  commandBuffer: VkCommandBuffer,
  pCopyImageToBufferInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdCopyImageToBuffer2(
    commandBuffer,
    pCopyImageToBufferInfo === null ? null : pCopyImageToBufferInfo instanceof Uint8Array ? pCopyImageToBufferInfo : pCopyImageToBufferInfo[BUFFER],
  );
}

export function vkCmdResolveImage2(
  commandBuffer: VkCommandBuffer,
  pResolveImageInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdResolveImage2(
    commandBuffer,
    pResolveImageInfo === null ? null : pResolveImageInfo instanceof Uint8Array ? pResolveImageInfo : pResolveImageInfo[BUFFER],
  );
}

export function vkCmdSetEvent2(
  commandBuffer: VkCommandBuffer,
  event: VkEvent,
  pDependencyInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdSetEvent2(
    commandBuffer,
    event,
    pDependencyInfo === null ? null : pDependencyInfo instanceof Uint8Array ? pDependencyInfo : pDependencyInfo[BUFFER],
  );
}

export function vkCmdResetEvent2(
  commandBuffer: VkCommandBuffer,
  event: VkEvent,
  stageMask: VkPipelineStageFlags2,
) : void {
  lib.vkCmdResetEvent2(
    commandBuffer,
    event,
    stageMask,
  );
}

export function vkCmdWaitEvents2(
  commandBuffer: VkCommandBuffer,
  eventCount: number,
  pEvents: IVkStructure | Uint8Array,
  pDependencyInfos: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdWaitEvents2(
    commandBuffer,
    eventCount,
    pEvents === null ? null : pEvents instanceof Uint8Array ? pEvents : pEvents[BUFFER],
    pDependencyInfos === null ? null : pDependencyInfos instanceof Uint8Array ? pDependencyInfos : pDependencyInfos[BUFFER],
  );
}

export function vkCmdPipelineBarrier2(
  commandBuffer: VkCommandBuffer,
  pDependencyInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdPipelineBarrier2(
    commandBuffer,
    pDependencyInfo === null ? null : pDependencyInfo instanceof Uint8Array ? pDependencyInfo : pDependencyInfo[BUFFER],
  );
}

export function vkQueueSubmit2(
  queue: VkQueue,
  submitCount: number,
  pSubmits: IVkStructure | Uint8Array,
  fence: VkFence,
) {
  const ret = lib.vkQueueSubmit2(
    queue,
    submitCount,
    pSubmits === null ? null : pSubmits instanceof Uint8Array ? pSubmits : pSubmits[BUFFER],
    fence,
  );
  if (ret === VkResult.VK_SUCCESS) {
    return;
  } else {
    throw new Error("Vulkan Error: " + ret + " (" + VkResult[ret] + ")");
  }
}

export function vkCmdWriteTimestamp2(
  commandBuffer: VkCommandBuffer,
  stage: VkPipelineStageFlags2,
  queryPool: VkQueryPool,
  query: number,
) : void {
  lib.vkCmdWriteTimestamp2(
    commandBuffer,
    stage,
    queryPool,
    query,
  );
}

export function vkCmdBeginRendering(
  commandBuffer: VkCommandBuffer,
  pRenderingInfo: IVkStructure | Uint8Array,
) : void {
  lib.vkCmdBeginRendering(
    commandBuffer,
    pRenderingInfo === null ? null : pRenderingInfo instanceof Uint8Array ? pRenderingInfo : pRenderingInfo[BUFFER],
  );
}

export function vkCmdEndRendering(
  commandBuffer: VkCommandBuffer,
) : void {
  lib.vkCmdEndRendering(
    commandBuffer,
  );
}

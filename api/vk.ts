/// This file is auto-generated. Do not edit.

export const BUFFER = Symbol("vkStructBuffer");
export const DATAVIEW = Symbol("vkStructDataView");
export const LE = new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x78;

export interface BaseStruct {
  readonly [BUFFER]: Uint8Array;
}

export type AnyBuffer = ArrayBuffer | Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array | BigUint64Array | BigInt64Array | null | BaseStruct;

export function anyBuffer(buffer: AnyBuffer) {
  if (!buffer) return null;
  else if (typeof buffer === "object" && BUFFER in buffer) return (buffer as BaseStruct)[BUFFER];
  else if (buffer instanceof Uint8Array) return buffer;
  return new Uint8Array(buffer instanceof ArrayBuffer ? buffer : (buffer as unknown as ArrayBufferView).buffer);
}

export type AnyPointer = Deno.PointerValue | null | AnyBuffer;

export function anyPointer(buffer: AnyPointer): Deno.PointerValue {
  if (!buffer) return 0;
  else if (typeof buffer === "number" || typeof buffer === "bigint") return buffer;
  const u8 = anyBuffer(buffer);
  return u8!.length === 0 ? 0 : Deno.UnsafePointer.of(u8 ?? new Uint8Array());
}

/// Type definitions

export type MTLDevice_id = Deno.PointerValue;

export type MTLCommandQueue_id = Deno.PointerValue;

export type MTLBuffer_id = Deno.PointerValue;

export type MTLTexture_id = Deno.PointerValue;

export type MTLSharedEvent_id = Deno.PointerValue;

export type IOSurfaceRef = Deno.PointerValue;

export type SampleMask = number;

export type Bool32 = number;

export type Flags = number;

export type Flags64 = Deno.PointerValue;

export type DeviceSize = Deno.PointerValue;

export type DeviceAddress = Deno.PointerValue;

export type FramebufferCreateFlags = Flags;

export type QueryPoolCreateFlags = Flags;

export type RenderPassCreateFlags = Flags;

export type SamplerCreateFlags = Flags;

export type PipelineLayoutCreateFlags = Flags;

export type PipelineCacheCreateFlags = Flags;

export type PipelineDepthStencilStateCreateFlags = Flags;

export type PipelineDynamicStateCreateFlags = Flags;

export type PipelineColorBlendStateCreateFlags = Flags;

export type PipelineMultisampleStateCreateFlags = Flags;

export type PipelineRasterizationStateCreateFlags = Flags;

export type PipelineViewportStateCreateFlags = Flags;

export type PipelineTessellationStateCreateFlags = Flags;

export type PipelineInputAssemblyStateCreateFlags = Flags;

export type PipelineVertexInputStateCreateFlags = Flags;

export type PipelineShaderStageCreateFlags = Flags;

export type DescriptorSetLayoutCreateFlags = Flags;

export type BufferViewCreateFlags = Flags;

export type InstanceCreateFlags = Flags;

export type DeviceCreateFlags = Flags;

export type DeviceQueueCreateFlags = Flags;

export type QueueFlags = Flags;

export type MemoryPropertyFlags = Flags;

export type MemoryHeapFlags = Flags;

export type AccessFlags = Flags;

export type BufferUsageFlags = Flags;

export type BufferCreateFlags = Flags;

export type ShaderStageFlags = Flags;

export type ImageUsageFlags = Flags;

export type ImageCreateFlags = Flags;

export type ImageViewCreateFlags = Flags;

export type PipelineCreateFlags = Flags;

export type ColorComponentFlags = Flags;

export type FenceCreateFlags = Flags;

export type SemaphoreCreateFlags = Flags;

export type FormatFeatureFlags = Flags;

export type QueryControlFlags = Flags;

export type QueryResultFlags = Flags;

export type ShaderModuleCreateFlags = Flags;

export type EventCreateFlags = Flags;

export type CommandPoolCreateFlags = Flags;

export type CommandPoolResetFlags = Flags;

export type CommandBufferResetFlags = Flags;

export type CommandBufferUsageFlags = Flags;

export type QueryPipelineStatisticFlags = Flags;

export type MemoryMapFlags = Flags;

export type ImageAspectFlags = Flags;

export type SparseMemoryBindFlags = Flags;

export type SparseImageFormatFlags = Flags;

export type SubpassDescriptionFlags = Flags;

export type PipelineStageFlags = Flags;

export type SampleCountFlags = Flags;

export type AttachmentDescriptionFlags = Flags;

export type StencilFaceFlags = Flags;

export type CullModeFlags = Flags;

export type DescriptorPoolCreateFlags = Flags;

export type DescriptorPoolResetFlags = Flags;

export type DependencyFlags = Flags;

export type SubgroupFeatureFlags = Flags;

export type IndirectCommandsLayoutUsageFlagsNV = Flags;

export type IndirectStateFlagsNV = Flags;

export type GeometryFlagsKHR = Flags;

export type GeometryFlagsNV = GeometryFlagsKHR;

export type GeometryInstanceFlagsKHR = Flags;

export type GeometryInstanceFlagsNV = GeometryInstanceFlagsKHR;

export type BuildAccelerationStructureFlagsKHR = Flags;

export type BuildAccelerationStructureFlagsNV = BuildAccelerationStructureFlagsKHR;

export type PrivateDataSlotCreateFlags = Flags;

export type PrivateDataSlotCreateFlagsEXT = PrivateDataSlotCreateFlags;

export type AccelerationStructureCreateFlagsKHR = Flags;

export type DescriptorUpdateTemplateCreateFlags = Flags;

export type DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;

export type PipelineCreationFeedbackFlags = Flags;

export type PipelineCreationFeedbackFlagsEXT = PipelineCreationFeedbackFlags;

export type PerformanceCounterDescriptionFlagsKHR = Flags;

export type AcquireProfilingLockFlagsKHR = Flags;

export type SemaphoreWaitFlags = Flags;

export type SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;

export type PipelineCompilerControlFlagsAMD = Flags;

export type ShaderCorePropertiesFlagsAMD = Flags;

export type DeviceDiagnosticsConfigFlagsNV = Flags;

export type AccessFlags2 = Flags64;

export type AccessFlags2KHR = AccessFlags2;

export type PipelineStageFlags2 = Flags64;

export type PipelineStageFlags2KHR = PipelineStageFlags2;

export type AccelerationStructureMotionInfoFlagsNV = Flags;

export type AccelerationStructureMotionInstanceFlagsNV = Flags;

export type FormatFeatureFlags2 = Flags64;

export type FormatFeatureFlags2KHR = FormatFeatureFlags2;

export type RenderingFlags = Flags;

export type MemoryDecompressionMethodFlagsNV = Flags64;

export type RenderingFlagsKHR = RenderingFlags;

export type BuildMicromapFlagsEXT = Flags;

export type MicromapCreateFlagsEXT = Flags;

export type CompositeAlphaFlagsKHR = Flags;

export type DisplayPlaneAlphaFlagsKHR = Flags;

export type SurfaceTransformFlagsKHR = Flags;

export type SwapchainCreateFlagsKHR = Flags;

export type DisplayModeCreateFlagsKHR = Flags;

export type DisplaySurfaceCreateFlagsKHR = Flags;

export type AndroidSurfaceCreateFlagsKHR = Flags;

export type ViSurfaceCreateFlagsNN = Flags;

export type WaylandSurfaceCreateFlagsKHR = Flags;

export type Win32SurfaceCreateFlagsKHR = Flags;

export type XlibSurfaceCreateFlagsKHR = Flags;

export type XcbSurfaceCreateFlagsKHR = Flags;

export type DirectFBSurfaceCreateFlagsEXT = Flags;

export type IOSSurfaceCreateFlagsMVK = Flags;

export type MacOSSurfaceCreateFlagsMVK = Flags;

export type MetalSurfaceCreateFlagsEXT = Flags;

export type ImagePipeSurfaceCreateFlagsFUCHSIA = Flags;

export type StreamDescriptorSurfaceCreateFlagsGGP = Flags;

export type HeadlessSurfaceCreateFlagsEXT = Flags;

export type ScreenSurfaceCreateFlagsQNX = Flags;

export type PeerMemoryFeatureFlags = Flags;

export type PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;

export type MemoryAllocateFlags = Flags;

export type MemoryAllocateFlagsKHR = MemoryAllocateFlags;

export type DeviceGroupPresentModeFlagsKHR = Flags;

export type DebugReportFlagsEXT = Flags;

export type CommandPoolTrimFlags = Flags;

export type CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;

export type ExternalMemoryHandleTypeFlagsNV = Flags;

export type ExternalMemoryFeatureFlagsNV = Flags;

export type ExternalMemoryHandleTypeFlags = Flags;

export type ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;

export type ExternalMemoryFeatureFlags = Flags;

export type ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;

export type ExternalSemaphoreHandleTypeFlags = Flags;

export type ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;

export type ExternalSemaphoreFeatureFlags = Flags;

export type ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;

export type SemaphoreImportFlags = Flags;

export type SemaphoreImportFlagsKHR = SemaphoreImportFlags;

export type ExternalFenceHandleTypeFlags = Flags;

export type ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;

export type ExternalFenceFeatureFlags = Flags;

export type ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;

export type FenceImportFlags = Flags;

export type FenceImportFlagsKHR = FenceImportFlags;

export type SurfaceCounterFlagsEXT = Flags;

export type PipelineViewportSwizzleStateCreateFlagsNV = Flags;

export type PipelineDiscardRectangleStateCreateFlagsEXT = Flags;

export type PipelineCoverageToColorStateCreateFlagsNV = Flags;

export type PipelineCoverageModulationStateCreateFlagsNV = Flags;

export type PipelineCoverageReductionStateCreateFlagsNV = Flags;

export type ValidationCacheCreateFlagsEXT = Flags;

export type DebugUtilsMessageSeverityFlagsEXT = Flags;

export type DebugUtilsMessageTypeFlagsEXT = Flags;

export type DebugUtilsMessengerCreateFlagsEXT = Flags;

export type DebugUtilsMessengerCallbackDataFlagsEXT = Flags;

export type DeviceMemoryReportFlagsEXT = Flags;

export type PipelineRasterizationConservativeStateCreateFlagsEXT = Flags;

export type DescriptorBindingFlags = Flags;

export type DescriptorBindingFlagsEXT = DescriptorBindingFlags;

export type ConditionalRenderingFlagsEXT = Flags;

export type ResolveModeFlags = Flags;

export type ResolveModeFlagsKHR = ResolveModeFlags;

export type PipelineRasterizationStateStreamCreateFlagsEXT = Flags;

export type PipelineRasterizationDepthClipStateCreateFlagsEXT = Flags;

export type SwapchainImageUsageFlagsANDROID = Flags;

export type ToolPurposeFlags = Flags;

export type ToolPurposeFlagsEXT = ToolPurposeFlags;

export type SubmitFlags = Flags;

export type SubmitFlagsKHR = SubmitFlags;

export type ImageFormatConstraintsFlagsFUCHSIA = Flags;

export type ImageConstraintsInfoFlagsFUCHSIA = Flags;

export type GraphicsPipelineLibraryFlagsEXT = Flags;

export type ImageCompressionFlagsEXT = Flags;

export type ImageCompressionFixedRateFlagsEXT = Flags;

export type ExportMetalObjectTypeFlagsEXT = Flags;

export type DeviceAddressBindingFlagsEXT = Flags;

export type OpticalFlowGridSizeFlagsNV = Flags;

export type OpticalFlowUsageFlagsNV = Flags;

export type OpticalFlowSessionCreateFlagsNV = Flags;

export type OpticalFlowExecuteFlagsNV = Flags;

export type VideoCodecOperationFlagsKHR = Flags;

export type VideoCapabilityFlagsKHR = Flags;

export type VideoSessionCreateFlagsKHR = Flags;

export type VideoSessionParametersCreateFlagsKHR = Flags;

export type VideoBeginCodingFlagsKHR = Flags;

export type VideoEndCodingFlagsKHR = Flags;

export type VideoCodingControlFlagsKHR = Flags;

export type VideoDecodeUsageFlagsKHR = Flags;

export type VideoDecodeCapabilityFlagsKHR = Flags;

export type VideoDecodeFlagsKHR = Flags;

export type VideoDecodeH264PictureLayoutFlagsEXT = Flags;

export type VideoEncodeFlagsKHR = Flags;

export type VideoEncodeUsageFlagsKHR = Flags;

export type VideoEncodeContentFlagsKHR = Flags;

export type VideoEncodeCapabilityFlagsKHR = Flags;

export type VideoEncodeRateControlFlagsKHR = Flags;

export type VideoEncodeRateControlModeFlagsKHR = Flags;

export type VideoChromaSubsamplingFlagsKHR = Flags;

export type VideoComponentBitDepthFlagsKHR = Flags;

export type VideoEncodeH264CapabilityFlagsEXT = Flags;

export type VideoEncodeH264InputModeFlagsEXT = Flags;

export type VideoEncodeH264OutputModeFlagsEXT = Flags;

export type VideoEncodeH265CapabilityFlagsEXT = Flags;

export type VideoEncodeH265InputModeFlagsEXT = Flags;

export type VideoEncodeH265OutputModeFlagsEXT = Flags;

export type VideoEncodeH265CtbSizeFlagsEXT = Flags;

export type VideoEncodeH265TransformBlockSizeFlagsEXT = Flags;

export type Instance = Deno.PointerValue;

export type PhysicalDevice = Deno.PointerValue;

export type Device = Deno.PointerValue;

export type Queue = Deno.PointerValue;

export type CommandBuffer = Deno.PointerValue;

export type DeviceMemory = Deno.PointerValue;

export type CommandPool = Deno.PointerValue;

export type Buffer = Deno.PointerValue;

export type BufferView = Deno.PointerValue;

export type Image = Deno.PointerValue;

export type ImageView = Deno.PointerValue;

export type ShaderModule = Deno.PointerValue;

export type Pipeline = Deno.PointerValue;

export type PipelineLayout = Deno.PointerValue;

export type Sampler = Deno.PointerValue;

export type DescriptorSet = Deno.PointerValue;

export type DescriptorSetLayout = Deno.PointerValue;

export type DescriptorPool = Deno.PointerValue;

export type Fence = Deno.PointerValue;

export type Semaphore = Deno.PointerValue;

export type Event = Deno.PointerValue;

export type QueryPool = Deno.PointerValue;

export type Framebuffer = Deno.PointerValue;

export type RenderPass = Deno.PointerValue;

export type PipelineCache = Deno.PointerValue;

export type IndirectCommandsLayoutNV = Deno.PointerValue;

export type DescriptorUpdateTemplate = Deno.PointerValue;

export type DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;

export type SamplerYcbcrConversion = Deno.PointerValue;

export type SamplerYcbcrConversionKHR = SamplerYcbcrConversion;

export type ValidationCacheEXT = Deno.PointerValue;

export type AccelerationStructureKHR = Deno.PointerValue;

export type AccelerationStructureNV = Deno.PointerValue;

export type PerformanceConfigurationINTEL = Deno.PointerValue;

export type BufferCollectionFUCHSIA = Deno.PointerValue;

export type DeferredOperationKHR = Deno.PointerValue;

export type PrivateDataSlot = Deno.PointerValue;

export type PrivateDataSlotEXT = PrivateDataSlot;

export type CuModuleNVX = Deno.PointerValue;

export type CuFunctionNVX = Deno.PointerValue;

export type OpticalFlowSessionNV = Deno.PointerValue;

export type MicromapEXT = Deno.PointerValue;

export type DisplayKHR = Deno.PointerValue;

export type DisplayModeKHR = Deno.PointerValue;

export type SurfaceKHR = Deno.PointerValue;

export type SwapchainKHR = Deno.PointerValue;

export type DebugReportCallbackEXT = Deno.PointerValue;

export type DebugUtilsMessengerEXT = Deno.PointerValue;

export type VideoSessionKHR = Deno.PointerValue;

export type VideoSessionParametersKHR = Deno.PointerValue;

export type PrivateDataSlotCreateFlagBitsEXT = PrivateDataSlotCreateFlagBits;

export type DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;

export type PointClippingBehaviorKHR = PointClippingBehavior;

export type QueueGlobalPriorityEXT = QueueGlobalPriorityKHR;

export type ResolveModeFlagBitsKHR = ResolveModeFlagBits;

export type DescriptorBindingFlagBitsEXT = DescriptorBindingFlagBits;

export type SemaphoreTypeKHR = SemaphoreType;

export type GeometryFlagBitsNV = GeometryFlagBitsKHR;

export type GeometryInstanceFlagBitsNV = GeometryInstanceFlagBitsKHR;

export type BuildAccelerationStructureFlagBitsNV = BuildAccelerationStructureFlagBitsKHR;

export type CopyAccelerationStructureModeNV = CopyAccelerationStructureModeKHR;

export type AccelerationStructureTypeNV = AccelerationStructureTypeKHR;

export type GeometryTypeNV = GeometryTypeKHR;

export type RayTracingShaderGroupTypeNV = RayTracingShaderGroupTypeKHR;

export type PipelineCreationFeedbackFlagBitsEXT = PipelineCreationFeedbackFlagBits;

export type SemaphoreWaitFlagBitsKHR = SemaphoreWaitFlagBits;

export type ToolPurposeFlagBitsEXT = ToolPurposeFlagBits;

export type AccessFlagBits2KHR = AccessFlagBits2;

export type PipelineStageFlagBits2KHR = PipelineStageFlagBits2;

export type FormatFeatureFlagBits2KHR = FormatFeatureFlagBits2;

export type RenderingFlagBitsKHR = RenderingFlagBits;

export type ExternalMemoryHandleTypeFlagBitsKHR = ExternalMemoryHandleTypeFlagBits;

export type ExternalMemoryFeatureFlagBitsKHR = ExternalMemoryFeatureFlagBits;

export type ExternalSemaphoreHandleTypeFlagBitsKHR = ExternalSemaphoreHandleTypeFlagBits;

export type ExternalSemaphoreFeatureFlagBitsKHR = ExternalSemaphoreFeatureFlagBits;

export type SemaphoreImportFlagBitsKHR = SemaphoreImportFlagBits;

export type ExternalFenceHandleTypeFlagBitsKHR = ExternalFenceHandleTypeFlagBits;

export type ExternalFenceFeatureFlagBitsKHR = ExternalFenceFeatureFlagBits;

export type FenceImportFlagBitsKHR = FenceImportFlagBits;

export type PeerMemoryFeatureFlagBitsKHR = PeerMemoryFeatureFlagBits;

export type MemoryAllocateFlagBitsKHR = MemoryAllocateFlagBits;

export type TessellationDomainOriginKHR = TessellationDomainOrigin;

export type SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;

export type SamplerYcbcrRangeKHR = SamplerYcbcrRange;

export type ChromaLocationKHR = ChromaLocation;

export type SamplerReductionModeEXT = SamplerReductionMode;

export type ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;

export type SubmitFlagBitsKHR = SubmitFlagBits;

export type DriverIdKHR = DriverId;

export type DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;

export type PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;

export type PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;

export type PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;

export type PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;

export type FormatProperties2KHR = FormatProperties2;

export type ImageFormatProperties2KHR = ImageFormatProperties2;

export type PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;

export type QueueFamilyProperties2KHR = QueueFamilyProperties2;

export type PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;

export type SparseImageFormatProperties2KHR = SparseImageFormatProperties2;

export type PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;

export type ConformanceVersionKHR = ConformanceVersion;

export type PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;

export type PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;

export type PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;

export type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;

export type ExternalMemoryPropertiesKHR = ExternalMemoryProperties;

export type PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;

export type ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;

export type PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;

export type ExternalBufferPropertiesKHR = ExternalBufferProperties;

export type PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;

export type ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;

export type ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;

export type ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;

export type PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;

export type ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;

export type ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;

export type PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;

export type ExternalFencePropertiesKHR = ExternalFenceProperties;

export type ExportFenceCreateInfoKHR = ExportFenceCreateInfo;

export type PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;

export type PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;

export type RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;

export type PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;

export type MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;

export type BindBufferMemoryInfoKHR = BindBufferMemoryInfo;

export type BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;

export type BindImageMemoryInfoKHR = BindImageMemoryInfo;

export type BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;

export type DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;

export type DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;

export type DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;

export type DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;

export type DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;

export type DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;

export type DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;

export type InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;

export type RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;

export type PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;

export type PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

export type BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;

export type DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;

export type ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;

export type ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;

export type DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;

export type MemoryRequirements2KHR = MemoryRequirements2;

export type SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;

export type PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;

export type MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;

export type MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;

export type ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;

export type PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;

export type SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;

export type SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;

export type BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;

export type ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;

export type PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;

export type SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;

export type PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;

export type SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;

export type PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;

export type PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;

export type WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;

export type DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;

export type ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;

export type PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;

export type PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;

export type PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;

export type DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;

export type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;

export type PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;

export type PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;

export type PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;

export type PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;

export type DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfoKHR;

export type PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeaturesKHR;

export type QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityPropertiesKHR;

export type PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;

export type PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;

export type DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;

export type DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;

export type DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;

export type AttachmentDescription2KHR = AttachmentDescription2;

export type AttachmentReference2KHR = AttachmentReference2;

export type SubpassDescription2KHR = SubpassDescription2;

export type SubpassDependency2KHR = SubpassDependency2;

export type RenderPassCreateInfo2KHR = RenderPassCreateInfo2;

export type SubpassBeginInfoKHR = SubpassBeginInfo;

export type SubpassEndInfoKHR = SubpassEndInfo;

export type PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;

export type PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;

export type SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;

export type TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;

export type SemaphoreWaitInfoKHR = SemaphoreWaitInfo;

export type SemaphoreSignalInfoKHR = SemaphoreSignalInfo;

export type PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;

export type PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;

export type PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;

export type PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;

export type SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;

export type PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;

export type ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;

export type PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;

export type PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;

export type PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;

export type PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;

export type BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;

export type BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;

export type BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;

export type PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;

export type FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;

export type FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;

export type RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;

export type PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;

export type PipelineCreationFeedbackEXT = PipelineCreationFeedback;

export type PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;

export type QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;

export type PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

export type AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;

export type AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;

export type PipelineInfoEXT = PipelineInfoKHR;

export type PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;

export type PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;

export type PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;

export type PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;

export type PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;

export type MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;

export type DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;

export type PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;

export type PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;

export type AabbPositionsNV = AabbPositionsKHR;

export type TransformMatrixNV = TransformMatrixKHR;

export type AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;

export type PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;

export type PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;

export type BufferCopy2KHR = BufferCopy2;

export type ImageCopy2KHR = ImageCopy2;

export type ImageBlit2KHR = ImageBlit2;

export type BufferImageCopy2KHR = BufferImageCopy2;

export type ImageResolve2KHR = ImageResolve2;

export type CopyBufferInfo2KHR = CopyBufferInfo2;

export type CopyImageInfo2KHR = CopyImageInfo2;

export type BlitImageInfo2KHR = BlitImageInfo2;

export type CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;

export type CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;

export type ResolveImageInfo2KHR = ResolveImageInfo2;

export type PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;

export type PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;

export type MutableDescriptorTypeListVALVE = MutableDescriptorTypeListEXT;

export type MutableDescriptorTypeCreateInfoVALVE = MutableDescriptorTypeCreateInfoEXT;

export type MemoryBarrier2KHR = MemoryBarrier2;

export type ImageMemoryBarrier2KHR = ImageMemoryBarrier2;

export type BufferMemoryBarrier2KHR = BufferMemoryBarrier2;

export type DependencyInfoKHR = DependencyInfo;

export type SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;

export type CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;

export type SubmitInfo2KHR = SubmitInfo2;

export type PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;

export type PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;

export type PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;

export type FormatProperties3KHR = FormatProperties3;

export type PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;

export type RenderingInfoKHR = RenderingInfo;

export type RenderingAttachmentInfoKHR = RenderingAttachmentInfo;

export type PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;

export type CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;

export type AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;

export type PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;

/// Constants

/// API Constants
/// Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate

export const MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
export const UUID_SIZE = 16;
export const LUID_SIZE = 8;
export const LUID_SIZE_KHR = undefined;
export const MAX_EXTENSION_NAME_SIZE = 256;
export const MAX_DESCRIPTION_SIZE = 256;
export const MAX_MEMORY_TYPES = 32;
/** The maximum number of unique memory heaps, each of which supporting 1 or more memory types */
export const MAX_MEMORY_HEAPS = 16;
export const LOD_CLAMP_NONE = 1000.0;
export const REMAINING_MIP_LEVELS = (~0);
export const REMAINING_ARRAY_LAYERS = (~0);
export const WHOLE_SIZE = (~0n);
export const ATTACHMENT_UNUSED = (~0);
export const TRUE = 1;
export const FALSE = 0;
export const QUEUE_FAMILY_IGNORED = (~0);
export const QUEUE_FAMILY_EXTERNAL = (~1);
export const QUEUE_FAMILY_EXTERNAL_KHR = undefined;
export const QUEUE_FAMILY_FOREIGN_EXT = (~2);
export const SUBPASS_EXTERNAL = (~0);
export const MAX_DEVICE_GROUP_SIZE = 32;
export const MAX_DEVICE_GROUP_SIZE_KHR = undefined;
export const MAX_DRIVER_NAME_SIZE = 256;
export const MAX_DRIVER_NAME_SIZE_KHR = undefined;
export const MAX_DRIVER_INFO_SIZE = 256;
export const MAX_DRIVER_INFO_SIZE_KHR = undefined;
export const SHADER_UNUSED_KHR = (~0);
export const SHADER_UNUSED_NV = undefined;
export const MAX_GLOBAL_PRIORITY_SIZE_KHR = 16;
export const MAX_GLOBAL_PRIORITY_SIZE_EXT = undefined;
export const MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32;

/// vulkan_video_codec_h264std

export const STD_VIDEO_H264_CPB_CNT_LIST_SIZE = 32;
export const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS = 6;
export const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS = 16;
export const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS = 6;
export const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS = 64;
export const STD_VIDEO_H264_MAX_NUM_LIST_REF = 32;
export const STD_VIDEO_H264_MAX_CHROMA_PLANES = 2;

/// vulkan_video_codec_h264std_decode

export const STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_decode";
export const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE = 2;

/// vulkan_video_codec_h264std_encode

export const STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_encode";

/// vulkan_video_codec_h265std

export const STD_VIDEO_H265_CPB_CNT_LIST_SIZE = 32;
export const STD_VIDEO_H265_SUBLAYERS_LIST_SIZE = 7;
export const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS = 6;
export const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS = 16;
export const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS = 6;
export const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS = 64;
export const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS = 6;
export const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS = 64;
export const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS = 2;
export const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS = 64;
export const STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE = 6;
export const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE = 19;
export const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE = 21;
export const STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE = 3;
export const STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE = 128;
export const STD_VIDEO_H265_MAX_NUM_LIST_REF = 15;
export const STD_VIDEO_H265_MAX_CHROMA_PLANES = 2;
export const STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS = 64;
export const STD_VIDEO_H265_MAX_DPB_SIZE = 16;
export const STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS = 32;
export const STD_VIDEO_H265_MAX_LONG_TERM_PICS = 16;
export const STD_VIDEO_H265_MAX_DELTA_POC = 48;

/// vulkan_video_codec_h265std_decode

export const STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_decode";
export const STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE = 8;

/// vulkan_video_codec_h265std_encode

export const STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_encode";

/// VK_KHR_surface

export const KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface";

/// VK_KHR_swapchain

export const KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain";

/// VK_KHR_display

export const KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display";

/// VK_KHR_display_swapchain

export const KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain";

/// VK_KHR_xlib_surface

export const KHR_XLIB_SURFACE_EXTENSION_NAME = "VK_KHR_xlib_surface";

/// VK_KHR_xcb_surface

export const KHR_XCB_SURFACE_EXTENSION_NAME = "VK_KHR_xcb_surface";

/// VK_KHR_wayland_surface

export const KHR_WAYLAND_SURFACE_EXTENSION_NAME = "VK_KHR_wayland_surface";

/// VK_KHR_mir_surface

export const KHR_MIR_SURFACE_EXTENSION_NAME = "VK_KHR_mir_surface";

/// VK_KHR_android_surface

export const KHR_ANDROID_SURFACE_EXTENSION_NAME = "VK_KHR_android_surface";

/// VK_KHR_win32_surface

export const KHR_WIN32_SURFACE_EXTENSION_NAME = "VK_KHR_win32_surface";

/// VK_ANDROID_native_buffer

export const ANDROID_NATIVE_BUFFER_NUMBER = 11;
export const ANDROID_NATIVE_BUFFER_EXTENSION_NAME = "VK_ANDROID_native_buffer";

/// VK_EXT_debug_report

export const EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report";

/// VK_NV_glsl_shader

export const NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader";

/// VK_EXT_depth_range_unrestricted

export const EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted";

/// VK_KHR_sampler_mirror_clamp_to_edge

export const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge";

/// VK_IMG_filter_cubic

export const IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic";

/// VK_AMD_extension_17

export const AMD_EXTENSION_17_EXTENSION_NAME = "VK_AMD_extension_17";

/// VK_AMD_extension_18

export const AMD_EXTENSION_18_EXTENSION_NAME = "VK_AMD_extension_18";

/// VK_AMD_rasterization_order

export const AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order";

/// VK_AMD_extension_20

export const AMD_EXTENSION_20_EXTENSION_NAME = "VK_AMD_extension_20";

/// VK_AMD_shader_trinary_minmax

export const AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax";

/// VK_AMD_shader_explicit_vertex_parameter

export const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter";

/// VK_EXT_debug_marker

export const EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker";

/// VK_KHR_video_queue

export const KHR_VIDEO_QUEUE_EXTENSION_NAME = "VK_KHR_video_queue";

/// VK_KHR_video_decode_queue

export const KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_decode_queue";

/// VK_AMD_gcn_shader

export const AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader";

/// VK_NV_dedicated_allocation

export const NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation";

/// VK_EXT_extension_28

export const EXT_EXTENSION_28_EXTENSION_NAME = "VK_EXT_extension_28";

/// VK_EXT_transform_feedback

export const EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback";

/// VK_NVX_binary_import

export const NVX_BINARY_IMPORT_EXTENSION_NAME = "VK_NVX_binary_import";

/// VK_NVX_image_view_handle

export const NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle";

/// VK_AMD_extension_32

export const AMD_EXTENSION_32_EXTENSION_NAME = "VK_AMD_extension_32";

/// VK_AMD_extension_33

export const AMD_EXTENSION_33_EXTENSION_NAME = "VK_AMD_extension_33";

/// VK_AMD_draw_indirect_count

export const AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count";

/// VK_AMD_extension_35

export const AMD_EXTENSION_35_EXTENSION_NAME = "VK_AMD_extension_35";

/// VK_AMD_negative_viewport_height

export const AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height";

/// VK_AMD_gpu_shader_half_float

export const AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float";

/// VK_AMD_shader_ballot

export const AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot";

/// VK_EXT_video_encode_h264

export const EXT_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_EXT_video_encode_h264";

/// VK_EXT_video_encode_h265

export const EXT_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_EXT_video_encode_h265";

/// VK_EXT_video_decode_h264

export const EXT_VIDEO_DECODE_H264_EXTENSION_NAME = "VK_EXT_video_decode_h264";

/// VK_AMD_texture_gather_bias_lod

export const AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod";

/// VK_AMD_shader_info

export const AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info";

/// VK_AMD_extension_44

export const AMD_EXTENSION_44_EXTENSION_NAME = "VK_AMD_extension_44";

/// VK_KHR_dynamic_rendering

export const KHR_DYNAMIC_RENDERING_EXTENSION_NAME = "VK_KHR_dynamic_rendering";

/// VK_AMD_extension_46

export const AMD_EXTENSION_46_EXTENSION_NAME = "VK_AMD_extension_46";

/// VK_AMD_shader_image_load_store_lod

export const AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod";

/// VK_NVX_extension_48

export const NVX_EXTENSION_48_EXTENSION_NAME = "VK_NVX_extension_48";

/// VK_GOOGLE_extension_49

export const GOOGLE_EXTENSION_49_EXTENSION_NAME = "VK_GOOGLE_extension_49";

/// VK_GGP_stream_descriptor_surface

export const GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = "VK_GGP_stream_descriptor_surface";

/// VK_NV_corner_sampled_image

export const NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image";

/// VK_NV_extension_52

export const NV_EXTENSION_52_EXTENSION_NAME = "VK_NV_extension_52";

/// VK_NV_extension_53

export const NV_EXTENSION_53_EXTENSION_NAME = "VK_NV_extension_53";

/// VK_KHR_multiview

export const KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview";

/// VK_IMG_format_pvrtc

export const IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc";

/// VK_NV_external_memory_capabilities

export const NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities";

/// VK_NV_external_memory

export const NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory";

/// VK_NV_external_memory_win32

export const NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = "VK_NV_external_memory_win32";

/// VK_NV_win32_keyed_mutex

export const NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = "VK_NV_win32_keyed_mutex";

/// VK_KHR_get_physical_device_properties2

export const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2";

/// VK_KHR_device_group

export const KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group";

/// VK_EXT_validation_flags

export const EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags";

/// VK_NN_vi_surface

export const NN_VI_SURFACE_EXTENSION_NAME = "VK_NN_vi_surface";

/// VK_KHR_shader_draw_parameters

export const KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters";

/// VK_EXT_shader_subgroup_ballot

export const EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot";

/// VK_EXT_shader_subgroup_vote

export const EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote";

/// VK_EXT_texture_compression_astc_hdr

export const EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr";

/// VK_EXT_astc_decode_mode

export const EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode";

/// VK_EXT_pipeline_robustness

export const EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_pipeline_robustness";

/// VK_KHR_maintenance1

export const KHR_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_maintenance1";

/// VK_KHR_device_group_creation

export const KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation";

/// VK_KHR_external_memory_capabilities

export const KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities";

/// VK_KHR_external_memory

export const KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory";

/// VK_KHR_external_memory_win32

export const KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = "VK_KHR_external_memory_win32";

/// VK_KHR_external_memory_fd

export const KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd";

/// VK_KHR_win32_keyed_mutex

export const KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME = "VK_KHR_win32_keyed_mutex";

/// VK_KHR_external_semaphore_capabilities

export const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities";

/// VK_KHR_external_semaphore

export const KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore";

/// VK_KHR_external_semaphore_win32

export const KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = "VK_KHR_external_semaphore_win32";

/// VK_KHR_external_semaphore_fd

export const KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd";

/// VK_KHR_push_descriptor

export const KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor";

/// VK_EXT_conditional_rendering

export const EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering";

/// VK_KHR_shader_float16_int8

export const KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8";

/// VK_KHR_16bit_storage

export const KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage";

/// VK_KHR_incremental_present

export const KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present";

/// VK_KHR_descriptor_update_template

export const KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template";

/// VK_NVX_device_generated_commands

export const NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NVX_device_generated_commands";

/// VK_NV_clip_space_w_scaling

export const NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling";

/// VK_EXT_direct_mode_display

export const EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display";

/// VK_EXT_acquire_xlib_display

export const EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_xlib_display";

/// VK_EXT_display_surface_counter

export const EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter";

/// VK_EXT_display_control

export const EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control";

/// VK_GOOGLE_display_timing

export const GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing";

/// VK_RESERVED_do_not_use_94

export const RESERVED_DO_NOT_USE_94_EXTENSION_NAME = "VK_RESERVED_do_not_use_94";

/// VK_NV_sample_mask_override_coverage

export const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage";

/// VK_NV_geometry_shader_passthrough

export const NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough";

/// VK_NV_viewport_array2

export const NV_VIEWPORT_ARRAY_2_EXTENSION_NAME = "VK_NV_viewport_array2";

/// VK_NVX_multiview_per_view_attributes

export const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes";

/// VK_NV_viewport_swizzle

export const NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle";

/// VK_EXT_discard_rectangles

export const EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles";

/// VK_NV_extension_101

export const NV_EXTENSION_101_EXTENSION_NAME = "VK_NV_extension_101";

/// VK_EXT_conservative_rasterization

export const EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization";

/// VK_EXT_depth_clip_enable

export const EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable";

/// VK_NV_extension_104

export const NV_EXTENSION_104_EXTENSION_NAME = "VK_NV_extension_104";

/// VK_EXT_swapchain_colorspace

export const EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace";

/// VK_EXT_hdr_metadata

export const EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata";

/// VK_IMG_extension_107

export const IMG_EXTENSION_107_EXTENSION_NAME = "VK_IMG_extension_107";

/// VK_IMG_extension_108

export const IMG_EXTENSION_108_EXTENSION_NAME = "VK_IMG_extension_108";

/// VK_KHR_imageless_framebuffer

export const KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer";

/// VK_KHR_create_renderpass2

export const KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2";

/// VK_IMG_extension_111

export const IMG_EXTENSION_111_EXTENSION_NAME = "VK_IMG_extension_111";

/// VK_KHR_shared_presentable_image

export const KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image";

/// VK_KHR_external_fence_capabilities

export const KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities";

/// VK_KHR_external_fence

export const KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence";

/// VK_KHR_external_fence_win32

export const KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME = "VK_KHR_external_fence_win32";

/// VK_KHR_external_fence_fd

export const KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd";

/// VK_KHR_performance_query

export const KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query";

/// VK_KHR_maintenance2

export const KHR_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_maintenance2";

/// VK_KHR_extension_119

export const KHR_EXTENSION_119_EXTENSION_NAME = "VK_KHR_extension_119";

/// VK_KHR_get_surface_capabilities2

export const KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2";

/// VK_KHR_variable_pointers

export const KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers";

/// VK_KHR_get_display_properties2

export const KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2";

/// VK_MVK_ios_surface

export const MVK_IOS_SURFACE_EXTENSION_NAME = "VK_MVK_ios_surface";

/// VK_MVK_macos_surface

export const MVK_MACOS_SURFACE_EXTENSION_NAME = "VK_MVK_macos_surface";

/// VK_MVK_moltenvk

export const MVK_MOLTENVK_EXTENSION_NAME = "VK_MVK_moltenvk";

/// VK_EXT_external_memory_dma_buf

export const EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf";

/// VK_EXT_queue_family_foreign

export const EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign";

/// VK_KHR_dedicated_allocation

export const KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation";

/// VK_EXT_debug_utils

export const EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils";

/// VK_ANDROID_external_memory_android_hardware_buffer

export const ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = "VK_ANDROID_external_memory_android_hardware_buffer";

/// VK_EXT_sampler_filter_minmax

export const EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax";

/// VK_KHR_storage_buffer_storage_class

export const KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class";

/// VK_AMD_gpu_shader_int16

export const AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16";

/// VK_AMD_extension_134

export const AMD_EXTENSION_134_EXTENSION_NAME = "VK_AMD_extension_134";

/// VK_AMD_extension_135

export const AMD_EXTENSION_135_EXTENSION_NAME = "VK_AMD_extension_135";

/// VK_AMD_extension_136

export const AMD_EXTENSION_136_EXTENSION_NAME = "VK_AMD_extension_136";

/// VK_AMD_mixed_attachment_samples

export const AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples";

/// VK_AMD_shader_fragment_mask

export const AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask";

/// VK_EXT_inline_uniform_block

export const EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block";

/// VK_AMD_extension_140

export const AMD_EXTENSION_140_EXTENSION_NAME = "VK_AMD_extension_140";

/// VK_EXT_shader_stencil_export

export const EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export";

/// VK_AMD_extension_142

export const AMD_EXTENSION_142_EXTENSION_NAME = "VK_AMD_extension_142";

/// VK_AMD_extension_143

export const AMD_EXTENSION_143_EXTENSION_NAME = "VK_AMD_extension_143";

/// VK_EXT_sample_locations

export const EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations";

/// VK_KHR_relaxed_block_layout

export const KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout";

/// VK_RESERVED_do_not_use_146

export const RESERVED_DO_NOT_USE_146_EXTENSION_NAME = "VK_RESERVED_do_not_use_146";

/// VK_KHR_get_memory_requirements2

export const KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2";

/// VK_KHR_image_format_list

export const KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list";

/// VK_EXT_blend_operation_advanced

export const EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced";

/// VK_NV_fragment_coverage_to_color

export const NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color";

/// VK_KHR_acceleration_structure

export const KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_KHR_acceleration_structure";

/// VK_KHR_ray_tracing_pipeline

export const KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = "VK_KHR_ray_tracing_pipeline";

/// VK_KHR_ray_query

export const KHR_RAY_QUERY_EXTENSION_NAME = "VK_KHR_ray_query";

/// VK_NV_extension_152

export const NV_EXTENSION_152_EXTENSION_NAME = "VK_NV_extension_152";

/// VK_NV_framebuffer_mixed_samples

export const NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples";

/// VK_NV_fill_rectangle

export const NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle";

/// VK_NV_shader_sm_builtins

export const NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins";

/// VK_EXT_post_depth_coverage

export const EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage";

/// VK_KHR_sampler_ycbcr_conversion

export const KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion";

/// VK_KHR_bind_memory2

export const KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2";

/// VK_EXT_image_drm_format_modifier

export const EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier";

/// VK_EXT_extension_160

export const EXT_EXTENSION_160_EXTENSION_NAME = "VK_EXT_extension_160";

/// VK_EXT_validation_cache

export const EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache";

/// VK_EXT_descriptor_indexing

export const EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing";

/// VK_EXT_shader_viewport_index_layer

export const EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer";

/// VK_KHR_portability_subset

export const KHR_PORTABILITY_SUBSET_EXTENSION_NAME = "VK_KHR_portability_subset";

/// VK_NV_shading_rate_image

export const NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image";

/// VK_NV_ray_tracing

export const NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing";

/// VK_NV_representative_fragment_test

export const NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test";

/// VK_NV_extension_168

export const NV_EXTENSION_168_EXTENSION_NAME = "VK_NV_extension_168";

/// VK_KHR_maintenance3

export const KHR_MAINTENANCE_3_EXTENSION_NAME = "VK_KHR_maintenance3";

/// VK_KHR_draw_indirect_count

export const KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count";

/// VK_EXT_filter_cubic

export const EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic";

/// VK_QCOM_render_pass_shader_resolve

export const QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = "VK_QCOM_render_pass_shader_resolve";

/// VK_QCOM_extension_173

export const QCOM_EXTENSION_173_EXTENSION_NAME = "VK_QCOM_extension_173";

/// VK_QCOM_extension_174

export const QCOM_EXTENSION_174_EXTENSION_NAME = "VK_QCOM_extension_174";

/// VK_EXT_global_priority

export const EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority";

/// VK_KHR_shader_subgroup_extended_types

export const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types";

/// VK_EXT_extension_177

export const EXT_EXTENSION_177_EXTENSION_NAME = "VK_EXT_extension_177";

/// VK_KHR_8bit_storage

export const KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage";

/// VK_EXT_external_memory_host

export const EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host";

/// VK_AMD_buffer_marker

export const AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker";

/// VK_KHR_shader_atomic_int64

export const KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64";

/// VK_KHR_shader_clock

export const KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock";

/// VK_AMD_extension_183

export const AMD_EXTENSION_183_EXTENSION_NAME = "VK_AMD_extension_183";

/// VK_AMD_pipeline_compiler_control

export const AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control";

/// VK_EXT_calibrated_timestamps

export const EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps";

/// VK_AMD_shader_core_properties

export const AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties";

/// VK_AMD_extension_187

export const AMD_EXTENSION_187_EXTENSION_NAME = "VK_AMD_extension_187";

/// VK_EXT_video_decode_h265

export const EXT_VIDEO_DECODE_H265_EXTENSION_NAME = "VK_EXT_video_decode_h265";

/// VK_KHR_global_priority

export const KHR_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_KHR_global_priority";

/// VK_AMD_memory_overallocation_behavior

export const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior";

/// VK_EXT_vertex_attribute_divisor

export const EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor";

/// VK_GGP_frame_token

export const GGP_FRAME_TOKEN_EXTENSION_NAME = "VK_GGP_frame_token";

/// VK_EXT_pipeline_creation_feedback

export const EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback";

/// VK_GOOGLE_extension_194

export const GOOGLE_EXTENSION_194_EXTENSION_NAME = "VK_GOOGLE_extension_194";

/// VK_GOOGLE_extension_195

export const GOOGLE_EXTENSION_195_EXTENSION_NAME = "VK_GOOGLE_extension_195";

/// VK_GOOGLE_extension_196

export const GOOGLE_EXTENSION_196_EXTENSION_NAME = "VK_GOOGLE_extension_196";

/// VK_KHR_driver_properties

export const KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties";

/// VK_KHR_shader_float_controls

export const KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls";

/// VK_NV_shader_subgroup_partitioned

export const NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned";

/// VK_KHR_depth_stencil_resolve

export const KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve";

/// VK_KHR_swapchain_mutable_format

export const KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format";

/// VK_NV_compute_shader_derivatives

export const NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives";

/// VK_NV_mesh_shader

export const NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader";

/// VK_NV_fragment_shader_barycentric

export const NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric";

/// VK_NV_shader_image_footprint

export const NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint";

/// VK_NV_scissor_exclusive

export const NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive";

/// VK_NV_device_diagnostic_checkpoints

export const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints";

/// VK_KHR_timeline_semaphore

export const KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore";

/// VK_KHR_extension_209

export const KHR_EXTENSION_209_EXTENSION_NAME = "VK_KHR_extension_209";

/// VK_INTEL_shader_integer_functions2

export const INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2";

/// VK_INTEL_performance_query

export const INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query";

/// VK_KHR_vulkan_memory_model

export const KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model";

/// VK_EXT_pci_bus_info

export const EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info";

/// VK_AMD_display_native_hdr

export const AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr";

/// VK_FUCHSIA_imagepipe_surface

export const FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME = "VK_FUCHSIA_imagepipe_surface";

/// VK_KHR_shader_terminate_invocation

export const KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = "VK_KHR_shader_terminate_invocation";

/// VK_GOOGLE_extension_217

export const GOOGLE_EXTENSION_217_EXTENSION_NAME = "VK_GOOGLE_extension_217";

/// VK_EXT_metal_surface

export const EXT_METAL_SURFACE_EXTENSION_NAME = "VK_EXT_metal_surface";

/// VK_EXT_fragment_density_map

export const EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map";

/// VK_EXT_extension_220

export const EXT_EXTENSION_220_EXTENSION_NAME = "VK_EXT_extension_220";

/// VK_KHR_extension_221

export const KHR_EXTENSION_221_EXTENSION_NAME = "VK_KHR_extension_221";

/// VK_EXT_scalar_block_layout

export const EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout";

/// VK_EXT_extension_223

export const EXT_EXTENSION_223_EXTENSION_NAME = "VK_EXT_extension_223";

/// VK_GOOGLE_hlsl_functionality1

export const GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1";

/// VK_GOOGLE_decorate_string

export const GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string";

/// VK_EXT_subgroup_size_control

export const EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control";

/// VK_KHR_fragment_shading_rate

export const KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = "VK_KHR_fragment_shading_rate";

/// VK_AMD_shader_core_properties2

export const AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2";

/// VK_AMD_extension_229

export const AMD_EXTENSION_229_EXTENSION_NAME = "VK_AMD_extension_229";

/// VK_AMD_device_coherent_memory

export const AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory";

/// VK_AMD_extension_231

export const AMD_EXTENSION_231_EXTENSION_NAME = "VK_AMD_extension_231";

/// VK_AMD_extension_232

export const AMD_EXTENSION_232_EXTENSION_NAME = "VK_AMD_extension_232";

/// VK_AMD_extension_233

export const AMD_EXTENSION_233_EXTENSION_NAME = "VK_AMD_extension_233";

/// VK_AMD_extension_234

export const AMD_EXTENSION_234_EXTENSION_NAME = "VK_AMD_extension_234";

/// VK_EXT_shader_image_atomic_int64

export const EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = "VK_EXT_shader_image_atomic_int64";

/// VK_AMD_extension_236

export const AMD_EXTENSION_236_EXTENSION_NAME = "VK_AMD_extension_236";

/// VK_KHR_spirv_1_4

export const KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4";

/// VK_EXT_memory_budget

export const EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget";

/// VK_EXT_memory_priority

export const EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority";

/// VK_KHR_surface_protected_capabilities

export const KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities";

/// VK_NV_dedicated_allocation_image_aliasing

export const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing";

/// VK_KHR_separate_depth_stencil_layouts

export const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts";

/// VK_INTEL_extension_243

export const INTEL_EXTENSION_243_EXTENSION_NAME = "VK_INTEL_extension_243";

/// VK_MESA_extension_244

export const MESA_EXTENSION_244_EXTENSION_NAME = "VK_MESA_extension_244";

/// VK_EXT_buffer_device_address

export const EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address";

/// VK_EXT_tooling_info

export const EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info";

/// VK_EXT_separate_stencil_usage

export const EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage";

/// VK_EXT_validation_features

export const EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features";

/// VK_KHR_present_wait

export const KHR_PRESENT_WAIT_EXTENSION_NAME = "VK_KHR_present_wait";

/// VK_NV_cooperative_matrix

export const NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix";

/// VK_NV_coverage_reduction_mode

export const NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode";

/// VK_EXT_fragment_shader_interlock

export const EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock";

/// VK_EXT_ycbcr_image_arrays

export const EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays";

/// VK_KHR_uniform_buffer_standard_layout

export const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout";

/// VK_EXT_provoking_vertex

export const EXT_PROVOKING_VERTEX_EXTENSION_NAME = "VK_EXT_provoking_vertex";

/// VK_EXT_full_screen_exclusive

export const EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME = "VK_EXT_full_screen_exclusive";

/// VK_EXT_headless_surface

export const EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface";

/// VK_KHR_buffer_device_address

export const KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address";

/// VK_EXT_extension_259

export const EXT_EXTENSION_259_EXTENSION_NAME = "VK_EXT_extension_259";

/// VK_EXT_line_rasterization

export const EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization";

/// VK_EXT_shader_atomic_float

export const EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = "VK_EXT_shader_atomic_float";

/// VK_EXT_host_query_reset

export const EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset";

/// VK_GGP_extension_263

export const GGP_EXTENSION_263_EXTENSION_NAME = "VK_GGP_extension_263";

/// VK_BRCM_extension_264

export const BRCM_EXTENSION_264_EXTENSION_NAME = "VK_BRCM_extension_264";

/// VK_BRCM_extension_265

export const BRCM_EXTENSION_265_EXTENSION_NAME = "VK_BRCM_extension_265";

/// VK_EXT_index_type_uint8

export const EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8";

/// VK_EXT_extension_267

export const EXT_EXTENSION_267_EXTENSION_NAME = "VK_EXT_extension_267";

/// VK_EXT_extended_dynamic_state

export const EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_extended_dynamic_state";

/// VK_KHR_deferred_host_operations

export const KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = "VK_KHR_deferred_host_operations";

/// VK_KHR_pipeline_executable_properties

export const KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties";

/// VK_INTEL_extension_271

export const INTEL_EXTENSION_271_EXTENSION_NAME = "VK_INTEL_extension_271";

/// VK_INTEL_extension_272

export const INTEL_EXTENSION_272_EXTENSION_NAME = "VK_INTEL_extension_272";

/// VK_INTEL_extension_273

export const INTEL_EXTENSION_273_EXTENSION_NAME = "VK_INTEL_extension_273";

/// VK_EXT_shader_atomic_float2

export const EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME = "VK_EXT_shader_atomic_float2";

/// VK_KHR_extension_275

export const KHR_EXTENSION_275_EXTENSION_NAME = "VK_KHR_extension_275";

/// VK_KHR_extension_276

export const KHR_EXTENSION_276_EXTENSION_NAME = "VK_KHR_extension_276";

/// VK_EXT_shader_demote_to_helper_invocation

export const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation";

/// VK_NV_device_generated_commands

export const NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NV_device_generated_commands";

/// VK_NV_inherited_viewport_scissor

export const NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = "VK_NV_inherited_viewport_scissor";

/// VK_KHR_extension_280

export const KHR_EXTENSION_280_EXTENSION_NAME = "VK_KHR_extension_280";

/// VK_KHR_shader_integer_dot_product

export const KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = "VK_KHR_shader_integer_dot_product";

/// VK_EXT_texel_buffer_alignment

export const EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment";

/// VK_QCOM_render_pass_transform

export const QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = "VK_QCOM_render_pass_transform";

/// VK_EXT_extension_284

export const EXT_EXTENSION_284_EXTENSION_NAME = "VK_EXT_extension_284";

/// VK_EXT_device_memory_report

export const EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = "VK_EXT_device_memory_report";

/// VK_EXT_acquire_drm_display

export const EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_drm_display";

/// VK_EXT_robustness2

export const EXT_ROBUSTNESS_2_EXTENSION_NAME = "VK_EXT_robustness2";

/// VK_EXT_custom_border_color

export const EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = "VK_EXT_custom_border_color";

/// VK_EXT_extension_289

export const EXT_EXTENSION_289_EXTENSION_NAME = "VK_EXT_extension_289";

/// VK_GOOGLE_user_type

export const GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type";

/// VK_KHR_pipeline_library

export const KHR_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_KHR_pipeline_library";

/// VK_NV_extension_292

export const NV_EXTENSION_292_EXTENSION_NAME = "VK_NV_extension_292";

/// VK_NV_present_barrier

export const NV_PRESENT_BARRIER_EXTENSION_NAME = "VK_NV_present_barrier";

/// VK_KHR_shader_non_semantic_info

export const KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = "VK_KHR_shader_non_semantic_info";

/// VK_KHR_present_id

export const KHR_PRESENT_ID_EXTENSION_NAME = "VK_KHR_present_id";

/// VK_EXT_private_data

export const EXT_PRIVATE_DATA_EXTENSION_NAME = "VK_EXT_private_data";

/// VK_KHR_extension_297

export const KHR_EXTENSION_297_EXTENSION_NAME = "VK_KHR_extension_297";

/// VK_EXT_pipeline_creation_cache_control

export const EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = "VK_EXT_pipeline_creation_cache_control";

/// VK_KHR_extension_299

export const KHR_EXTENSION_299_EXTENSION_NAME = "VK_KHR_extension_299";

/// VK_KHR_video_encode_queue

export const KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue";

/// VK_NV_device_diagnostics_config

export const NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = "VK_NV_device_diagnostics_config";

/// VK_QCOM_render_pass_store_ops

export const QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = "VK_QCOM_render_pass_store_ops";

/// VK_QCOM_extension_303

export const QCOM_EXTENSION_303_EXTENSION_NAME = "VK_QCOM_extension_303";

/// VK_QCOM_extension_304

export const QCOM_EXTENSION_304_EXTENSION_NAME = "VK_QCOM_extension_304";

/// VK_QCOM_extension_305

export const QCOM_EXTENSION_305_EXTENSION_NAME = "VK_QCOM_extension_305";

/// VK_QCOM_extension_306

export const QCOM_EXTENSION_306_EXTENSION_NAME = "VK_QCOM_extension_306";

/// VK_QCOM_extension_307

export const QCOM_EXTENSION_307_EXTENSION_NAME = "VK_QCOM_extension_307";

/// VK_NV_extension_308

export const NV_EXTENSION_308_EXTENSION_NAME = "VK_NV_extension_308";

/// VK_KHR_extension_309

export const KHR_EXTENSION_309_EXTENSION_NAME = "VK_KHR_extension_309";

/// VK_QCOM_extension_310

export const QCOM_EXTENSION_310_EXTENSION_NAME = "VK_QCOM_extension_310";

/// VK_NV_extension_311

export const NV_EXTENSION_311_EXTENSION_NAME = "VK_NV_extension_311";

/// VK_EXT_metal_objects

export const EXT_METAL_OBJECTS_EXTENSION_NAME = "VK_EXT_metal_objects";

/// VK_EXT_extension_313

export const EXT_EXTENSION_313_EXTENSION_NAME = "VK_EXT_extension_313";

/// VK_AMD_extension_314

export const AMD_EXTENSION_314_EXTENSION_NAME = "VK_AMD_extension_314";

/// VK_KHR_synchronization2

export const KHR_SYNCHRONIZATION_2_EXTENSION_NAME = "VK_KHR_synchronization2";

/// VK_AMD_extension_316

export const AMD_EXTENSION_316_EXTENSION_NAME = "VK_AMD_extension_316";

/// VK_EXT_descriptor_buffer

export const EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME = "VK_EXT_descriptor_buffer";

/// VK_AMD_extension_318

export const AMD_EXTENSION_318_EXTENSION_NAME = "VK_AMD_extension_318";

/// VK_AMD_extension_319

export const AMD_EXTENSION_319_EXTENSION_NAME = "VK_AMD_extension_319";

/// VK_AMD_extension_320

export const AMD_EXTENSION_320_EXTENSION_NAME = "VK_AMD_extension_320";

/// VK_EXT_graphics_pipeline_library

export const EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_EXT_graphics_pipeline_library";

/// VK_AMD_shader_early_and_late_fragment_tests

export const AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME = "VK_AMD_shader_early_and_late_fragment_tests";

/// VK_KHR_fragment_shader_barycentric

export const KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_KHR_fragment_shader_barycentric";

/// VK_KHR_shader_subgroup_uniform_control_flow

export const KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = "VK_KHR_shader_subgroup_uniform_control_flow";

/// VK_KHR_extension_325

export const KHR_EXTENSION_325_EXTENSION_NAME = "VK_KHR_extension_325";

/// VK_KHR_zero_initialize_workgroup_memory

export const KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = "VK_KHR_zero_initialize_workgroup_memory";

/// VK_NV_fragment_shading_rate_enums

export const NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = "VK_NV_fragment_shading_rate_enums";

/// VK_NV_ray_tracing_motion_blur

export const NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = "VK_NV_ray_tracing_motion_blur";

/// VK_EXT_mesh_shader

export const EXT_MESH_SHADER_EXTENSION_NAME = "VK_EXT_mesh_shader";

/// VK_NV_extension_330

export const NV_EXTENSION_330_EXTENSION_NAME = "VK_NV_extension_330";

/// VK_EXT_ycbcr_2plane_444_formats

export const EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = "VK_EXT_ycbcr_2plane_444_formats";

/// VK_NV_extension_332

export const NV_EXTENSION_332_EXTENSION_NAME = "VK_NV_extension_332";

/// VK_EXT_fragment_density_map2

export const EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME = "VK_EXT_fragment_density_map2";

/// VK_QCOM_rotated_copy_commands

export const QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = "VK_QCOM_rotated_copy_commands";

/// VK_KHR_extension_335

export const KHR_EXTENSION_335_EXTENSION_NAME = "VK_KHR_extension_335";

/// VK_EXT_image_robustness

export const EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_image_robustness";

/// VK_KHR_workgroup_memory_explicit_layout

export const KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = "VK_KHR_workgroup_memory_explicit_layout";

/// VK_KHR_copy_commands2

export const KHR_COPY_COMMANDS_2_EXTENSION_NAME = "VK_KHR_copy_commands2";

/// VK_EXT_image_compression_control

export const EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME = "VK_EXT_image_compression_control";

/// VK_EXT_attachment_feedback_loop_layout

export const EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_layout";

/// VK_EXT_4444_formats

export const EXT_4444_FORMATS_EXTENSION_NAME = "VK_EXT_4444_formats";

/// VK_EXT_device_fault

export const EXT_DEVICE_FAULT_EXTENSION_NAME = "VK_EXT_device_fault";

/// VK_ARM_rasterization_order_attachment_access

export const ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_ARM_rasterization_order_attachment_access";

/// VK_ARM_extension_344

export const ARM_EXTENSION_344_EXTENSION_NAME = "VK_ARM_extension_344";

/// VK_EXT_rgba10x6_formats

export const EXT_RGBA10X6_FORMATS_EXTENSION_NAME = "VK_EXT_rgba10x6_formats";

/// VK_NV_acquire_winrt_display

export const NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME = "VK_NV_acquire_winrt_display";

/// VK_EXT_directfb_surface

export const EXT_DIRECTFB_SURFACE_EXTENSION_NAME = "VK_EXT_directfb_surface";

/// VK_KHR_extension_350

export const KHR_EXTENSION_350_EXTENSION_NAME = "VK_KHR_extension_350";

/// VK_NV_extension_351

export const NV_EXTENSION_351_EXTENSION_NAME = "VK_NV_extension_351";

/// VK_VALVE_mutable_descriptor_type

export const VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_VALVE_mutable_descriptor_type";

/// VK_EXT_vertex_input_dynamic_state

export const EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_vertex_input_dynamic_state";

/// VK_EXT_physical_device_drm

export const EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = "VK_EXT_physical_device_drm";

/// VK_EXT_device_address_binding_report

export const EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME = "VK_EXT_device_address_binding_report";

/// VK_EXT_depth_clip_control

export const EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clip_control";

/// VK_EXT_primitive_topology_list_restart

export const EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = "VK_EXT_primitive_topology_list_restart";

/// VK_KHR_extension_358

export const KHR_EXTENSION_358_EXTENSION_NAME = "VK_KHR_extension_358";

/// VK_EXT_extension_359

export const EXT_EXTENSION_359_EXTENSION_NAME = "VK_EXT_extension_359";

/// VK_EXT_extension_360

export const EXT_EXTENSION_360_EXTENSION_NAME = "VK_EXT_extension_360";

/// VK_KHR_format_feature_flags2

export const KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2";

/// VK_EXT_extension_362

export const EXT_EXTENSION_362_EXTENSION_NAME = "VK_EXT_extension_362";

/// VK_EXT_extension_363

export const EXT_EXTENSION_363_EXTENSION_NAME = "VK_EXT_extension_363";

/// VK_FUCHSIA_extension_364

export const FUCHSIA_EXTENSION_364_EXTENSION_NAME = "VK_FUCHSIA_extension_364";

/// VK_FUCHSIA_external_memory

export const FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_FUCHSIA_external_memory";

/// VK_FUCHSIA_external_semaphore

export const FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_FUCHSIA_external_semaphore";

/// VK_FUCHSIA_buffer_collection

export const FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME = "VK_FUCHSIA_buffer_collection";

/// VK_FUCHSIA_extension_368

export const FUCHSIA_EXTENSION_368_EXTENSION_NAME = "VK_FUCHSIA_extension_368";

/// VK_QCOM_extension_369

export const QCOM_EXTENSION_369_EXTENSION_NAME = "VK_QCOM_extension_369";

/// VK_HUAWEI_subpass_shading

export const HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = "VK_HUAWEI_subpass_shading";

/// VK_HUAWEI_invocation_mask

export const HUAWEI_INVOCATION_MASK_EXTENSION_NAME = "VK_HUAWEI_invocation_mask";

/// VK_NV_external_memory_rdma

export const NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = "VK_NV_external_memory_rdma";

/// VK_EXT_pipeline_properties

export const EXT_PIPELINE_PROPERTIES_EXTENSION_NAME = "VK_EXT_pipeline_properties";

/// VK_NV_extension_374

export const NV_EXTENSION_374_EXTENSION_NAME = "VK_NV_extension_374";

/// VK_NV_extension_375

export const NV_EXTENSION_375_EXTENSION_NAME = "VK_NV_extension_375";

/// VK_EXT_extension_376

export const EXT_EXTENSION_376_EXTENSION_NAME = "VK_EXT_extension_376";

/// VK_EXT_multisampled_render_to_single_sampled

export const EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME = "VK_EXT_multisampled_render_to_single_sampled";

/// VK_EXT_extended_dynamic_state2

export const EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME = "VK_EXT_extended_dynamic_state2";

/// VK_QNX_screen_surface

export const QNX_SCREEN_SURFACE_EXTENSION_NAME = "VK_QNX_screen_surface";

/// VK_KHR_extension_380

export const KHR_EXTENSION_380_EXTENSION_NAME = "VK_KHR_extension_380";

/// VK_KHR_extension_381

export const KHR_EXTENSION_381_EXTENSION_NAME = "VK_KHR_extension_381";

/// VK_EXT_color_write_enable

export const EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = "VK_EXT_color_write_enable";

/// VK_EXT_primitives_generated_query

export const EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME = "VK_EXT_primitives_generated_query";

/// VK_EXT_extension_384

export const EXT_EXTENSION_384_EXTENSION_NAME = "VK_EXT_extension_384";

/// VK_MESA_extension_385

export const MESA_EXTENSION_385_EXTENSION_NAME = "VK_MESA_extension_385";

/// VK_GOOGLE_extension_386

export const GOOGLE_EXTENSION_386_EXTENSION_NAME = "VK_GOOGLE_extension_386";

/// VK_KHR_ray_tracing_maintenance1

export const KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_ray_tracing_maintenance1";

/// VK_EXT_extension_388

export const EXT_EXTENSION_388_EXTENSION_NAME = "VK_EXT_extension_388";

/// VK_EXT_global_priority_query

export const EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = "VK_EXT_global_priority_query";

/// VK_EXT_extension_390

export const EXT_EXTENSION_390_EXTENSION_NAME = "VK_EXT_extension_390";

/// VK_EXT_extension_391

export const EXT_EXTENSION_391_EXTENSION_NAME = "VK_EXT_extension_391";

/// VK_EXT_image_view_min_lod

export const EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = "VK_EXT_image_view_min_lod";

/// VK_EXT_multi_draw

export const EXT_MULTI_DRAW_EXTENSION_NAME = "VK_EXT_multi_draw";

/// VK_EXT_image_2d_view_of_3d

export const EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_2d_view_of_3d";

/// VK_KHR_portability_enumeration

export const KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME = "VK_KHR_portability_enumeration";

/// VK_KHR_extension_396

export const KHR_EXTENSION_396_EXTENSION_NAME = "VK_KHR_extension_396";

/// VK_EXT_opacity_micromap

export const EXT_OPACITY_MICROMAP_EXTENSION_NAME = "VK_EXT_opacity_micromap";

/// VK_NV_extension_398

export const NV_EXTENSION_398_EXTENSION_NAME = "VK_NV_extension_398";

/// VK_JUICE_extension_399

export const JUICE_EXTENSION_399_EXTENSION_NAME = "VK_JUICE_extension_399";

/// VK_JUICE_extension_400

export const JUICE_EXTENSION_400_EXTENSION_NAME = "VK_JUICE_extension_400";

/// VK_EXT_load_store_op_none

export const EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_EXT_load_store_op_none";

/// VK_FB_extension_402

export const FB_EXTENSION_402_EXTENSION_NAME = "VK_FB_extension_402";

/// VK_FB_extension_403

export const FB_EXTENSION_403_EXTENSION_NAME = "VK_FB_extension_403";

/// VK_FB_extension_404

export const FB_EXTENSION_404_EXTENSION_NAME = "VK_FB_extension_404";

/// VK_HUAWEI_extension_405

export const HUAWEI_EXTENSION_405_EXTENSION_NAME = "VK_HUAWEI_extension_405";

/// VK_HUAWEI_extension_406

export const HUAWEI_EXTENSION_406_EXTENSION_NAME = "VK_HUAWEI_extension_406";

/// VK_GGP_extension_407

export const GGP_EXTENSION_407_EXTENSION_NAME = "VK_GGP_extension_407";

/// VK_GGP_extension_408

export const GGP_EXTENSION_408_EXTENSION_NAME = "VK_GGP_extension_408";

/// VK_GGP_extension_409

export const GGP_EXTENSION_409_EXTENSION_NAME = "VK_GGP_extension_409";

/// VK_GGP_extension_410

export const GGP_EXTENSION_410_EXTENSION_NAME = "VK_GGP_extension_410";

/// VK_GGP_extension_411

export const GGP_EXTENSION_411_EXTENSION_NAME = "VK_GGP_extension_411";

/// VK_EXT_border_color_swizzle

export const EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = "VK_EXT_border_color_swizzle";

/// VK_EXT_pageable_device_local_memory

export const EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = "VK_EXT_pageable_device_local_memory";

/// VK_KHR_maintenance4

export const KHR_MAINTENANCE_4_EXTENSION_NAME = "VK_KHR_maintenance4";

/// VK_HUAWEI_extension_415

export const HUAWEI_EXTENSION_415_EXTENSION_NAME = "VK_HUAWEI_extension_415";

/// VK_ARM_extension_416

export const ARM_EXTENSION_416_EXTENSION_NAME = "VK_ARM_extension_416";

/// VK_KHR_extension_417

export const KHR_EXTENSION_417_EXTENSION_NAME = "VK_KHR_extension_417";

/// VK_ARM_extension_418

export const ARM_EXTENSION_418_EXTENSION_NAME = "VK_ARM_extension_418";

/// VK_EXT_extension_419

export const EXT_EXTENSION_419_EXTENSION_NAME = "VK_EXT_extension_419";

/// VK_EXT_extension_420

export const EXT_EXTENSION_420_EXTENSION_NAME = "VK_EXT_extension_420";

/// VK_VALVE_descriptor_set_host_mapping

export const VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME = "VK_VALVE_descriptor_set_host_mapping";

/// VK_EXT_depth_clamp_zero_one

export const EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_EXT_depth_clamp_zero_one";

/// VK_EXT_non_seamless_cube_map

export const EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME = "VK_EXT_non_seamless_cube_map";

/// VK_ARM_extension_424

export const ARM_EXTENSION_424_EXTENSION_NAME = "VK_ARM_extension_424";

/// VK_ARM_extension_425

export const ARM_EXTENSION_425_EXTENSION_NAME = "VK_ARM_extension_425";

/// VK_QCOM_fragment_density_map_offset

export const QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_QCOM_fragment_density_map_offset";

/// VK_NV_copy_memory_indirect

export const NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_NV_copy_memory_indirect";

/// VK_NV_memory_decompression

export const NV_MEMORY_DECOMPRESSION_EXTENSION_NAME = "VK_NV_memory_decompression";

/// VK_NV_extension_429

export const NV_EXTENSION_429_EXTENSION_NAME = "VK_NV_extension_429";

/// VK_NV_extension_430

export const NV_EXTENSION_430_EXTENSION_NAME = "VK_NV_extension_430";

/// VK_NV_linear_color_attachment

export const NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = "VK_NV_linear_color_attachment";

/// VK_NV_extension_432

export const NV_EXTENSION_432_EXTENSION_NAME = "VK_NV_extension_432";

/// VK_NV_extension_433

export const NV_EXTENSION_433_EXTENSION_NAME = "VK_NV_extension_433";

/// VK_GOOGLE_surfaceless_query

export const GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = "VK_GOOGLE_surfaceless_query";

/// VK_KHR_extension_435

export const KHR_EXTENSION_435_EXTENSION_NAME = "VK_KHR_extension_435";

/// VK_NV_extension_436

export const NV_EXTENSION_436_EXTENSION_NAME = "VK_NV_extension_436";

/// VK_EXT_extension_437

export const EXT_EXTENSION_437_EXTENSION_NAME = "VK_EXT_extension_437";

/// VK_EXT_image_compression_control_swapchain

export const EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME = "VK_EXT_image_compression_control_swapchain";

/// VK_SEC_extension_439

export const SEC_EXTENSION_439_EXTENSION_NAME = "VK_SEC_extension_439";

/// VK_QCOM_extension_440

export const QCOM_EXTENSION_440_EXTENSION_NAME = "VK_QCOM_extension_440";

/// VK_QCOM_image_processing

export const QCOM_IMAGE_PROCESSING_EXTENSION_NAME = "VK_QCOM_image_processing";

/// VK_COREAVI_extension_442

export const COREAVI_EXTENSION_442_EXTENSION_NAME = "VK_COREAVI_extension_442";

/// VK_COREAVI_extension_443

export const COREAVI_EXTENSION_443_EXTENSION_NAME = "VK_COREAVI_extension_443";

/// VK_COREAVI_extension_444

export const COREAVI_EXTENSION_444_EXTENSION_NAME = "VK_COREAVI_extension_444";

/// VK_COREAVI_extension_445

export const COREAVI_EXTENSION_445_EXTENSION_NAME = "VK_COREAVI_extension_445";

/// VK_COREAVI_extension_446

export const COREAVI_EXTENSION_446_EXTENSION_NAME = "VK_COREAVI_extension_446";

/// VK_COREAVI_extension_447

export const COREAVI_EXTENSION_447_EXTENSION_NAME = "VK_COREAVI_extension_447";

/// VK_SEC_extension_448

export const SEC_EXTENSION_448_EXTENSION_NAME = "VK_SEC_extension_448";

/// VK_SEC_extension_449

export const SEC_EXTENSION_449_EXTENSION_NAME = "VK_SEC_extension_449";

/// VK_SEC_extension_450

export const SEC_EXTENSION_450_EXTENSION_NAME = "VK_SEC_extension_450";

/// VK_SEC_extension_451

export const SEC_EXTENSION_451_EXTENSION_NAME = "VK_SEC_extension_451";

/// VK_NV_extension_452

export const NV_EXTENSION_452_EXTENSION_NAME = "VK_NV_extension_452";

/// VK_ARM_extension_453

export const ARM_EXTENSION_453_EXTENSION_NAME = "VK_ARM_extension_453";

/// VK_GOOGLE_extension_454

export const GOOGLE_EXTENSION_454_EXTENSION_NAME = "VK_GOOGLE_extension_454";

/// VK_GOOGLE_extension_455

export const GOOGLE_EXTENSION_455_EXTENSION_NAME = "VK_GOOGLE_extension_455";

/// VK_EXT_extended_dynamic_state3

export const EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME = "VK_EXT_extended_dynamic_state3";

/// VK_EXT_extension_457

export const EXT_EXTENSION_457_EXTENSION_NAME = "VK_EXT_extension_457";

/// VK_EXT_extension_458

export const EXT_EXTENSION_458_EXTENSION_NAME = "VK_EXT_extension_458";

/// VK_EXT_subpass_merge_feedback

export const EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME = "VK_EXT_subpass_merge_feedback";

/// VK_EXT_extension_460

export const EXT_EXTENSION_460_EXTENSION_NAME = "VK_EXT_extension_460";

/// VK_EXT_extension_461

export const EXT_EXTENSION_461_EXTENSION_NAME = "VK_EXT_extension_461";

/// VK_EXT_extension_462

export const EXT_EXTENSION_462_EXTENSION_NAME = "VK_EXT_extension_462";

/// VK_EXT_shader_module_identifier

export const EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME = "VK_EXT_shader_module_identifier";

/// VK_EXT_rasterization_order_attachment_access

export const EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_EXT_rasterization_order_attachment_access";

/// VK_NV_optical_flow

export const NV_OPTICAL_FLOW_EXTENSION_NAME = "VK_NV_optical_flow";

/// VK_EXT_legacy_dithering

export const EXT_LEGACY_DITHERING_EXTENSION_NAME = "VK_EXT_legacy_dithering";

/// VK_EXT_pipeline_protected_access

export const EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME = "VK_EXT_pipeline_protected_access";

/// VK_EXT_extension_468

export const EXT_EXTENSION_468_EXTENSION_NAME = "VK_EXT_extension_468";

/// VK_ANDROID_extension_469

export const ANDROID_EXTENSION_469_EXTENSION_NAME = "VK_ANDROID_extension_469";

/// VK_AMD_extension_470

export const AMD_EXTENSION_470_EXTENSION_NAME = "VK_AMD_extension_470";

/// VK_AMD_extension_471

export const AMD_EXTENSION_471_EXTENSION_NAME = "VK_AMD_extension_471";

/// VK_AMD_extension_472

export const AMD_EXTENSION_472_EXTENSION_NAME = "VK_AMD_extension_472";

/// VK_AMD_extension_473

export const AMD_EXTENSION_473_EXTENSION_NAME = "VK_AMD_extension_473";

/// VK_AMD_extension_474

export const AMD_EXTENSION_474_EXTENSION_NAME = "VK_AMD_extension_474";

/// VK_AMD_extension_475

export const AMD_EXTENSION_475_EXTENSION_NAME = "VK_AMD_extension_475";

/// VK_AMD_extension_476

export const AMD_EXTENSION_476_EXTENSION_NAME = "VK_AMD_extension_476";

/// VK_AMD_extension_477

export const AMD_EXTENSION_477_EXTENSION_NAME = "VK_AMD_extension_477";

/// VK_AMD_extension_478

export const AMD_EXTENSION_478_EXTENSION_NAME = "VK_AMD_extension_478";

/// VK_AMD_extension_479

export const AMD_EXTENSION_479_EXTENSION_NAME = "VK_AMD_extension_479";

/// VK_EXT_extension_480

export const EXT_EXTENSION_480_EXTENSION_NAME = "VK_EXT_extension_480";

/// VK_EXT_extension_481

export const EXT_EXTENSION_481_EXTENSION_NAME = "VK_EXT_extension_481";

/// VK_EXT_extension_482

export const EXT_EXTENSION_482_EXTENSION_NAME = "VK_EXT_extension_482";

/// VK_EXT_extension_483

export const EXT_EXTENSION_483_EXTENSION_NAME = "VK_EXT_extension_483";

/// VK_EXT_extension_484

export const EXT_EXTENSION_484_EXTENSION_NAME = "VK_EXT_extension_484";

/// VK_QCOM_tile_properties

export const QCOM_TILE_PROPERTIES_EXTENSION_NAME = "VK_QCOM_tile_properties";

/// VK_SEC_amigo_profiling

export const SEC_AMIGO_PROFILING_EXTENSION_NAME = "VK_SEC_amigo_profiling";

/// VK_EXT_extension_487

export const EXT_EXTENSION_487_EXTENSION_NAME = "VK_EXT_extension_487";

/// VK_EXT_extension_488

export const EXT_EXTENSION_488_EXTENSION_NAME = "VK_EXT_extension_488";

/// VK_QCOM_extension_489

export const QCOM_EXTENSION_489_EXTENSION_NAME = "VK_QCOM_extension_489";

/// VK_NV_extension_490

export const NV_EXTENSION_490_EXTENSION_NAME = "VK_NV_extension_490";

/// VK_NV_ray_tracing_invocation_reorder

export const NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME = "VK_NV_ray_tracing_invocation_reorder";

/// VK_NV_extension_492

export const NV_EXTENSION_492_EXTENSION_NAME = "VK_NV_extension_492";

/// VK_NV_extension_493

export const NV_EXTENSION_493_EXTENSION_NAME = "VK_NV_extension_493";

/// VK_NV_extension_494

export const NV_EXTENSION_494_EXTENSION_NAME = "VK_NV_extension_494";

/// VK_EXT_mutable_descriptor_type

export const EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_EXT_mutable_descriptor_type";

/// VK_EXT_extension_496

export const EXT_EXTENSION_496_EXTENSION_NAME = "VK_EXT_extension_496";

/// VK_EXT_extension_497

export const EXT_EXTENSION_497_EXTENSION_NAME = "VK_EXT_extension_497";

/// VK_ARM_shader_core_builtins

export const ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME = "VK_ARM_shader_core_builtins";

/// VK_EXT_extension_499

export const EXT_EXTENSION_499_EXTENSION_NAME = "VK_EXT_extension_499";

/// VK_EXT_extension_500

export const EXT_EXTENSION_500_EXTENSION_NAME = "VK_EXT_extension_500";

/// VK_EXT_extension_501

export const EXT_EXTENSION_501_EXTENSION_NAME = "VK_EXT_extension_501";

/// VK_EXT_extension_502

export const EXT_EXTENSION_502_EXTENSION_NAME = "VK_EXT_extension_502";

/// VK_EXT_extension_503

export const EXT_EXTENSION_503_EXTENSION_NAME = "VK_EXT_extension_503";

/// VK_NV_extension_504

export const NV_EXTENSION_504_EXTENSION_NAME = "VK_NV_extension_504";

/// Enums

export enum StdVideoH264ChromaFormatIdc {
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
  STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 2147483647,
}

export enum StdVideoH264ProfileIdc {
  /** Only constrained baseline is supported */
  STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
  STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
  STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
  STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
  STD_VIDEO_H264_PROFILE_IDC_INVALID = 2147483647,
}

export enum StdVideoH264LevelIdc {
  STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
  STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
  STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
  STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
  STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
  STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
  STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
  STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
  STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
  STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
  STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
  STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
  STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
  STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
  STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
  STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
  STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
  STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
  STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
  STD_VIDEO_H264_LEVEL_IDC_INVALID = 2147483647,
}

export enum StdVideoH264PocType {
  STD_VIDEO_H264_POC_TYPE_0 = 0,
  STD_VIDEO_H264_POC_TYPE_1 = 1,
  STD_VIDEO_H264_POC_TYPE_2 = 2,
  STD_VIDEO_H264_POC_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264AspectRatioIdc {
  STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
  STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 2147483647,
}

export enum StdVideoH264WeightedBipredIdc {
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
  STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 2147483647,
}

export enum StdVideoH264ModificationOfPicNumsIdc {
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
  STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 2147483647,
}

export enum StdVideoH264MemMgmtControlOp {
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
  STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 2147483647,
}

export enum StdVideoH264CabacInitIdc {
  STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
  STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
  STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
  STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 2147483647,
}

export enum StdVideoH264DisableDeblockingFilterIdc {
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
  STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 2147483647,
}

export enum StdVideoH264SliceType {
  STD_VIDEO_H264_SLICE_TYPE_P = 0,
  STD_VIDEO_H264_SLICE_TYPE_B = 1,
  STD_VIDEO_H264_SLICE_TYPE_I = 2,
  STD_VIDEO_H264_SLICE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264PictureType {
  STD_VIDEO_H264_PICTURE_TYPE_P = 0,
  STD_VIDEO_H264_PICTURE_TYPE_B = 1,
  STD_VIDEO_H264_PICTURE_TYPE_I = 2,
  STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
  STD_VIDEO_H264_PICTURE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH264NonVclNaluType {
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
  STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 2147483647,
}

export enum StdVideoDecodeH264FieldOrderCount {
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
  STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 2147483647,
}

export enum StdVideoH265ChromaFormatIdc {
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
  STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 2147483647,
}

export enum StdVideoH265ProfileIdc {
  STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
  STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
  STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
  STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
  STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
  STD_VIDEO_H265_PROFILE_IDC_INVALID = 2147483647,
}

export enum StdVideoH265LevelIdc {
  STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
  STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
  STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
  STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
  STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
  STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
  STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
  STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
  STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
  STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
  STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
  STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
  STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
  STD_VIDEO_H265_LEVEL_IDC_INVALID = 2147483647,
}

export enum StdVideoH265SliceType {
  STD_VIDEO_H265_SLICE_TYPE_B = 0,
  STD_VIDEO_H265_SLICE_TYPE_P = 1,
  STD_VIDEO_H265_SLICE_TYPE_I = 2,
  STD_VIDEO_H265_SLICE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH265PictureType {
  STD_VIDEO_H265_PICTURE_TYPE_P = 0,
  STD_VIDEO_H265_PICTURE_TYPE_B = 1,
  STD_VIDEO_H265_PICTURE_TYPE_I = 2,
  STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
  STD_VIDEO_H265_PICTURE_TYPE_INVALID = 2147483647,
}

export enum StdVideoH265AspectRatioIdc {
  STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
  STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 2147483647,
}

export enum ImageLayout {
  /** Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation) */
  IMAGE_LAYOUT_UNDEFINED = 0,
  /** General layout when image can be used for any kind of access */
  IMAGE_LAYOUT_GENERAL = 1,
  /** Optimal layout when image is only used for color attachment read/write */
  IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
  /** Optimal layout when image is only used for depth/stencil attachment read/write */
  IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
  /** Optimal layout when image is used for read only depth/stencil attachment and shader access */
  IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
  /** Optimal layout when image is used for read only shader access */
  IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
  /** Optimal layout when image is used only as source of transfer operations */
  IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
  /** Optimal layout when image is used only as destination of transfer operations */
  IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
  /** Initial layout used when the data is populated by the CPU */
  IMAGE_LAYOUT_PREINITIALIZED = 8,
  IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
  IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
  IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
  IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
  IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
  IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
  IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
  IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
  IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
  IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
  IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
  IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
  IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
  IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
  IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
  IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003,
  IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
  IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
  IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000,
  IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001,
  IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002,
  IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003,
  IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
  IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
  IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
  IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000,
  IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001,
  IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
}

export enum AttachmentLoadOp {
  ATTACHMENT_LOAD_OP_LOAD = 0,
  ATTACHMENT_LOAD_OP_CLEAR = 1,
  ATTACHMENT_LOAD_OP_DONT_CARE = 2,
  ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000,
}

export enum AttachmentStoreOp {
  ATTACHMENT_STORE_OP_STORE = 0,
  ATTACHMENT_STORE_OP_DONT_CARE = 1,
  ATTACHMENT_STORE_OP_NONE = 1000301000,
  ATTACHMENT_STORE_OP_NONE_KHR = 1000301000,
  ATTACHMENT_STORE_OP_NONE_QCOM = 1000301000,
  ATTACHMENT_STORE_OP_NONE_EXT = 1000301000,
}

export enum ImageType {
  IMAGE_TYPE_1D = 0,
  IMAGE_TYPE_2D = 1,
  IMAGE_TYPE_3D = 2,
}

export enum ImageTiling {
  IMAGE_TILING_OPTIMAL = 0,
  IMAGE_TILING_LINEAR = 1,
  IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
}

export enum ImageViewType {
  IMAGE_VIEW_TYPE_1D = 0,
  IMAGE_VIEW_TYPE_2D = 1,
  IMAGE_VIEW_TYPE_3D = 2,
  IMAGE_VIEW_TYPE_CUBE = 3,
  IMAGE_VIEW_TYPE_1D_ARRAY = 4,
  IMAGE_VIEW_TYPE_2D_ARRAY = 5,
  IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
}

export enum CommandBufferLevel {
  COMMAND_BUFFER_LEVEL_PRIMARY = 0,
  COMMAND_BUFFER_LEVEL_SECONDARY = 1,
}

export enum ComponentSwizzle {
  COMPONENT_SWIZZLE_IDENTITY = 0,
  COMPONENT_SWIZZLE_ZERO = 1,
  COMPONENT_SWIZZLE_ONE = 2,
  COMPONENT_SWIZZLE_R = 3,
  COMPONENT_SWIZZLE_G = 4,
  COMPONENT_SWIZZLE_B = 5,
  COMPONENT_SWIZZLE_A = 6,
}

export enum DescriptorType {
  DESCRIPTOR_TYPE_SAMPLER = 0,
  DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
  DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
  DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
  DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
  DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
  DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
  DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
  DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
  DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
  DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
  DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
  DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
  DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  DESCRIPTOR_TYPE_MUTABLE_VALVE = 1000351000,
  DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
  DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
  DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
}

export enum QueryType {
  QUERY_TYPE_OCCLUSION = 0,
  /** Optional */
  QUERY_TYPE_PIPELINE_STATISTICS = 1,
  QUERY_TYPE_TIMESTAMP = 2,
  QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
  QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
  QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
  QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
  QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
  QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
  QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
  QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR = 1000299000,
  QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
  QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
  QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
  QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
  QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
  QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
}

export enum BorderColor {
  BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
  BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
  BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
  BORDER_COLOR_INT_OPAQUE_BLACK = 3,
  BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
  BORDER_COLOR_INT_OPAQUE_WHITE = 5,
  BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
  BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
}

export enum PipelineBindPoint {
  PIPELINE_BIND_POINT_GRAPHICS = 0,
  PIPELINE_BIND_POINT_COMPUTE = 1,
  PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
  PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000,
  PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
}

export enum PipelineCacheHeaderVersion {
  PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

export enum PipelineCacheCreateFlagBits {
  PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 1 << 0,
  PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT = 1 << 1,
  PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = 1 << 0,
  PIPELINE_CACHE_CREATE_RESERVED_1_BIT_KHR = 1 << 1,
  PIPELINE_CACHE_CREATE_RESERVED_2_BIT_KHR = 1 << 2,
}

export enum PrimitiveTopology {
  PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
  PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
  PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
  PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
  PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
  PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
  PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
  PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
  PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
  PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
  PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
}

export enum SharingMode {
  SHARING_MODE_EXCLUSIVE = 0,
  SHARING_MODE_CONCURRENT = 1,
}

export enum IndexType {
  INDEX_TYPE_UINT16 = 0,
  INDEX_TYPE_UINT32 = 1,
  INDEX_TYPE_NONE_KHR = 1000165000,
  INDEX_TYPE_NONE_NV = 1000165000,
  INDEX_TYPE_UINT8_EXT = 1000265000,
}

export enum Filter {
  FILTER_NEAREST = 0,
  FILTER_LINEAR = 1,
  FILTER_CUBIC_IMG = 1000015000,
  FILTER_CUBIC_EXT = 1000015000,
}

export enum SamplerMipmapMode {
  /** Choose nearest mip level */
  SAMPLER_MIPMAP_MODE_NEAREST = 0,
  /** Linear filter between mip levels */
  SAMPLER_MIPMAP_MODE_LINEAR = 1,
}

export enum SamplerAddressMode {
  SAMPLER_ADDRESS_MODE_REPEAT = 0,
  SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
  SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
  SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
  /** No need to add an extnumber attribute, since this uses a core enum value */
  SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
  /** Alias introduced for consistency with extension suffixing rules */
  SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = 4,
}

export enum CompareOp {
  COMPARE_OP_NEVER = 0,
  COMPARE_OP_LESS = 1,
  COMPARE_OP_EQUAL = 2,
  COMPARE_OP_LESS_OR_EQUAL = 3,
  COMPARE_OP_GREATER = 4,
  COMPARE_OP_NOT_EQUAL = 5,
  COMPARE_OP_GREATER_OR_EQUAL = 6,
  COMPARE_OP_ALWAYS = 7,
}

export enum PolygonMode {
  POLYGON_MODE_FILL = 0,
  POLYGON_MODE_LINE = 1,
  POLYGON_MODE_POINT = 2,
  POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
}

export enum FrontFace {
  FRONT_FACE_COUNTER_CLOCKWISE = 0,
  FRONT_FACE_CLOCKWISE = 1,
}

export enum BlendFactor {
  BLEND_FACTOR_ZERO = 0,
  BLEND_FACTOR_ONE = 1,
  BLEND_FACTOR_SRC_COLOR = 2,
  BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
  BLEND_FACTOR_DST_COLOR = 4,
  BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
  BLEND_FACTOR_SRC_ALPHA = 6,
  BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
  BLEND_FACTOR_DST_ALPHA = 8,
  BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
  BLEND_FACTOR_CONSTANT_COLOR = 10,
  BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
  BLEND_FACTOR_CONSTANT_ALPHA = 12,
  BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
  BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
  BLEND_FACTOR_SRC1_COLOR = 15,
  BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
  BLEND_FACTOR_SRC1_ALPHA = 17,
  BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
}

export enum BlendOp {
  BLEND_OP_ADD = 0,
  BLEND_OP_SUBTRACT = 1,
  BLEND_OP_REVERSE_SUBTRACT = 2,
  BLEND_OP_MIN = 3,
  BLEND_OP_MAX = 4,
  BLEND_OP_ZERO_EXT = 1000148000,
  BLEND_OP_SRC_EXT = 1000148001,
  BLEND_OP_DST_EXT = 1000148002,
  BLEND_OP_SRC_OVER_EXT = 1000148003,
  BLEND_OP_DST_OVER_EXT = 1000148004,
  BLEND_OP_SRC_IN_EXT = 1000148005,
  BLEND_OP_DST_IN_EXT = 1000148006,
  BLEND_OP_SRC_OUT_EXT = 1000148007,
  BLEND_OP_DST_OUT_EXT = 1000148008,
  BLEND_OP_SRC_ATOP_EXT = 1000148009,
  BLEND_OP_DST_ATOP_EXT = 1000148010,
  BLEND_OP_XOR_EXT = 1000148011,
  BLEND_OP_MULTIPLY_EXT = 1000148012,
  BLEND_OP_SCREEN_EXT = 1000148013,
  BLEND_OP_OVERLAY_EXT = 1000148014,
  BLEND_OP_DARKEN_EXT = 1000148015,
  BLEND_OP_LIGHTEN_EXT = 1000148016,
  BLEND_OP_COLORDODGE_EXT = 1000148017,
  BLEND_OP_COLORBURN_EXT = 1000148018,
  BLEND_OP_HARDLIGHT_EXT = 1000148019,
  BLEND_OP_SOFTLIGHT_EXT = 1000148020,
  BLEND_OP_DIFFERENCE_EXT = 1000148021,
  BLEND_OP_EXCLUSION_EXT = 1000148022,
  BLEND_OP_INVERT_EXT = 1000148023,
  BLEND_OP_INVERT_RGB_EXT = 1000148024,
  BLEND_OP_LINEARDODGE_EXT = 1000148025,
  BLEND_OP_LINEARBURN_EXT = 1000148026,
  BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
  BLEND_OP_LINEARLIGHT_EXT = 1000148028,
  BLEND_OP_PINLIGHT_EXT = 1000148029,
  BLEND_OP_HARDMIX_EXT = 1000148030,
  BLEND_OP_HSL_HUE_EXT = 1000148031,
  BLEND_OP_HSL_SATURATION_EXT = 1000148032,
  BLEND_OP_HSL_COLOR_EXT = 1000148033,
  BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
  BLEND_OP_PLUS_EXT = 1000148035,
  BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
  BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
  BLEND_OP_PLUS_DARKER_EXT = 1000148038,
  BLEND_OP_MINUS_EXT = 1000148039,
  BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
  BLEND_OP_CONTRAST_EXT = 1000148041,
  BLEND_OP_INVERT_OVG_EXT = 1000148042,
  BLEND_OP_RED_EXT = 1000148043,
  BLEND_OP_GREEN_EXT = 1000148044,
  BLEND_OP_BLUE_EXT = 1000148045,
}

export enum StencilOp {
  STENCIL_OP_KEEP = 0,
  STENCIL_OP_ZERO = 1,
  STENCIL_OP_REPLACE = 2,
  STENCIL_OP_INCREMENT_AND_CLAMP = 3,
  STENCIL_OP_DECREMENT_AND_CLAMP = 4,
  STENCIL_OP_INVERT = 5,
  STENCIL_OP_INCREMENT_AND_WRAP = 6,
  STENCIL_OP_DECREMENT_AND_WRAP = 7,
}

export enum LogicOp {
  LOGIC_OP_CLEAR = 0,
  LOGIC_OP_AND = 1,
  LOGIC_OP_AND_REVERSE = 2,
  LOGIC_OP_COPY = 3,
  LOGIC_OP_AND_INVERTED = 4,
  LOGIC_OP_NO_OP = 5,
  LOGIC_OP_XOR = 6,
  LOGIC_OP_OR = 7,
  LOGIC_OP_NOR = 8,
  LOGIC_OP_EQUIVALENT = 9,
  LOGIC_OP_INVERT = 10,
  LOGIC_OP_OR_REVERSE = 11,
  LOGIC_OP_COPY_INVERTED = 12,
  LOGIC_OP_OR_INVERTED = 13,
  LOGIC_OP_NAND = 14,
  LOGIC_OP_SET = 15,
}

export enum InternalAllocationType {
  INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
}

export enum SystemAllocationScope {
  SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
  SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
  SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
  SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
  SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
}

export enum PhysicalDeviceType {
  PHYSICAL_DEVICE_TYPE_OTHER = 0,
  PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
  PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
  PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
  PHYSICAL_DEVICE_TYPE_CPU = 4,
}

export enum VertexInputRate {
  VERTEX_INPUT_RATE_VERTEX = 0,
  VERTEX_INPUT_RATE_INSTANCE = 1,
}

/** Vulkan format definitions */
export enum Format {
  FORMAT_UNDEFINED = 0,
  FORMAT_R4G4_UNORM_PACK8 = 1,
  FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
  FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
  FORMAT_R5G6B5_UNORM_PACK16 = 4,
  FORMAT_B5G6R5_UNORM_PACK16 = 5,
  FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
  FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
  FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
  FORMAT_R8_UNORM = 9,
  FORMAT_R8_SNORM = 10,
  FORMAT_R8_USCALED = 11,
  FORMAT_R8_SSCALED = 12,
  FORMAT_R8_UINT = 13,
  FORMAT_R8_SINT = 14,
  FORMAT_R8_SRGB = 15,
  FORMAT_R8G8_UNORM = 16,
  FORMAT_R8G8_SNORM = 17,
  FORMAT_R8G8_USCALED = 18,
  FORMAT_R8G8_SSCALED = 19,
  FORMAT_R8G8_UINT = 20,
  FORMAT_R8G8_SINT = 21,
  FORMAT_R8G8_SRGB = 22,
  FORMAT_R8G8B8_UNORM = 23,
  FORMAT_R8G8B8_SNORM = 24,
  FORMAT_R8G8B8_USCALED = 25,
  FORMAT_R8G8B8_SSCALED = 26,
  FORMAT_R8G8B8_UINT = 27,
  FORMAT_R8G8B8_SINT = 28,
  FORMAT_R8G8B8_SRGB = 29,
  FORMAT_B8G8R8_UNORM = 30,
  FORMAT_B8G8R8_SNORM = 31,
  FORMAT_B8G8R8_USCALED = 32,
  FORMAT_B8G8R8_SSCALED = 33,
  FORMAT_B8G8R8_UINT = 34,
  FORMAT_B8G8R8_SINT = 35,
  FORMAT_B8G8R8_SRGB = 36,
  FORMAT_R8G8B8A8_UNORM = 37,
  FORMAT_R8G8B8A8_SNORM = 38,
  FORMAT_R8G8B8A8_USCALED = 39,
  FORMAT_R8G8B8A8_SSCALED = 40,
  FORMAT_R8G8B8A8_UINT = 41,
  FORMAT_R8G8B8A8_SINT = 42,
  FORMAT_R8G8B8A8_SRGB = 43,
  FORMAT_B8G8R8A8_UNORM = 44,
  FORMAT_B8G8R8A8_SNORM = 45,
  FORMAT_B8G8R8A8_USCALED = 46,
  FORMAT_B8G8R8A8_SSCALED = 47,
  FORMAT_B8G8R8A8_UINT = 48,
  FORMAT_B8G8R8A8_SINT = 49,
  FORMAT_B8G8R8A8_SRGB = 50,
  FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
  FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
  FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
  FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
  FORMAT_A8B8G8R8_UINT_PACK32 = 55,
  FORMAT_A8B8G8R8_SINT_PACK32 = 56,
  FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
  FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
  FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
  FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  FORMAT_A2R10G10B10_UINT_PACK32 = 62,
  FORMAT_A2R10G10B10_SINT_PACK32 = 63,
  FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
  FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
  FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  FORMAT_A2B10G10R10_UINT_PACK32 = 68,
  FORMAT_A2B10G10R10_SINT_PACK32 = 69,
  FORMAT_R16_UNORM = 70,
  FORMAT_R16_SNORM = 71,
  FORMAT_R16_USCALED = 72,
  FORMAT_R16_SSCALED = 73,
  FORMAT_R16_UINT = 74,
  FORMAT_R16_SINT = 75,
  FORMAT_R16_SFLOAT = 76,
  FORMAT_R16G16_UNORM = 77,
  FORMAT_R16G16_SNORM = 78,
  FORMAT_R16G16_USCALED = 79,
  FORMAT_R16G16_SSCALED = 80,
  FORMAT_R16G16_UINT = 81,
  FORMAT_R16G16_SINT = 82,
  FORMAT_R16G16_SFLOAT = 83,
  FORMAT_R16G16B16_UNORM = 84,
  FORMAT_R16G16B16_SNORM = 85,
  FORMAT_R16G16B16_USCALED = 86,
  FORMAT_R16G16B16_SSCALED = 87,
  FORMAT_R16G16B16_UINT = 88,
  FORMAT_R16G16B16_SINT = 89,
  FORMAT_R16G16B16_SFLOAT = 90,
  FORMAT_R16G16B16A16_UNORM = 91,
  FORMAT_R16G16B16A16_SNORM = 92,
  FORMAT_R16G16B16A16_USCALED = 93,
  FORMAT_R16G16B16A16_SSCALED = 94,
  FORMAT_R16G16B16A16_UINT = 95,
  FORMAT_R16G16B16A16_SINT = 96,
  FORMAT_R16G16B16A16_SFLOAT = 97,
  FORMAT_R32_UINT = 98,
  FORMAT_R32_SINT = 99,
  FORMAT_R32_SFLOAT = 100,
  FORMAT_R32G32_UINT = 101,
  FORMAT_R32G32_SINT = 102,
  FORMAT_R32G32_SFLOAT = 103,
  FORMAT_R32G32B32_UINT = 104,
  FORMAT_R32G32B32_SINT = 105,
  FORMAT_R32G32B32_SFLOAT = 106,
  FORMAT_R32G32B32A32_UINT = 107,
  FORMAT_R32G32B32A32_SINT = 108,
  FORMAT_R32G32B32A32_SFLOAT = 109,
  FORMAT_R64_UINT = 110,
  FORMAT_R64_SINT = 111,
  FORMAT_R64_SFLOAT = 112,
  FORMAT_R64G64_UINT = 113,
  FORMAT_R64G64_SINT = 114,
  FORMAT_R64G64_SFLOAT = 115,
  FORMAT_R64G64B64_UINT = 116,
  FORMAT_R64G64B64_SINT = 117,
  FORMAT_R64G64B64_SFLOAT = 118,
  FORMAT_R64G64B64A64_UINT = 119,
  FORMAT_R64G64B64A64_SINT = 120,
  FORMAT_R64G64B64A64_SFLOAT = 121,
  FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
  FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
  FORMAT_D16_UNORM = 124,
  FORMAT_X8_D24_UNORM_PACK32 = 125,
  FORMAT_D32_SFLOAT = 126,
  FORMAT_S8_UINT = 127,
  FORMAT_D16_UNORM_S8_UINT = 128,
  FORMAT_D24_UNORM_S8_UINT = 129,
  FORMAT_D32_SFLOAT_S8_UINT = 130,
  FORMAT_BC1_RGB_UNORM_BLOCK = 131,
  FORMAT_BC1_RGB_SRGB_BLOCK = 132,
  FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
  FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
  FORMAT_BC2_UNORM_BLOCK = 135,
  FORMAT_BC2_SRGB_BLOCK = 136,
  FORMAT_BC3_UNORM_BLOCK = 137,
  FORMAT_BC3_SRGB_BLOCK = 138,
  FORMAT_BC4_UNORM_BLOCK = 139,
  FORMAT_BC4_SNORM_BLOCK = 140,
  FORMAT_BC5_UNORM_BLOCK = 141,
  FORMAT_BC5_SNORM_BLOCK = 142,
  FORMAT_BC6H_UFLOAT_BLOCK = 143,
  FORMAT_BC6H_SFLOAT_BLOCK = 144,
  FORMAT_BC7_UNORM_BLOCK = 145,
  FORMAT_BC7_SRGB_BLOCK = 146,
  FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
  FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
  FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
  FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
  FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
  FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
  FORMAT_EAC_R11_UNORM_BLOCK = 153,
  FORMAT_EAC_R11_SNORM_BLOCK = 154,
  FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
  FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
  FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
  FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
  FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
  FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
  FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
  FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
  FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
  FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
  FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
  FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
  FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
  FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
  FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
  FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
  FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
  FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
  FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
  FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
  FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
  FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
  FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
  FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
  FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
  FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
  FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
  FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
  FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
  FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
  FORMAT_G8B8G8R8_422_UNORM = 1000156000,
  FORMAT_B8G8R8G8_422_UNORM = 1000156001,
  FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
  FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
  FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
  FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
  FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
  FORMAT_R10X6_UNORM_PACK16 = 1000156007,
  FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
  FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
  FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
  FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
  FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
  FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
  FORMAT_R12X4_UNORM_PACK16 = 1000156017,
  FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
  FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
  FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
  FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
  FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
  FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
  FORMAT_G16B16G16R16_422_UNORM = 1000156027,
  FORMAT_B16G16R16G16_422_UNORM = 1000156028,
  FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
  FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
  FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
  FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
  FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
  FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
  FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
  FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
  FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
  FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
  FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
  FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
  FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
  FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
  FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
  FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
  FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
  FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
  FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
  FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
  FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
  FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
  FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
  FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
  FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
  FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
  FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
  FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
  FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
  FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
  FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
  FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
  FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
  FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
  FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
  FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
  FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
  FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
  FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
  FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
  FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
  FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
  FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
  FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
  FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
  FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
  FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
  FORMAT_G8B8G8R8_422_UNORM_KHR = 1000156000,
  FORMAT_B8G8R8G8_422_UNORM_KHR = 1000156001,
  FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002,
  FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003,
  FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004,
  FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005,
  FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006,
  FORMAT_R10X6_UNORM_PACK16_KHR = 1000156007,
  FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = 1000156008,
  FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009,
  FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010,
  FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012,
  FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014,
  FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015,
  FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016,
  FORMAT_R12X4_UNORM_PACK16_KHR = 1000156017,
  FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = 1000156018,
  FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019,
  FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020,
  FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022,
  FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024,
  FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025,
  FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026,
  FORMAT_G16B16G16R16_422_UNORM_KHR = 1000156027,
  FORMAT_B16G16R16G16_422_UNORM_KHR = 1000156028,
  FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029,
  FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030,
  FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031,
  FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032,
  FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033,
  FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT = 1000288000,
  FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT = 1000288001,
  FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT = 1000288002,
  FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT = 1000288003,
  FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT = 1000288004,
  FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT = 1000288005,
  FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT = 1000288006,
  FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT = 1000288007,
  FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT = 1000288008,
  FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT = 1000288009,
  FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT = 1000288010,
  FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT = 1000288011,
  FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT = 1000288012,
  FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT = 1000288013,
  FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT = 1000288014,
  FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT = 1000288015,
  FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT = 1000288016,
  FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT = 1000288017,
  FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT = 1000288018,
  FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT = 1000288019,
  FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT = 1000288020,
  FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT = 1000288021,
  FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT = 1000288022,
  FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT = 1000288023,
  FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT = 1000288024,
  FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT = 1000288025,
  FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT = 1000288026,
  FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT = 1000288027,
  FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT = 1000288028,
  FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT = 1000288029,
  FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000,
  FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001,
  FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002,
  FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003,
  FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
  FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001,
  FORMAT_R16G16_S10_5_NV = 1000464000,
}

/** Structure type enumerant */
export enum StructureType {
  STRUCTURE_TYPE_APPLICATION_INFO = 0,
  STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
  STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
  STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
  STRUCTURE_TYPE_SUBMIT_INFO = 4,
  STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
  STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
  STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
  STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
  STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
  STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
  STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
  STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
  STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
  STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
  STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
  STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
  STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
  STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
  STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
  STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
  STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
  STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
  STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
  STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
  STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
  STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
  STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
  STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
  STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
  STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
  STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
  STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
  STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
  STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
  STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
  STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
  STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
  STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
  STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
  STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
  STRUCTURE_TYPE_MEMORY_BARRIER = 46,
  /** Reserved for internal use by the loader, layers, and ICDs */
  STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
  /** Reserved for internal use by the loader, layers, and ICDs */
  STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
  STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
  STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
  STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
  STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
  STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
  STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
  STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
  STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
  STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
  STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
  STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
  STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
  STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
  STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
  STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
  STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
  STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
  STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
  STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
  STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
  STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
  STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
  STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
  STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
  STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
  STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
  STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
  STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
  STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
  STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
  STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
  STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
  STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
  STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
  STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
  STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
  STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
  STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
  STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
  STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
  STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
  STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
  STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
  STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
  STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
  STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
  STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
  STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
  STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
  STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
  STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
  STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
  STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
  STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
  STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
  STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
  STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
  STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
  STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
  STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
  STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
  STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
  STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
  STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
  STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
  STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
  STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
  STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
  STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
  STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
  STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
  STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
  STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
  STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
  STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
  STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
  STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
  STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
  STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
  STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
  STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
  STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
  STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
  STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
  STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
  STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
  STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
  STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
  STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
  STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
  STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
  STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
  STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
  STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
  STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
  STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
  STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
  STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
  STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
  STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
  STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
  STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
  STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
  STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
  STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
  STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
  STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
  STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
  STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
  STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
  STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,
  STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID = 1000010001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID = 1000010002,
  STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
  /** Backwards-compatible alias containing a typo */
  STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
  STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
  STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
  STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
  STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
  STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
  STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
  STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
  STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
  STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
  STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
  STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
  STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
  STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
  STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
  STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
  STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
  STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
  STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
  STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
  STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
  STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
  STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
  STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
  STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
  STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
  STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
  STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
  STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
  STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
  STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038001,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038002,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT = 1000038003,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038004,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT = 1000038005,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000038006,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT = 1000038007,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038008,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038009,
  STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT = 1000038010,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039001,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039002,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT = 1000039003,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039004,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT = 1000039005,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000039006,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT = 1000039007,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT = 1000039008,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039009,
  STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039010,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT = 1000040000,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT = 1000040001,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_EXT = 1000040003,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000040004,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000040005,
  STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT = 1000040006,
  STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
  STRUCTURE_TYPE_RENDERING_INFO_KHR = 1000044000,
  STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = 1000044001,
  STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = 1000044002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 1000044003,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 1000044004,
  STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
  STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
  STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
  STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = 1000044008,
  STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
  STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
  STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002,
  STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
  STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
  STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
  STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
  STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
  STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002,
  STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
  STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
  STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
  STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000,
  STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003,
  STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
  STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005,
  STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006,
  STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013,
  STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014,
  STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
  STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
  STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
  STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000,
  STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
  STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
  STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
  STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
  STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
  STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
  STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
  STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
  STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
  STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
  STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
  STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
  STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
  STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
  STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
  STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
  STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
  STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
  STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
  STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
  STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
  STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
  STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
  STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
  STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
  STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
  /** Backwards-compatible alias containing a typo */
  STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = 1000090000,
  STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
  STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
  STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
  STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
  STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
  STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
  STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000,
  STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001,
  STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002,
  STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003,
  STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
  STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
  STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
  STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
  STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
  STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
  STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
  STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
  STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
  STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
  STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
  STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
  STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
  STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
  STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
  STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
  STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
  STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
  STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
  STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
  STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
  STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
  STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
  STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
  STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = 1000120000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
  STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
  STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
  STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
  STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
  STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
  STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
  STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
  STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
  STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
  STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
  STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
  STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
  STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
  STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
  STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
  STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
  STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
  STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
  STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
  STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
  STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
  STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
  STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
  STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
  STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
  STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
  STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
  STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
  STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
  STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
  STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
  STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 1000146003,
  STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
  STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
  STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
  STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
  STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
  STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
  STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
  STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
  STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
  STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
  STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
  STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
  STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
  STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
  STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
  STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
  STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
  STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
  STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
  STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
  STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
  STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
  STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
  STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
  STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
  STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
  STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
  STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
  STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
  STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
  STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
  STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
  STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
  STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
  STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
  STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
  STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
  STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
  STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
  STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT = 1000187000,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000187001,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000187002,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_EXT = 1000187003,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT = 1000187004,
  STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT = 1000187005,
  STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
  STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
  STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
  STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
  STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
  STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
  STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
  STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
  STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001,
  STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002,
  STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 1000207003,
  STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 1000207004,
  STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 1000207005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
  STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
  /** Backwards-compatible alias containing a typo */
  STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
  STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
  STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
  STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
  STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
  STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
  STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
  STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
  STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000,
  STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
  STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
  STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
  STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
  STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
  STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
  STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000,
  STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001,
  STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000,
  STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
  STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000,
  STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
  STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
  STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
  STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
  STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
  STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
  STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
  STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
  STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000,
  STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = 1000244001,
  STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 1000257002,
  STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003,
  STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
  STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
  /** Not promoted to 1.3 */
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
  STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
  STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
  STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
  STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
  STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
  STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
  STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
  STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
  STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
  STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
  STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 1000280000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 1000280001,
  /** Not promoted to 1.3 */
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
  STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
  STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
  STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
  STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
  STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
  STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
  STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
  STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
  STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000,
  STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001,
  STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000,
  STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
  STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
  STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
  STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
  STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
  STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
  STRUCTURE_TYPE_RESERVED_QCOM = 1000309000,
  STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
  STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
  STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
  STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
  STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
  STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
  STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
  STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
  STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
  STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
  STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
  STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
  STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000,
  STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001,
  STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002,
  STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003,
  STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004,
  STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005,
  STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007,
  STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
  STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
  STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
  STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
  STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
  STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
  STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
  STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
  STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
  STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
  STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
  STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
  STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
  STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
  STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000,
  STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001,
  STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002,
  STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003,
  STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004,
  STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005,
  STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006,
  STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007,
  STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008,
  STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009,
  STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
  STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
  STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = 1000338002,
  STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = 1000338003,
  STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
  STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
  STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 1000342000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
  STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000,
  STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
  STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
  STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
  STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
  STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
  STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = 1000360000,
  STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
  STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
  STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
  STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
  STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
  STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
  STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
  STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
  STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
  STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
  STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
  STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
  STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
  STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
  STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
  STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
  STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
  STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
  STRUCTURE_TYPE_PIPELINE_INFO_EXT = 1000269001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
  STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
  STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
  /** Not promoted to 1.3 */
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
  STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
  STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 1000388000,
  STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 1000388001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
  STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
  STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
  STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
  STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
  STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
  STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
  STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
  STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
  STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
  STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 1000413000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 1000413001,
  STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 1000413002,
  STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 1000413003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
  STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
  STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
  STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
  STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
  STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
  STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
  STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
  STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
  STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
  STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
  STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
  STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
  STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
  STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
  STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
  STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
  STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
  STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
}

export enum SubpassContents {
  SUBPASS_CONTENTS_INLINE = 0,
  SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
}

/** API result codes */
export enum Result {
  /** Command completed successfully */
  SUCCESS = 0,
  /** A fence or query has not yet completed */
  NOT_READY = 1,
  /** A wait operation has not completed in the specified time */
  TIMEOUT = 2,
  /** An event is signaled */
  EVENT_SET = 3,
  /** An event is unsignaled */
  EVENT_RESET = 4,
  /** A return array was too small for the result */
  INCOMPLETE = 5,
  /** A host memory allocation has failed */
  ERROR_OUT_OF_HOST_MEMORY = -1,
  /** A device memory allocation has failed */
  ERROR_OUT_OF_DEVICE_MEMORY = -2,
  /** Initialization of an object has failed */
  ERROR_INITIALIZATION_FAILED = -3,
  /** The logical device has been lost. See <<devsandqueues-lost-device>> */
  ERROR_DEVICE_LOST = -4,
  /** Mapping of a memory object has failed */
  ERROR_MEMORY_MAP_FAILED = -5,
  /** Layer specified does not exist */
  ERROR_LAYER_NOT_PRESENT = -6,
  /** Extension specified does not exist */
  ERROR_EXTENSION_NOT_PRESENT = -7,
  /** Requested feature is not available on this device */
  ERROR_FEATURE_NOT_PRESENT = -8,
  /** Unable to find a Vulkan driver */
  ERROR_INCOMPATIBLE_DRIVER = -9,
  /** Too many objects of the type have already been created */
  ERROR_TOO_MANY_OBJECTS = -10,
  /** Requested format is not supported on this device */
  ERROR_FORMAT_NOT_SUPPORTED = -11,
  /** A requested pool allocation has failed due to fragmentation of the pool's memory */
  ERROR_FRAGMENTED_POOL = -12,
  /** An unknown error has occurred, due to an implementation or application bug */
  ERROR_UNKNOWN = -13,
  ERROR_OUT_OF_POOL_MEMORY = 1000069000,
  ERROR_INVALID_EXTERNAL_HANDLE = 1000072003,
  ERROR_FRAGMENTATION = 1000161000,
  ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = 1000257000,
  PIPELINE_COMPILE_REQUIRED = 1000297000,
  ERROR_SURFACE_LOST_KHR = 1000000000,
  ERROR_NATIVE_WINDOW_IN_USE_KHR = 1000000001,
  SUBOPTIMAL_KHR = 1000001003,
  ERROR_OUT_OF_DATE_KHR = 1000001004,
  ERROR_INCOMPATIBLE_DISPLAY_KHR = 1000003001,
  ERROR_VALIDATION_FAILED_EXT = 1000011001,
  ERROR_INVALID_SHADER_NV = 1000012000,
  ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = 1000023000,
  ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = 1000023001,
  ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = 1000023002,
  ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = 1000023003,
  ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = 1000023004,
  ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = 1000023005,
  ERROR_OUT_OF_POOL_MEMORY_KHR = 1000069000,
  ERROR_INVALID_EXTERNAL_HANDLE_KHR = 1000072003,
  ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = 1000158000,
  ERROR_FRAGMENTATION_EXT = 1000161000,
  ERROR_NOT_PERMITTED_EXT = 1000174001,
  ERROR_NOT_PERMITTED_KHR = 1000174001,
  ERROR_INVALID_DEVICE_ADDRESS_EXT = 1000257000,
  ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = 1000255000,
  ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = 1000257000,
  THREAD_IDLE_KHR = 1000268000,
  THREAD_DONE_KHR = 1000268001,
  OPERATION_DEFERRED_KHR = 1000268002,
  OPERATION_NOT_DEFERRED_KHR = 1000268003,
  PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
  ERROR_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
  ERROR_COMPRESSION_EXHAUSTED_EXT = 1000338000,
}

export enum DynamicState {
  DYNAMIC_STATE_VIEWPORT = 0,
  DYNAMIC_STATE_SCISSOR = 1,
  DYNAMIC_STATE_LINE_WIDTH = 2,
  DYNAMIC_STATE_DEPTH_BIAS = 3,
  DYNAMIC_STATE_BLEND_CONSTANTS = 4,
  DYNAMIC_STATE_DEPTH_BOUNDS = 5,
  DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
  DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
  DYNAMIC_STATE_STENCIL_REFERENCE = 8,
  DYNAMIC_STATE_CULL_MODE = 1000267000,
  DYNAMIC_STATE_FRONT_FACE = 1000267001,
  DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
  DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
  DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
  DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
  DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
  DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
  DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
  DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
  DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
  DYNAMIC_STATE_STENCIL_OP = 1000267011,
  DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
  DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
  DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
  DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
  DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
  DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
  DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
  DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
  DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
  DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
  DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
  DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
  DYNAMIC_STATE_CULL_MODE_EXT = 1000267000,
  DYNAMIC_STATE_FRONT_FACE_EXT = 1000267001,
  DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 1000267002,
  DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 1000267003,
  DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 1000267004,
  DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005,
  DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 1000267006,
  DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 1000267007,
  DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 1000267008,
  DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009,
  DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 1000267010,
  DYNAMIC_STATE_STENCIL_OP_EXT = 1000267011,
  DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
  /** Not promoted to 1.3 */
  DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
  DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = 1000377001,
  DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = 1000377002,
  /** Not promoted to 1.3 */
  DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
  DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = 1000377004,
  DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
  DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
  DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
  DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
  DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
  DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
  DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
  DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
  DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
  DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
  DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
  DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
  DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
  DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
  DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
  DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
  DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
  DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
  DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
  DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
  DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
  DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
  DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
  DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
  DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
  DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
  DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
  DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
  DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
  DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
  DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
  DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
}

export enum DescriptorUpdateTemplateType {
  /** Create descriptor update template for descriptor set updates */
  DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
  /** Create descriptor update template for pushed descriptor updates */
  DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
  DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0,
}

/** Enums to track objects of various types - also see objtypeenum attributes on type tags */
export enum ObjectType {
  OBJECT_TYPE_UNKNOWN = 0,
  OBJECT_TYPE_INSTANCE = 1,
  OBJECT_TYPE_PHYSICAL_DEVICE = 2,
  OBJECT_TYPE_DEVICE = 3,
  OBJECT_TYPE_QUEUE = 4,
  OBJECT_TYPE_SEMAPHORE = 5,
  OBJECT_TYPE_COMMAND_BUFFER = 6,
  OBJECT_TYPE_FENCE = 7,
  OBJECT_TYPE_DEVICE_MEMORY = 8,
  OBJECT_TYPE_BUFFER = 9,
  OBJECT_TYPE_IMAGE = 10,
  OBJECT_TYPE_EVENT = 11,
  OBJECT_TYPE_QUERY_POOL = 12,
  OBJECT_TYPE_BUFFER_VIEW = 13,
  OBJECT_TYPE_IMAGE_VIEW = 14,
  OBJECT_TYPE_SHADER_MODULE = 15,
  OBJECT_TYPE_PIPELINE_CACHE = 16,
  OBJECT_TYPE_PIPELINE_LAYOUT = 17,
  OBJECT_TYPE_RENDER_PASS = 18,
  OBJECT_TYPE_PIPELINE = 19,
  OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
  OBJECT_TYPE_SAMPLER = 21,
  OBJECT_TYPE_DESCRIPTOR_POOL = 22,
  OBJECT_TYPE_DESCRIPTOR_SET = 23,
  OBJECT_TYPE_FRAMEBUFFER = 24,
  OBJECT_TYPE_COMMAND_POOL = 25,
  OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
  OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
  OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
  OBJECT_TYPE_SURFACE_KHR = 1000000000,
  OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
  OBJECT_TYPE_DISPLAY_KHR = 1000002000,
  OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
  OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
  /** VkVideoSessionKHR */
  OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
  /** VkVideoSessionParametersKHR */
  OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
  OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
  OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
  OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
  OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
  OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
  OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
  OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
  OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
  OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
  OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = 1000295000,
  /** VkBufferCollectionFUCHSIA */
  OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
  OBJECT_TYPE_MICROMAP_EXT = 1000396000,
  OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
}

export enum RayTracingInvocationReorderModeNV {
  RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
  RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
}

export enum QueueFlagBits {
  /** Queue supports graphics operations */
  QUEUE_GRAPHICS_BIT = 1 << 0,
  /** Queue supports compute operations */
  QUEUE_COMPUTE_BIT = 1 << 1,
  /** Queue supports transfer operations */
  QUEUE_TRANSFER_BIT = 1 << 2,
  /** Queue supports sparse resource memory management operations */
  QUEUE_SPARSE_BINDING_BIT = 1 << 3,
  /** Queues may support protected operations */
  QUEUE_PROTECTED_BIT = 1 << 4,
  QUEUE_VIDEO_DECODE_BIT_KHR = 1 << 5,
  QUEUE_RESERVED_9_BIT_EXT = 1 << 9,
  QUEUE_VIDEO_ENCODE_BIT_KHR = 1 << 6,
  QUEUE_RESERVED_7_BIT_QCOM = 1 << 7,
  QUEUE_OPTICAL_FLOW_BIT_NV = 1 << 8,
}

export enum CullModeFlagBits {
  CULL_MODE_NONE = 0,
  CULL_MODE_FRONT_BIT = 1 << 0,
  CULL_MODE_BACK_BIT = 1 << 1,
  CULL_MODE_FRONT_AND_BACK = 3,
}

export enum RenderPassCreateFlagBits {
  RENDER_PASS_CREATE_RESERVED_0_BIT_KHR = 1 << 0,
  RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 1 << 1,
}

export enum DeviceQueueCreateFlagBits {
  /** Queue is a protected-capable device queue */
  DEVICE_QUEUE_CREATE_PROTECTED_BIT = 1 << 0,
  DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM = 1 << 1,
}

export enum MemoryPropertyFlagBits {
  /** If otherwise stated, then allocate memory on device */
  MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1 << 0,
  /** Memory is mappable by host */
  MEMORY_PROPERTY_HOST_VISIBLE_BIT = 1 << 1,
  /** Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache */
  MEMORY_PROPERTY_HOST_COHERENT_BIT = 1 << 2,
  /** Memory will be cached by the host */
  MEMORY_PROPERTY_HOST_CACHED_BIT = 1 << 3,
  /** Memory may be allocated by the driver when it is required */
  MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 1 << 4,
  /** Memory is protected */
  MEMORY_PROPERTY_PROTECTED_BIT = 1 << 5,
  MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 1 << 6,
  MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 1 << 7,
  MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 1 << 8,
}

export enum MemoryHeapFlagBits {
  /** If set, heap represents device memory */
  MEMORY_HEAP_DEVICE_LOCAL_BIT = 1 << 0,
  /** If set, heap allocations allocate multiple instances by default */
  MEMORY_HEAP_MULTI_INSTANCE_BIT = 1 << 1,
  MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = 1 << 1,
  MEMORY_HEAP_RESERVED_2_BIT_KHR = 1 << 2,
}

export enum AccessFlagBits {
  /** Controls coherency of indirect command reads */
  ACCESS_INDIRECT_COMMAND_READ_BIT = 1 << 0,
  /** Controls coherency of index reads */
  ACCESS_INDEX_READ_BIT = 1 << 1,
  /** Controls coherency of vertex attribute reads */
  ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 1 << 2,
  /** Controls coherency of uniform buffer reads */
  ACCESS_UNIFORM_READ_BIT = 1 << 3,
  /** Controls coherency of input attachment reads */
  ACCESS_INPUT_ATTACHMENT_READ_BIT = 1 << 4,
  /** Controls coherency of shader reads */
  ACCESS_SHADER_READ_BIT = 1 << 5,
  /** Controls coherency of shader writes */
  ACCESS_SHADER_WRITE_BIT = 1 << 6,
  /** Controls coherency of color attachment reads */
  ACCESS_COLOR_ATTACHMENT_READ_BIT = 1 << 7,
  /** Controls coherency of color attachment writes */
  ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 1 << 8,
  /** Controls coherency of depth/stencil attachment reads */
  ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 1 << 9,
  /** Controls coherency of depth/stencil attachment writes */
  ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1 << 10,
  /** Controls coherency of transfer reads */
  ACCESS_TRANSFER_READ_BIT = 1 << 11,
  /** Controls coherency of transfer writes */
  ACCESS_TRANSFER_WRITE_BIT = 1 << 12,
  /** Controls coherency of host reads */
  ACCESS_HOST_READ_BIT = 1 << 13,
  /** Controls coherency of host writes */
  ACCESS_HOST_WRITE_BIT = 1 << 14,
  /** Controls coherency of memory reads */
  ACCESS_MEMORY_READ_BIT = 1 << 15,
  /** Controls coherency of memory writes */
  ACCESS_MEMORY_WRITE_BIT = 1 << 16,
  ACCESS_NONE = 0,
  ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 1 << 25,
  ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 1 << 26,
  ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 1 << 27,
  /** read access flag for reading conditional rendering predicate */
  ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1 << 20,
  ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 1 << 19,
  ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 1 << 21,
  ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 1 << 22,
  ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 1 << 23,
  ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 1 << 21,
  ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 1 << 22,
  ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 1 << 24,
  ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 1 << 23,
  ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 1 << 17,
  ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 1 << 18,
  ACCESS_NONE_KHR = 0,
}

export enum BufferUsageFlagBits {
  /** Can be used as a source of transfer operations */
  BUFFER_USAGE_TRANSFER_SRC_BIT = 1 << 0,
  /** Can be used as a destination of transfer operations */
  BUFFER_USAGE_TRANSFER_DST_BIT = 1 << 1,
  /** Can be used as TBO */
  BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 1 << 2,
  /** Can be used as IBO */
  BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 1 << 3,
  /** Can be used as UBO */
  BUFFER_USAGE_UNIFORM_BUFFER_BIT = 1 << 4,
  /** Can be used as SSBO */
  BUFFER_USAGE_STORAGE_BUFFER_BIT = 1 << 5,
  /** Can be used as source of fixed-function index fetch (index buffer) */
  BUFFER_USAGE_INDEX_BUFFER_BIT = 1 << 6,
  /** Can be used as source of fixed-function vertex fetch (VBO) */
  BUFFER_USAGE_VERTEX_BUFFER_BIT = 1 << 7,
  /** Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer) */
  BUFFER_USAGE_INDIRECT_BUFFER_BIT = 1 << 8,
  BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 1 << 17,
  BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 1 << 13,
  BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 1 << 14,
  BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 1 << 11,
  BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 1 << 12,
  /** Specifies the buffer can be used as predicate in conditional rendering */
  BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 << 9,
  BUFFER_USAGE_RESERVED_25_BIT_AMD = 1 << 25,
  BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 1 << 19,
  BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 1 << 20,
  BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 1 << 10,
  BUFFER_USAGE_RAY_TRACING_BIT_NV = 1 << 10,
  BUFFER_USAGE_RESERVED_18_BIT_QCOM = 1 << 18,
  BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 1 << 17,
  BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = 1 << 17,
  BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 1 << 15,
  BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 1 << 16,
  BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 21,
  BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 22,
  BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 26,
  BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 1 << 23,
  BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 1 << 24,
}

export enum BufferCreateFlagBits {
  /** Buffer should support sparse backing */
  BUFFER_CREATE_SPARSE_BINDING_BIT = 1 << 0,
  /** Buffer should support sparse backing with partial residency */
  BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 1 << 1,
  /** Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers */
  BUFFER_CREATE_SPARSE_ALIASED_BIT = 1 << 2,
  /** Buffer requires protected memory */
  BUFFER_CREATE_PROTECTED_BIT = 1 << 3,
  BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 1 << 4,
  BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1 << 4,
  BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 4,
  BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 5,
}

export enum ShaderStageFlagBits {
  SHADER_STAGE_VERTEX_BIT = 1 << 0,
  SHADER_STAGE_TESSELLATION_CONTROL_BIT = 1 << 1,
  SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 1 << 2,
  SHADER_STAGE_GEOMETRY_BIT = 1 << 3,
  SHADER_STAGE_FRAGMENT_BIT = 1 << 4,
  SHADER_STAGE_COMPUTE_BIT = 1 << 5,
  SHADER_STAGE_ALL_GRAPHICS = 31,
  SHADER_STAGE_ALL = 2147483647,
  SHADER_STAGE_RAYGEN_BIT_KHR = 1 << 8,
  SHADER_STAGE_ANY_HIT_BIT_KHR = 1 << 9,
  SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 1 << 10,
  SHADER_STAGE_MISS_BIT_KHR = 1 << 11,
  SHADER_STAGE_INTERSECTION_BIT_KHR = 1 << 12,
  SHADER_STAGE_CALLABLE_BIT_KHR = 1 << 13,
  SHADER_STAGE_RAYGEN_BIT_NV = 1 << 8,
  SHADER_STAGE_ANY_HIT_BIT_NV = 1 << 9,
  SHADER_STAGE_CLOSEST_HIT_BIT_NV = 1 << 10,
  SHADER_STAGE_MISS_BIT_NV = 1 << 11,
  SHADER_STAGE_INTERSECTION_BIT_NV = 1 << 12,
  SHADER_STAGE_CALLABLE_BIT_NV = 1 << 13,
  SHADER_STAGE_TASK_BIT_NV = 1 << 6,
  SHADER_STAGE_MESH_BIT_NV = 1 << 7,
  SHADER_STAGE_TASK_BIT_EXT = 1 << 6,
  SHADER_STAGE_MESH_BIT_EXT = 1 << 7,
  SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 1 << 14,
  SHADER_STAGE_RESERVED_19_BIT_HUAWEI = 1 << 19,
  SHADER_STAGE_EXT_483_RESERVE_15 = 1 << 15,
  SHADER_STAGE_EXT_483_RESERVE_16 = 1 << 16,
  SHADER_STAGE_EXT_483_RESERVE_17 = 1 << 17,
}

export enum ImageUsageFlagBits {
  /** Can be used as a source of transfer operations */
  IMAGE_USAGE_TRANSFER_SRC_BIT = 1 << 0,
  /** Can be used as a destination of transfer operations */
  IMAGE_USAGE_TRANSFER_DST_BIT = 1 << 1,
  /** Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types) */
  IMAGE_USAGE_SAMPLED_BIT = 1 << 2,
  /** Can be used as storage image (STORAGE_IMAGE descriptor type) */
  IMAGE_USAGE_STORAGE_BIT = 1 << 3,
  /** Can be used as framebuffer color attachment */
  IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 1 << 4,
  /** Can be used as framebuffer depth/stencil attachment */
  IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 5,
  /** Image data not needed outside of rendering */
  IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 1 << 6,
  /** Can be used as framebuffer input attachment */
  IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 1 << 7,
  IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 1 << 10,
  IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 1 << 11,
  IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 1 << 12,
  IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 1 << 8,
  IMAGE_USAGE_RESERVED_16_BIT_QCOM = 1 << 16,
  IMAGE_USAGE_RESERVED_17_BIT_QCOM = 1 << 17,
  IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 9,
  IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 8,
  IMAGE_USAGE_RESERVED_22_BIT_EXT = 1 << 22,
  IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 1 << 13,
  IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 1 << 14,
  IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 15,
  IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 19,
  IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 1 << 18,
  IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 1 << 20,
  IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 1 << 21,
}

export enum ImageCreateFlagBits {
  /** Image should support sparse backing */
  IMAGE_CREATE_SPARSE_BINDING_BIT = 1 << 0,
  /** Image should support sparse backing with partial residency */
  IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 1 << 1,
  /** Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images */
  IMAGE_CREATE_SPARSE_ALIASED_BIT = 1 << 2,
  /** Allows image views to have different format than the base image */
  IMAGE_CREATE_MUTABLE_FORMAT_BIT = 1 << 3,
  /** Allows creating image views with cube type from the created image */
  IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 1 << 4,
  IMAGE_CREATE_ALIAS_BIT = 1 << 10,
  /** Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image */
  IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 1 << 6,
  /** The 3D image can be viewed as a 2D or 2D array image */
  IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 1 << 5,
  IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 1 << 7,
  IMAGE_CREATE_EXTENDED_USAGE_BIT = 1 << 8,
  /** Image requires protected memory */
  IMAGE_CREATE_PROTECTED_BIT = 1 << 11,
  IMAGE_CREATE_DISJOINT_BIT = 1 << 9,
  IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 1 << 13,
  IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1 << 6,
  IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 1 << 5,
  IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 1 << 7,
  IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = 1 << 8,
  IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 1 << 12,
  IMAGE_CREATE_DISJOINT_BIT_KHR = 1 << 9,
  IMAGE_CREATE_ALIAS_BIT_KHR = 1 << 10,
  IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 1 << 14,
  IMAGE_CREATE_RESERVED_19_BIT_EXT = 1 << 19,
  IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 16,
  IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 1 << 18,
  /** Image is created with a layout where individual slices are capable of being used as 2D images */
  IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 1 << 17,
  IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 1 << 15,
}

export enum ImageViewCreateFlagBits {
  IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1 << 0,
  IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 2,
  IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 1 << 1,
  IMAGE_VIEW_CREATE_RESERVED_3_BIT_EXT = 1 << 3,
}

export enum SamplerCreateFlagBits {
  SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 1 << 0,
  SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 1 << 1,
  SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 3,
  SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 1 << 2,
  SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 1 << 4,
}

/** Note that the gap at bitpos 10 is unused, and can be reserved */
export enum PipelineCreateFlagBits {
  PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1 << 0,
  PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 1 << 1,
  PIPELINE_CREATE_DERIVATIVE_BIT = 1 << 2,
  PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 1 << 3,
  PIPELINE_CREATE_DISPATCH_BASE_BIT = 1 << 4,
  PIPELINE_CREATE_DISPATCH_BASE = 1 << 4,
  PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 1 << 8,
  PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 1 << 9,
  PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 21,
  /** Backwards-compatible alias containing a typo */
  PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 21,
  PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 1 << 22,
  /** Backwards-compatible alias containing a typo */
  PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 1 << 22,
  PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 1 << 3,
  PIPELINE_CREATE_DISPATCH_BASE_KHR = PIPELINE_CREATE_DISPATCH_BASE_BIT,
  PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 1 << 14,
  PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 1 << 15,
  PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 1 << 16,
  PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 1 << 17,
  PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 1 << 12,
  PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 1 << 13,
  PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 1 << 19,
  PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 1 << 5,
  PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 1 << 6,
  PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 1 << 7,
  PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 1 << 18,
  PIPELINE_CREATE_LIBRARY_BIT_KHR = 1 << 11,
  PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 1 << 8,
  PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = 1 << 9,
  PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 29,
  PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 1 << 23,
  PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 1 << 10,
  PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 1 << 20,
  PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 25,
  PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 1 << 26,
  PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 1 << 24,
  PIPELINE_CREATE_RESERVED_BIT_28_NV = 1 << 28,
  PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 1 << 27,
  PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 1 << 30,
}

export enum PipelineShaderStageCreateFlagBits {
  PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 1 << 0,
  PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 1 << 1,
  PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 1 << 0,
  PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 1 << 1,
  PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR = 1 << 3,
}

export enum ColorComponentFlagBits {
  COLOR_COMPONENT_R_BIT = 1 << 0,
  COLOR_COMPONENT_G_BIT = 1 << 1,
  COLOR_COMPONENT_B_BIT = 1 << 2,
  COLOR_COMPONENT_A_BIT = 1 << 3,
}

export enum FenceCreateFlagBits {
  FENCE_CREATE_SIGNALED_BIT = 1 << 0,
}

export enum SemaphoreCreateFlagBits {
}

export enum FormatFeatureFlagBits {
  /** Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types) */
  FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1 << 0,
  /** Format can be used for storage images (STORAGE_IMAGE descriptor type) */
  FORMAT_FEATURE_STORAGE_IMAGE_BIT = 1 << 1,
  /** Format supports atomic operations in case it is used for storage images */
  FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 1 << 2,
  /** Format can be used for uniform texel buffers (TBOs) */
  FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 1 << 3,
  /** Format can be used for storage texel buffers (IBOs) */
  FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 1 << 4,
  /** Format supports atomic operations in case it is used for storage texel buffers */
  FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 1 << 5,
  /** Format can be used for vertex buffers (VBOs) */
  FORMAT_FEATURE_VERTEX_BUFFER_BIT = 1 << 6,
  /** Format can be used for color attachment images */
  FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 1 << 7,
  /** Format supports blending in case it is used for color attachment images */
  FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 1 << 8,
  /** Format can be used for depth/stencil attachment images */
  FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 9,
  /** Format can be used as the source image of blits with vkCmdBlitImage */
  FORMAT_FEATURE_BLIT_SRC_BIT = 1 << 10,
  /** Format can be used as the destination image of blits with vkCmdBlitImage */
  FORMAT_FEATURE_BLIT_DST_BIT = 1 << 11,
  /** Format can be filtered with VK_FILTER_LINEAR when being sampled */
  FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 1 << 12,
  /** Format can be used as the source image of image transfer commands */
  FORMAT_FEATURE_TRANSFER_SRC_BIT = 1 << 14,
  /** Format can be used as the destination image of image transfer commands */
  FORMAT_FEATURE_TRANSFER_DST_BIT = 1 << 15,
  /** Format can have midpoint rather than cosited chroma samples */
  FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 1 << 17,
  /** Format can be used with linear filtering whilst color conversion is enabled */
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 1 << 18,
  /** Format can have different chroma, min and mag filters */
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 1 << 19,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1 << 20,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 1 << 21,
  /** Format supports disjoint planes */
  FORMAT_FEATURE_DISJOINT_BIT = 1 << 22,
  /** Format can have cosited rather than midpoint chroma samples */
  FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 1 << 23,
  /** Format can be used with min/max reduction filtering */
  FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 1 << 16,
  /** Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled */
  FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 1 << 13,
  FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 1 << 25,
  FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 1 << 26,
  FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 1 << 14,
  FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 1 << 15,
  FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 1 << 16,
  FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 1 << 29,
  FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 1 << 17,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 1 << 18,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 1 << 19,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1 << 20,
  FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 1 << 21,
  FORMAT_FEATURE_DISJOINT_BIT_KHR = 1 << 22,
  FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = 1 << 23,
  FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 1 << 13,
  FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 24,
  FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 30,
  FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 1 << 27,
  FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 28,
}

export enum QueryControlFlagBits {
  /** Require precise results to be collected by the query */
  QUERY_CONTROL_PRECISE_BIT = 1 << 0,
}

export enum QueryResultFlagBits {
  /** Results of the queries are written to the destination buffer as 64-bit values */
  QUERY_RESULT_64_BIT = 1 << 0,
  /** Results of the queries are waited on before proceeding with the result copy */
  QUERY_RESULT_WAIT_BIT = 1 << 1,
  /** Besides the results of the query, the availability of the results is also written */
  QUERY_RESULT_WITH_AVAILABILITY_BIT = 1 << 2,
  /** Copy the partial results of the query even if the final results are not available */
  QUERY_RESULT_PARTIAL_BIT = 1 << 3,
  QUERY_RESULT_WITH_STATUS_BIT_KHR = 1 << 4,
}

export enum CommandBufferUsageFlagBits {
  COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1 << 0,
  COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 1 << 1,
  /** Command buffer may be submitted/executed more than once simultaneously */
  COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 1 << 2,
}

export enum QueryPipelineStatisticFlagBits {
  /** Optional */
  QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1 << 0,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 1 << 1,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 1 << 2,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 1 << 3,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 1 << 4,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 1 << 5,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 1 << 6,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 1 << 7,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 1 << 8,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 1 << 9,
  /** Optional */
  QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1 << 10,
  QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 1 << 11,
  QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 1 << 12,
}

export enum ImageAspectFlagBits {
  IMAGE_ASPECT_COLOR_BIT = 1 << 0,
  IMAGE_ASPECT_DEPTH_BIT = 1 << 1,
  IMAGE_ASPECT_STENCIL_BIT = 1 << 2,
  IMAGE_ASPECT_METADATA_BIT = 1 << 3,
  IMAGE_ASPECT_PLANE_0_BIT = 1 << 4,
  IMAGE_ASPECT_PLANE_1_BIT = 1 << 5,
  IMAGE_ASPECT_PLANE_2_BIT = 1 << 6,
  IMAGE_ASPECT_NONE = 0,
  IMAGE_ASPECT_PLANE_0_BIT_KHR = 1 << 4,
  IMAGE_ASPECT_PLANE_1_BIT_KHR = 1 << 5,
  IMAGE_ASPECT_PLANE_2_BIT_KHR = 1 << 6,
  IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 1 << 7,
  IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 1 << 8,
  IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 1 << 9,
  IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 1 << 10,
  IMAGE_ASPECT_NONE_KHR = 0,
}

export enum SparseImageFormatFlagBits {
  /** Image uses a single mip tail region for all array layers */
  SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1 << 0,
  /** Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels. */
  SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 1 << 1,
  /** Image uses a non-standard sparse image block dimensions */
  SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 1 << 2,
}

export enum SparseMemoryBindFlagBits {
  /** Operation binds resource metadata to memory */
  SPARSE_MEMORY_BIND_METADATA_BIT = 1 << 0,
}

export enum PipelineStageFlagBits {
  /** Before subsequent commands are processed */
  PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1 << 0,
  /** Draw/DispatchIndirect command fetch */
  PIPELINE_STAGE_DRAW_INDIRECT_BIT = 1 << 1,
  /** Vertex/index fetch */
  PIPELINE_STAGE_VERTEX_INPUT_BIT = 1 << 2,
  /** Vertex shading */
  PIPELINE_STAGE_VERTEX_SHADER_BIT = 1 << 3,
  /** Tessellation control shading */
  PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 1 << 4,
  /** Tessellation evaluation shading */
  PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 1 << 5,
  /** Geometry shading */
  PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 1 << 6,
  /** Fragment shading */
  PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 1 << 7,
  /** Early fragment (depth and stencil) tests */
  PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 1 << 8,
  /** Late fragment (depth and stencil) tests */
  PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 1 << 9,
  /** Color attachment writes */
  PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1 << 10,
  /** Compute shading */
  PIPELINE_STAGE_COMPUTE_SHADER_BIT = 1 << 11,
  /** Transfer/copy operations */
  PIPELINE_STAGE_TRANSFER_BIT = 1 << 12,
  /** After previous commands have completed */
  PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 1 << 13,
  /** Indicates host (CPU) is a source/sink of the dependency */
  PIPELINE_STAGE_HOST_BIT = 1 << 14,
  /** All stages of the graphics pipeline */
  PIPELINE_STAGE_ALL_GRAPHICS_BIT = 1 << 15,
  /** All stages supported on the queue */
  PIPELINE_STAGE_ALL_COMMANDS_BIT = 1 << 16,
  PIPELINE_STAGE_NONE = 0,
  PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 1 << 24,
  /** A pipeline stage for conditional rendering predicate fetch */
  PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 << 18,
  PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 1 << 25,
  PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 1 << 21,
  PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 1 << 22,
  PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 1 << 21,
  PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 1 << 25,
  PIPELINE_STAGE_TASK_SHADER_BIT_NV = 1 << 19,
  PIPELINE_STAGE_MESH_SHADER_BIT_NV = 1 << 20,
  PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 1 << 23,
  PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 22,
  PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 1 << 17,
  PIPELINE_STAGE_NONE_KHR = 0,
  PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 1 << 19,
  PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 1 << 20,
}

export enum CommandPoolCreateFlagBits {
  /** Command buffers have a short lifetime */
  COMMAND_POOL_CREATE_TRANSIENT_BIT = 1 << 0,
  /** Command buffers may release their memory individually */
  COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 1 << 1,
  /** Command buffers allocated from pool are protected command buffers */
  COMMAND_POOL_CREATE_PROTECTED_BIT = 1 << 2,
}

export enum CommandPoolResetFlagBits {
  /** Release resources owned by the pool */
  COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1 << 0,
  COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI = 1 << 1,
}

export enum CommandBufferResetFlagBits {
  /** Release resources owned by the buffer */
  COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1 << 0,
}

export enum SampleCountFlagBits {
  /** Sample count 1 supported */
  SAMPLE_COUNT_1_BIT = 1 << 0,
  /** Sample count 2 supported */
  SAMPLE_COUNT_2_BIT = 1 << 1,
  /** Sample count 4 supported */
  SAMPLE_COUNT_4_BIT = 1 << 2,
  /** Sample count 8 supported */
  SAMPLE_COUNT_8_BIT = 1 << 3,
  /** Sample count 16 supported */
  SAMPLE_COUNT_16_BIT = 1 << 4,
  /** Sample count 32 supported */
  SAMPLE_COUNT_32_BIT = 1 << 5,
  /** Sample count 64 supported */
  SAMPLE_COUNT_64_BIT = 1 << 6,
}

export enum AttachmentDescriptionFlagBits {
  /** The attachment may alias physical memory of another attachment in the same render pass */
  ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1 << 0,
}

export enum StencilFaceFlagBits {
  /** Front face */
  STENCIL_FACE_FRONT_BIT = 1 << 0,
  /** Back face */
  STENCIL_FACE_BACK_BIT = 1 << 1,
  /** Front and back faces */
  STENCIL_FACE_FRONT_AND_BACK = 3,
  /** Backwards-compatible alias containing a typo */
  STENCIL_FRONT_AND_BACK = 3,
}

export enum DescriptorPoolCreateFlagBits {
  /** Descriptor sets may be freed individually */
  DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1 << 0,
  DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 1 << 1,
  DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 1 << 1,
  DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 1 << 2,
  DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 1 << 2,
}

export enum DependencyFlagBits {
  /** Dependency is per pixel region */
  DEPENDENCY_BY_REGION_BIT = 1 << 0,
  /** Dependency is across devices */
  DEPENDENCY_DEVICE_GROUP_BIT = 1 << 2,
  DEPENDENCY_VIEW_LOCAL_BIT = 1 << 1,
  DEPENDENCY_VIEW_LOCAL_BIT_KHR = 1 << 1,
  DEPENDENCY_DEVICE_GROUP_BIT_KHR = 1 << 2,
  /** Dependency may be a feedback loop */
  DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 1 << 3,
}

export enum SemaphoreType {
  SEMAPHORE_TYPE_BINARY = 0,
  SEMAPHORE_TYPE_TIMELINE = 1,
  SEMAPHORE_TYPE_BINARY_KHR = 0,
  SEMAPHORE_TYPE_TIMELINE_KHR = 1,
}

export enum SemaphoreWaitFlagBits {
  SEMAPHORE_WAIT_ANY_BIT = 1 << 0,
  SEMAPHORE_WAIT_ANY_BIT_KHR = 1 << 0,
}

export enum PresentModeKHR {
  PRESENT_MODE_IMMEDIATE_KHR = 0,
  PRESENT_MODE_MAILBOX_KHR = 1,
  PRESENT_MODE_FIFO_KHR = 2,
  PRESENT_MODE_FIFO_RELAXED_KHR = 3,
  PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
  PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
}

export enum ColorSpaceKHR {
  COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
  /** Backwards-compatible alias containing a typo */
  COLORSPACE_SRGB_NONLINEAR_KHR = 0,
  COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
  COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
  COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
  COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
  COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
  COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
  COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
  COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
  COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
  COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
  COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
  COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
  COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
  COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
  /** Backwards-compatible alias containing a typo */
  COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
  COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
}

export enum DisplayPlaneAlphaFlagBitsKHR {
  DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1 << 0,
  DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 1 << 1,
  DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 1 << 2,
  DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 1 << 3,
}

export enum CompositeAlphaFlagBitsKHR {
  COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1 << 0,
  COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 1 << 1,
  COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 1 << 2,
  COMPOSITE_ALPHA_INHERIT_BIT_KHR = 1 << 3,
}

export enum SurfaceTransformFlagBitsKHR {
  SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1 << 0,
  SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 1 << 1,
  SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 1 << 2,
  SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 1 << 3,
  SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 1 << 4,
  SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 1 << 5,
  SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 1 << 6,
  SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 1 << 7,
  SURFACE_TRANSFORM_INHERIT_BIT_KHR = 1 << 8,
}

export enum SwapchainImageUsageFlagBitsANDROID {
  SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 1 << 0,
}

export enum TimeDomainEXT {
  TIME_DOMAIN_DEVICE_EXT = 0,
  TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
  TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
  TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
}

export enum DebugReportFlagBitsEXT {
  DEBUG_REPORT_INFORMATION_BIT_EXT = 1 << 0,
  DEBUG_REPORT_WARNING_BIT_EXT = 1 << 1,
  DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 1 << 2,
  DEBUG_REPORT_ERROR_BIT_EXT = 1 << 3,
  DEBUG_REPORT_DEBUG_BIT_EXT = 1 << 4,
}

export enum DebugReportObjectTypeEXT {
  DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
  DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
  DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
  DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
  DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
  DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
  DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
  DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
  DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
  DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
  DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
  DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
  DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
  DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
  DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
  DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
  DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
  DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
  DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
  DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
  DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
  DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
  DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
  DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
  DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
  DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
  DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
  DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
  /** Backwards-compatible alias containing a typo */
  DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
  DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
  DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
  DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
  /** Backwards-compatible alias containing a typo */
  DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = 33,
  DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
  DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
  DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
  DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
  DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,
  DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
  DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
  DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
  DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
}

export enum DeviceMemoryReportEventTypeEXT {
  DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
  DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
  DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
  DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
  DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
}

export enum RasterizationOrderAMD {
  RASTERIZATION_ORDER_STRICT_AMD = 0,
  RASTERIZATION_ORDER_RELAXED_AMD = 1,
}

export enum ExternalMemoryHandleTypeFlagBitsNV {
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1 << 0,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 1 << 1,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 1 << 2,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 1 << 3,
}

export enum ExternalMemoryFeatureFlagBitsNV {
  EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1 << 0,
  EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 1 << 1,
  EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 1 << 2,
}

export enum ValidationCheckEXT {
  VALIDATION_CHECK_ALL_EXT = 0,
  VALIDATION_CHECK_SHADERS_EXT = 1,
}

export enum ValidationFeatureEnableEXT {
  VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
  VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
  VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
  VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
  VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
}

export enum ValidationFeatureDisableEXT {
  VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
  VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
  VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
  VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
  VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
  VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
  VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
  VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
}

export enum SubgroupFeatureFlagBits {
  /** Basic subgroup operations */
  SUBGROUP_FEATURE_BASIC_BIT = 1 << 0,
  /** Vote subgroup operations */
  SUBGROUP_FEATURE_VOTE_BIT = 1 << 1,
  /** Arithmetic subgroup operations */
  SUBGROUP_FEATURE_ARITHMETIC_BIT = 1 << 2,
  /** Ballot subgroup operations */
  SUBGROUP_FEATURE_BALLOT_BIT = 1 << 3,
  /** Shuffle subgroup operations */
  SUBGROUP_FEATURE_SHUFFLE_BIT = 1 << 4,
  /** Shuffle relative subgroup operations */
  SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 1 << 5,
  /** Clustered subgroup operations */
  SUBGROUP_FEATURE_CLUSTERED_BIT = 1 << 6,
  /** Quad subgroup operations */
  SUBGROUP_FEATURE_QUAD_BIT = 1 << 7,
  SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 1 << 8,
}

export enum IndirectCommandsLayoutUsageFlagBitsNV {
  INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 1 << 0,
  INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 1 << 1,
  INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 1 << 2,
}

export enum IndirectStateFlagBitsNV {
  INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 1 << 0,
}

export enum IndirectCommandsTokenTypeNV {
  INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
  INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
  INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
  INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
  INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
  INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
  INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
  INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
  INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
}

export enum PrivateDataSlotCreateFlagBits {
}

export enum DescriptorSetLayoutCreateFlagBits {
  DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 1 << 1,
  /** Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR */
  DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 1 << 0,
  DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 1 << 1,
  DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 1 << 4,
  DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 1 << 5,
  DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD = 1 << 3,
  DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 1 << 2,
  DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 1 << 2,
}

export enum ExternalMemoryHandleTypeFlagBits {
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 1 << 3,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 1 << 4,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 1 << 5,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 1 << 6,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 1 << 3,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 1 << 4,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 1 << 5,
  EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 1 << 6,
  EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 1 << 9,
  EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1 << 10,
  EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 1 << 7,
  EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 1 << 8,
  EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 1 << 11,
  EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 1 << 12,
  EXTERNAL_MEMORY_HANDLE_TYPE_RESERVED_13_BIT_NV = 1 << 13,
}

export enum ExternalMemoryFeatureFlagBits {
  EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1 << 0,
  EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 1 << 1,
  EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 1 << 2,
  EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 1 << 0,
  EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 1 << 1,
  EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 1 << 2,
}

export enum ExternalSemaphoreHandleTypeFlagBits {
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 1 << 3,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = 1 << 3,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 1 << 4,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 1 << 3,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 1 << 4,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 1 << 7,
  EXTERNAL_SEMAPHORE_HANDLE_TYPE_RESERVED_5_BIT_NV = 1 << 5,
}

export enum ExternalSemaphoreFeatureFlagBits {
  EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1 << 0,
  EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 1 << 1,
  EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 1 << 0,
  EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 1 << 1,
}

export enum SemaphoreImportFlagBits {
  SEMAPHORE_IMPORT_TEMPORARY_BIT = 1 << 0,
  SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 1 << 0,
}

export enum ExternalFenceHandleTypeFlagBits {
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1 << 0,
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 << 1,
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 << 2,
  EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 1 << 3,
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1 << 0,
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 1 << 1,
  EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 1 << 2,
  EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 1 << 3,
  EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_4_BIT_NV = 1 << 4,
  EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_5_BIT_NV = 1 << 5,
}

export enum ExternalFenceFeatureFlagBits {
  EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1 << 0,
  EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 1 << 1,
  EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 1 << 0,
  EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 1 << 1,
}

export enum FenceImportFlagBits {
  FENCE_IMPORT_TEMPORARY_BIT = 1 << 0,
  FENCE_IMPORT_TEMPORARY_BIT_KHR = 1 << 0,
}

export enum SurfaceCounterFlagBitsEXT {
  SURFACE_COUNTER_VBLANK_BIT_EXT = 1 << 0,
  /** Backwards-compatible alias containing a typo */
  SURFACE_COUNTER_VBLANK_EXT = 1 << 0,
}

export enum DisplayPowerStateEXT {
  DISPLAY_POWER_STATE_OFF_EXT = 0,
  DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
  DISPLAY_POWER_STATE_ON_EXT = 2,
}

export enum DeviceEventTypeEXT {
  DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
}

export enum DisplayEventTypeEXT {
  DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
}

export enum PeerMemoryFeatureFlagBits {
  /** Can read with vkCmdCopy commands */
  PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1 << 0,
  /** Can write with vkCmdCopy commands */
  PEER_MEMORY_FEATURE_COPY_DST_BIT = 1 << 1,
  /** Can read with any access type/command */
  PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 1 << 2,
  /** Can write with and access type/command */
  PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 1 << 3,
  PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = 1 << 0,
  PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = 1 << 1,
  PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = 1 << 2,
  PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = 1 << 3,
}

export enum MemoryAllocateFlagBits {
  /** Force allocation on specific devices */
  MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1 << 0,
  MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 1 << 1,
  MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 1 << 2,
  MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = 1 << 0,
  MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = 1 << 1,
  MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 2,
}

export enum DeviceGroupPresentModeFlagBitsKHR {
  /** Present from local memory */
  DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1 << 0,
  /** Present from remote memory */
  DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 1 << 1,
  /** Present sum of local and/or remote memory */
  DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 1 << 2,
  /** Each physical device presents from local memory */
  DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 1 << 3,
}

export enum SwapchainCreateFlagBitsKHR {
  /** Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT */
  SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1 << 0,
  /** Swapchain is protected */
  SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 1 << 1,
  SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 1 << 2,
  SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT = 1 << 4,
  SWAPCHAIN_CREATE_RESERVED_3_BIT_SEC = 1 << 3,
}

export enum ViewportCoordinateSwizzleNV {
  VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
  VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
  VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
  VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
  VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
  VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
  VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
  VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
}

export enum DiscardRectangleModeEXT {
  DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
  DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}

export enum SubpassDescriptionFlagBits {
  SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 1 << 0,
  SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 1 << 1,
  SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 1 << 2,
  SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 1 << 3,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 1 << 4,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 1 << 5,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 1 << 6,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 1 << 4,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 1 << 5,
  SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 1 << 6,
  SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 1 << 7,
}

export enum PointClippingBehavior {
  POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
  POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
  POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = 0,
  POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = 1,
}

export enum SamplerReductionMode {
  SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
  SAMPLER_REDUCTION_MODE_MIN = 1,
  SAMPLER_REDUCTION_MODE_MAX = 2,
  SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
  SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
  SAMPLER_REDUCTION_MODE_MAX_EXT = 2,
}

export enum TessellationDomainOrigin {
  TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
  TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
  TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = 0,
  TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = 1,
}

export enum SamplerYcbcrModelConversion {
  SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
  /** just range expansion */
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
  /** aka HD YUV */
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
  /** aka SD YUV */
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
  /** aka UHD YUV */
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
  SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = 0,
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = 1,
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = 2,
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = 3,
  SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = 4,
}

export enum SamplerYcbcrRange {
  /** Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped) */
  SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
  /** Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240 */
  SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
  SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = 0,
  SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = 1,
}

export enum ChromaLocation {
  CHROMA_LOCATION_COSITED_EVEN = 0,
  CHROMA_LOCATION_MIDPOINT = 1,
  CHROMA_LOCATION_COSITED_EVEN_KHR = 0,
  CHROMA_LOCATION_MIDPOINT_KHR = 1,
}

export enum BlendOverlapEXT {
  BLEND_OVERLAP_UNCORRELATED_EXT = 0,
  BLEND_OVERLAP_DISJOINT_EXT = 1,
  BLEND_OVERLAP_CONJOINT_EXT = 2,
}

export enum CoverageModulationModeNV {
  COVERAGE_MODULATION_MODE_NONE_NV = 0,
  COVERAGE_MODULATION_MODE_RGB_NV = 1,
  COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
  COVERAGE_MODULATION_MODE_RGBA_NV = 3,
}

export enum CoverageReductionModeNV {
  COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
  COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
}

export enum ValidationCacheHeaderVersionEXT {
  VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
}

export enum ShaderInfoTypeAMD {
  SHADER_INFO_TYPE_STATISTICS_AMD = 0,
  SHADER_INFO_TYPE_BINARY_AMD = 1,
  SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
}

export enum QueueGlobalPriorityKHR {
  QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128,
  QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256,
  QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512,
  QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024,
  QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
  QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
  QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
  QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024,
}

export enum DebugUtilsMessageSeverityFlagBitsEXT {
  DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1 << 0,
  DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 1 << 4,
  DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 1 << 8,
  DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 1 << 12,
}

export enum DebugUtilsMessageTypeFlagBitsEXT {
  DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1 << 0,
  DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 1 << 1,
  DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 1 << 2,
  DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 1 << 3,
}

export enum ConservativeRasterizationModeEXT {
  CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
  CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
  CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
}

export enum DescriptorBindingFlagBits {
  DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1 << 0,
  DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 1 << 1,
  DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 1 << 2,
  DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 1 << 3,
  DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 1 << 0,
  DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 1 << 1,
  DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 1 << 2,
  DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 1 << 3,
  DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM = 1 << 4,
}

export enum VendorId {
  /** Vivante vendor ID */
  VENDOR_ID_VIV = 65537,
  /** VeriSilicon vendor ID */
  VENDOR_ID_VSI = 65538,
  /** Kazan Software Renderer */
  VENDOR_ID_KAZAN = 65539,
  /** Codeplay Software Ltd. vendor ID */
  VENDOR_ID_CODEPLAY = 65540,
  /** Mesa vendor ID */
  VENDOR_ID_MESA = 65541,
  /** PoCL vendor ID */
  VENDOR_ID_POCL = 65542,
}

export enum DriverId {
  /** Advanced Micro Devices, Inc. */
  DRIVER_ID_AMD_PROPRIETARY = 1,
  /** Advanced Micro Devices, Inc. */
  DRIVER_ID_AMD_OPEN_SOURCE = 2,
  /** Mesa open source project */
  DRIVER_ID_MESA_RADV = 3,
  /** NVIDIA Corporation */
  DRIVER_ID_NVIDIA_PROPRIETARY = 4,
  /** Intel Corporation */
  DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
  /** Intel Corporation */
  DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
  /** Imagination Technologies */
  DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
  /** Qualcomm Technologies, Inc. */
  DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
  /** Arm Limited */
  DRIVER_ID_ARM_PROPRIETARY = 9,
  /** Google LLC */
  DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
  /** Google LLC */
  DRIVER_ID_GGP_PROPRIETARY = 11,
  /** Broadcom Inc. */
  DRIVER_ID_BROADCOM_PROPRIETARY = 12,
  /** Mesa */
  DRIVER_ID_MESA_LLVMPIPE = 13,
  /** MoltenVK */
  DRIVER_ID_MOLTENVK = 14,
  /** Core Avionics & Industrial Inc. */
  DRIVER_ID_COREAVI_PROPRIETARY = 15,
  /** Juice Technologies, Inc. */
  DRIVER_ID_JUICE_PROPRIETARY = 16,
  /** Verisilicon, Inc. */
  DRIVER_ID_VERISILICON_PROPRIETARY = 17,
  /** Mesa open source project */
  DRIVER_ID_MESA_TURNIP = 18,
  /** Mesa open source project */
  DRIVER_ID_MESA_V3DV = 19,
  /** Mesa open source project */
  DRIVER_ID_MESA_PANVK = 20,
  /** Samsung Electronics Co., Ltd. */
  DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
  /** Mesa open source project */
  DRIVER_ID_MESA_VENUS = 22,
  /** Mesa open source project */
  DRIVER_ID_MESA_DOZEN = 23,
  /** Mesa open source project */
  DRIVER_ID_MESA_NVK = 24,
  DRIVER_ID_AMD_PROPRIETARY_KHR = 1,
  DRIVER_ID_AMD_OPEN_SOURCE_KHR = 2,
  DRIVER_ID_MESA_RADV_KHR = 3,
  DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 4,
  DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 5,
  DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 6,
  DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 7,
  DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 8,
  DRIVER_ID_ARM_PROPRIETARY_KHR = 9,
  DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = 10,
  DRIVER_ID_GGP_PROPRIETARY_KHR = 11,
  DRIVER_ID_BROADCOM_PROPRIETARY_KHR = 12,
}

export enum ConditionalRenderingFlagBitsEXT {
  CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1 << 0,
}

export enum ResolveModeFlagBits {
  RESOLVE_MODE_NONE = 0,
  RESOLVE_MODE_SAMPLE_ZERO_BIT = 1 << 0,
  RESOLVE_MODE_AVERAGE_BIT = 1 << 1,
  RESOLVE_MODE_MIN_BIT = 1 << 2,
  RESOLVE_MODE_MAX_BIT = 1 << 3,
  RESOLVE_MODE_NONE_KHR = 0,
  RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 1 << 0,
  RESOLVE_MODE_AVERAGE_BIT_KHR = 1 << 1,
  RESOLVE_MODE_MIN_BIT_KHR = 1 << 2,
  RESOLVE_MODE_MAX_BIT_KHR = 1 << 3,
}

export enum ShadingRatePaletteEntryNV {
  SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
  SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
  SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
  SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
  SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
  SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
}

export enum CoarseSampleOrderTypeNV {
  COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
  COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
  COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
  COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
}

export enum GeometryInstanceFlagBitsKHR {
  GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1 << 0,
  GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 1 << 1,
  GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 1 << 2,
  GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 1 << 3,
  GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = 1 << 1,
  GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 1 << 0,
  GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
  GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 1 << 2,
  GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 1 << 3,
  GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 1 << 4,
  GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 1 << 5,
}

export enum GeometryFlagBitsKHR {
  GEOMETRY_OPAQUE_BIT_KHR = 1 << 0,
  GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 1 << 1,
  GEOMETRY_OPAQUE_BIT_NV = 1 << 0,
  GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 1 << 1,
}

export enum BuildAccelerationStructureFlagBitsKHR {
  BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 1 << 0,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 1 << 1,
  BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 1 << 2,
  BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 1 << 3,
  BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 1 << 4,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 1 << 0,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 1 << 1,
  BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 1 << 2,
  BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 1 << 3,
  BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 1 << 4,
  BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 1 << 5,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 1 << 6,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 1 << 7,
  BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 1 << 8,
  BUILD_ACCELERATION_STRUCTURE_RESERVED_BIT_9_NV = 1 << 9,
  BUILD_ACCELERATION_STRUCTURE_RESERVED_BIT_10_NV = 1 << 10,
}

export enum AccelerationStructureCreateFlagBitsKHR {
  ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1 << 0,
  ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 1 << 3,
  ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 1 << 2,
}

export enum CopyAccelerationStructureModeKHR {
  COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
  COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
  COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
  COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
  COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0,
  COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 1,
}

export enum BuildAccelerationStructureModeKHR {
  BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
  BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
}

export enum AccelerationStructureTypeKHR {
  ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
  ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
  ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
  ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0,
  ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 1,
}

export enum GeometryTypeKHR {
  GEOMETRY_TYPE_TRIANGLES_KHR = 0,
  GEOMETRY_TYPE_AABBS_KHR = 1,
  GEOMETRY_TYPE_INSTANCES_KHR = 2,
  GEOMETRY_TYPE_TRIANGLES_NV = 0,
  GEOMETRY_TYPE_AABBS_NV = 1,
}

export enum AccelerationStructureMemoryRequirementsTypeNV {
  ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
  ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
  ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
}

export enum AccelerationStructureBuildTypeKHR {
  ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
  ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
  ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
}

export enum RayTracingShaderGroupTypeKHR {
  RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
  RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
  RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
  RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0,
  RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 1,
  RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 2,
}

export enum AccelerationStructureCompatibilityKHR {
  ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
  ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
}

export enum ShaderGroupShaderKHR {
  SHADER_GROUP_SHADER_GENERAL_KHR = 0,
  SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
  SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
  SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
}

export enum MemoryOverallocationBehaviorAMD {
  MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
  MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
  MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
}

export enum FramebufferCreateFlagBits {
  FRAMEBUFFER_CREATE_IMAGELESS_BIT = 1 << 0,
  FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 1 << 0,
}

export enum ScopeNV {
  SCOPE_DEVICE_NV = 1,
  SCOPE_WORKGROUP_NV = 2,
  SCOPE_SUBGROUP_NV = 3,
  SCOPE_QUEUE_FAMILY_NV = 5,
}

export enum ComponentTypeNV {
  COMPONENT_TYPE_FLOAT16_NV = 0,
  COMPONENT_TYPE_FLOAT32_NV = 1,
  COMPONENT_TYPE_FLOAT64_NV = 2,
  COMPONENT_TYPE_SINT8_NV = 3,
  COMPONENT_TYPE_SINT16_NV = 4,
  COMPONENT_TYPE_SINT32_NV = 5,
  COMPONENT_TYPE_SINT64_NV = 6,
  COMPONENT_TYPE_UINT8_NV = 7,
  COMPONENT_TYPE_UINT16_NV = 8,
  COMPONENT_TYPE_UINT32_NV = 9,
  COMPONENT_TYPE_UINT64_NV = 10,
}

export enum DeviceDiagnosticsConfigFlagBitsNV {
  DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1 << 0,
  DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 1 << 1,
  DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 1 << 2,
  DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 1 << 3,
}

export enum PipelineCreationFeedbackFlagBits {
  PIPELINE_CREATION_FEEDBACK_VALID_BIT = 1 << 0,
  PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1 << 0,
  PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 1 << 1,
  PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 1 << 1,
  PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 1 << 2,
  PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 1 << 2,
}

export enum FullScreenExclusiveEXT {
  FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
  FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
  FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
  FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
}

export enum PerformanceCounterScopeKHR {
  PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
  PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
  PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
  /** Backwards-compatible alias containing a typo */
  QUERY_SCOPE_COMMAND_BUFFER_KHR = 0,
  /** Backwards-compatible alias containing a typo */
  QUERY_SCOPE_RENDER_PASS_KHR = 1,
  /** Backwards-compatible alias containing a typo */
  QUERY_SCOPE_COMMAND_KHR = 2,
}

export enum MemoryDecompressionMethodFlagBitsNV {
  MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = 1 << 0,
}

export enum PerformanceCounterUnitKHR {
  PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
  PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
  PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
  PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
  PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
  PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
  PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
  PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
  PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
  PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
  PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
}

export enum PerformanceCounterStorageKHR {
  PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
  PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
  PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
  PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
  PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
  PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
}

export enum PerformanceCounterDescriptionFlagBitsKHR {
  PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 1 << 0,
  /** Backwards-compatible alias containing a typo */
  PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 1 << 0,
  PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 1 << 1,
  /** Backwards-compatible alias containing a typo */
  PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 1 << 1,
}

export enum AcquireProfilingLockFlagBitsKHR {
}

export enum ShaderCorePropertiesFlagBitsAMD {
}

export enum PerformanceConfigurationTypeINTEL {
  PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}

export enum QueryPoolSamplingModeINTEL {
  QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
}

export enum PerformanceOverrideTypeINTEL {
  PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
  PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
}

export enum PerformanceParameterTypeINTEL {
  PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
  PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
}

export enum PerformanceValueTypeINTEL {
  PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
  PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
  PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
  PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
  PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
}

export enum ShaderFloatControlsIndependence {
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = 0,
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = 1,
  SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = 2,
}

export enum PipelineExecutableStatisticFormatKHR {
  PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
  PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
  PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
  PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
}

export enum LineRasterizationModeEXT {
  LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
  LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
  LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
  LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
}

export enum ShaderModuleCreateFlagBits {
}

export enum PipelineCompilerControlFlagBitsAMD {
}

export enum ToolPurposeFlagBits {
  TOOL_PURPOSE_VALIDATION_BIT = 1 << 0,
  TOOL_PURPOSE_VALIDATION_BIT_EXT = 1 << 0,
  TOOL_PURPOSE_PROFILING_BIT = 1 << 1,
  TOOL_PURPOSE_PROFILING_BIT_EXT = 1 << 1,
  TOOL_PURPOSE_TRACING_BIT = 1 << 2,
  TOOL_PURPOSE_TRACING_BIT_EXT = 1 << 2,
  TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 1 << 3,
  TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 1 << 3,
  TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 1 << 4,
  TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 1 << 4,
  TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 1 << 5,
  TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 1 << 6,
}

export enum FragmentShadingRateCombinerOpKHR {
  FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
  FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
  FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
  FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
  FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
}

export enum FragmentShadingRateNV {
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
  FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
  FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
  FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
  FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
  FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
}

export enum FragmentShadingRateTypeNV {
  FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
  FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
}

export enum SubpassMergeStatusEXT {
  SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
  SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
  SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
  SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
  SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
  SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
  SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
  SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
  SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
  SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
  SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
  SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
  SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
  SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
}

export enum AccessFlagBits2 {
  ACCESS_2_NONE = 0,
  ACCESS_2_NONE_KHR = 0,
  ACCESS_2_INDIRECT_COMMAND_READ_BIT = 1 << 0,
  ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 1 << 0,
  ACCESS_2_INDEX_READ_BIT = 1 << 1,
  ACCESS_2_INDEX_READ_BIT_KHR = 1 << 1,
  ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 1 << 2,
  ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 1 << 2,
  ACCESS_2_UNIFORM_READ_BIT = 1 << 3,
  ACCESS_2_UNIFORM_READ_BIT_KHR = 1 << 3,
  ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 1 << 4,
  ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 1 << 4,
  ACCESS_2_SHADER_READ_BIT = 1 << 5,
  ACCESS_2_SHADER_READ_BIT_KHR = 1 << 5,
  ACCESS_2_SHADER_WRITE_BIT = 1 << 6,
  ACCESS_2_SHADER_WRITE_BIT_KHR = 1 << 6,
  ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 1 << 7,
  ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 1 << 7,
  ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 1 << 8,
  ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 1 << 8,
  ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 1 << 9,
  ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 1 << 9,
  ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1 << 10,
  ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 1 << 10,
  ACCESS_2_TRANSFER_READ_BIT = 1 << 11,
  ACCESS_2_TRANSFER_READ_BIT_KHR = 1 << 11,
  ACCESS_2_TRANSFER_WRITE_BIT = 1 << 12,
  ACCESS_2_TRANSFER_WRITE_BIT_KHR = 1 << 12,
  ACCESS_2_HOST_READ_BIT = 1 << 13,
  ACCESS_2_HOST_READ_BIT_KHR = 1 << 13,
  ACCESS_2_HOST_WRITE_BIT = 1 << 14,
  ACCESS_2_HOST_WRITE_BIT_KHR = 1 << 14,
  ACCESS_2_MEMORY_READ_BIT = 1 << 15,
  ACCESS_2_MEMORY_READ_BIT_KHR = 1 << 15,
  ACCESS_2_MEMORY_WRITE_BIT = 1 << 16,
  ACCESS_2_MEMORY_WRITE_BIT_KHR = 1 << 16,
  ACCESS_2_SHADER_SAMPLED_READ_BIT = 1 << 32,
  ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 1 << 32,
  ACCESS_2_SHADER_STORAGE_READ_BIT = 1 << 33,
  ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 1 << 33,
  ACCESS_2_SHADER_STORAGE_WRITE_BIT = 1 << 34,
  ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 1 << 34,
  ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 1 << 35,
  ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 1 << 36,
  ACCESS_2_RESERVED_46_BIT_EXT = 1 << 46,
  ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 1 << 37,
  ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 1 << 38,
  ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 1 << 25,
  ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 1 << 26,
  ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 1 << 27,
  /** read access flag for reading conditional rendering predicate */
  ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 1 << 20,
  ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 1 << 17,
  ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 1 << 18,
  ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 1 << 23,
  ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 1 << 23,
  ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 1 << 21,
  ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 1 << 22,
  ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 1 << 21,
  ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 1 << 22,
  ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 1 << 24,
  ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 1 << 19,
  ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 1 << 41,
  ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 1 << 39,
  ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 1 << 40,
  ACCESS_2_MICROMAP_READ_BIT_EXT = 1 << 44,
  ACCESS_2_MICROMAP_WRITE_BIT_EXT = 1 << 45,
  ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 1 << 42,
  ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 1 << 43,
}

export enum PipelineStageFlagBits2 {
  PIPELINE_STAGE_2_NONE = 0,
  PIPELINE_STAGE_2_NONE_KHR = 0,
  PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 1 << 0,
  PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 1 << 0,
  PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 1 << 1,
  PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 1 << 1,
  PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 1 << 2,
  PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 1 << 2,
  PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 1 << 3,
  PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 1 << 3,
  PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 1 << 4,
  PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 1 << 4,
  PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 1 << 5,
  PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 1 << 5,
  PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 1 << 6,
  PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 1 << 6,
  PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 1 << 7,
  PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 1 << 7,
  PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 1 << 8,
  PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 1 << 8,
  PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 1 << 9,
  PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 1 << 9,
  PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 1 << 10,
  PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 1 << 10,
  PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 1 << 11,
  PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 1 << 11,
  PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 1 << 12,
  PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 1 << 12,
  PIPELINE_STAGE_2_TRANSFER_BIT = PIPELINE_STAGE_2_ALL_TRANSFER_BIT,
  PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 1 << 12,
  PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 1 << 13,
  PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 1 << 13,
  PIPELINE_STAGE_2_HOST_BIT = 1 << 14,
  PIPELINE_STAGE_2_HOST_BIT_KHR = 1 << 14,
  PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 1 << 15,
  PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 1 << 15,
  PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 1 << 16,
  PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 1 << 16,
  PIPELINE_STAGE_2_COPY_BIT = 1 << 32,
  PIPELINE_STAGE_2_COPY_BIT_KHR = 1 << 32,
  PIPELINE_STAGE_2_RESOLVE_BIT = 1 << 33,
  PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 1 << 33,
  PIPELINE_STAGE_2_BLIT_BIT = 1 << 34,
  PIPELINE_STAGE_2_BLIT_BIT_KHR = 1 << 34,
  PIPELINE_STAGE_2_CLEAR_BIT = 1 << 35,
  PIPELINE_STAGE_2_CLEAR_BIT_KHR = 1 << 35,
  PIPELINE_STAGE_2_INDEX_INPUT_BIT = 1 << 36,
  PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 1 << 36,
  PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 1 << 37,
  PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 1 << 37,
  PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 1 << 38,
  PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 1 << 38,
  PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 1 << 26,
  PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 1 << 27,
  PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 1 << 24,
  /** A pipeline stage for conditional rendering predicate fetch */
  PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 1 << 18,
  PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 1 << 17,
  PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 22,
  PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 1 << 22,
  PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 1 << 25,
  PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 1 << 21,
  PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 1 << 21,
  PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 1 << 25,
  PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 1 << 23,
  PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 1 << 19,
  PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 1 << 20,
  PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 1 << 19,
  PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 1 << 20,
  PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 1 << 39,
  PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 1 << 40,
  PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 1 << 28,
  PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 1 << 30,
  PIPELINE_STAGE_2_RESEVED_41_BIT_HUAWEI = 1 << 41,
  PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 1 << 29,
}

export enum SubmitFlagBits {
  SUBMIT_PROTECTED_BIT = 1 << 0,
  SUBMIT_PROTECTED_BIT_KHR = 1 << 0,
}

export enum EventCreateFlagBits {
  EVENT_CREATE_DEVICE_ONLY_BIT = 1 << 0,
  EVENT_CREATE_DEVICE_ONLY_BIT_KHR = 1 << 0,
}

export enum PipelineLayoutCreateFlagBits {
  PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD = 1 << 0,
  PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 1 << 1,
}

export enum ProvokingVertexModeEXT {
  PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
  PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
}

export enum AccelerationStructureMotionInstanceTypeNV {
  ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
  ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
  ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
}

export enum PipelineColorBlendStateCreateFlagBits {
  PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = 1 << 0,
  PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 1 << 0,
}

export enum PipelineDepthStencilStateCreateFlagBits {
  PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 1 << 0,
  PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 1 << 1,
  PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 1 << 0,
  PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 1 << 1,
}

export enum GraphicsPipelineLibraryFlagBitsEXT {
  GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 1 << 0,
  GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 1 << 1,
  GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 1 << 2,
  GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 1 << 3,
}

export enum DeviceAddressBindingFlagBitsEXT {
  DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 1 << 0,
}

export enum DeviceAddressBindingTypeEXT {
  DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
  DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
}

export enum VideoCodecOperationFlagBitsKHR {
  VIDEO_CODEC_OPERATION_NONE_KHR = 0,
  VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT = 1 << 16,
  VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT = 1 << 17,
  VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT = 1 << 0,
  VIDEO_CODEC_OPERATION_DECODE_H265_BIT_EXT = 1 << 1,
}

/** Vulkan video chroma subsampling definitions */
export enum VideoChromaSubsamplingFlagBitsKHR {
  VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
  VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 1 << 0,
  VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 1 << 1,
  VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 1 << 2,
  VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 1 << 3,
}

/** Vulkan video component bit depth definitions */
export enum VideoComponentBitDepthFlagBitsKHR {
  VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
  VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 1 << 0,
  VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 1 << 2,
  VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 1 << 4,
}

export enum VideoCapabilityFlagBitsKHR {
  VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 1 << 0,
  VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 1 << 1,
}

export enum VideoSessionCreateFlagBitsKHR {
  VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 1 << 0,
}

export enum VideoDecodeH264PictureLayoutFlagBitsEXT {
  VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0,
  VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 1 << 0,
  VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 1 << 1,
}

export enum VideoCodingControlFlagBitsKHR {
  VIDEO_CODING_CONTROL_RESET_BIT_KHR = 1 << 0,
  VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 1 << 1,
  VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR = 1 << 2,
}

export enum QueryResultStatusKHR {
  QUERY_RESULT_STATUS_ERROR_KHR = -1,
  QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
  QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
}

export enum VideoDecodeUsageFlagBitsKHR {
  VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
  VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 1 << 0,
  VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 1 << 1,
  VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 1 << 2,
}

export enum VideoDecodeCapabilityFlagBitsKHR {
  VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 1 << 0,
  VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 1 << 1,
}

export enum VideoEncodeUsageFlagBitsKHR {
  VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
  VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 1 << 0,
  VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 1 << 1,
  VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 1 << 2,
  VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 1 << 3,
}

export enum VideoEncodeContentFlagBitsKHR {
  VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
  VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 1 << 0,
  VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 1 << 1,
  VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 1 << 2,
}

export enum VideoEncodeTuningModeKHR {
  VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
  VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
  VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
  VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
  VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
}

export enum VideoEncodeCapabilityFlagBitsKHR {
  VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 1 << 0,
}

export enum VideoEncodeRateControlModeFlagBitsKHR {
  VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR = 0,
  VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 1,
  VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 2,
}

export enum VideoEncodeH264CapabilityFlagBitsEXT {
  VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_ENABLED_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_DISABLED_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H264_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 1 << 2,
  VIDEO_ENCODE_H264_CAPABILITY_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_BIT_EXT = 1 << 3,
  VIDEO_ENCODE_H264_CAPABILITY_SCALING_LISTS_BIT_EXT = 1 << 4,
  VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 1 << 5,
  VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 1 << 6,
  VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 1 << 7,
  VIDEO_ENCODE_H264_CAPABILITY_PIC_INIT_QP_MINUS26_BIT_EXT = 1 << 8,
  VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 1 << 9,
  VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_EXPLICIT_BIT_EXT = 1 << 10,
  VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_IMPLICIT_BIT_EXT = 1 << 11,
  VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 1 << 12,
  VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 1 << 13,
  VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 1 << 14,
  VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 1 << 15,
  VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 1 << 16,
  VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 1 << 17,
  VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 1 << 18,
  VIDEO_ENCODE_H264_CAPABILITY_DISABLE_DIRECT_SPATIAL_MV_PRED_BIT_EXT = 1 << 19,
  VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 1 << 20,
  VIDEO_ENCODE_H264_CAPABILITY_SLICE_MB_COUNT_BIT_EXT = 1 << 21,
  VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = 1 << 22,
  VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 1 << 23,
  VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 1 << 24,
}

export enum VideoEncodeH264InputModeFlagBitsEXT {
  VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VideoEncodeH264OutputModeFlagBitsEXT {
  VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VideoEncodeH264RateControlStructureEXT {
  VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
  VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
  VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
}

export enum ImageFormatConstraintsFlagBitsFUCHSIA {
}

export enum ImageConstraintsInfoFlagBitsFUCHSIA {
  IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = 1 << 0,
  IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = 1 << 1,
  IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = 1 << 2,
  IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = 1 << 3,
  IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = 1 << 4,
}

export enum FormatFeatureFlagBits2 {
  FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 1 << 0,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 1 << 0,
  FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 1 << 1,
  FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 1 << 1,
  FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 1 << 2,
  FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 1 << 2,
  FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 1 << 3,
  FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 1 << 3,
  FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 1 << 4,
  FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 1 << 4,
  FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 1 << 5,
  FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 1 << 5,
  FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 1 << 6,
  FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 1 << 6,
  FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 1 << 7,
  FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 1 << 7,
  FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 1 << 8,
  FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 1 << 8,
  FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 1 << 9,
  FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 1 << 9,
  FORMAT_FEATURE_2_BLIT_SRC_BIT = 1 << 10,
  FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 1 << 10,
  FORMAT_FEATURE_2_BLIT_DST_BIT = 1 << 11,
  FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 1 << 11,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 1 << 12,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 1 << 12,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 1 << 13,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 1 << 13,
  FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 1 << 14,
  FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 1 << 14,
  FORMAT_FEATURE_2_TRANSFER_DST_BIT = 1 << 15,
  FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 1 << 15,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 1 << 16,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 1 << 16,
  FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 1 << 17,
  FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 1 << 17,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 1 << 18,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 1 << 18,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 1 << 19,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 1 << 19,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1 << 20,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1 << 20,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 1 << 21,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 1 << 21,
  FORMAT_FEATURE_2_DISJOINT_BIT = 1 << 22,
  FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 1 << 22,
  FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 1 << 23,
  FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 1 << 23,
  FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 1 << 31,
  FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 1 << 31,
  FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 1 << 32,
  FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 1 << 32,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 1 << 33,
  FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 1 << 33,
  FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 1 << 25,
  FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 1 << 26,
  FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 1 << 29,
  FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 1 << 24,
  FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1 << 30,
  FORMAT_FEATURE_2_RESERVED_44_BIT_EXT = 1 << 44,
  FORMAT_FEATURE_2_RESERVED_45_BIT_EXT = 1 << 45,
  FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 1 << 27,
  FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 1 << 28,
  /** Format support linear image as render target, it cannot be mixed with non linear attachment */
  FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 1 << 38,
  FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 1 << 34,
  FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 1 << 35,
  FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = 1 << 36,
  FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = 1 << 37,
  FORMAT_FEATURE_2_RESERVED_39_BIT_EXT = 1 << 39,
  FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 1 << 40,
  FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 1 << 41,
  FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 1 << 42,
}

export enum RenderingFlagBits {
  RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 1 << 0,
  RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = 1 << 0,
  RENDERING_SUSPENDING_BIT = 1 << 1,
  RENDERING_SUSPENDING_BIT_KHR = 1 << 1,
  RENDERING_RESUMING_BIT = 1 << 2,
  RENDERING_RESUMING_BIT_KHR = 1 << 2,
  RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 1 << 3,
}

export enum VideoEncodeH265CapabilityFlagBitsEXT {
  VIDEO_ENCODE_H265_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H265_CAPABILITY_SCALING_LISTS_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H265_CAPABILITY_SAMPLE_ADAPTIVE_OFFSET_ENABLED_BIT_EXT = 1 << 2,
  VIDEO_ENCODE_H265_CAPABILITY_PCM_ENABLE_BIT_EXT = 1 << 3,
  VIDEO_ENCODE_H265_CAPABILITY_SPS_TEMPORAL_MVP_ENABLED_BIT_EXT = 1 << 4,
  VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 1 << 5,
  VIDEO_ENCODE_H265_CAPABILITY_INIT_QP_MINUS26_BIT_EXT = 1 << 6,
  VIDEO_ENCODE_H265_CAPABILITY_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = 1 << 7,
  VIDEO_ENCODE_H265_CAPABILITY_SIGN_DATA_HIDING_ENABLED_BIT_EXT = 1 << 8,
  VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_ENABLED_BIT_EXT = 1 << 9,
  VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_DISABLED_BIT_EXT = 1 << 10,
  VIDEO_ENCODE_H265_CAPABILITY_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_BIT_EXT = 1 << 11,
  VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 1 << 12,
  VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_BIPRED_BIT_EXT = 1 << 13,
  VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 1 << 14,
  VIDEO_ENCODE_H265_CAPABILITY_TRANSQUANT_BYPASS_ENABLED_BIT_EXT = 1 << 15,
  VIDEO_ENCODE_H265_CAPABILITY_ENTROPY_CODING_SYNC_ENABLED_BIT_EXT = 1 << 16,
  VIDEO_ENCODE_H265_CAPABILITY_DEBLOCKING_FILTER_OVERRIDE_ENABLED_BIT_EXT = 1 << 17,
  VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_FRAME_BIT_EXT = 1 << 18,
  VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_PER_TILE_BIT_EXT = 1 << 19,
  VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_SLICE_BIT_EXT = 1 << 20,
  VIDEO_ENCODE_H265_CAPABILITY_SLICE_SEGMENT_CTB_COUNT_BIT_EXT = 1 << 21,
  VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = 1 << 22,
  VIDEO_ENCODE_H265_CAPABILITY_DEPENDENT_SLICE_SEGMENT_BIT_EXT = 1 << 23,
  VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 1 << 24,
  VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 1 << 25,
}

export enum VideoEncodeH265InputModeFlagBitsEXT {
  VIDEO_ENCODE_H265_INPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H265_INPUT_MODE_SLICE_SEGMENT_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H265_INPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VideoEncodeH265OutputModeFlagBitsEXT {
  VIDEO_ENCODE_H265_OUTPUT_MODE_FRAME_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H265_OUTPUT_MODE_SLICE_SEGMENT_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H265_OUTPUT_MODE_NON_VCL_BIT_EXT = 1 << 2,
}

export enum VideoEncodeH265RateControlStructureEXT {
  VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
  VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
  VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
}

export enum VideoEncodeH265CtbSizeFlagBitsEXT {
  VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 1 << 2,
}

export enum VideoEncodeH265TransformBlockSizeFlagBitsEXT {
  VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = 1 << 0,
  VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = 1 << 1,
  VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = 1 << 2,
  VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = 1 << 3,
}

export enum ExportMetalObjectTypeFlagBitsEXT {
  EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 1 << 0,
  EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 1 << 1,
  EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 1 << 2,
  EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 1 << 3,
  EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 1 << 4,
  EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 1 << 5,
}

export enum InstanceCreateFlagBits {
  INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 1 << 0,
}

export enum ImageCompressionFlagBitsEXT {
  IMAGE_COMPRESSION_DEFAULT_EXT = 0,
  IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 1 << 0,
  IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 1 << 1,
  IMAGE_COMPRESSION_DISABLED_EXT = 1 << 2,
}

export enum ImageCompressionFixedRateFlagBitsEXT {
  IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
  IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 1 << 0,
  IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 1 << 1,
  IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 1 << 2,
  IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 1 << 3,
  IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 1 << 4,
  IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 1 << 5,
  IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 1 << 6,
  IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 1 << 7,
  IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 1 << 8,
  IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 1 << 9,
  IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 1 << 10,
  IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 1 << 11,
  IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 1 << 12,
  IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 1 << 13,
  IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 1 << 14,
  IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 1 << 15,
  IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 1 << 16,
  IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 1 << 17,
  IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 1 << 18,
  IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 1 << 19,
  IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 1 << 20,
  IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 1 << 21,
  IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 1 << 22,
  IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 1 << 23,
}

export enum PipelineRobustnessBufferBehaviorEXT {
  PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1,
  PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2,
  PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3,
}

export enum PipelineRobustnessImageBehaviorEXT {
  PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1,
  PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2,
  PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3,
}

export enum OpticalFlowGridSizeFlagBitsNV {
  OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
  OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 1 << 0,
  OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 1 << 1,
  OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 1 << 2,
  OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 1 << 3,
}

export enum OpticalFlowUsageFlagBitsNV {
  OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
  OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 1 << 0,
  OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 1 << 1,
  OPTICAL_FLOW_USAGE_HINT_BIT_NV = 1 << 2,
  OPTICAL_FLOW_USAGE_COST_BIT_NV = 1 << 3,
  OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 1 << 4,
}

export enum OpticalFlowPerformanceLevelNV {
  OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
  OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
  OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
  OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
}

export enum OpticalFlowSessionBindingPointNV {
  OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
  OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
  OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
  OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
  OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
  OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
  OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
  OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
  OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
}

export enum OpticalFlowSessionCreateFlagBitsNV {
  OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 1 << 0,
  OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 1 << 1,
  OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 1 << 2,
  OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 1 << 3,
  OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 1 << 4,
}

export enum OpticalFlowExecuteFlagBitsNV {
  OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 1 << 0,
}

export enum MicromapTypeEXT {
  MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
}

export enum BuildMicromapFlagBitsEXT {
  BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 1 << 0,
  BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 1 << 1,
  BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 1 << 2,
}

export enum MicromapCreateFlagBitsEXT {
  MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1 << 0,
}

export enum CopyMicromapModeEXT {
  COPY_MICROMAP_MODE_CLONE_EXT = 0,
  COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
  COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
  COPY_MICROMAP_MODE_COMPACT_EXT = 3,
}

export enum BuildMicromapModeEXT {
  BUILD_MICROMAP_MODE_BUILD_EXT = 0,
}

export enum OpacityMicromapFormatEXT {
  OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
  OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
}

export enum OpacityMicromapSpecialIndexEXT {
  OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
  OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
  OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
  OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
}

export enum DeviceFaultAddressTypeEXT {
  /** Currently unused */
  DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
  DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
  DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
  DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
  DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
  DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
  DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
}

export enum DeviceFaultVendorBinaryHeaderVersionEXT {
  DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
}

/// Structs

export interface InitStdVideoH264SpsVuiFlags {
  aspect_ratio_info_present_flag?: number;
  overscan_info_present_flag?: number;
  overscan_appropriate_flag?: number;
  video_signal_type_present_flag?: number;
  video_full_range_flag?: number;
  color_description_present_flag?: number;
  chroma_loc_info_present_flag?: number;
  timing_info_present_flag?: number;
  fixed_frame_rate_flag?: number;
  bitstream_restriction_flag?: number;
  nal_hrd_parameters_present_flag?: number;
  vcl_hrd_parameters_present_flag?: number;
}

export class StdVideoH264SpsVuiFlags implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264SpsVuiFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264SpsVuiFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264SpsVuiFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264SpsVuiFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264SpsVuiFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspect_ratio_info_present_flag !== undefined) this.aspect_ratio_info_present_flag = data.aspect_ratio_info_present_flag;
      if (data.overscan_info_present_flag !== undefined) this.overscan_info_present_flag = data.overscan_info_present_flag;
      if (data.overscan_appropriate_flag !== undefined) this.overscan_appropriate_flag = data.overscan_appropriate_flag;
      if (data.video_signal_type_present_flag !== undefined) this.video_signal_type_present_flag = data.video_signal_type_present_flag;
      if (data.video_full_range_flag !== undefined) this.video_full_range_flag = data.video_full_range_flag;
      if (data.color_description_present_flag !== undefined) this.color_description_present_flag = data.color_description_present_flag;
      if (data.chroma_loc_info_present_flag !== undefined) this.chroma_loc_info_present_flag = data.chroma_loc_info_present_flag;
      if (data.timing_info_present_flag !== undefined) this.timing_info_present_flag = data.timing_info_present_flag;
      if (data.fixed_frame_rate_flag !== undefined) this.fixed_frame_rate_flag = data.fixed_frame_rate_flag;
      if (data.bitstream_restriction_flag !== undefined) this.bitstream_restriction_flag = data.bitstream_restriction_flag;
      if (data.nal_hrd_parameters_present_flag !== undefined) this.nal_hrd_parameters_present_flag = data.nal_hrd_parameters_present_flag;
      if (data.vcl_hrd_parameters_present_flag !== undefined) this.vcl_hrd_parameters_present_flag = data.vcl_hrd_parameters_present_flag;
    }
  }
  
  get aspect_ratio_info_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspect_ratio_info_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get overscan_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set overscan_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get overscan_appropriate_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set overscan_appropriate_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get video_signal_type_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set video_signal_type_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get video_full_range_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set video_full_range_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get color_description_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set color_description_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get chroma_loc_info_present_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set chroma_loc_info_present_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get timing_info_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set timing_info_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fixed_frame_rate_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set fixed_frame_rate_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get bitstream_restriction_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set bitstream_restriction_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get nal_hrd_parameters_present_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set nal_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get vcl_hrd_parameters_present_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set vcl_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitStdVideoH264HrdParameters {
  cpb_cnt_minus1?: number;
  bit_rate_scale?: number;
  cpb_size_scale?: number;
  reserved1?: number;
  bit_rate_value_minus1?: number[];
  cpb_size_value_minus1?: number[];
  cbr_flag?: number[];
  initial_cpb_removal_delay_length_minus1?: number;
  cpb_removal_delay_length_minus1?: number;
  dpb_output_delay_length_minus1?: number;
  time_offset_length?: number;
}

/** hrd_parameters */
export class StdVideoH264HrdParameters implements BaseStruct {
  static size = 308;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264HrdParameters);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264HrdParameters) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264HrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264HrdParameters.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264HrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.cpb_cnt_minus1 !== undefined) this.cpb_cnt_minus1 = data.cpb_cnt_minus1;
      if (data.bit_rate_scale !== undefined) this.bit_rate_scale = data.bit_rate_scale;
      if (data.cpb_size_scale !== undefined) this.cpb_size_scale = data.cpb_size_scale;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.bit_rate_value_minus1 !== undefined) this.bit_rate_value_minus1 = data.bit_rate_value_minus1;
      if (data.cpb_size_value_minus1 !== undefined) this.cpb_size_value_minus1 = data.cpb_size_value_minus1;
      if (data.cbr_flag !== undefined) this.cbr_flag = data.cbr_flag;
      if (data.initial_cpb_removal_delay_length_minus1 !== undefined) this.initial_cpb_removal_delay_length_minus1 = data.initial_cpb_removal_delay_length_minus1;
      if (data.cpb_removal_delay_length_minus1 !== undefined) this.cpb_removal_delay_length_minus1 = data.cpb_removal_delay_length_minus1;
      if (data.dpb_output_delay_length_minus1 !== undefined) this.dpb_output_delay_length_minus1 = data.dpb_output_delay_length_minus1;
      if (data.time_offset_length !== undefined) this.time_offset_length = data.time_offset_length;
    }
  }
  
  get cpb_cnt_minus1() {
    return this.#view.getUint8(0);
  }
  
  set cpb_cnt_minus1(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get bit_rate_scale() {
    return this.#view.getUint8(1);
  }
  
  set bit_rate_scale(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get cpb_size_scale() {
    return this.#view.getUint8(2);
  }
  
  set cpb_size_scale(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(3);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(3, Number(value));
  }
  
  get bit_rate_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(4 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set bit_rate_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(4 + i * 4, Number(value[i]), LE);
    }
  }
  
  get cpb_size_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(132 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set cpb_size_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(132 + i * 4, Number(value[i]), LE);
    }
  }
  
  get cbr_flag() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint8(260 + i * 1);
      })());
    }
    return result;
  }
  
  set cbr_flag(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(260 + i * 1, Number(value[i]));
    }
  }
  
  get initial_cpb_removal_delay_length_minus1() {
    return this.#view.getUint32(292, LE);
  }
  
  set initial_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint32(292, Number(value), LE);
  }
  
  get cpb_removal_delay_length_minus1() {
    return this.#view.getUint32(296, LE);
  }
  
  set cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint32(296, Number(value), LE);
  }
  
  get dpb_output_delay_length_minus1() {
    return this.#view.getUint32(300, LE);
  }
  
  set dpb_output_delay_length_minus1(value: number) {
    this.#view.setUint32(300, Number(value), LE);
  }
  
  get time_offset_length() {
    return this.#view.getUint32(304, LE);
  }
  
  set time_offset_length(value: number) {
    this.#view.setUint32(304, Number(value), LE);
  }
}

export interface InitStdVideoH264SequenceParameterSetVui {
  flags?: StdVideoH264SpsVuiFlags;
  aspect_ratio_idc?: StdVideoH264AspectRatioIdc;
  sar_width?: number;
  sar_height?: number;
  video_format?: number;
  colour_primaries?: number;
  transfer_characteristics?: number;
  matrix_coefficients?: number;
  num_units_in_tick?: number;
  time_scale?: number;
  max_num_reorder_frames?: number;
  max_dec_frame_buffering?: number;
  chroma_sample_loc_type_top_field?: number;
  chroma_sample_loc_type_bottom_field?: number;
  reserved1?: number;
  pHrdParameters?: AnyPointer;
}

export class StdVideoH264SequenceParameterSetVui implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264SequenceParameterSetVui);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264SequenceParameterSetVui) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264SequenceParameterSetVui.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264SequenceParameterSetVui.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264SequenceParameterSetVui.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.aspect_ratio_idc !== undefined) this.aspect_ratio_idc = data.aspect_ratio_idc;
      if (data.sar_width !== undefined) this.sar_width = data.sar_width;
      if (data.sar_height !== undefined) this.sar_height = data.sar_height;
      if (data.video_format !== undefined) this.video_format = data.video_format;
      if (data.colour_primaries !== undefined) this.colour_primaries = data.colour_primaries;
      if (data.transfer_characteristics !== undefined) this.transfer_characteristics = data.transfer_characteristics;
      if (data.matrix_coefficients !== undefined) this.matrix_coefficients = data.matrix_coefficients;
      if (data.num_units_in_tick !== undefined) this.num_units_in_tick = data.num_units_in_tick;
      if (data.time_scale !== undefined) this.time_scale = data.time_scale;
      if (data.max_num_reorder_frames !== undefined) this.max_num_reorder_frames = data.max_num_reorder_frames;
      if (data.max_dec_frame_buffering !== undefined) this.max_dec_frame_buffering = data.max_dec_frame_buffering;
      if (data.chroma_sample_loc_type_top_field !== undefined) this.chroma_sample_loc_type_top_field = data.chroma_sample_loc_type_top_field;
      if (data.chroma_sample_loc_type_bottom_field !== undefined) this.chroma_sample_loc_type_bottom_field = data.chroma_sample_loc_type_bottom_field;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.pHrdParameters !== undefined) this.pHrdParameters = data.pHrdParameters;
    }
  }
  
  get flags() {
    return new StdVideoH264SpsVuiFlags(this.#data.subarray(0, 0 + StdVideoH264SpsVuiFlags.size));
  }
  
  set flags(value: StdVideoH264SpsVuiFlags) {
    if (value[BUFFER].byteLength < StdVideoH264SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aspect_ratio_idc() {
    return this.#view.getUint32(48, LE);
  }
  
  set aspect_ratio_idc(value: StdVideoH264AspectRatioIdc) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get sar_width() {
    return this.#view.getUint16(52, LE);
  }
  
  set sar_width(value: number) {
    this.#view.setUint16(52, Number(value), LE);
  }
  
  get sar_height() {
    return this.#view.getUint16(54, LE);
  }
  
  set sar_height(value: number) {
    this.#view.setUint16(54, Number(value), LE);
  }
  
  get video_format() {
    return this.#view.getUint8(56);
  }
  
  set video_format(value: number) {
    this.#view.setUint8(56, Number(value));
  }
  
  get colour_primaries() {
    return this.#view.getUint8(57);
  }
  
  set colour_primaries(value: number) {
    this.#view.setUint8(57, Number(value));
  }
  
  get transfer_characteristics() {
    return this.#view.getUint8(58);
  }
  
  set transfer_characteristics(value: number) {
    this.#view.setUint8(58, Number(value));
  }
  
  get matrix_coefficients() {
    return this.#view.getUint8(59);
  }
  
  set matrix_coefficients(value: number) {
    this.#view.setUint8(59, Number(value));
  }
  
  get num_units_in_tick() {
    return this.#view.getUint32(60, LE);
  }
  
  set num_units_in_tick(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get time_scale() {
    return this.#view.getUint32(64, LE);
  }
  
  set time_scale(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get max_num_reorder_frames() {
    return this.#view.getUint8(68);
  }
  
  set max_num_reorder_frames(value: number) {
    this.#view.setUint8(68, Number(value));
  }
  
  get max_dec_frame_buffering() {
    return this.#view.getUint8(69);
  }
  
  set max_dec_frame_buffering(value: number) {
    this.#view.setUint8(69, Number(value));
  }
  
  get chroma_sample_loc_type_top_field() {
    return this.#view.getUint8(70);
  }
  
  set chroma_sample_loc_type_top_field(value: number) {
    this.#view.setUint8(70, Number(value));
  }
  
  get chroma_sample_loc_type_bottom_field() {
    return this.#view.getUint8(71);
  }
  
  set chroma_sample_loc_type_bottom_field(value: number) {
    this.#view.setUint8(71, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint32(72, LE);
  }
  
  set reserved1(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pHrdParameters(value: AnyPointer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH264SpsFlags {
  constraint_set0_flag?: number;
  constraint_set1_flag?: number;
  constraint_set2_flag?: number;
  constraint_set3_flag?: number;
  constraint_set4_flag?: number;
  constraint_set5_flag?: number;
  direct_8x8_inference_flag?: number;
  mb_adaptive_frame_field_flag?: number;
  frame_mbs_only_flag?: number;
  delta_pic_order_always_zero_flag?: number;
  separate_colour_plane_flag?: number;
  gaps_in_frame_num_value_allowed_flag?: number;
  qpprime_y_zero_transform_bypass_flag?: number;
  frame_cropping_flag?: number;
  seq_scaling_matrix_present_flag?: number;
  vui_parameters_present_flag?: number;
}

export class StdVideoH264SpsFlags implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264SpsFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264SpsFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264SpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264SpsFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264SpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.constraint_set0_flag !== undefined) this.constraint_set0_flag = data.constraint_set0_flag;
      if (data.constraint_set1_flag !== undefined) this.constraint_set1_flag = data.constraint_set1_flag;
      if (data.constraint_set2_flag !== undefined) this.constraint_set2_flag = data.constraint_set2_flag;
      if (data.constraint_set3_flag !== undefined) this.constraint_set3_flag = data.constraint_set3_flag;
      if (data.constraint_set4_flag !== undefined) this.constraint_set4_flag = data.constraint_set4_flag;
      if (data.constraint_set5_flag !== undefined) this.constraint_set5_flag = data.constraint_set5_flag;
      if (data.direct_8x8_inference_flag !== undefined) this.direct_8x8_inference_flag = data.direct_8x8_inference_flag;
      if (data.mb_adaptive_frame_field_flag !== undefined) this.mb_adaptive_frame_field_flag = data.mb_adaptive_frame_field_flag;
      if (data.frame_mbs_only_flag !== undefined) this.frame_mbs_only_flag = data.frame_mbs_only_flag;
      if (data.delta_pic_order_always_zero_flag !== undefined) this.delta_pic_order_always_zero_flag = data.delta_pic_order_always_zero_flag;
      if (data.separate_colour_plane_flag !== undefined) this.separate_colour_plane_flag = data.separate_colour_plane_flag;
      if (data.gaps_in_frame_num_value_allowed_flag !== undefined) this.gaps_in_frame_num_value_allowed_flag = data.gaps_in_frame_num_value_allowed_flag;
      if (data.qpprime_y_zero_transform_bypass_flag !== undefined) this.qpprime_y_zero_transform_bypass_flag = data.qpprime_y_zero_transform_bypass_flag;
      if (data.frame_cropping_flag !== undefined) this.frame_cropping_flag = data.frame_cropping_flag;
      if (data.seq_scaling_matrix_present_flag !== undefined) this.seq_scaling_matrix_present_flag = data.seq_scaling_matrix_present_flag;
      if (data.vui_parameters_present_flag !== undefined) this.vui_parameters_present_flag = data.vui_parameters_present_flag;
    }
  }
  
  get constraint_set0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set constraint_set0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get constraint_set1_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set constraint_set1_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get constraint_set2_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set constraint_set2_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get constraint_set3_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set constraint_set3_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get constraint_set4_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set constraint_set4_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get constraint_set5_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set constraint_set5_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get direct_8x8_inference_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set direct_8x8_inference_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get mb_adaptive_frame_field_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set mb_adaptive_frame_field_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get frame_mbs_only_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set frame_mbs_only_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get delta_pic_order_always_zero_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set delta_pic_order_always_zero_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get separate_colour_plane_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set separate_colour_plane_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get gaps_in_frame_num_value_allowed_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set gaps_in_frame_num_value_allowed_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get qpprime_y_zero_transform_bypass_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set qpprime_y_zero_transform_bypass_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get frame_cropping_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set frame_cropping_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get seq_scaling_matrix_present_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set seq_scaling_matrix_present_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get vui_parameters_present_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set vui_parameters_present_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitStdVideoH264ScalingLists {
  scaling_list_present_mask?: number;
  use_default_scaling_matrix_mask?: number;
  ScalingList4x4?: number[];
  ScalingList8x8?: number[];
}

export class StdVideoH264ScalingLists implements BaseStruct {
  static size = 484;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264ScalingLists);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264ScalingLists) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264ScalingLists.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264ScalingLists.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264ScalingLists.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.scaling_list_present_mask !== undefined) this.scaling_list_present_mask = data.scaling_list_present_mask;
      if (data.use_default_scaling_matrix_mask !== undefined) this.use_default_scaling_matrix_mask = data.use_default_scaling_matrix_mask;
      if (data.ScalingList4x4 !== undefined) this.ScalingList4x4 = data.ScalingList4x4;
      if (data.ScalingList8x8 !== undefined) this.ScalingList8x8 = data.ScalingList8x8;
    }
  }
  
  get scaling_list_present_mask() {
    return this.#view.getUint16(0, LE);
  }
  
  set scaling_list_present_mask(value: number) {
    this.#view.setUint16(0, Number(value), LE);
  }
  
  get use_default_scaling_matrix_mask() {
    return this.#view.getUint16(2, LE);
  }
  
  set use_default_scaling_matrix_mask(value: number) {
    this.#view.setUint16(2, Number(value), LE);
  }
  
  get ScalingList4x4() {
    const result: number[] = [];
    for (let i = 0; i < 96; i++) {
      result.push((() => {
        return this.#view.getUint8(4 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList4x4(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(4 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingList8x8() {
    const result: number[] = [];
    for (let i = 0; i < 384; i++) {
      result.push((() => {
        return this.#view.getUint8(100 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList8x8(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(100 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoH264SequenceParameterSet {
  flags?: StdVideoH264SpsFlags;
  profile_idc?: StdVideoH264ProfileIdc;
  level_idc?: StdVideoH264LevelIdc;
  chroma_format_idc?: StdVideoH264ChromaFormatIdc;
  seq_parameter_set_id?: number;
  bit_depth_luma_minus8?: number;
  bit_depth_chroma_minus8?: number;
  log2_max_frame_num_minus4?: number;
  pic_order_cnt_type?: StdVideoH264PocType;
  offset_for_non_ref_pic?: number;
  offset_for_top_to_bottom_field?: number;
  log2_max_pic_order_cnt_lsb_minus4?: number;
  num_ref_frames_in_pic_order_cnt_cycle?: number;
  max_num_ref_frames?: number;
  reserved1?: number;
  pic_width_in_mbs_minus1?: number;
  pic_height_in_map_units_minus1?: number;
  frame_crop_left_offset?: number;
  frame_crop_right_offset?: number;
  frame_crop_top_offset?: number;
  frame_crop_bottom_offset?: number;
  reserved2?: number;
  pOffsetForRefFrame?: AnyPointer;
  pScalingLists?: AnyPointer;
  pSequenceParameterSetVui?: AnyPointer;
}

export class StdVideoH264SequenceParameterSet implements BaseStruct {
  static size = 152;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264SequenceParameterSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264SequenceParameterSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264SequenceParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264SequenceParameterSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264SequenceParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.profile_idc !== undefined) this.profile_idc = data.profile_idc;
      if (data.level_idc !== undefined) this.level_idc = data.level_idc;
      if (data.chroma_format_idc !== undefined) this.chroma_format_idc = data.chroma_format_idc;
      if (data.seq_parameter_set_id !== undefined) this.seq_parameter_set_id = data.seq_parameter_set_id;
      if (data.bit_depth_luma_minus8 !== undefined) this.bit_depth_luma_minus8 = data.bit_depth_luma_minus8;
      if (data.bit_depth_chroma_minus8 !== undefined) this.bit_depth_chroma_minus8 = data.bit_depth_chroma_minus8;
      if (data.log2_max_frame_num_minus4 !== undefined) this.log2_max_frame_num_minus4 = data.log2_max_frame_num_minus4;
      if (data.pic_order_cnt_type !== undefined) this.pic_order_cnt_type = data.pic_order_cnt_type;
      if (data.offset_for_non_ref_pic !== undefined) this.offset_for_non_ref_pic = data.offset_for_non_ref_pic;
      if (data.offset_for_top_to_bottom_field !== undefined) this.offset_for_top_to_bottom_field = data.offset_for_top_to_bottom_field;
      if (data.log2_max_pic_order_cnt_lsb_minus4 !== undefined) this.log2_max_pic_order_cnt_lsb_minus4 = data.log2_max_pic_order_cnt_lsb_minus4;
      if (data.num_ref_frames_in_pic_order_cnt_cycle !== undefined) this.num_ref_frames_in_pic_order_cnt_cycle = data.num_ref_frames_in_pic_order_cnt_cycle;
      if (data.max_num_ref_frames !== undefined) this.max_num_ref_frames = data.max_num_ref_frames;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.pic_width_in_mbs_minus1 !== undefined) this.pic_width_in_mbs_minus1 = data.pic_width_in_mbs_minus1;
      if (data.pic_height_in_map_units_minus1 !== undefined) this.pic_height_in_map_units_minus1 = data.pic_height_in_map_units_minus1;
      if (data.frame_crop_left_offset !== undefined) this.frame_crop_left_offset = data.frame_crop_left_offset;
      if (data.frame_crop_right_offset !== undefined) this.frame_crop_right_offset = data.frame_crop_right_offset;
      if (data.frame_crop_top_offset !== undefined) this.frame_crop_top_offset = data.frame_crop_top_offset;
      if (data.frame_crop_bottom_offset !== undefined) this.frame_crop_bottom_offset = data.frame_crop_bottom_offset;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.pOffsetForRefFrame !== undefined) this.pOffsetForRefFrame = data.pOffsetForRefFrame;
      if (data.pScalingLists !== undefined) this.pScalingLists = data.pScalingLists;
      if (data.pSequenceParameterSetVui !== undefined) this.pSequenceParameterSetVui = data.pSequenceParameterSetVui;
    }
  }
  
  get flags() {
    return new StdVideoH264SpsFlags(this.#data.subarray(0, 0 + StdVideoH264SpsFlags.size));
  }
  
  set flags(value: StdVideoH264SpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH264SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get profile_idc() {
    return this.#view.getUint32(64, LE);
  }
  
  set profile_idc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get level_idc() {
    return this.#view.getUint32(68, LE);
  }
  
  set level_idc(value: StdVideoH264LevelIdc) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get chroma_format_idc() {
    return this.#view.getUint32(72, LE);
  }
  
  set chroma_format_idc(value: StdVideoH264ChromaFormatIdc) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(76);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(76, Number(value));
  }
  
  get bit_depth_luma_minus8() {
    return this.#view.getUint8(77);
  }
  
  set bit_depth_luma_minus8(value: number) {
    this.#view.setUint8(77, Number(value));
  }
  
  get bit_depth_chroma_minus8() {
    return this.#view.getUint8(78);
  }
  
  set bit_depth_chroma_minus8(value: number) {
    this.#view.setUint8(78, Number(value));
  }
  
  get log2_max_frame_num_minus4() {
    return this.#view.getUint8(79);
  }
  
  set log2_max_frame_num_minus4(value: number) {
    this.#view.setUint8(79, Number(value));
  }
  
  get pic_order_cnt_type() {
    return this.#view.getUint32(80, LE);
  }
  
  set pic_order_cnt_type(value: StdVideoH264PocType) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get offset_for_non_ref_pic() {
    return this.#view.getInt32(84, LE);
  }
  
  set offset_for_non_ref_pic(value: number) {
    this.#view.setInt32(84, Number(value), LE);
  }
  
  get offset_for_top_to_bottom_field() {
    return this.#view.getInt32(88, LE);
  }
  
  set offset_for_top_to_bottom_field(value: number) {
    this.#view.setInt32(88, Number(value), LE);
  }
  
  get log2_max_pic_order_cnt_lsb_minus4() {
    return this.#view.getUint8(92);
  }
  
  set log2_max_pic_order_cnt_lsb_minus4(value: number) {
    this.#view.setUint8(92, Number(value));
  }
  
  get num_ref_frames_in_pic_order_cnt_cycle() {
    return this.#view.getUint8(93);
  }
  
  set num_ref_frames_in_pic_order_cnt_cycle(value: number) {
    this.#view.setUint8(93, Number(value));
  }
  
  get max_num_ref_frames() {
    return this.#view.getUint8(94);
  }
  
  set max_num_ref_frames(value: number) {
    this.#view.setUint8(94, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(95);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(95, Number(value));
  }
  
  get pic_width_in_mbs_minus1() {
    return this.#view.getUint32(96, LE);
  }
  
  set pic_width_in_mbs_minus1(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get pic_height_in_map_units_minus1() {
    return this.#view.getUint32(100, LE);
  }
  
  set pic_height_in_map_units_minus1(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get frame_crop_left_offset() {
    return this.#view.getUint32(104, LE);
  }
  
  set frame_crop_left_offset(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get frame_crop_right_offset() {
    return this.#view.getUint32(108, LE);
  }
  
  set frame_crop_right_offset(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get frame_crop_top_offset() {
    return this.#view.getUint32(112, LE);
  }
  
  set frame_crop_top_offset(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get frame_crop_bottom_offset() {
    return this.#view.getUint32(116, LE);
  }
  
  set frame_crop_bottom_offset(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get reserved2() {
    return this.#view.getUint32(120, LE);
  }
  
  set reserved2(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get pOffsetForRefFrame() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set pOffsetForRefFrame(value: AnyPointer) {
    this.#view.setBigUint64(128, BigInt(anyPointer(value)), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(136, LE);
  }
  
  set pScalingLists(value: AnyPointer) {
    this.#view.setBigUint64(136, BigInt(anyPointer(value)), LE);
  }
  
  get pSequenceParameterSetVui() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set pSequenceParameterSetVui(value: AnyPointer) {
    this.#view.setBigUint64(144, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH264PpsFlags {
  transform_8x8_mode_flag?: number;
  redundant_pic_cnt_present_flag?: number;
  constrained_intra_pred_flag?: number;
  deblocking_filter_control_present_flag?: number;
  weighted_pred_flag?: number;
  bottom_field_pic_order_in_frame_present_flag?: number;
  entropy_coding_mode_flag?: number;
  pic_scaling_matrix_present_flag?: number;
}

export class StdVideoH264PpsFlags implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264PpsFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264PpsFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264PpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264PpsFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264PpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.transform_8x8_mode_flag !== undefined) this.transform_8x8_mode_flag = data.transform_8x8_mode_flag;
      if (data.redundant_pic_cnt_present_flag !== undefined) this.redundant_pic_cnt_present_flag = data.redundant_pic_cnt_present_flag;
      if (data.constrained_intra_pred_flag !== undefined) this.constrained_intra_pred_flag = data.constrained_intra_pred_flag;
      if (data.deblocking_filter_control_present_flag !== undefined) this.deblocking_filter_control_present_flag = data.deblocking_filter_control_present_flag;
      if (data.weighted_pred_flag !== undefined) this.weighted_pred_flag = data.weighted_pred_flag;
      if (data.bottom_field_pic_order_in_frame_present_flag !== undefined) this.bottom_field_pic_order_in_frame_present_flag = data.bottom_field_pic_order_in_frame_present_flag;
      if (data.entropy_coding_mode_flag !== undefined) this.entropy_coding_mode_flag = data.entropy_coding_mode_flag;
      if (data.pic_scaling_matrix_present_flag !== undefined) this.pic_scaling_matrix_present_flag = data.pic_scaling_matrix_present_flag;
    }
  }
  
  get transform_8x8_mode_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set transform_8x8_mode_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get redundant_pic_cnt_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set redundant_pic_cnt_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get constrained_intra_pred_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set constrained_intra_pred_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deblocking_filter_control_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set deblocking_filter_control_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get weighted_pred_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set weighted_pred_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bottom_field_pic_order_in_frame_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set bottom_field_pic_order_in_frame_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get entropy_coding_mode_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set entropy_coding_mode_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pic_scaling_matrix_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set pic_scaling_matrix_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitStdVideoH264PictureParameterSet {
  flags?: StdVideoH264PpsFlags;
  seq_parameter_set_id?: number;
  pic_parameter_set_id?: number;
  num_ref_idx_l0_default_active_minus1?: number;
  num_ref_idx_l1_default_active_minus1?: number;
  weighted_bipred_idc?: StdVideoH264WeightedBipredIdc;
  pic_init_qp_minus26?: number;
  pic_init_qs_minus26?: number;
  chroma_qp_index_offset?: number;
  second_chroma_qp_index_offset?: number;
  pScalingLists?: AnyPointer;
}

export class StdVideoH264PictureParameterSet implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH264PictureParameterSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH264PictureParameterSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH264PictureParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH264PictureParameterSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH264PictureParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.seq_parameter_set_id !== undefined) this.seq_parameter_set_id = data.seq_parameter_set_id;
      if (data.pic_parameter_set_id !== undefined) this.pic_parameter_set_id = data.pic_parameter_set_id;
      if (data.num_ref_idx_l0_default_active_minus1 !== undefined) this.num_ref_idx_l0_default_active_minus1 = data.num_ref_idx_l0_default_active_minus1;
      if (data.num_ref_idx_l1_default_active_minus1 !== undefined) this.num_ref_idx_l1_default_active_minus1 = data.num_ref_idx_l1_default_active_minus1;
      if (data.weighted_bipred_idc !== undefined) this.weighted_bipred_idc = data.weighted_bipred_idc;
      if (data.pic_init_qp_minus26 !== undefined) this.pic_init_qp_minus26 = data.pic_init_qp_minus26;
      if (data.pic_init_qs_minus26 !== undefined) this.pic_init_qs_minus26 = data.pic_init_qs_minus26;
      if (data.chroma_qp_index_offset !== undefined) this.chroma_qp_index_offset = data.chroma_qp_index_offset;
      if (data.second_chroma_qp_index_offset !== undefined) this.second_chroma_qp_index_offset = data.second_chroma_qp_index_offset;
      if (data.pScalingLists !== undefined) this.pScalingLists = data.pScalingLists;
    }
  }
  
  get flags() {
    return new StdVideoH264PpsFlags(this.#data.subarray(0, 0 + StdVideoH264PpsFlags.size));
  }
  
  set flags(value: StdVideoH264PpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH264PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(32);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(33);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(33, Number(value));
  }
  
  get num_ref_idx_l0_default_active_minus1() {
    return this.#view.getUint8(34);
  }
  
  set num_ref_idx_l0_default_active_minus1(value: number) {
    this.#view.setUint8(34, Number(value));
  }
  
  get num_ref_idx_l1_default_active_minus1() {
    return this.#view.getUint8(35);
  }
  
  set num_ref_idx_l1_default_active_minus1(value: number) {
    this.#view.setUint8(35, Number(value));
  }
  
  get weighted_bipred_idc() {
    return this.#view.getUint32(36, LE);
  }
  
  set weighted_bipred_idc(value: StdVideoH264WeightedBipredIdc) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pic_init_qp_minus26() {
    return this.#view.getInt8(40);
  }
  
  set pic_init_qp_minus26(value: number) {
    this.#view.setInt8(40, Number(value));
  }
  
  get pic_init_qs_minus26() {
    return this.#view.getInt8(41);
  }
  
  set pic_init_qs_minus26(value: number) {
    this.#view.setInt8(41, Number(value));
  }
  
  get chroma_qp_index_offset() {
    return this.#view.getInt8(42);
  }
  
  set chroma_qp_index_offset(value: number) {
    this.#view.setInt8(42, Number(value));
  }
  
  get second_chroma_qp_index_offset() {
    return this.#view.getInt8(43);
  }
  
  set second_chroma_qp_index_offset(value: number) {
    this.#view.setInt8(43, Number(value));
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pScalingLists(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoDecodeH264PictureInfoFlags {
  field_pic_flag?: number;
  is_intra?: number;
  IdrPicFlag?: number;
  bottom_field_flag?: number;
  is_reference?: number;
  complementary_field_pair?: number;
}

export class StdVideoDecodeH264PictureInfoFlags implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH264PictureInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH264PictureInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH264PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH264PictureInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH264PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.field_pic_flag !== undefined) this.field_pic_flag = data.field_pic_flag;
      if (data.is_intra !== undefined) this.is_intra = data.is_intra;
      if (data.IdrPicFlag !== undefined) this.IdrPicFlag = data.IdrPicFlag;
      if (data.bottom_field_flag !== undefined) this.bottom_field_flag = data.bottom_field_flag;
      if (data.is_reference !== undefined) this.is_reference = data.is_reference;
      if (data.complementary_field_pair !== undefined) this.complementary_field_pair = data.complementary_field_pair;
    }
  }
  
  get field_pic_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set field_pic_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get is_intra() {
    return this.#view.getUint32(4, LE);
  }
  
  set is_intra(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get IdrPicFlag() {
    return this.#view.getUint32(8, LE);
  }
  
  set IdrPicFlag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bottom_field_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set bottom_field_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get is_reference() {
    return this.#view.getUint32(16, LE);
  }
  
  set is_reference(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get complementary_field_pair() {
    return this.#view.getUint32(20, LE);
  }
  
  set complementary_field_pair(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitStdVideoDecodeH264PictureInfo {
  flags?: StdVideoDecodeH264PictureInfoFlags;
  seq_parameter_set_id?: number;
  pic_parameter_set_id?: number;
  reserved1?: number;
  reserved2?: number;
  frame_num?: number;
  idr_pic_id?: number;
  PicOrderCnt?: number[];
}

/** requires tag is for PicOrderCnt, which needs the enum type */
export class StdVideoDecodeH264PictureInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH264PictureInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH264PictureInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH264PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH264PictureInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH264PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.seq_parameter_set_id !== undefined) this.seq_parameter_set_id = data.seq_parameter_set_id;
      if (data.pic_parameter_set_id !== undefined) this.pic_parameter_set_id = data.pic_parameter_set_id;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.frame_num !== undefined) this.frame_num = data.frame_num;
      if (data.idr_pic_id !== undefined) this.idr_pic_id = data.idr_pic_id;
      if (data.PicOrderCnt !== undefined) this.PicOrderCnt = data.PicOrderCnt;
    }
  }
  
  get flags() {
    return new StdVideoDecodeH264PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH264PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH264PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(24);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(25);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(26);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(27);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(27, Number(value));
  }
  
  get frame_num() {
    return this.#view.getUint16(28, LE);
  }
  
  set frame_num(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
  
  get idr_pic_id() {
    return this.#view.getUint16(30, LE);
  }
  
  set idr_pic_id(value: number) {
    this.#view.setUint16(30, Number(value), LE);
  }
  
  get PicOrderCnt() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getInt32(32 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set PicOrderCnt(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt32(32 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitStdVideoDecodeH264ReferenceInfoFlags {
  top_field_flag?: number;
  bottom_field_flag?: number;
  used_for_long_term_reference?: number;
  is_non_existing?: number;
}

export class StdVideoDecodeH264ReferenceInfoFlags implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH264ReferenceInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH264ReferenceInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH264ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH264ReferenceInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH264ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.top_field_flag !== undefined) this.top_field_flag = data.top_field_flag;
      if (data.bottom_field_flag !== undefined) this.bottom_field_flag = data.bottom_field_flag;
      if (data.used_for_long_term_reference !== undefined) this.used_for_long_term_reference = data.used_for_long_term_reference;
      if (data.is_non_existing !== undefined) this.is_non_existing = data.is_non_existing;
    }
  }
  
  get top_field_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set top_field_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get bottom_field_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set bottom_field_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(8, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get is_non_existing() {
    return this.#view.getUint32(12, LE);
  }
  
  set is_non_existing(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitStdVideoDecodeH264ReferenceInfo {
  flags?: StdVideoDecodeH264ReferenceInfoFlags;
  FrameNum?: number;
  reserved?: number;
  PicOrderCnt?: number[];
}

export class StdVideoDecodeH264ReferenceInfo implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH264ReferenceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH264ReferenceInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH264ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH264ReferenceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH264ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.FrameNum !== undefined) this.FrameNum = data.FrameNum;
      if (data.reserved !== undefined) this.reserved = data.reserved;
      if (data.PicOrderCnt !== undefined) this.PicOrderCnt = data.PicOrderCnt;
    }
  }
  
  get flags() {
    return new StdVideoDecodeH264ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH264ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH264ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get FrameNum() {
    return this.#view.getUint16(16, LE);
  }
  
  set FrameNum(value: number) {
    this.#view.setUint16(16, Number(value), LE);
  }
  
  get reserved() {
    return this.#view.getUint16(18, LE);
  }
  
  set reserved(value: number) {
    this.#view.setUint16(18, Number(value), LE);
  }
  
  get PicOrderCnt() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getInt32(20 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set PicOrderCnt(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt32(20 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitStdVideoEncodeH264WeightTableFlags {
  luma_weight_l0_flag?: number;
  chroma_weight_l0_flag?: number;
  luma_weight_l1_flag?: number;
  chroma_weight_l1_flag?: number;
}

export class StdVideoEncodeH264WeightTableFlags implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264WeightTableFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264WeightTableFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264WeightTableFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264WeightTableFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264WeightTableFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.luma_weight_l0_flag !== undefined) this.luma_weight_l0_flag = data.luma_weight_l0_flag;
      if (data.chroma_weight_l0_flag !== undefined) this.chroma_weight_l0_flag = data.chroma_weight_l0_flag;
      if (data.luma_weight_l1_flag !== undefined) this.luma_weight_l1_flag = data.luma_weight_l1_flag;
      if (data.chroma_weight_l1_flag !== undefined) this.chroma_weight_l1_flag = data.chroma_weight_l1_flag;
    }
  }
  
  get luma_weight_l0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set luma_weight_l0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get chroma_weight_l0_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set chroma_weight_l0_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get luma_weight_l1_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set luma_weight_l1_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get chroma_weight_l1_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set chroma_weight_l1_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264WeightTable {
  flags?: StdVideoEncodeH264WeightTableFlags;
  luma_log2_weight_denom?: number;
  chroma_log2_weight_denom?: number;
  luma_weight_l0?: number[];
  luma_offset_l0?: number[];
  chroma_weight_l0?: number[];
  chroma_offset_l0?: number[];
  luma_weight_l1?: number[];
  luma_offset_l1?: number[];
  chroma_weight_l1?: number[];
  chroma_offset_l1?: number[];
}

export class StdVideoEncodeH264WeightTable implements BaseStruct {
  static size = 404;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264WeightTable);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264WeightTable) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264WeightTable.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264WeightTable.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264WeightTable.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.luma_log2_weight_denom !== undefined) this.luma_log2_weight_denom = data.luma_log2_weight_denom;
      if (data.chroma_log2_weight_denom !== undefined) this.chroma_log2_weight_denom = data.chroma_log2_weight_denom;
      if (data.luma_weight_l0 !== undefined) this.luma_weight_l0 = data.luma_weight_l0;
      if (data.luma_offset_l0 !== undefined) this.luma_offset_l0 = data.luma_offset_l0;
      if (data.chroma_weight_l0 !== undefined) this.chroma_weight_l0 = data.chroma_weight_l0;
      if (data.chroma_offset_l0 !== undefined) this.chroma_offset_l0 = data.chroma_offset_l0;
      if (data.luma_weight_l1 !== undefined) this.luma_weight_l1 = data.luma_weight_l1;
      if (data.luma_offset_l1 !== undefined) this.luma_offset_l1 = data.luma_offset_l1;
      if (data.chroma_weight_l1 !== undefined) this.chroma_weight_l1 = data.chroma_weight_l1;
      if (data.chroma_offset_l1 !== undefined) this.chroma_offset_l1 = data.chroma_offset_l1;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH264WeightTableFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264WeightTableFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264WeightTableFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get luma_log2_weight_denom() {
    return this.#view.getUint8(16);
  }
  
  set luma_log2_weight_denom(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get chroma_log2_weight_denom() {
    return this.#view.getUint8(17);
  }
  
  set chroma_log2_weight_denom(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get luma_weight_l0() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getInt8(18 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_weight_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(18 + i * 1, Number(value[i]));
    }
  }
  
  get luma_offset_l0() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getInt8(50 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_offset_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(50 + i * 1, Number(value[i]));
    }
  }
  
  get chroma_weight_l0() {
    const result: number[] = [];
    for (let i = 0; i < 64; i++) {
      result.push((() => {
        return this.#view.getInt8(82 + i * 1);
      })());
    }
    return result;
  }
  
  set chroma_weight_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(82 + i * 1, Number(value[i]));
    }
  }
  
  get chroma_offset_l0() {
    const result: number[] = [];
    for (let i = 0; i < 64; i++) {
      result.push((() => {
        return this.#view.getInt8(146 + i * 1);
      })());
    }
    return result;
  }
  
  set chroma_offset_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(146 + i * 1, Number(value[i]));
    }
  }
  
  get luma_weight_l1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getInt8(210 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_weight_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(210 + i * 1, Number(value[i]));
    }
  }
  
  get luma_offset_l1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getInt8(242 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_offset_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(242 + i * 1, Number(value[i]));
    }
  }
  
  get chroma_weight_l1() {
    const result: number[] = [];
    for (let i = 0; i < 64; i++) {
      result.push((() => {
        return this.#view.getInt8(274 + i * 1);
      })());
    }
    return result;
  }
  
  set chroma_weight_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(274 + i * 1, Number(value[i]));
    }
  }
  
  get chroma_offset_l1() {
    const result: number[] = [];
    for (let i = 0; i < 64; i++) {
      result.push((() => {
        return this.#view.getInt8(338 + i * 1);
      })());
    }
    return result;
  }
  
  set chroma_offset_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(338 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoEncodeH264SliceHeaderFlags {
  direct_spatial_mv_pred_flag?: number;
  num_ref_idx_active_override_flag?: number;
  no_output_of_prior_pics_flag?: number;
  adaptive_ref_pic_marking_mode_flag?: number;
  no_prior_references_available_flag?: number;
}

export class StdVideoEncodeH264SliceHeaderFlags implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264SliceHeaderFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264SliceHeaderFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264SliceHeaderFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264SliceHeaderFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264SliceHeaderFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.direct_spatial_mv_pred_flag !== undefined) this.direct_spatial_mv_pred_flag = data.direct_spatial_mv_pred_flag;
      if (data.num_ref_idx_active_override_flag !== undefined) this.num_ref_idx_active_override_flag = data.num_ref_idx_active_override_flag;
      if (data.no_output_of_prior_pics_flag !== undefined) this.no_output_of_prior_pics_flag = data.no_output_of_prior_pics_flag;
      if (data.adaptive_ref_pic_marking_mode_flag !== undefined) this.adaptive_ref_pic_marking_mode_flag = data.adaptive_ref_pic_marking_mode_flag;
      if (data.no_prior_references_available_flag !== undefined) this.no_prior_references_available_flag = data.no_prior_references_available_flag;
    }
  }
  
  get direct_spatial_mv_pred_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set direct_spatial_mv_pred_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get num_ref_idx_active_override_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set num_ref_idx_active_override_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get no_output_of_prior_pics_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set no_output_of_prior_pics_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get adaptive_ref_pic_marking_mode_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set adaptive_ref_pic_marking_mode_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get no_prior_references_available_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set no_prior_references_available_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264PictureInfoFlags {
  idr_flag?: number;
  is_reference_flag?: number;
  used_for_long_term_reference?: number;
}

export class StdVideoEncodeH264PictureInfoFlags implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264PictureInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264PictureInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264PictureInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.idr_flag !== undefined) this.idr_flag = data.idr_flag;
      if (data.is_reference_flag !== undefined) this.is_reference_flag = data.is_reference_flag;
      if (data.used_for_long_term_reference !== undefined) this.used_for_long_term_reference = data.used_for_long_term_reference;
    }
  }
  
  get idr_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set idr_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get is_reference_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set is_reference_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(8, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264ReferenceInfoFlags {
  used_for_long_term_reference?: number;
}

export class StdVideoEncodeH264ReferenceInfoFlags implements BaseStruct {
  static size = 4;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264ReferenceInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264ReferenceInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264ReferenceInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.used_for_long_term_reference !== undefined) this.used_for_long_term_reference = data.used_for_long_term_reference;
    }
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264RefMgmtFlags {
  ref_pic_list_modification_l0_flag?: number;
  ref_pic_list_modification_l1_flag?: number;
}

export class StdVideoEncodeH264RefMgmtFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264RefMgmtFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264RefMgmtFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264RefMgmtFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264RefMgmtFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264RefMgmtFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.ref_pic_list_modification_l0_flag !== undefined) this.ref_pic_list_modification_l0_flag = data.ref_pic_list_modification_l0_flag;
      if (data.ref_pic_list_modification_l1_flag !== undefined) this.ref_pic_list_modification_l1_flag = data.ref_pic_list_modification_l1_flag;
    }
  }
  
  get ref_pic_list_modification_l0_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set ref_pic_list_modification_l0_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get ref_pic_list_modification_l1_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set ref_pic_list_modification_l1_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264RefListModEntry {
  modification_of_pic_nums_idc?: StdVideoH264ModificationOfPicNumsIdc;
  abs_diff_pic_num_minus1?: number;
  long_term_pic_num?: number;
}

export class StdVideoEncodeH264RefListModEntry implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264RefListModEntry);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264RefListModEntry) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264RefListModEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264RefListModEntry.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264RefListModEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.modification_of_pic_nums_idc !== undefined) this.modification_of_pic_nums_idc = data.modification_of_pic_nums_idc;
      if (data.abs_diff_pic_num_minus1 !== undefined) this.abs_diff_pic_num_minus1 = data.abs_diff_pic_num_minus1;
      if (data.long_term_pic_num !== undefined) this.long_term_pic_num = data.long_term_pic_num;
    }
  }
  
  get modification_of_pic_nums_idc() {
    return this.#view.getUint32(0, LE);
  }
  
  set modification_of_pic_nums_idc(value: StdVideoH264ModificationOfPicNumsIdc) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get abs_diff_pic_num_minus1() {
    return this.#view.getUint16(4, LE);
  }
  
  set abs_diff_pic_num_minus1(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(6, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264RefPicMarkingEntry {
  operation?: StdVideoH264MemMgmtControlOp;
  difference_of_pic_nums_minus1?: number;
  long_term_pic_num?: number;
  long_term_frame_idx?: number;
  max_long_term_frame_idx_plus1?: number;
}

export class StdVideoEncodeH264RefPicMarkingEntry implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264RefPicMarkingEntry);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264RefPicMarkingEntry) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264RefPicMarkingEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264RefPicMarkingEntry.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264RefPicMarkingEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.operation !== undefined) this.operation = data.operation;
      if (data.difference_of_pic_nums_minus1 !== undefined) this.difference_of_pic_nums_minus1 = data.difference_of_pic_nums_minus1;
      if (data.long_term_pic_num !== undefined) this.long_term_pic_num = data.long_term_pic_num;
      if (data.long_term_frame_idx !== undefined) this.long_term_frame_idx = data.long_term_frame_idx;
      if (data.max_long_term_frame_idx_plus1 !== undefined) this.max_long_term_frame_idx_plus1 = data.max_long_term_frame_idx_plus1;
    }
  }
  
  get operation() {
    return this.#view.getUint32(0, LE);
  }
  
  set operation(value: StdVideoH264MemMgmtControlOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get difference_of_pic_nums_minus1() {
    return this.#view.getUint16(4, LE);
  }
  
  set difference_of_pic_nums_minus1(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(6, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
  
  get long_term_frame_idx() {
    return this.#view.getUint16(8, LE);
  }
  
  set long_term_frame_idx(value: number) {
    this.#view.setUint16(8, Number(value), LE);
  }
  
  get max_long_term_frame_idx_plus1() {
    return this.#view.getUint16(10, LE);
  }
  
  set max_long_term_frame_idx_plus1(value: number) {
    this.#view.setUint16(10, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264RefMemMgmtCtrlOperations {
  flags?: StdVideoEncodeH264RefMgmtFlags;
  refList0ModOpCount?: number;
  pRefList0ModOperations?: AnyPointer;
  refList1ModOpCount?: number;
  pRefList1ModOperations?: AnyPointer;
  refPicMarkingOpCount?: number;
  pRefPicMarkingOperations?: AnyPointer;
}

export class StdVideoEncodeH264RefMemMgmtCtrlOperations implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264RefMemMgmtCtrlOperations);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264RefMemMgmtCtrlOperations) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264RefMemMgmtCtrlOperations.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264RefMemMgmtCtrlOperations.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264RefMemMgmtCtrlOperations.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.refList0ModOpCount !== undefined) this.refList0ModOpCount = data.refList0ModOpCount;
      if (data.pRefList0ModOperations !== undefined) this.pRefList0ModOperations = data.pRefList0ModOperations;
      if (data.refList1ModOpCount !== undefined) this.refList1ModOpCount = data.refList1ModOpCount;
      if (data.pRefList1ModOperations !== undefined) this.pRefList1ModOperations = data.pRefList1ModOperations;
      if (data.refPicMarkingOpCount !== undefined) this.refPicMarkingOpCount = data.refPicMarkingOpCount;
      if (data.pRefPicMarkingOperations !== undefined) this.pRefPicMarkingOperations = data.pRefPicMarkingOperations;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH264RefMgmtFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264RefMgmtFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264RefMgmtFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264RefMgmtFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get refList0ModOpCount() {
    return this.#view.getUint8(8);
  }
  
  set refList0ModOpCount(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get pRefList0ModOperations() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pRefList0ModOperations(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get refList1ModOpCount() {
    return this.#view.getUint8(24);
  }
  
  set refList1ModOpCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pRefList1ModOperations() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pRefList1ModOperations(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get refPicMarkingOpCount() {
    return this.#view.getUint8(40);
  }
  
  set refPicMarkingOpCount(value: number) {
    this.#view.setUint8(40, Number(value));
  }
  
  get pRefPicMarkingOperations() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRefPicMarkingOperations(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoEncodeH264PictureInfo {
  flags?: StdVideoEncodeH264PictureInfoFlags;
  seq_parameter_set_id?: number;
  pic_parameter_set_id?: number;
  pictureType?: StdVideoH264PictureType;
  frame_num?: number;
  PicOrderCnt?: number;
}

export class StdVideoEncodeH264PictureInfo implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264PictureInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264PictureInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264PictureInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.seq_parameter_set_id !== undefined) this.seq_parameter_set_id = data.seq_parameter_set_id;
      if (data.pic_parameter_set_id !== undefined) this.pic_parameter_set_id = data.pic_parameter_set_id;
      if (data.pictureType !== undefined) this.pictureType = data.pictureType;
      if (data.frame_num !== undefined) this.frame_num = data.frame_num;
      if (data.PicOrderCnt !== undefined) this.PicOrderCnt = data.PicOrderCnt;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH264PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get seq_parameter_set_id() {
    return this.#view.getUint8(12);
  }
  
  set seq_parameter_set_id(value: number) {
    this.#view.setUint8(12, Number(value));
  }
  
  get pic_parameter_set_id() {
    return this.#view.getUint8(13);
  }
  
  set pic_parameter_set_id(value: number) {
    this.#view.setUint8(13, Number(value));
  }
  
  get pictureType() {
    return this.#view.getUint32(16, LE);
  }
  
  set pictureType(value: StdVideoH264PictureType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get frame_num() {
    return this.#view.getUint32(20, LE);
  }
  
  set frame_num(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(24, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(24, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264ReferenceInfo {
  flags?: StdVideoEncodeH264ReferenceInfoFlags;
  FrameNum?: number;
  PicOrderCnt?: number;
  long_term_pic_num?: number;
  long_term_frame_idx?: number;
}

export class StdVideoEncodeH264ReferenceInfo implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264ReferenceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264ReferenceInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264ReferenceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.FrameNum !== undefined) this.FrameNum = data.FrameNum;
      if (data.PicOrderCnt !== undefined) this.PicOrderCnt = data.PicOrderCnt;
      if (data.long_term_pic_num !== undefined) this.long_term_pic_num = data.long_term_pic_num;
      if (data.long_term_frame_idx !== undefined) this.long_term_frame_idx = data.long_term_frame_idx;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH264ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get FrameNum() {
    return this.#view.getUint32(4, LE);
  }
  
  set FrameNum(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get PicOrderCnt() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCnt(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
  
  get long_term_pic_num() {
    return this.#view.getUint16(12, LE);
  }
  
  set long_term_pic_num(value: number) {
    this.#view.setUint16(12, Number(value), LE);
  }
  
  get long_term_frame_idx() {
    return this.#view.getUint16(14, LE);
  }
  
  set long_term_frame_idx(value: number) {
    this.#view.setUint16(14, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH264SliceHeader {
  flags?: StdVideoEncodeH264SliceHeaderFlags;
  first_mb_in_slice?: number;
  slice_type?: StdVideoH264SliceType;
  idr_pic_id?: number;
  num_ref_idx_l0_active_minus1?: number;
  num_ref_idx_l1_active_minus1?: number;
  cabac_init_idc?: StdVideoH264CabacInitIdc;
  disable_deblocking_filter_idc?: StdVideoH264DisableDeblockingFilterIdc;
  slice_alpha_c0_offset_div2?: number;
  slice_beta_offset_div2?: number;
  pWeightTable?: AnyPointer;
}

export class StdVideoEncodeH264SliceHeader implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH264SliceHeader);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH264SliceHeader) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH264SliceHeader.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH264SliceHeader.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH264SliceHeader.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.first_mb_in_slice !== undefined) this.first_mb_in_slice = data.first_mb_in_slice;
      if (data.slice_type !== undefined) this.slice_type = data.slice_type;
      if (data.idr_pic_id !== undefined) this.idr_pic_id = data.idr_pic_id;
      if (data.num_ref_idx_l0_active_minus1 !== undefined) this.num_ref_idx_l0_active_minus1 = data.num_ref_idx_l0_active_minus1;
      if (data.num_ref_idx_l1_active_minus1 !== undefined) this.num_ref_idx_l1_active_minus1 = data.num_ref_idx_l1_active_minus1;
      if (data.cabac_init_idc !== undefined) this.cabac_init_idc = data.cabac_init_idc;
      if (data.disable_deblocking_filter_idc !== undefined) this.disable_deblocking_filter_idc = data.disable_deblocking_filter_idc;
      if (data.slice_alpha_c0_offset_div2 !== undefined) this.slice_alpha_c0_offset_div2 = data.slice_alpha_c0_offset_div2;
      if (data.slice_beta_offset_div2 !== undefined) this.slice_beta_offset_div2 = data.slice_beta_offset_div2;
      if (data.pWeightTable !== undefined) this.pWeightTable = data.pWeightTable;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH264SliceHeaderFlags(this.#data.subarray(0, 0 + StdVideoEncodeH264SliceHeaderFlags.size));
  }
  
  set flags(value: StdVideoEncodeH264SliceHeaderFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH264SliceHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get first_mb_in_slice() {
    return this.#view.getUint32(20, LE);
  }
  
  set first_mb_in_slice(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get slice_type() {
    return this.#view.getUint32(24, LE);
  }
  
  set slice_type(value: StdVideoH264SliceType) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get idr_pic_id() {
    return this.#view.getUint16(28, LE);
  }
  
  set idr_pic_id(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
  
  get num_ref_idx_l0_active_minus1() {
    return this.#view.getUint8(30);
  }
  
  set num_ref_idx_l0_active_minus1(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get num_ref_idx_l1_active_minus1() {
    return this.#view.getUint8(31);
  }
  
  set num_ref_idx_l1_active_minus1(value: number) {
    this.#view.setUint8(31, Number(value));
  }
  
  get cabac_init_idc() {
    return this.#view.getUint32(32, LE);
  }
  
  set cabac_init_idc(value: StdVideoH264CabacInitIdc) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get disable_deblocking_filter_idc() {
    return this.#view.getUint32(36, LE);
  }
  
  set disable_deblocking_filter_idc(value: StdVideoH264DisableDeblockingFilterIdc) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get slice_alpha_c0_offset_div2() {
    return this.#view.getInt8(40);
  }
  
  set slice_alpha_c0_offset_div2(value: number) {
    this.#view.setInt8(40, Number(value));
  }
  
  get slice_beta_offset_div2() {
    return this.#view.getInt8(41);
  }
  
  set slice_beta_offset_div2(value: number) {
    this.#view.setInt8(41, Number(value));
  }
  
  get pWeightTable() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pWeightTable(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH265ProfileTierLevelFlags {
  general_tier_flag?: number;
  general_progressive_source_flag?: number;
  general_interlaced_source_flag?: number;
  general_non_packed_constraint_flag?: number;
  general_frame_only_constraint_flag?: number;
}

export class StdVideoH265ProfileTierLevelFlags implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265ProfileTierLevelFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265ProfileTierLevelFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265ProfileTierLevelFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265ProfileTierLevelFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265ProfileTierLevelFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.general_tier_flag !== undefined) this.general_tier_flag = data.general_tier_flag;
      if (data.general_progressive_source_flag !== undefined) this.general_progressive_source_flag = data.general_progressive_source_flag;
      if (data.general_interlaced_source_flag !== undefined) this.general_interlaced_source_flag = data.general_interlaced_source_flag;
      if (data.general_non_packed_constraint_flag !== undefined) this.general_non_packed_constraint_flag = data.general_non_packed_constraint_flag;
      if (data.general_frame_only_constraint_flag !== undefined) this.general_frame_only_constraint_flag = data.general_frame_only_constraint_flag;
    }
  }
  
  get general_tier_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set general_tier_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get general_progressive_source_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set general_progressive_source_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get general_interlaced_source_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set general_interlaced_source_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get general_non_packed_constraint_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set general_non_packed_constraint_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get general_frame_only_constraint_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set general_frame_only_constraint_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitStdVideoH265ProfileTierLevel {
  flags?: StdVideoH265ProfileTierLevelFlags;
  general_profile_idc?: StdVideoH265ProfileIdc;
  general_level_idc?: StdVideoH265LevelIdc;
}

/** profile_tier_level */
export class StdVideoH265ProfileTierLevel implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265ProfileTierLevel);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265ProfileTierLevel) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265ProfileTierLevel.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265ProfileTierLevel.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265ProfileTierLevel.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.general_profile_idc !== undefined) this.general_profile_idc = data.general_profile_idc;
      if (data.general_level_idc !== undefined) this.general_level_idc = data.general_level_idc;
    }
  }
  
  get flags() {
    return new StdVideoH265ProfileTierLevelFlags(this.#data.subarray(0, 0 + StdVideoH265ProfileTierLevelFlags.size));
  }
  
  set flags(value: StdVideoH265ProfileTierLevelFlags) {
    if (value[BUFFER].byteLength < StdVideoH265ProfileTierLevelFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get general_profile_idc() {
    return this.#view.getUint32(20, LE);
  }
  
  set general_profile_idc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get general_level_idc() {
    return this.#view.getUint32(24, LE);
  }
  
  set general_level_idc(value: StdVideoH265LevelIdc) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitStdVideoH265DecPicBufMgr {
  max_latency_increase_plus1?: number[];
  max_dec_pic_buffering_minus1?: number[];
  max_num_reorder_pics?: number[];
}

/** sps_ or vps_ parameters, based on if the StdVideoH265DecPicBufMgr is used within the StdVideoH265SequenceParameterSet or StdVideoH265VideoParameterSet */
export class StdVideoH265DecPicBufMgr implements BaseStruct {
  static size = 44;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265DecPicBufMgr);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265DecPicBufMgr) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265DecPicBufMgr.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265DecPicBufMgr.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265DecPicBufMgr.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.max_latency_increase_plus1 !== undefined) this.max_latency_increase_plus1 = data.max_latency_increase_plus1;
      if (data.max_dec_pic_buffering_minus1 !== undefined) this.max_dec_pic_buffering_minus1 = data.max_dec_pic_buffering_minus1;
      if (data.max_num_reorder_pics !== undefined) this.max_num_reorder_pics = data.max_num_reorder_pics;
    }
  }
  
  get max_latency_increase_plus1() {
    const result: number[] = [];
    for (let i = 0; i < 7; i++) {
      result.push((() => {
        return this.#view.getUint32(0 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set max_latency_increase_plus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(0 + i * 4, Number(value[i]), LE);
    }
  }
  
  get max_dec_pic_buffering_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 7; i++) {
      result.push((() => {
        return this.#view.getUint8(28 + i * 1);
      })());
    }
    return result;
  }
  
  set max_dec_pic_buffering_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(28 + i * 1, Number(value[i]));
    }
  }
  
  get max_num_reorder_pics() {
    const result: number[] = [];
    for (let i = 0; i < 7; i++) {
      result.push((() => {
        return this.#view.getUint8(35 + i * 1);
      })());
    }
    return result;
  }
  
  set max_num_reorder_pics(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(35 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoH265SubLayerHrdParameters {
  bit_rate_value_minus1?: number[];
  cpb_size_value_minus1?: number[];
  cpb_size_du_value_minus1?: number[];
  bit_rate_du_value_minus1?: number[];
  cbr_flag?: number;
}

/** sub_layer_hrd_parameters */
export class StdVideoH265SubLayerHrdParameters implements BaseStruct {
  static size = 516;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265SubLayerHrdParameters);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265SubLayerHrdParameters) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265SubLayerHrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265SubLayerHrdParameters.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265SubLayerHrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.bit_rate_value_minus1 !== undefined) this.bit_rate_value_minus1 = data.bit_rate_value_minus1;
      if (data.cpb_size_value_minus1 !== undefined) this.cpb_size_value_minus1 = data.cpb_size_value_minus1;
      if (data.cpb_size_du_value_minus1 !== undefined) this.cpb_size_du_value_minus1 = data.cpb_size_du_value_minus1;
      if (data.bit_rate_du_value_minus1 !== undefined) this.bit_rate_du_value_minus1 = data.bit_rate_du_value_minus1;
      if (data.cbr_flag !== undefined) this.cbr_flag = data.cbr_flag;
    }
  }
  
  get bit_rate_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(0 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set bit_rate_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(0 + i * 4, Number(value[i]), LE);
    }
  }
  
  get cpb_size_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(128 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set cpb_size_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(128 + i * 4, Number(value[i]), LE);
    }
  }
  
  get cpb_size_du_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(256 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set cpb_size_du_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(256 + i * 4, Number(value[i]), LE);
    }
  }
  
  get bit_rate_du_value_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(384 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set bit_rate_du_value_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(384 + i * 4, Number(value[i]), LE);
    }
  }
  
  get cbr_flag() {
    return this.#view.getUint32(512, LE);
  }
  
  set cbr_flag(value: number) {
    this.#view.setUint32(512, Number(value), LE);
  }
}

export interface InitStdVideoH265HrdFlags {
  nal_hrd_parameters_present_flag?: number;
  vcl_hrd_parameters_present_flag?: number;
  sub_pic_hrd_params_present_flag?: number;
  sub_pic_cpb_params_in_pic_timing_sei_flag?: number;
  fixed_pic_rate_general_flag?: number;
  fixed_pic_rate_within_cvs_flag?: number;
  low_delay_hrd_flag?: number;
}

export class StdVideoH265HrdFlags implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265HrdFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265HrdFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265HrdFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265HrdFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265HrdFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.nal_hrd_parameters_present_flag !== undefined) this.nal_hrd_parameters_present_flag = data.nal_hrd_parameters_present_flag;
      if (data.vcl_hrd_parameters_present_flag !== undefined) this.vcl_hrd_parameters_present_flag = data.vcl_hrd_parameters_present_flag;
      if (data.sub_pic_hrd_params_present_flag !== undefined) this.sub_pic_hrd_params_present_flag = data.sub_pic_hrd_params_present_flag;
      if (data.sub_pic_cpb_params_in_pic_timing_sei_flag !== undefined) this.sub_pic_cpb_params_in_pic_timing_sei_flag = data.sub_pic_cpb_params_in_pic_timing_sei_flag;
      if (data.fixed_pic_rate_general_flag !== undefined) this.fixed_pic_rate_general_flag = data.fixed_pic_rate_general_flag;
      if (data.fixed_pic_rate_within_cvs_flag !== undefined) this.fixed_pic_rate_within_cvs_flag = data.fixed_pic_rate_within_cvs_flag;
      if (data.low_delay_hrd_flag !== undefined) this.low_delay_hrd_flag = data.low_delay_hrd_flag;
    }
  }
  
  get nal_hrd_parameters_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set nal_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vcl_hrd_parameters_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set vcl_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sub_pic_hrd_params_present_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set sub_pic_hrd_params_present_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get sub_pic_cpb_params_in_pic_timing_sei_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set sub_pic_cpb_params_in_pic_timing_sei_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get fixed_pic_rate_general_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set fixed_pic_rate_general_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fixed_pic_rate_within_cvs_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set fixed_pic_rate_within_cvs_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get low_delay_hrd_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set low_delay_hrd_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitStdVideoH265HrdParameters {
  flags?: StdVideoH265HrdFlags;
  tick_divisor_minus2?: number;
  du_cpb_removal_delay_increment_length_minus1?: number;
  dpb_output_delay_du_length_minus1?: number;
  bit_rate_scale?: number;
  cpb_size_scale?: number;
  cpb_size_du_scale?: number;
  initial_cpb_removal_delay_length_minus1?: number;
  au_cpb_removal_delay_length_minus1?: number;
  dpb_output_delay_length_minus1?: number;
  cpb_cnt_minus1?: number[];
  elemental_duration_in_tc_minus1?: number[];
  reserved?: number[];
  pSubLayerHrdParametersNal?: AnyPointer;
  pSubLayerHrdParametersVcl?: AnyPointer;
}

export class StdVideoH265HrdParameters implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265HrdParameters);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265HrdParameters) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265HrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265HrdParameters.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265HrdParameters.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.tick_divisor_minus2 !== undefined) this.tick_divisor_minus2 = data.tick_divisor_minus2;
      if (data.du_cpb_removal_delay_increment_length_minus1 !== undefined) this.du_cpb_removal_delay_increment_length_minus1 = data.du_cpb_removal_delay_increment_length_minus1;
      if (data.dpb_output_delay_du_length_minus1 !== undefined) this.dpb_output_delay_du_length_minus1 = data.dpb_output_delay_du_length_minus1;
      if (data.bit_rate_scale !== undefined) this.bit_rate_scale = data.bit_rate_scale;
      if (data.cpb_size_scale !== undefined) this.cpb_size_scale = data.cpb_size_scale;
      if (data.cpb_size_du_scale !== undefined) this.cpb_size_du_scale = data.cpb_size_du_scale;
      if (data.initial_cpb_removal_delay_length_minus1 !== undefined) this.initial_cpb_removal_delay_length_minus1 = data.initial_cpb_removal_delay_length_minus1;
      if (data.au_cpb_removal_delay_length_minus1 !== undefined) this.au_cpb_removal_delay_length_minus1 = data.au_cpb_removal_delay_length_minus1;
      if (data.dpb_output_delay_length_minus1 !== undefined) this.dpb_output_delay_length_minus1 = data.dpb_output_delay_length_minus1;
      if (data.cpb_cnt_minus1 !== undefined) this.cpb_cnt_minus1 = data.cpb_cnt_minus1;
      if (data.elemental_duration_in_tc_minus1 !== undefined) this.elemental_duration_in_tc_minus1 = data.elemental_duration_in_tc_minus1;
      if (data.reserved !== undefined) this.reserved = data.reserved;
      if (data.pSubLayerHrdParametersNal !== undefined) this.pSubLayerHrdParametersNal = data.pSubLayerHrdParametersNal;
      if (data.pSubLayerHrdParametersVcl !== undefined) this.pSubLayerHrdParametersVcl = data.pSubLayerHrdParametersVcl;
    }
  }
  
  get flags() {
    return new StdVideoH265HrdFlags(this.#data.subarray(0, 0 + StdVideoH265HrdFlags.size));
  }
  
  set flags(value: StdVideoH265HrdFlags) {
    if (value[BUFFER].byteLength < StdVideoH265HrdFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get tick_divisor_minus2() {
    return this.#view.getUint8(28);
  }
  
  set tick_divisor_minus2(value: number) {
    this.#view.setUint8(28, Number(value));
  }
  
  get du_cpb_removal_delay_increment_length_minus1() {
    return this.#view.getUint8(29);
  }
  
  set du_cpb_removal_delay_increment_length_minus1(value: number) {
    this.#view.setUint8(29, Number(value));
  }
  
  get dpb_output_delay_du_length_minus1() {
    return this.#view.getUint8(30);
  }
  
  set dpb_output_delay_du_length_minus1(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get bit_rate_scale() {
    return this.#view.getUint8(31);
  }
  
  set bit_rate_scale(value: number) {
    this.#view.setUint8(31, Number(value));
  }
  
  get cpb_size_scale() {
    return this.#view.getUint8(32);
  }
  
  set cpb_size_scale(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get cpb_size_du_scale() {
    return this.#view.getUint8(33);
  }
  
  set cpb_size_du_scale(value: number) {
    this.#view.setUint8(33, Number(value));
  }
  
  get initial_cpb_removal_delay_length_minus1() {
    return this.#view.getUint8(34);
  }
  
  set initial_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint8(34, Number(value));
  }
  
  get au_cpb_removal_delay_length_minus1() {
    return this.#view.getUint8(35);
  }
  
  set au_cpb_removal_delay_length_minus1(value: number) {
    this.#view.setUint8(35, Number(value));
  }
  
  get dpb_output_delay_length_minus1() {
    return this.#view.getUint8(36);
  }
  
  set dpb_output_delay_length_minus1(value: number) {
    this.#view.setUint8(36, Number(value));
  }
  
  get cpb_cnt_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 7; i++) {
      result.push((() => {
        return this.#view.getUint8(37 + i * 1);
      })());
    }
    return result;
  }
  
  set cpb_cnt_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(37 + i * 1, Number(value[i]));
    }
  }
  
  get elemental_duration_in_tc_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 7; i++) {
      result.push((() => {
        return this.#view.getUint16(44 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set elemental_duration_in_tc_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(44 + i * 2, Number(value[i]), LE);
    }
  }
  
  get reserved() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint16(58 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set reserved(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(58 + i * 2, Number(value[i]), LE);
    }
  }
  
  get pSubLayerHrdParametersNal() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pSubLayerHrdParametersNal(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get pSubLayerHrdParametersVcl() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pSubLayerHrdParametersVcl(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH265VpsFlags {
  vps_temporal_id_nesting_flag?: number;
  vps_sub_layer_ordering_info_present_flag?: number;
  vps_timing_info_present_flag?: number;
  vps_poc_proportional_to_timing_flag?: number;
}

export class StdVideoH265VpsFlags implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265VpsFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265VpsFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265VpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265VpsFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265VpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.vps_temporal_id_nesting_flag !== undefined) this.vps_temporal_id_nesting_flag = data.vps_temporal_id_nesting_flag;
      if (data.vps_sub_layer_ordering_info_present_flag !== undefined) this.vps_sub_layer_ordering_info_present_flag = data.vps_sub_layer_ordering_info_present_flag;
      if (data.vps_timing_info_present_flag !== undefined) this.vps_timing_info_present_flag = data.vps_timing_info_present_flag;
      if (data.vps_poc_proportional_to_timing_flag !== undefined) this.vps_poc_proportional_to_timing_flag = data.vps_poc_proportional_to_timing_flag;
    }
  }
  
  get vps_temporal_id_nesting_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set vps_temporal_id_nesting_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vps_sub_layer_ordering_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set vps_sub_layer_ordering_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vps_timing_info_present_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set vps_timing_info_present_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get vps_poc_proportional_to_timing_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set vps_poc_proportional_to_timing_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitStdVideoH265VideoParameterSet {
  flags?: StdVideoH265VpsFlags;
  vps_video_parameter_set_id?: number;
  vps_max_sub_layers_minus1?: number;
  reserved1?: number;
  reserved2?: number;
  vps_num_units_in_tick?: number;
  vps_time_scale?: number;
  vps_num_ticks_poc_diff_one_minus1?: number;
  reserved3?: number;
  pDecPicBufMgr?: AnyPointer;
  pHrdParameters?: AnyPointer;
  pProfileTierLevel?: AnyPointer;
}

export class StdVideoH265VideoParameterSet implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265VideoParameterSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265VideoParameterSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265VideoParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265VideoParameterSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265VideoParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.vps_video_parameter_set_id !== undefined) this.vps_video_parameter_set_id = data.vps_video_parameter_set_id;
      if (data.vps_max_sub_layers_minus1 !== undefined) this.vps_max_sub_layers_minus1 = data.vps_max_sub_layers_minus1;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.vps_num_units_in_tick !== undefined) this.vps_num_units_in_tick = data.vps_num_units_in_tick;
      if (data.vps_time_scale !== undefined) this.vps_time_scale = data.vps_time_scale;
      if (data.vps_num_ticks_poc_diff_one_minus1 !== undefined) this.vps_num_ticks_poc_diff_one_minus1 = data.vps_num_ticks_poc_diff_one_minus1;
      if (data.reserved3 !== undefined) this.reserved3 = data.reserved3;
      if (data.pDecPicBufMgr !== undefined) this.pDecPicBufMgr = data.pDecPicBufMgr;
      if (data.pHrdParameters !== undefined) this.pHrdParameters = data.pHrdParameters;
      if (data.pProfileTierLevel !== undefined) this.pProfileTierLevel = data.pProfileTierLevel;
    }
  }
  
  get flags() {
    return new StdVideoH265VpsFlags(this.#data.subarray(0, 0 + StdVideoH265VpsFlags.size));
  }
  
  set flags(value: StdVideoH265VpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265VpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get vps_video_parameter_set_id() {
    return this.#view.getUint8(16);
  }
  
  set vps_video_parameter_set_id(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get vps_max_sub_layers_minus1() {
    return this.#view.getUint8(17);
  }
  
  set vps_max_sub_layers_minus1(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(18);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(19);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(19, Number(value));
  }
  
  get vps_num_units_in_tick() {
    return this.#view.getUint32(20, LE);
  }
  
  set vps_num_units_in_tick(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vps_time_scale() {
    return this.#view.getUint32(24, LE);
  }
  
  set vps_time_scale(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get vps_num_ticks_poc_diff_one_minus1() {
    return this.#view.getUint32(28, LE);
  }
  
  set vps_num_ticks_poc_diff_one_minus1(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get reserved3() {
    return this.#view.getUint32(32, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pDecPicBufMgr() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pDecPicBufMgr(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pHrdParameters(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pProfileTierLevel() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pProfileTierLevel(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH265ScalingLists {
  ScalingList4x4?: number[];
  ScalingList8x8?: number[];
  ScalingList16x16?: number[];
  ScalingList32x32?: number[];
  ScalingListDCCoef16x16?: number[];
  ScalingListDCCoef32x32?: number[];
}

export class StdVideoH265ScalingLists implements BaseStruct {
  static size = 1000;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265ScalingLists);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265ScalingLists) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265ScalingLists.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265ScalingLists.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265ScalingLists.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.ScalingList4x4 !== undefined) this.ScalingList4x4 = data.ScalingList4x4;
      if (data.ScalingList8x8 !== undefined) this.ScalingList8x8 = data.ScalingList8x8;
      if (data.ScalingList16x16 !== undefined) this.ScalingList16x16 = data.ScalingList16x16;
      if (data.ScalingList32x32 !== undefined) this.ScalingList32x32 = data.ScalingList32x32;
      if (data.ScalingListDCCoef16x16 !== undefined) this.ScalingListDCCoef16x16 = data.ScalingListDCCoef16x16;
      if (data.ScalingListDCCoef32x32 !== undefined) this.ScalingListDCCoef32x32 = data.ScalingListDCCoef32x32;
    }
  }
  
  get ScalingList4x4() {
    const result: number[] = [];
    for (let i = 0; i < 96; i++) {
      result.push((() => {
        return this.#view.getUint8(0 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList4x4(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(0 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingList8x8() {
    const result: number[] = [];
    for (let i = 0; i < 384; i++) {
      result.push((() => {
        return this.#view.getUint8(96 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList8x8(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(96 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingList16x16() {
    const result: number[] = [];
    for (let i = 0; i < 384; i++) {
      result.push((() => {
        return this.#view.getUint8(480 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList16x16(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(480 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingList32x32() {
    const result: number[] = [];
    for (let i = 0; i < 128; i++) {
      result.push((() => {
        return this.#view.getUint8(864 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingList32x32(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(864 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingListDCCoef16x16() {
    const result: number[] = [];
    for (let i = 0; i < 6; i++) {
      result.push((() => {
        return this.#view.getUint8(992 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingListDCCoef16x16(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(992 + i * 1, Number(value[i]));
    }
  }
  
  get ScalingListDCCoef32x32() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getUint8(998 + i * 1);
      })());
    }
    return result;
  }
  
  set ScalingListDCCoef32x32(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(998 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoH265ShortTermRefPicSetFlags {
  inter_ref_pic_set_prediction_flag?: number;
  delta_rps_sign?: number;
}

export class StdVideoH265ShortTermRefPicSetFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265ShortTermRefPicSetFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265ShortTermRefPicSetFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265ShortTermRefPicSetFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265ShortTermRefPicSetFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265ShortTermRefPicSetFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.inter_ref_pic_set_prediction_flag !== undefined) this.inter_ref_pic_set_prediction_flag = data.inter_ref_pic_set_prediction_flag;
      if (data.delta_rps_sign !== undefined) this.delta_rps_sign = data.delta_rps_sign;
    }
  }
  
  get inter_ref_pic_set_prediction_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set inter_ref_pic_set_prediction_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get delta_rps_sign() {
    return this.#view.getUint32(4, LE);
  }
  
  set delta_rps_sign(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitStdVideoH265ShortTermRefPicSet {
  flags?: StdVideoH265ShortTermRefPicSetFlags;
  delta_idx_minus1?: number;
  use_delta_flag?: number;
  abs_delta_rps_minus1?: number;
  used_by_curr_pic_flag?: number;
  used_by_curr_pic_s0_flag?: number;
  used_by_curr_pic_s1_flag?: number;
  reserved1?: number;
  reserved2?: number;
  reserved3?: number;
  num_negative_pics?: number;
  num_positive_pics?: number;
  delta_poc_s0_minus1?: number[];
  delta_poc_s1_minus1?: number[];
}

export class StdVideoH265ShortTermRefPicSet implements BaseStruct {
  static size = 92;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265ShortTermRefPicSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265ShortTermRefPicSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265ShortTermRefPicSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265ShortTermRefPicSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265ShortTermRefPicSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.delta_idx_minus1 !== undefined) this.delta_idx_minus1 = data.delta_idx_minus1;
      if (data.use_delta_flag !== undefined) this.use_delta_flag = data.use_delta_flag;
      if (data.abs_delta_rps_minus1 !== undefined) this.abs_delta_rps_minus1 = data.abs_delta_rps_minus1;
      if (data.used_by_curr_pic_flag !== undefined) this.used_by_curr_pic_flag = data.used_by_curr_pic_flag;
      if (data.used_by_curr_pic_s0_flag !== undefined) this.used_by_curr_pic_s0_flag = data.used_by_curr_pic_s0_flag;
      if (data.used_by_curr_pic_s1_flag !== undefined) this.used_by_curr_pic_s1_flag = data.used_by_curr_pic_s1_flag;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.reserved3 !== undefined) this.reserved3 = data.reserved3;
      if (data.num_negative_pics !== undefined) this.num_negative_pics = data.num_negative_pics;
      if (data.num_positive_pics !== undefined) this.num_positive_pics = data.num_positive_pics;
      if (data.delta_poc_s0_minus1 !== undefined) this.delta_poc_s0_minus1 = data.delta_poc_s0_minus1;
      if (data.delta_poc_s1_minus1 !== undefined) this.delta_poc_s1_minus1 = data.delta_poc_s1_minus1;
    }
  }
  
  get flags() {
    return new StdVideoH265ShortTermRefPicSetFlags(this.#data.subarray(0, 0 + StdVideoH265ShortTermRefPicSetFlags.size));
  }
  
  set flags(value: StdVideoH265ShortTermRefPicSetFlags) {
    if (value[BUFFER].byteLength < StdVideoH265ShortTermRefPicSetFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get delta_idx_minus1() {
    return this.#view.getUint32(8, LE);
  }
  
  set delta_idx_minus1(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get use_delta_flag() {
    return this.#view.getUint16(12, LE);
  }
  
  set use_delta_flag(value: number) {
    this.#view.setUint16(12, Number(value), LE);
  }
  
  get abs_delta_rps_minus1() {
    return this.#view.getUint16(14, LE);
  }
  
  set abs_delta_rps_minus1(value: number) {
    this.#view.setUint16(14, Number(value), LE);
  }
  
  get used_by_curr_pic_flag() {
    return this.#view.getUint16(16, LE);
  }
  
  set used_by_curr_pic_flag(value: number) {
    this.#view.setUint16(16, Number(value), LE);
  }
  
  get used_by_curr_pic_s0_flag() {
    return this.#view.getUint16(18, LE);
  }
  
  set used_by_curr_pic_s0_flag(value: number) {
    this.#view.setUint16(18, Number(value), LE);
  }
  
  get used_by_curr_pic_s1_flag() {
    return this.#view.getUint16(20, LE);
  }
  
  set used_by_curr_pic_s1_flag(value: number) {
    this.#view.setUint16(20, Number(value), LE);
  }
  
  get reserved1() {
    return this.#view.getUint16(22, LE);
  }
  
  set reserved1(value: number) {
    this.#view.setUint16(22, Number(value), LE);
  }
  
  get reserved2() {
    return this.#view.getUint8(24);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get reserved3() {
    return this.#view.getUint8(25);
  }
  
  set reserved3(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get num_negative_pics() {
    return this.#view.getUint8(26);
  }
  
  set num_negative_pics(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get num_positive_pics() {
    return this.#view.getUint8(27);
  }
  
  set num_positive_pics(value: number) {
    this.#view.setUint8(27, Number(value));
  }
  
  get delta_poc_s0_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint16(28 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set delta_poc_s0_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(28 + i * 2, Number(value[i]), LE);
    }
  }
  
  get delta_poc_s1_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint16(60 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set delta_poc_s1_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(60 + i * 2, Number(value[i]), LE);
    }
  }
}

export interface InitStdVideoH265LongTermRefPicsSps {
  used_by_curr_pic_lt_sps_flag?: number;
  lt_ref_pic_poc_lsb_sps?: number[];
}

export class StdVideoH265LongTermRefPicsSps implements BaseStruct {
  static size = 132;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265LongTermRefPicsSps);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265LongTermRefPicsSps) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265LongTermRefPicsSps.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265LongTermRefPicsSps.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265LongTermRefPicsSps.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.used_by_curr_pic_lt_sps_flag !== undefined) this.used_by_curr_pic_lt_sps_flag = data.used_by_curr_pic_lt_sps_flag;
      if (data.lt_ref_pic_poc_lsb_sps !== undefined) this.lt_ref_pic_poc_lsb_sps = data.lt_ref_pic_poc_lsb_sps;
    }
  }
  
  get used_by_curr_pic_lt_sps_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_by_curr_pic_lt_sps_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get lt_ref_pic_poc_lsb_sps() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(4 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set lt_ref_pic_poc_lsb_sps(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(4 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitStdVideoH265SpsVuiFlags {
  aspect_ratio_info_present_flag?: number;
  overscan_info_present_flag?: number;
  overscan_appropriate_flag?: number;
  video_signal_type_present_flag?: number;
  video_full_range_flag?: number;
  colour_description_present_flag?: number;
  chroma_loc_info_present_flag?: number;
  neutral_chroma_indication_flag?: number;
  field_seq_flag?: number;
  frame_field_info_present_flag?: number;
  default_display_window_flag?: number;
  vui_timing_info_present_flag?: number;
  vui_poc_proportional_to_timing_flag?: number;
  vui_hrd_parameters_present_flag?: number;
  bitstream_restriction_flag?: number;
  tiles_fixed_structure_flag?: number;
  motion_vectors_over_pic_boundaries_flag?: number;
  restricted_ref_pic_lists_flag?: number;
}

export class StdVideoH265SpsVuiFlags implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265SpsVuiFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265SpsVuiFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265SpsVuiFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265SpsVuiFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265SpsVuiFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspect_ratio_info_present_flag !== undefined) this.aspect_ratio_info_present_flag = data.aspect_ratio_info_present_flag;
      if (data.overscan_info_present_flag !== undefined) this.overscan_info_present_flag = data.overscan_info_present_flag;
      if (data.overscan_appropriate_flag !== undefined) this.overscan_appropriate_flag = data.overscan_appropriate_flag;
      if (data.video_signal_type_present_flag !== undefined) this.video_signal_type_present_flag = data.video_signal_type_present_flag;
      if (data.video_full_range_flag !== undefined) this.video_full_range_flag = data.video_full_range_flag;
      if (data.colour_description_present_flag !== undefined) this.colour_description_present_flag = data.colour_description_present_flag;
      if (data.chroma_loc_info_present_flag !== undefined) this.chroma_loc_info_present_flag = data.chroma_loc_info_present_flag;
      if (data.neutral_chroma_indication_flag !== undefined) this.neutral_chroma_indication_flag = data.neutral_chroma_indication_flag;
      if (data.field_seq_flag !== undefined) this.field_seq_flag = data.field_seq_flag;
      if (data.frame_field_info_present_flag !== undefined) this.frame_field_info_present_flag = data.frame_field_info_present_flag;
      if (data.default_display_window_flag !== undefined) this.default_display_window_flag = data.default_display_window_flag;
      if (data.vui_timing_info_present_flag !== undefined) this.vui_timing_info_present_flag = data.vui_timing_info_present_flag;
      if (data.vui_poc_proportional_to_timing_flag !== undefined) this.vui_poc_proportional_to_timing_flag = data.vui_poc_proportional_to_timing_flag;
      if (data.vui_hrd_parameters_present_flag !== undefined) this.vui_hrd_parameters_present_flag = data.vui_hrd_parameters_present_flag;
      if (data.bitstream_restriction_flag !== undefined) this.bitstream_restriction_flag = data.bitstream_restriction_flag;
      if (data.tiles_fixed_structure_flag !== undefined) this.tiles_fixed_structure_flag = data.tiles_fixed_structure_flag;
      if (data.motion_vectors_over_pic_boundaries_flag !== undefined) this.motion_vectors_over_pic_boundaries_flag = data.motion_vectors_over_pic_boundaries_flag;
      if (data.restricted_ref_pic_lists_flag !== undefined) this.restricted_ref_pic_lists_flag = data.restricted_ref_pic_lists_flag;
    }
  }
  
  get aspect_ratio_info_present_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspect_ratio_info_present_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get overscan_info_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set overscan_info_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get overscan_appropriate_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set overscan_appropriate_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get video_signal_type_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set video_signal_type_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get video_full_range_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set video_full_range_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get colour_description_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set colour_description_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get chroma_loc_info_present_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set chroma_loc_info_present_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get neutral_chroma_indication_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set neutral_chroma_indication_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get field_seq_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set field_seq_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get frame_field_info_present_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set frame_field_info_present_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get default_display_window_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set default_display_window_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get vui_timing_info_present_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set vui_timing_info_present_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get vui_poc_proportional_to_timing_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set vui_poc_proportional_to_timing_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get vui_hrd_parameters_present_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set vui_hrd_parameters_present_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get bitstream_restriction_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set bitstream_restriction_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get tiles_fixed_structure_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set tiles_fixed_structure_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get motion_vectors_over_pic_boundaries_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set motion_vectors_over_pic_boundaries_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get restricted_ref_pic_lists_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set restricted_ref_pic_lists_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export interface InitStdVideoH265SequenceParameterSetVui {
  flags?: StdVideoH265SpsVuiFlags;
  aspect_ratio_idc?: StdVideoH265AspectRatioIdc;
  sar_width?: number;
  sar_height?: number;
  video_format?: number;
  colour_primaries?: number;
  transfer_characteristics?: number;
  matrix_coeffs?: number;
  chroma_sample_loc_type_top_field?: number;
  chroma_sample_loc_type_bottom_field?: number;
  reserved1?: number;
  reserved2?: number;
  def_disp_win_left_offset?: number;
  def_disp_win_right_offset?: number;
  def_disp_win_top_offset?: number;
  def_disp_win_bottom_offset?: number;
  vui_num_units_in_tick?: number;
  vui_time_scale?: number;
  vui_num_ticks_poc_diff_one_minus1?: number;
  min_spatial_segmentation_idc?: number;
  reserved3?: number;
  max_bytes_per_pic_denom?: number;
  max_bits_per_min_cu_denom?: number;
  log2_max_mv_length_horizontal?: number;
  log2_max_mv_length_vertical?: number;
  pHrdParameters?: AnyPointer;
}

export class StdVideoH265SequenceParameterSetVui implements BaseStruct {
  static size = 128;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265SequenceParameterSetVui);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265SequenceParameterSetVui) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265SequenceParameterSetVui.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265SequenceParameterSetVui.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265SequenceParameterSetVui.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.aspect_ratio_idc !== undefined) this.aspect_ratio_idc = data.aspect_ratio_idc;
      if (data.sar_width !== undefined) this.sar_width = data.sar_width;
      if (data.sar_height !== undefined) this.sar_height = data.sar_height;
      if (data.video_format !== undefined) this.video_format = data.video_format;
      if (data.colour_primaries !== undefined) this.colour_primaries = data.colour_primaries;
      if (data.transfer_characteristics !== undefined) this.transfer_characteristics = data.transfer_characteristics;
      if (data.matrix_coeffs !== undefined) this.matrix_coeffs = data.matrix_coeffs;
      if (data.chroma_sample_loc_type_top_field !== undefined) this.chroma_sample_loc_type_top_field = data.chroma_sample_loc_type_top_field;
      if (data.chroma_sample_loc_type_bottom_field !== undefined) this.chroma_sample_loc_type_bottom_field = data.chroma_sample_loc_type_bottom_field;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.def_disp_win_left_offset !== undefined) this.def_disp_win_left_offset = data.def_disp_win_left_offset;
      if (data.def_disp_win_right_offset !== undefined) this.def_disp_win_right_offset = data.def_disp_win_right_offset;
      if (data.def_disp_win_top_offset !== undefined) this.def_disp_win_top_offset = data.def_disp_win_top_offset;
      if (data.def_disp_win_bottom_offset !== undefined) this.def_disp_win_bottom_offset = data.def_disp_win_bottom_offset;
      if (data.vui_num_units_in_tick !== undefined) this.vui_num_units_in_tick = data.vui_num_units_in_tick;
      if (data.vui_time_scale !== undefined) this.vui_time_scale = data.vui_time_scale;
      if (data.vui_num_ticks_poc_diff_one_minus1 !== undefined) this.vui_num_ticks_poc_diff_one_minus1 = data.vui_num_ticks_poc_diff_one_minus1;
      if (data.min_spatial_segmentation_idc !== undefined) this.min_spatial_segmentation_idc = data.min_spatial_segmentation_idc;
      if (data.reserved3 !== undefined) this.reserved3 = data.reserved3;
      if (data.max_bytes_per_pic_denom !== undefined) this.max_bytes_per_pic_denom = data.max_bytes_per_pic_denom;
      if (data.max_bits_per_min_cu_denom !== undefined) this.max_bits_per_min_cu_denom = data.max_bits_per_min_cu_denom;
      if (data.log2_max_mv_length_horizontal !== undefined) this.log2_max_mv_length_horizontal = data.log2_max_mv_length_horizontal;
      if (data.log2_max_mv_length_vertical !== undefined) this.log2_max_mv_length_vertical = data.log2_max_mv_length_vertical;
      if (data.pHrdParameters !== undefined) this.pHrdParameters = data.pHrdParameters;
    }
  }
  
  get flags() {
    return new StdVideoH265SpsVuiFlags(this.#data.subarray(0, 0 + StdVideoH265SpsVuiFlags.size));
  }
  
  set flags(value: StdVideoH265SpsVuiFlags) {
    if (value[BUFFER].byteLength < StdVideoH265SpsVuiFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aspect_ratio_idc() {
    return this.#view.getUint32(72, LE);
  }
  
  set aspect_ratio_idc(value: StdVideoH265AspectRatioIdc) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get sar_width() {
    return this.#view.getUint16(76, LE);
  }
  
  set sar_width(value: number) {
    this.#view.setUint16(76, Number(value), LE);
  }
  
  get sar_height() {
    return this.#view.getUint16(78, LE);
  }
  
  set sar_height(value: number) {
    this.#view.setUint16(78, Number(value), LE);
  }
  
  get video_format() {
    return this.#view.getUint8(80);
  }
  
  set video_format(value: number) {
    this.#view.setUint8(80, Number(value));
  }
  
  get colour_primaries() {
    return this.#view.getUint8(81);
  }
  
  set colour_primaries(value: number) {
    this.#view.setUint8(81, Number(value));
  }
  
  get transfer_characteristics() {
    return this.#view.getUint8(82);
  }
  
  set transfer_characteristics(value: number) {
    this.#view.setUint8(82, Number(value));
  }
  
  get matrix_coeffs() {
    return this.#view.getUint8(83);
  }
  
  set matrix_coeffs(value: number) {
    this.#view.setUint8(83, Number(value));
  }
  
  get chroma_sample_loc_type_top_field() {
    return this.#view.getUint8(84);
  }
  
  set chroma_sample_loc_type_top_field(value: number) {
    this.#view.setUint8(84, Number(value));
  }
  
  get chroma_sample_loc_type_bottom_field() {
    return this.#view.getUint8(85);
  }
  
  set chroma_sample_loc_type_bottom_field(value: number) {
    this.#view.setUint8(85, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(86);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(86, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(87);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(87, Number(value));
  }
  
  get def_disp_win_left_offset() {
    return this.#view.getUint16(88, LE);
  }
  
  set def_disp_win_left_offset(value: number) {
    this.#view.setUint16(88, Number(value), LE);
  }
  
  get def_disp_win_right_offset() {
    return this.#view.getUint16(90, LE);
  }
  
  set def_disp_win_right_offset(value: number) {
    this.#view.setUint16(90, Number(value), LE);
  }
  
  get def_disp_win_top_offset() {
    return this.#view.getUint16(92, LE);
  }
  
  set def_disp_win_top_offset(value: number) {
    this.#view.setUint16(92, Number(value), LE);
  }
  
  get def_disp_win_bottom_offset() {
    return this.#view.getUint16(94, LE);
  }
  
  set def_disp_win_bottom_offset(value: number) {
    this.#view.setUint16(94, Number(value), LE);
  }
  
  get vui_num_units_in_tick() {
    return this.#view.getUint32(96, LE);
  }
  
  set vui_num_units_in_tick(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get vui_time_scale() {
    return this.#view.getUint32(100, LE);
  }
  
  set vui_time_scale(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get vui_num_ticks_poc_diff_one_minus1() {
    return this.#view.getUint32(104, LE);
  }
  
  set vui_num_ticks_poc_diff_one_minus1(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get min_spatial_segmentation_idc() {
    return this.#view.getUint16(108, LE);
  }
  
  set min_spatial_segmentation_idc(value: number) {
    this.#view.setUint16(108, Number(value), LE);
  }
  
  get reserved3() {
    return this.#view.getUint16(110, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint16(110, Number(value), LE);
  }
  
  get max_bytes_per_pic_denom() {
    return this.#view.getUint8(112);
  }
  
  set max_bytes_per_pic_denom(value: number) {
    this.#view.setUint8(112, Number(value));
  }
  
  get max_bits_per_min_cu_denom() {
    return this.#view.getUint8(113);
  }
  
  set max_bits_per_min_cu_denom(value: number) {
    this.#view.setUint8(113, Number(value));
  }
  
  get log2_max_mv_length_horizontal() {
    return this.#view.getUint8(114);
  }
  
  set log2_max_mv_length_horizontal(value: number) {
    this.#view.setUint8(114, Number(value));
  }
  
  get log2_max_mv_length_vertical() {
    return this.#view.getUint8(115);
  }
  
  set log2_max_mv_length_vertical(value: number) {
    this.#view.setUint8(115, Number(value));
  }
  
  get pHrdParameters() {
    return this.#view.getBigUint64(120, LE);
  }
  
  set pHrdParameters(value: AnyPointer) {
    this.#view.setBigUint64(120, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH265PredictorPaletteEntries {
  PredictorPaletteEntries?: number[];
}

export class StdVideoH265PredictorPaletteEntries implements BaseStruct {
  static size = 768;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265PredictorPaletteEntries);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265PredictorPaletteEntries) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265PredictorPaletteEntries.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265PredictorPaletteEntries.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265PredictorPaletteEntries.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.PredictorPaletteEntries !== undefined) this.PredictorPaletteEntries = data.PredictorPaletteEntries;
    }
  }
  
  get PredictorPaletteEntries() {
    const result: number[] = [];
    for (let i = 0; i < 384; i++) {
      result.push((() => {
        return this.#view.getUint16(0 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set PredictorPaletteEntries(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(0 + i * 2, Number(value[i]), LE);
    }
  }
}

export interface InitStdVideoH265SpsFlags {
  sps_temporal_id_nesting_flag?: number;
  separate_colour_plane_flag?: number;
  conformance_window_flag?: number;
  sps_sub_layer_ordering_info_present_flag?: number;
  scaling_list_enabled_flag?: number;
  sps_scaling_list_data_present_flag?: number;
  amp_enabled_flag?: number;
  sample_adaptive_offset_enabled_flag?: number;
  pcm_enabled_flag?: number;
  pcm_loop_filter_disabled_flag?: number;
  long_term_ref_pics_present_flag?: number;
  sps_temporal_mvp_enabled_flag?: number;
  strong_intra_smoothing_enabled_flag?: number;
  vui_parameters_present_flag?: number;
  sps_extension_present_flag?: number;
  sps_range_extension_flag?: number;
  transform_skip_rotation_enabled_flag?: number;
  transform_skip_context_enabled_flag?: number;
  implicit_rdpcm_enabled_flag?: number;
  explicit_rdpcm_enabled_flag?: number;
  extended_precision_processing_flag?: number;
  intra_smoothing_disabled_flag?: number;
  high_precision_offsets_enabled_flag?: number;
  persistent_rice_adaptation_enabled_flag?: number;
  cabac_bypass_alignment_enabled_flag?: number;
  sps_scc_extension_flag?: number;
  sps_curr_pic_ref_enabled_flag?: number;
  palette_mode_enabled_flag?: number;
  sps_palette_predictor_initializers_present_flag?: number;
  intra_boundary_filtering_disabled_flag?: number;
}

export class StdVideoH265SpsFlags implements BaseStruct {
  static size = 120;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265SpsFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265SpsFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265SpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265SpsFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265SpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.sps_temporal_id_nesting_flag !== undefined) this.sps_temporal_id_nesting_flag = data.sps_temporal_id_nesting_flag;
      if (data.separate_colour_plane_flag !== undefined) this.separate_colour_plane_flag = data.separate_colour_plane_flag;
      if (data.conformance_window_flag !== undefined) this.conformance_window_flag = data.conformance_window_flag;
      if (data.sps_sub_layer_ordering_info_present_flag !== undefined) this.sps_sub_layer_ordering_info_present_flag = data.sps_sub_layer_ordering_info_present_flag;
      if (data.scaling_list_enabled_flag !== undefined) this.scaling_list_enabled_flag = data.scaling_list_enabled_flag;
      if (data.sps_scaling_list_data_present_flag !== undefined) this.sps_scaling_list_data_present_flag = data.sps_scaling_list_data_present_flag;
      if (data.amp_enabled_flag !== undefined) this.amp_enabled_flag = data.amp_enabled_flag;
      if (data.sample_adaptive_offset_enabled_flag !== undefined) this.sample_adaptive_offset_enabled_flag = data.sample_adaptive_offset_enabled_flag;
      if (data.pcm_enabled_flag !== undefined) this.pcm_enabled_flag = data.pcm_enabled_flag;
      if (data.pcm_loop_filter_disabled_flag !== undefined) this.pcm_loop_filter_disabled_flag = data.pcm_loop_filter_disabled_flag;
      if (data.long_term_ref_pics_present_flag !== undefined) this.long_term_ref_pics_present_flag = data.long_term_ref_pics_present_flag;
      if (data.sps_temporal_mvp_enabled_flag !== undefined) this.sps_temporal_mvp_enabled_flag = data.sps_temporal_mvp_enabled_flag;
      if (data.strong_intra_smoothing_enabled_flag !== undefined) this.strong_intra_smoothing_enabled_flag = data.strong_intra_smoothing_enabled_flag;
      if (data.vui_parameters_present_flag !== undefined) this.vui_parameters_present_flag = data.vui_parameters_present_flag;
      if (data.sps_extension_present_flag !== undefined) this.sps_extension_present_flag = data.sps_extension_present_flag;
      if (data.sps_range_extension_flag !== undefined) this.sps_range_extension_flag = data.sps_range_extension_flag;
      if (data.transform_skip_rotation_enabled_flag !== undefined) this.transform_skip_rotation_enabled_flag = data.transform_skip_rotation_enabled_flag;
      if (data.transform_skip_context_enabled_flag !== undefined) this.transform_skip_context_enabled_flag = data.transform_skip_context_enabled_flag;
      if (data.implicit_rdpcm_enabled_flag !== undefined) this.implicit_rdpcm_enabled_flag = data.implicit_rdpcm_enabled_flag;
      if (data.explicit_rdpcm_enabled_flag !== undefined) this.explicit_rdpcm_enabled_flag = data.explicit_rdpcm_enabled_flag;
      if (data.extended_precision_processing_flag !== undefined) this.extended_precision_processing_flag = data.extended_precision_processing_flag;
      if (data.intra_smoothing_disabled_flag !== undefined) this.intra_smoothing_disabled_flag = data.intra_smoothing_disabled_flag;
      if (data.high_precision_offsets_enabled_flag !== undefined) this.high_precision_offsets_enabled_flag = data.high_precision_offsets_enabled_flag;
      if (data.persistent_rice_adaptation_enabled_flag !== undefined) this.persistent_rice_adaptation_enabled_flag = data.persistent_rice_adaptation_enabled_flag;
      if (data.cabac_bypass_alignment_enabled_flag !== undefined) this.cabac_bypass_alignment_enabled_flag = data.cabac_bypass_alignment_enabled_flag;
      if (data.sps_scc_extension_flag !== undefined) this.sps_scc_extension_flag = data.sps_scc_extension_flag;
      if (data.sps_curr_pic_ref_enabled_flag !== undefined) this.sps_curr_pic_ref_enabled_flag = data.sps_curr_pic_ref_enabled_flag;
      if (data.palette_mode_enabled_flag !== undefined) this.palette_mode_enabled_flag = data.palette_mode_enabled_flag;
      if (data.sps_palette_predictor_initializers_present_flag !== undefined) this.sps_palette_predictor_initializers_present_flag = data.sps_palette_predictor_initializers_present_flag;
      if (data.intra_boundary_filtering_disabled_flag !== undefined) this.intra_boundary_filtering_disabled_flag = data.intra_boundary_filtering_disabled_flag;
    }
  }
  
  get sps_temporal_id_nesting_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set sps_temporal_id_nesting_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get separate_colour_plane_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set separate_colour_plane_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get conformance_window_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set conformance_window_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get sps_sub_layer_ordering_info_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set sps_sub_layer_ordering_info_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get scaling_list_enabled_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set scaling_list_enabled_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sps_scaling_list_data_present_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set sps_scaling_list_data_present_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get amp_enabled_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set amp_enabled_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sample_adaptive_offset_enabled_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set sample_adaptive_offset_enabled_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pcm_enabled_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set pcm_enabled_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pcm_loop_filter_disabled_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set pcm_loop_filter_disabled_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get long_term_ref_pics_present_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set long_term_ref_pics_present_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get sps_temporal_mvp_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set sps_temporal_mvp_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get strong_intra_smoothing_enabled_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set strong_intra_smoothing_enabled_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get vui_parameters_present_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set vui_parameters_present_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get sps_extension_present_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set sps_extension_present_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sps_range_extension_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set sps_range_extension_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get transform_skip_rotation_enabled_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set transform_skip_rotation_enabled_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get transform_skip_context_enabled_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set transform_skip_context_enabled_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get implicit_rdpcm_enabled_flag() {
    return this.#view.getUint32(72, LE);
  }
  
  set implicit_rdpcm_enabled_flag(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get explicit_rdpcm_enabled_flag() {
    return this.#view.getUint32(76, LE);
  }
  
  set explicit_rdpcm_enabled_flag(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get extended_precision_processing_flag() {
    return this.#view.getUint32(80, LE);
  }
  
  set extended_precision_processing_flag(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get intra_smoothing_disabled_flag() {
    return this.#view.getUint32(84, LE);
  }
  
  set intra_smoothing_disabled_flag(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get high_precision_offsets_enabled_flag() {
    return this.#view.getUint32(88, LE);
  }
  
  set high_precision_offsets_enabled_flag(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get persistent_rice_adaptation_enabled_flag() {
    return this.#view.getUint32(92, LE);
  }
  
  set persistent_rice_adaptation_enabled_flag(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get cabac_bypass_alignment_enabled_flag() {
    return this.#view.getUint32(96, LE);
  }
  
  set cabac_bypass_alignment_enabled_flag(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get sps_scc_extension_flag() {
    return this.#view.getUint32(100, LE);
  }
  
  set sps_scc_extension_flag(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get sps_curr_pic_ref_enabled_flag() {
    return this.#view.getUint32(104, LE);
  }
  
  set sps_curr_pic_ref_enabled_flag(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get palette_mode_enabled_flag() {
    return this.#view.getUint32(108, LE);
  }
  
  set palette_mode_enabled_flag(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get sps_palette_predictor_initializers_present_flag() {
    return this.#view.getUint32(112, LE);
  }
  
  set sps_palette_predictor_initializers_present_flag(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get intra_boundary_filtering_disabled_flag() {
    return this.#view.getUint32(116, LE);
  }
  
  set intra_boundary_filtering_disabled_flag(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
}

export interface InitStdVideoH265SequenceParameterSet {
  flags?: StdVideoH265SpsFlags;
  chroma_format_idc?: StdVideoH265ChromaFormatIdc;
  pic_width_in_luma_samples?: number;
  pic_height_in_luma_samples?: number;
  sps_video_parameter_set_id?: number;
  sps_max_sub_layers_minus1?: number;
  sps_seq_parameter_set_id?: number;
  bit_depth_luma_minus8?: number;
  bit_depth_chroma_minus8?: number;
  log2_max_pic_order_cnt_lsb_minus4?: number;
  log2_min_luma_coding_block_size_minus3?: number;
  log2_diff_max_min_luma_coding_block_size?: number;
  log2_min_luma_transform_block_size_minus2?: number;
  log2_diff_max_min_luma_transform_block_size?: number;
  max_transform_hierarchy_depth_inter?: number;
  max_transform_hierarchy_depth_intra?: number;
  num_short_term_ref_pic_sets?: number;
  num_long_term_ref_pics_sps?: number;
  pcm_sample_bit_depth_luma_minus1?: number;
  pcm_sample_bit_depth_chroma_minus1?: number;
  log2_min_pcm_luma_coding_block_size_minus3?: number;
  log2_diff_max_min_pcm_luma_coding_block_size?: number;
  reserved1?: number;
  reserved2?: number;
  palette_max_size?: number;
  delta_palette_max_predictor_size?: number;
  motion_vector_resolution_control_idc?: number;
  sps_num_palette_predictor_initializers_minus1?: number;
  conf_win_left_offset?: number;
  conf_win_right_offset?: number;
  conf_win_top_offset?: number;
  conf_win_bottom_offset?: number;
  pProfileTierLevel?: AnyPointer;
  pDecPicBufMgr?: AnyPointer;
  pScalingLists?: AnyPointer;
  pShortTermRefPicSet?: AnyPointer;
  pLongTermRefPicsSps?: AnyPointer;
  pSequenceParameterSetVui?: AnyPointer;
  pPredictorPaletteEntries?: AnyPointer;
}

export class StdVideoH265SequenceParameterSet implements BaseStruct {
  static size = 232;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265SequenceParameterSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265SequenceParameterSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265SequenceParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265SequenceParameterSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265SequenceParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.chroma_format_idc !== undefined) this.chroma_format_idc = data.chroma_format_idc;
      if (data.pic_width_in_luma_samples !== undefined) this.pic_width_in_luma_samples = data.pic_width_in_luma_samples;
      if (data.pic_height_in_luma_samples !== undefined) this.pic_height_in_luma_samples = data.pic_height_in_luma_samples;
      if (data.sps_video_parameter_set_id !== undefined) this.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
      if (data.sps_max_sub_layers_minus1 !== undefined) this.sps_max_sub_layers_minus1 = data.sps_max_sub_layers_minus1;
      if (data.sps_seq_parameter_set_id !== undefined) this.sps_seq_parameter_set_id = data.sps_seq_parameter_set_id;
      if (data.bit_depth_luma_minus8 !== undefined) this.bit_depth_luma_minus8 = data.bit_depth_luma_minus8;
      if (data.bit_depth_chroma_minus8 !== undefined) this.bit_depth_chroma_minus8 = data.bit_depth_chroma_minus8;
      if (data.log2_max_pic_order_cnt_lsb_minus4 !== undefined) this.log2_max_pic_order_cnt_lsb_minus4 = data.log2_max_pic_order_cnt_lsb_minus4;
      if (data.log2_min_luma_coding_block_size_minus3 !== undefined) this.log2_min_luma_coding_block_size_minus3 = data.log2_min_luma_coding_block_size_minus3;
      if (data.log2_diff_max_min_luma_coding_block_size !== undefined) this.log2_diff_max_min_luma_coding_block_size = data.log2_diff_max_min_luma_coding_block_size;
      if (data.log2_min_luma_transform_block_size_minus2 !== undefined) this.log2_min_luma_transform_block_size_minus2 = data.log2_min_luma_transform_block_size_minus2;
      if (data.log2_diff_max_min_luma_transform_block_size !== undefined) this.log2_diff_max_min_luma_transform_block_size = data.log2_diff_max_min_luma_transform_block_size;
      if (data.max_transform_hierarchy_depth_inter !== undefined) this.max_transform_hierarchy_depth_inter = data.max_transform_hierarchy_depth_inter;
      if (data.max_transform_hierarchy_depth_intra !== undefined) this.max_transform_hierarchy_depth_intra = data.max_transform_hierarchy_depth_intra;
      if (data.num_short_term_ref_pic_sets !== undefined) this.num_short_term_ref_pic_sets = data.num_short_term_ref_pic_sets;
      if (data.num_long_term_ref_pics_sps !== undefined) this.num_long_term_ref_pics_sps = data.num_long_term_ref_pics_sps;
      if (data.pcm_sample_bit_depth_luma_minus1 !== undefined) this.pcm_sample_bit_depth_luma_minus1 = data.pcm_sample_bit_depth_luma_minus1;
      if (data.pcm_sample_bit_depth_chroma_minus1 !== undefined) this.pcm_sample_bit_depth_chroma_minus1 = data.pcm_sample_bit_depth_chroma_minus1;
      if (data.log2_min_pcm_luma_coding_block_size_minus3 !== undefined) this.log2_min_pcm_luma_coding_block_size_minus3 = data.log2_min_pcm_luma_coding_block_size_minus3;
      if (data.log2_diff_max_min_pcm_luma_coding_block_size !== undefined) this.log2_diff_max_min_pcm_luma_coding_block_size = data.log2_diff_max_min_pcm_luma_coding_block_size;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.palette_max_size !== undefined) this.palette_max_size = data.palette_max_size;
      if (data.delta_palette_max_predictor_size !== undefined) this.delta_palette_max_predictor_size = data.delta_palette_max_predictor_size;
      if (data.motion_vector_resolution_control_idc !== undefined) this.motion_vector_resolution_control_idc = data.motion_vector_resolution_control_idc;
      if (data.sps_num_palette_predictor_initializers_minus1 !== undefined) this.sps_num_palette_predictor_initializers_minus1 = data.sps_num_palette_predictor_initializers_minus1;
      if (data.conf_win_left_offset !== undefined) this.conf_win_left_offset = data.conf_win_left_offset;
      if (data.conf_win_right_offset !== undefined) this.conf_win_right_offset = data.conf_win_right_offset;
      if (data.conf_win_top_offset !== undefined) this.conf_win_top_offset = data.conf_win_top_offset;
      if (data.conf_win_bottom_offset !== undefined) this.conf_win_bottom_offset = data.conf_win_bottom_offset;
      if (data.pProfileTierLevel !== undefined) this.pProfileTierLevel = data.pProfileTierLevel;
      if (data.pDecPicBufMgr !== undefined) this.pDecPicBufMgr = data.pDecPicBufMgr;
      if (data.pScalingLists !== undefined) this.pScalingLists = data.pScalingLists;
      if (data.pShortTermRefPicSet !== undefined) this.pShortTermRefPicSet = data.pShortTermRefPicSet;
      if (data.pLongTermRefPicsSps !== undefined) this.pLongTermRefPicsSps = data.pLongTermRefPicsSps;
      if (data.pSequenceParameterSetVui !== undefined) this.pSequenceParameterSetVui = data.pSequenceParameterSetVui;
      if (data.pPredictorPaletteEntries !== undefined) this.pPredictorPaletteEntries = data.pPredictorPaletteEntries;
    }
  }
  
  get flags() {
    return new StdVideoH265SpsFlags(this.#data.subarray(0, 0 + StdVideoH265SpsFlags.size));
  }
  
  set flags(value: StdVideoH265SpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265SpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get chroma_format_idc() {
    return this.#view.getUint32(120, LE);
  }
  
  set chroma_format_idc(value: StdVideoH265ChromaFormatIdc) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get pic_width_in_luma_samples() {
    return this.#view.getUint32(124, LE);
  }
  
  set pic_width_in_luma_samples(value: number) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get pic_height_in_luma_samples() {
    return this.#view.getUint32(128, LE);
  }
  
  set pic_height_in_luma_samples(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(132);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(132, Number(value));
  }
  
  get sps_max_sub_layers_minus1() {
    return this.#view.getUint8(133);
  }
  
  set sps_max_sub_layers_minus1(value: number) {
    this.#view.setUint8(133, Number(value));
  }
  
  get sps_seq_parameter_set_id() {
    return this.#view.getUint8(134);
  }
  
  set sps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(134, Number(value));
  }
  
  get bit_depth_luma_minus8() {
    return this.#view.getUint8(135);
  }
  
  set bit_depth_luma_minus8(value: number) {
    this.#view.setUint8(135, Number(value));
  }
  
  get bit_depth_chroma_minus8() {
    return this.#view.getUint8(136);
  }
  
  set bit_depth_chroma_minus8(value: number) {
    this.#view.setUint8(136, Number(value));
  }
  
  get log2_max_pic_order_cnt_lsb_minus4() {
    return this.#view.getUint8(137);
  }
  
  set log2_max_pic_order_cnt_lsb_minus4(value: number) {
    this.#view.setUint8(137, Number(value));
  }
  
  get log2_min_luma_coding_block_size_minus3() {
    return this.#view.getUint8(138);
  }
  
  set log2_min_luma_coding_block_size_minus3(value: number) {
    this.#view.setUint8(138, Number(value));
  }
  
  get log2_diff_max_min_luma_coding_block_size() {
    return this.#view.getUint8(139);
  }
  
  set log2_diff_max_min_luma_coding_block_size(value: number) {
    this.#view.setUint8(139, Number(value));
  }
  
  get log2_min_luma_transform_block_size_minus2() {
    return this.#view.getUint8(140);
  }
  
  set log2_min_luma_transform_block_size_minus2(value: number) {
    this.#view.setUint8(140, Number(value));
  }
  
  get log2_diff_max_min_luma_transform_block_size() {
    return this.#view.getUint8(141);
  }
  
  set log2_diff_max_min_luma_transform_block_size(value: number) {
    this.#view.setUint8(141, Number(value));
  }
  
  get max_transform_hierarchy_depth_inter() {
    return this.#view.getUint8(142);
  }
  
  set max_transform_hierarchy_depth_inter(value: number) {
    this.#view.setUint8(142, Number(value));
  }
  
  get max_transform_hierarchy_depth_intra() {
    return this.#view.getUint8(143);
  }
  
  set max_transform_hierarchy_depth_intra(value: number) {
    this.#view.setUint8(143, Number(value));
  }
  
  get num_short_term_ref_pic_sets() {
    return this.#view.getUint8(144);
  }
  
  set num_short_term_ref_pic_sets(value: number) {
    this.#view.setUint8(144, Number(value));
  }
  
  get num_long_term_ref_pics_sps() {
    return this.#view.getUint8(145);
  }
  
  set num_long_term_ref_pics_sps(value: number) {
    this.#view.setUint8(145, Number(value));
  }
  
  get pcm_sample_bit_depth_luma_minus1() {
    return this.#view.getUint8(146);
  }
  
  set pcm_sample_bit_depth_luma_minus1(value: number) {
    this.#view.setUint8(146, Number(value));
  }
  
  get pcm_sample_bit_depth_chroma_minus1() {
    return this.#view.getUint8(147);
  }
  
  set pcm_sample_bit_depth_chroma_minus1(value: number) {
    this.#view.setUint8(147, Number(value));
  }
  
  get log2_min_pcm_luma_coding_block_size_minus3() {
    return this.#view.getUint8(148);
  }
  
  set log2_min_pcm_luma_coding_block_size_minus3(value: number) {
    this.#view.setUint8(148, Number(value));
  }
  
  get log2_diff_max_min_pcm_luma_coding_block_size() {
    return this.#view.getUint8(149);
  }
  
  set log2_diff_max_min_pcm_luma_coding_block_size(value: number) {
    this.#view.setUint8(149, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(150);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(150, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(151);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(151, Number(value));
  }
  
  get palette_max_size() {
    return this.#view.getUint8(152);
  }
  
  set palette_max_size(value: number) {
    this.#view.setUint8(152, Number(value));
  }
  
  get delta_palette_max_predictor_size() {
    return this.#view.getUint8(153);
  }
  
  set delta_palette_max_predictor_size(value: number) {
    this.#view.setUint8(153, Number(value));
  }
  
  get motion_vector_resolution_control_idc() {
    return this.#view.getUint8(154);
  }
  
  set motion_vector_resolution_control_idc(value: number) {
    this.#view.setUint8(154, Number(value));
  }
  
  get sps_num_palette_predictor_initializers_minus1() {
    return this.#view.getUint8(155);
  }
  
  set sps_num_palette_predictor_initializers_minus1(value: number) {
    this.#view.setUint8(155, Number(value));
  }
  
  get conf_win_left_offset() {
    return this.#view.getUint32(156, LE);
  }
  
  set conf_win_left_offset(value: number) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get conf_win_right_offset() {
    return this.#view.getUint32(160, LE);
  }
  
  set conf_win_right_offset(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get conf_win_top_offset() {
    return this.#view.getUint32(164, LE);
  }
  
  set conf_win_top_offset(value: number) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get conf_win_bottom_offset() {
    return this.#view.getUint32(168, LE);
  }
  
  set conf_win_bottom_offset(value: number) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get pProfileTierLevel() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set pProfileTierLevel(value: AnyPointer) {
    this.#view.setBigUint64(176, BigInt(anyPointer(value)), LE);
  }
  
  get pDecPicBufMgr() {
    return this.#view.getBigUint64(184, LE);
  }
  
  set pDecPicBufMgr(value: AnyPointer) {
    this.#view.setBigUint64(184, BigInt(anyPointer(value)), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set pScalingLists(value: AnyPointer) {
    this.#view.setBigUint64(192, BigInt(anyPointer(value)), LE);
  }
  
  get pShortTermRefPicSet() {
    return this.#view.getBigUint64(200, LE);
  }
  
  set pShortTermRefPicSet(value: AnyPointer) {
    this.#view.setBigUint64(200, BigInt(anyPointer(value)), LE);
  }
  
  get pLongTermRefPicsSps() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set pLongTermRefPicsSps(value: AnyPointer) {
    this.#view.setBigUint64(208, BigInt(anyPointer(value)), LE);
  }
  
  get pSequenceParameterSetVui() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set pSequenceParameterSetVui(value: AnyPointer) {
    this.#view.setBigUint64(216, BigInt(anyPointer(value)), LE);
  }
  
  get pPredictorPaletteEntries() {
    return this.#view.getBigUint64(224, LE);
  }
  
  set pPredictorPaletteEntries(value: AnyPointer) {
    this.#view.setBigUint64(224, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoH265PpsFlags {
  dependent_slice_segments_enabled_flag?: number;
  output_flag_present_flag?: number;
  sign_data_hiding_enabled_flag?: number;
  cabac_init_present_flag?: number;
  constrained_intra_pred_flag?: number;
  transform_skip_enabled_flag?: number;
  cu_qp_delta_enabled_flag?: number;
  pps_slice_chroma_qp_offsets_present_flag?: number;
  weighted_pred_flag?: number;
  weighted_bipred_flag?: number;
  transquant_bypass_enabled_flag?: number;
  tiles_enabled_flag?: number;
  entropy_coding_sync_enabled_flag?: number;
  uniform_spacing_flag?: number;
  loop_filter_across_tiles_enabled_flag?: number;
  pps_loop_filter_across_slices_enabled_flag?: number;
  deblocking_filter_control_present_flag?: number;
  deblocking_filter_override_enabled_flag?: number;
  pps_deblocking_filter_disabled_flag?: number;
  pps_scaling_list_data_present_flag?: number;
  lists_modification_present_flag?: number;
  slice_segment_header_extension_present_flag?: number;
  pps_extension_present_flag?: number;
  cross_component_prediction_enabled_flag?: number;
  chroma_qp_offset_list_enabled_flag?: number;
  pps_curr_pic_ref_enabled_flag?: number;
  residual_adaptive_colour_transform_enabled_flag?: number;
  pps_slice_act_qp_offsets_present_flag?: number;
  pps_palette_predictor_initializers_present_flag?: number;
  monochrome_palette_flag?: number;
  pps_range_extension_flag?: number;
}

export class StdVideoH265PpsFlags implements BaseStruct {
  static size = 124;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265PpsFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265PpsFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265PpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265PpsFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265PpsFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.dependent_slice_segments_enabled_flag !== undefined) this.dependent_slice_segments_enabled_flag = data.dependent_slice_segments_enabled_flag;
      if (data.output_flag_present_flag !== undefined) this.output_flag_present_flag = data.output_flag_present_flag;
      if (data.sign_data_hiding_enabled_flag !== undefined) this.sign_data_hiding_enabled_flag = data.sign_data_hiding_enabled_flag;
      if (data.cabac_init_present_flag !== undefined) this.cabac_init_present_flag = data.cabac_init_present_flag;
      if (data.constrained_intra_pred_flag !== undefined) this.constrained_intra_pred_flag = data.constrained_intra_pred_flag;
      if (data.transform_skip_enabled_flag !== undefined) this.transform_skip_enabled_flag = data.transform_skip_enabled_flag;
      if (data.cu_qp_delta_enabled_flag !== undefined) this.cu_qp_delta_enabled_flag = data.cu_qp_delta_enabled_flag;
      if (data.pps_slice_chroma_qp_offsets_present_flag !== undefined) this.pps_slice_chroma_qp_offsets_present_flag = data.pps_slice_chroma_qp_offsets_present_flag;
      if (data.weighted_pred_flag !== undefined) this.weighted_pred_flag = data.weighted_pred_flag;
      if (data.weighted_bipred_flag !== undefined) this.weighted_bipred_flag = data.weighted_bipred_flag;
      if (data.transquant_bypass_enabled_flag !== undefined) this.transquant_bypass_enabled_flag = data.transquant_bypass_enabled_flag;
      if (data.tiles_enabled_flag !== undefined) this.tiles_enabled_flag = data.tiles_enabled_flag;
      if (data.entropy_coding_sync_enabled_flag !== undefined) this.entropy_coding_sync_enabled_flag = data.entropy_coding_sync_enabled_flag;
      if (data.uniform_spacing_flag !== undefined) this.uniform_spacing_flag = data.uniform_spacing_flag;
      if (data.loop_filter_across_tiles_enabled_flag !== undefined) this.loop_filter_across_tiles_enabled_flag = data.loop_filter_across_tiles_enabled_flag;
      if (data.pps_loop_filter_across_slices_enabled_flag !== undefined) this.pps_loop_filter_across_slices_enabled_flag = data.pps_loop_filter_across_slices_enabled_flag;
      if (data.deblocking_filter_control_present_flag !== undefined) this.deblocking_filter_control_present_flag = data.deblocking_filter_control_present_flag;
      if (data.deblocking_filter_override_enabled_flag !== undefined) this.deblocking_filter_override_enabled_flag = data.deblocking_filter_override_enabled_flag;
      if (data.pps_deblocking_filter_disabled_flag !== undefined) this.pps_deblocking_filter_disabled_flag = data.pps_deblocking_filter_disabled_flag;
      if (data.pps_scaling_list_data_present_flag !== undefined) this.pps_scaling_list_data_present_flag = data.pps_scaling_list_data_present_flag;
      if (data.lists_modification_present_flag !== undefined) this.lists_modification_present_flag = data.lists_modification_present_flag;
      if (data.slice_segment_header_extension_present_flag !== undefined) this.slice_segment_header_extension_present_flag = data.slice_segment_header_extension_present_flag;
      if (data.pps_extension_present_flag !== undefined) this.pps_extension_present_flag = data.pps_extension_present_flag;
      if (data.cross_component_prediction_enabled_flag !== undefined) this.cross_component_prediction_enabled_flag = data.cross_component_prediction_enabled_flag;
      if (data.chroma_qp_offset_list_enabled_flag !== undefined) this.chroma_qp_offset_list_enabled_flag = data.chroma_qp_offset_list_enabled_flag;
      if (data.pps_curr_pic_ref_enabled_flag !== undefined) this.pps_curr_pic_ref_enabled_flag = data.pps_curr_pic_ref_enabled_flag;
      if (data.residual_adaptive_colour_transform_enabled_flag !== undefined) this.residual_adaptive_colour_transform_enabled_flag = data.residual_adaptive_colour_transform_enabled_flag;
      if (data.pps_slice_act_qp_offsets_present_flag !== undefined) this.pps_slice_act_qp_offsets_present_flag = data.pps_slice_act_qp_offsets_present_flag;
      if (data.pps_palette_predictor_initializers_present_flag !== undefined) this.pps_palette_predictor_initializers_present_flag = data.pps_palette_predictor_initializers_present_flag;
      if (data.monochrome_palette_flag !== undefined) this.monochrome_palette_flag = data.monochrome_palette_flag;
      if (data.pps_range_extension_flag !== undefined) this.pps_range_extension_flag = data.pps_range_extension_flag;
    }
  }
  
  get dependent_slice_segments_enabled_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set dependent_slice_segments_enabled_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get output_flag_present_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set output_flag_present_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sign_data_hiding_enabled_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set sign_data_hiding_enabled_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get cabac_init_present_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set cabac_init_present_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get constrained_intra_pred_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set constrained_intra_pred_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transform_skip_enabled_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set transform_skip_enabled_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get cu_qp_delta_enabled_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set cu_qp_delta_enabled_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pps_slice_chroma_qp_offsets_present_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set pps_slice_chroma_qp_offsets_present_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get weighted_pred_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set weighted_pred_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get weighted_bipred_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set weighted_bipred_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get transquant_bypass_enabled_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set transquant_bypass_enabled_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get tiles_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set tiles_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get entropy_coding_sync_enabled_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set entropy_coding_sync_enabled_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get uniform_spacing_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set uniform_spacing_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get loop_filter_across_tiles_enabled_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set loop_filter_across_tiles_enabled_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pps_loop_filter_across_slices_enabled_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set pps_loop_filter_across_slices_enabled_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get deblocking_filter_control_present_flag() {
    return this.#view.getUint32(64, LE);
  }
  
  set deblocking_filter_control_present_flag(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get deblocking_filter_override_enabled_flag() {
    return this.#view.getUint32(68, LE);
  }
  
  set deblocking_filter_override_enabled_flag(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get pps_deblocking_filter_disabled_flag() {
    return this.#view.getUint32(72, LE);
  }
  
  set pps_deblocking_filter_disabled_flag(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pps_scaling_list_data_present_flag() {
    return this.#view.getUint32(76, LE);
  }
  
  set pps_scaling_list_data_present_flag(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get lists_modification_present_flag() {
    return this.#view.getUint32(80, LE);
  }
  
  set lists_modification_present_flag(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get slice_segment_header_extension_present_flag() {
    return this.#view.getUint32(84, LE);
  }
  
  set slice_segment_header_extension_present_flag(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get pps_extension_present_flag() {
    return this.#view.getUint32(88, LE);
  }
  
  set pps_extension_present_flag(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get cross_component_prediction_enabled_flag() {
    return this.#view.getUint32(92, LE);
  }
  
  set cross_component_prediction_enabled_flag(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get chroma_qp_offset_list_enabled_flag() {
    return this.#view.getUint32(96, LE);
  }
  
  set chroma_qp_offset_list_enabled_flag(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get pps_curr_pic_ref_enabled_flag() {
    return this.#view.getUint32(100, LE);
  }
  
  set pps_curr_pic_ref_enabled_flag(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get residual_adaptive_colour_transform_enabled_flag() {
    return this.#view.getUint32(104, LE);
  }
  
  set residual_adaptive_colour_transform_enabled_flag(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pps_slice_act_qp_offsets_present_flag() {
    return this.#view.getUint32(108, LE);
  }
  
  set pps_slice_act_qp_offsets_present_flag(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get pps_palette_predictor_initializers_present_flag() {
    return this.#view.getUint32(112, LE);
  }
  
  set pps_palette_predictor_initializers_present_flag(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get monochrome_palette_flag() {
    return this.#view.getUint32(116, LE);
  }
  
  set monochrome_palette_flag(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get pps_range_extension_flag() {
    return this.#view.getUint32(120, LE);
  }
  
  set pps_range_extension_flag(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
}

export interface InitStdVideoH265PictureParameterSet {
  flags?: StdVideoH265PpsFlags;
  pps_pic_parameter_set_id?: number;
  pps_seq_parameter_set_id?: number;
  sps_video_parameter_set_id?: number;
  num_extra_slice_header_bits?: number;
  num_ref_idx_l0_default_active_minus1?: number;
  num_ref_idx_l1_default_active_minus1?: number;
  init_qp_minus26?: number;
  diff_cu_qp_delta_depth?: number;
  pps_cb_qp_offset?: number;
  pps_cr_qp_offset?: number;
  pps_beta_offset_div2?: number;
  pps_tc_offset_div2?: number;
  log2_parallel_merge_level_minus2?: number;
  log2_max_transform_skip_block_size_minus2?: number;
  diff_cu_chroma_qp_offset_depth?: number;
  chroma_qp_offset_list_len_minus1?: number;
  cb_qp_offset_list?: number[];
  cr_qp_offset_list?: number[];
  log2_sao_offset_scale_luma?: number;
  log2_sao_offset_scale_chroma?: number;
  pps_act_y_qp_offset_plus5?: number;
  pps_act_cb_qp_offset_plus5?: number;
  pps_act_cr_qp_offset_plus3?: number;
  pps_num_palette_predictor_initializers?: number;
  luma_bit_depth_entry_minus8?: number;
  chroma_bit_depth_entry_minus8?: number;
  num_tile_columns_minus1?: number;
  num_tile_rows_minus1?: number;
  reserved1?: number;
  reserved2?: number;
  column_width_minus1?: number[];
  row_height_minus1?: number[];
  reserved3?: number;
  pScalingLists?: AnyPointer;
  pPredictorPaletteEntries?: AnyPointer;
}

export class StdVideoH265PictureParameterSet implements BaseStruct {
  static size = 264;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoH265PictureParameterSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoH265PictureParameterSet) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoH265PictureParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoH265PictureParameterSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoH265PictureParameterSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pps_pic_parameter_set_id !== undefined) this.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
      if (data.pps_seq_parameter_set_id !== undefined) this.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
      if (data.sps_video_parameter_set_id !== undefined) this.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
      if (data.num_extra_slice_header_bits !== undefined) this.num_extra_slice_header_bits = data.num_extra_slice_header_bits;
      if (data.num_ref_idx_l0_default_active_minus1 !== undefined) this.num_ref_idx_l0_default_active_minus1 = data.num_ref_idx_l0_default_active_minus1;
      if (data.num_ref_idx_l1_default_active_minus1 !== undefined) this.num_ref_idx_l1_default_active_minus1 = data.num_ref_idx_l1_default_active_minus1;
      if (data.init_qp_minus26 !== undefined) this.init_qp_minus26 = data.init_qp_minus26;
      if (data.diff_cu_qp_delta_depth !== undefined) this.diff_cu_qp_delta_depth = data.diff_cu_qp_delta_depth;
      if (data.pps_cb_qp_offset !== undefined) this.pps_cb_qp_offset = data.pps_cb_qp_offset;
      if (data.pps_cr_qp_offset !== undefined) this.pps_cr_qp_offset = data.pps_cr_qp_offset;
      if (data.pps_beta_offset_div2 !== undefined) this.pps_beta_offset_div2 = data.pps_beta_offset_div2;
      if (data.pps_tc_offset_div2 !== undefined) this.pps_tc_offset_div2 = data.pps_tc_offset_div2;
      if (data.log2_parallel_merge_level_minus2 !== undefined) this.log2_parallel_merge_level_minus2 = data.log2_parallel_merge_level_minus2;
      if (data.log2_max_transform_skip_block_size_minus2 !== undefined) this.log2_max_transform_skip_block_size_minus2 = data.log2_max_transform_skip_block_size_minus2;
      if (data.diff_cu_chroma_qp_offset_depth !== undefined) this.diff_cu_chroma_qp_offset_depth = data.diff_cu_chroma_qp_offset_depth;
      if (data.chroma_qp_offset_list_len_minus1 !== undefined) this.chroma_qp_offset_list_len_minus1 = data.chroma_qp_offset_list_len_minus1;
      if (data.cb_qp_offset_list !== undefined) this.cb_qp_offset_list = data.cb_qp_offset_list;
      if (data.cr_qp_offset_list !== undefined) this.cr_qp_offset_list = data.cr_qp_offset_list;
      if (data.log2_sao_offset_scale_luma !== undefined) this.log2_sao_offset_scale_luma = data.log2_sao_offset_scale_luma;
      if (data.log2_sao_offset_scale_chroma !== undefined) this.log2_sao_offset_scale_chroma = data.log2_sao_offset_scale_chroma;
      if (data.pps_act_y_qp_offset_plus5 !== undefined) this.pps_act_y_qp_offset_plus5 = data.pps_act_y_qp_offset_plus5;
      if (data.pps_act_cb_qp_offset_plus5 !== undefined) this.pps_act_cb_qp_offset_plus5 = data.pps_act_cb_qp_offset_plus5;
      if (data.pps_act_cr_qp_offset_plus3 !== undefined) this.pps_act_cr_qp_offset_plus3 = data.pps_act_cr_qp_offset_plus3;
      if (data.pps_num_palette_predictor_initializers !== undefined) this.pps_num_palette_predictor_initializers = data.pps_num_palette_predictor_initializers;
      if (data.luma_bit_depth_entry_minus8 !== undefined) this.luma_bit_depth_entry_minus8 = data.luma_bit_depth_entry_minus8;
      if (data.chroma_bit_depth_entry_minus8 !== undefined) this.chroma_bit_depth_entry_minus8 = data.chroma_bit_depth_entry_minus8;
      if (data.num_tile_columns_minus1 !== undefined) this.num_tile_columns_minus1 = data.num_tile_columns_minus1;
      if (data.num_tile_rows_minus1 !== undefined) this.num_tile_rows_minus1 = data.num_tile_rows_minus1;
      if (data.reserved1 !== undefined) this.reserved1 = data.reserved1;
      if (data.reserved2 !== undefined) this.reserved2 = data.reserved2;
      if (data.column_width_minus1 !== undefined) this.column_width_minus1 = data.column_width_minus1;
      if (data.row_height_minus1 !== undefined) this.row_height_minus1 = data.row_height_minus1;
      if (data.reserved3 !== undefined) this.reserved3 = data.reserved3;
      if (data.pScalingLists !== undefined) this.pScalingLists = data.pScalingLists;
      if (data.pPredictorPaletteEntries !== undefined) this.pPredictorPaletteEntries = data.pPredictorPaletteEntries;
    }
  }
  
  get flags() {
    return new StdVideoH265PpsFlags(this.#data.subarray(0, 0 + StdVideoH265PpsFlags.size));
  }
  
  set flags(value: StdVideoH265PpsFlags) {
    if (value[BUFFER].byteLength < StdVideoH265PpsFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(124);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(124, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(125);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(125, Number(value));
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(126);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(126, Number(value));
  }
  
  get num_extra_slice_header_bits() {
    return this.#view.getUint8(127);
  }
  
  set num_extra_slice_header_bits(value: number) {
    this.#view.setUint8(127, Number(value));
  }
  
  get num_ref_idx_l0_default_active_minus1() {
    return this.#view.getUint8(128);
  }
  
  set num_ref_idx_l0_default_active_minus1(value: number) {
    this.#view.setUint8(128, Number(value));
  }
  
  get num_ref_idx_l1_default_active_minus1() {
    return this.#view.getUint8(129);
  }
  
  set num_ref_idx_l1_default_active_minus1(value: number) {
    this.#view.setUint8(129, Number(value));
  }
  
  get init_qp_minus26() {
    return this.#view.getInt8(130);
  }
  
  set init_qp_minus26(value: number) {
    this.#view.setInt8(130, Number(value));
  }
  
  get diff_cu_qp_delta_depth() {
    return this.#view.getUint8(131);
  }
  
  set diff_cu_qp_delta_depth(value: number) {
    this.#view.setUint8(131, Number(value));
  }
  
  get pps_cb_qp_offset() {
    return this.#view.getInt8(132);
  }
  
  set pps_cb_qp_offset(value: number) {
    this.#view.setInt8(132, Number(value));
  }
  
  get pps_cr_qp_offset() {
    return this.#view.getInt8(133);
  }
  
  set pps_cr_qp_offset(value: number) {
    this.#view.setInt8(133, Number(value));
  }
  
  get pps_beta_offset_div2() {
    return this.#view.getInt8(134);
  }
  
  set pps_beta_offset_div2(value: number) {
    this.#view.setInt8(134, Number(value));
  }
  
  get pps_tc_offset_div2() {
    return this.#view.getInt8(135);
  }
  
  set pps_tc_offset_div2(value: number) {
    this.#view.setInt8(135, Number(value));
  }
  
  get log2_parallel_merge_level_minus2() {
    return this.#view.getUint8(136);
  }
  
  set log2_parallel_merge_level_minus2(value: number) {
    this.#view.setUint8(136, Number(value));
  }
  
  get log2_max_transform_skip_block_size_minus2() {
    return this.#view.getUint8(137);
  }
  
  set log2_max_transform_skip_block_size_minus2(value: number) {
    this.#view.setUint8(137, Number(value));
  }
  
  get diff_cu_chroma_qp_offset_depth() {
    return this.#view.getUint8(138);
  }
  
  set diff_cu_chroma_qp_offset_depth(value: number) {
    this.#view.setUint8(138, Number(value));
  }
  
  get chroma_qp_offset_list_len_minus1() {
    return this.#view.getUint8(139);
  }
  
  set chroma_qp_offset_list_len_minus1(value: number) {
    this.#view.setUint8(139, Number(value));
  }
  
  get cb_qp_offset_list() {
    const result: number[] = [];
    for (let i = 0; i < 6; i++) {
      result.push((() => {
        return this.#view.getInt8(140 + i * 1);
      })());
    }
    return result;
  }
  
  set cb_qp_offset_list(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(140 + i * 1, Number(value[i]));
    }
  }
  
  get cr_qp_offset_list() {
    const result: number[] = [];
    for (let i = 0; i < 6; i++) {
      result.push((() => {
        return this.#view.getInt8(146 + i * 1);
      })());
    }
    return result;
  }
  
  set cr_qp_offset_list(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(146 + i * 1, Number(value[i]));
    }
  }
  
  get log2_sao_offset_scale_luma() {
    return this.#view.getUint8(152);
  }
  
  set log2_sao_offset_scale_luma(value: number) {
    this.#view.setUint8(152, Number(value));
  }
  
  get log2_sao_offset_scale_chroma() {
    return this.#view.getUint8(153);
  }
  
  set log2_sao_offset_scale_chroma(value: number) {
    this.#view.setUint8(153, Number(value));
  }
  
  get pps_act_y_qp_offset_plus5() {
    return this.#view.getInt8(154);
  }
  
  set pps_act_y_qp_offset_plus5(value: number) {
    this.#view.setInt8(154, Number(value));
  }
  
  get pps_act_cb_qp_offset_plus5() {
    return this.#view.getInt8(155);
  }
  
  set pps_act_cb_qp_offset_plus5(value: number) {
    this.#view.setInt8(155, Number(value));
  }
  
  get pps_act_cr_qp_offset_plus3() {
    return this.#view.getInt8(156);
  }
  
  set pps_act_cr_qp_offset_plus3(value: number) {
    this.#view.setInt8(156, Number(value));
  }
  
  get pps_num_palette_predictor_initializers() {
    return this.#view.getUint8(157);
  }
  
  set pps_num_palette_predictor_initializers(value: number) {
    this.#view.setUint8(157, Number(value));
  }
  
  get luma_bit_depth_entry_minus8() {
    return this.#view.getUint8(158);
  }
  
  set luma_bit_depth_entry_minus8(value: number) {
    this.#view.setUint8(158, Number(value));
  }
  
  get chroma_bit_depth_entry_minus8() {
    return this.#view.getUint8(159);
  }
  
  set chroma_bit_depth_entry_minus8(value: number) {
    this.#view.setUint8(159, Number(value));
  }
  
  get num_tile_columns_minus1() {
    return this.#view.getUint8(160);
  }
  
  set num_tile_columns_minus1(value: number) {
    this.#view.setUint8(160, Number(value));
  }
  
  get num_tile_rows_minus1() {
    return this.#view.getUint8(161);
  }
  
  set num_tile_rows_minus1(value: number) {
    this.#view.setUint8(161, Number(value));
  }
  
  get reserved1() {
    return this.#view.getUint8(162);
  }
  
  set reserved1(value: number) {
    this.#view.setUint8(162, Number(value));
  }
  
  get reserved2() {
    return this.#view.getUint8(163);
  }
  
  set reserved2(value: number) {
    this.#view.setUint8(163, Number(value));
  }
  
  get column_width_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 19; i++) {
      result.push((() => {
        return this.#view.getUint16(164 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set column_width_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(164 + i * 2, Number(value[i]), LE);
    }
  }
  
  get row_height_minus1() {
    const result: number[] = [];
    for (let i = 0; i < 21; i++) {
      result.push((() => {
        return this.#view.getUint16(202 + i * 2, LE);
      })());
    }
    return result;
  }
  
  set row_height_minus1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint16(202 + i * 2, Number(value[i]), LE);
    }
  }
  
  get reserved3() {
    return this.#view.getUint32(244, LE);
  }
  
  set reserved3(value: number) {
    this.#view.setUint32(244, Number(value), LE);
  }
  
  get pScalingLists() {
    return this.#view.getBigUint64(248, LE);
  }
  
  set pScalingLists(value: AnyPointer) {
    this.#view.setBigUint64(248, BigInt(anyPointer(value)), LE);
  }
  
  get pPredictorPaletteEntries() {
    return this.#view.getBigUint64(256, LE);
  }
  
  set pPredictorPaletteEntries(value: AnyPointer) {
    this.#view.setBigUint64(256, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoDecodeH265PictureInfoFlags {
  IrapPicFlag?: number;
  IdrPicFlag?: number;
  IsReference?: number;
  short_term_ref_pic_set_sps_flag?: number;
}

export class StdVideoDecodeH265PictureInfoFlags implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH265PictureInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH265PictureInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH265PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH265PictureInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH265PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.IrapPicFlag !== undefined) this.IrapPicFlag = data.IrapPicFlag;
      if (data.IdrPicFlag !== undefined) this.IdrPicFlag = data.IdrPicFlag;
      if (data.IsReference !== undefined) this.IsReference = data.IsReference;
      if (data.short_term_ref_pic_set_sps_flag !== undefined) this.short_term_ref_pic_set_sps_flag = data.short_term_ref_pic_set_sps_flag;
    }
  }
  
  get IrapPicFlag() {
    return this.#view.getUint32(0, LE);
  }
  
  set IrapPicFlag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get IdrPicFlag() {
    return this.#view.getUint32(4, LE);
  }
  
  set IdrPicFlag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get IsReference() {
    return this.#view.getUint32(8, LE);
  }
  
  set IsReference(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get short_term_ref_pic_set_sps_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set short_term_ref_pic_set_sps_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitStdVideoDecodeH265PictureInfo {
  flags?: StdVideoDecodeH265PictureInfoFlags;
  sps_video_parameter_set_id?: number;
  pps_seq_parameter_set_id?: number;
  pps_pic_parameter_set_id?: number;
  NumDeltaPocsOfRefRpsIdx?: number;
  PicOrderCntVal?: number;
  NumBitsForSTRefPicSetInSlice?: number;
  reserved?: number;
  RefPicSetStCurrBefore?: number[];
  RefPicSetStCurrAfter?: number[];
  RefPicSetLtCurr?: number[];
}

export class StdVideoDecodeH265PictureInfo implements BaseStruct {
  static size = 52;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH265PictureInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH265PictureInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH265PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH265PictureInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH265PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.sps_video_parameter_set_id !== undefined) this.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
      if (data.pps_seq_parameter_set_id !== undefined) this.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
      if (data.pps_pic_parameter_set_id !== undefined) this.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
      if (data.NumDeltaPocsOfRefRpsIdx !== undefined) this.NumDeltaPocsOfRefRpsIdx = data.NumDeltaPocsOfRefRpsIdx;
      if (data.PicOrderCntVal !== undefined) this.PicOrderCntVal = data.PicOrderCntVal;
      if (data.NumBitsForSTRefPicSetInSlice !== undefined) this.NumBitsForSTRefPicSetInSlice = data.NumBitsForSTRefPicSetInSlice;
      if (data.reserved !== undefined) this.reserved = data.reserved;
      if (data.RefPicSetStCurrBefore !== undefined) this.RefPicSetStCurrBefore = data.RefPicSetStCurrBefore;
      if (data.RefPicSetStCurrAfter !== undefined) this.RefPicSetStCurrAfter = data.RefPicSetStCurrAfter;
      if (data.RefPicSetLtCurr !== undefined) this.RefPicSetLtCurr = data.RefPicSetLtCurr;
    }
  }
  
  get flags() {
    return new StdVideoDecodeH265PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH265PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH265PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(16);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(17);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(18);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(18, Number(value));
  }
  
  get NumDeltaPocsOfRefRpsIdx() {
    return this.#view.getUint8(19);
  }
  
  set NumDeltaPocsOfRefRpsIdx(value: number) {
    this.#view.setUint8(19, Number(value));
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(20, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(20, Number(value), LE);
  }
  
  get NumBitsForSTRefPicSetInSlice() {
    return this.#view.getUint16(24, LE);
  }
  
  set NumBitsForSTRefPicSetInSlice(value: number) {
    this.#view.setUint16(24, Number(value), LE);
  }
  
  get reserved() {
    return this.#view.getUint16(26, LE);
  }
  
  set reserved(value: number) {
    this.#view.setUint16(26, Number(value), LE);
  }
  
  get RefPicSetStCurrBefore() {
    const result: number[] = [];
    for (let i = 0; i < 8; i++) {
      result.push((() => {
        return this.#view.getUint8(28 + i * 1);
      })());
    }
    return result;
  }
  
  set RefPicSetStCurrBefore(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(28 + i * 1, Number(value[i]));
    }
  }
  
  get RefPicSetStCurrAfter() {
    const result: number[] = [];
    for (let i = 0; i < 8; i++) {
      result.push((() => {
        return this.#view.getUint8(36 + i * 1);
      })());
    }
    return result;
  }
  
  set RefPicSetStCurrAfter(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(36 + i * 1, Number(value[i]));
    }
  }
  
  get RefPicSetLtCurr() {
    const result: number[] = [];
    for (let i = 0; i < 8; i++) {
      result.push((() => {
        return this.#view.getUint8(44 + i * 1);
      })());
    }
    return result;
  }
  
  set RefPicSetLtCurr(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(44 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoDecodeH265ReferenceInfoFlags {
  used_for_long_term_reference?: number;
  unused_for_reference?: number;
}

export class StdVideoDecodeH265ReferenceInfoFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH265ReferenceInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH265ReferenceInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH265ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH265ReferenceInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH265ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.used_for_long_term_reference !== undefined) this.used_for_long_term_reference = data.used_for_long_term_reference;
      if (data.unused_for_reference !== undefined) this.unused_for_reference = data.unused_for_reference;
    }
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get unused_for_reference() {
    return this.#view.getUint32(4, LE);
  }
  
  set unused_for_reference(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitStdVideoDecodeH265ReferenceInfo {
  flags?: StdVideoDecodeH265ReferenceInfoFlags;
  PicOrderCntVal?: number;
}

export class StdVideoDecodeH265ReferenceInfo implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoDecodeH265ReferenceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoDecodeH265ReferenceInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoDecodeH265ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoDecodeH265ReferenceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoDecodeH265ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.PicOrderCntVal !== undefined) this.PicOrderCntVal = data.PicOrderCntVal;
    }
  }
  
  get flags() {
    return new StdVideoDecodeH265ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoDecodeH265ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoDecodeH265ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoDecodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265WeightTableFlags {
  luma_weight_l0_flag?: number;
  chroma_weight_l0_flag?: number;
  luma_weight_l1_flag?: number;
  chroma_weight_l1_flag?: number;
}

export class StdVideoEncodeH265WeightTableFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265WeightTableFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265WeightTableFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265WeightTableFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265WeightTableFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265WeightTableFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.luma_weight_l0_flag !== undefined) this.luma_weight_l0_flag = data.luma_weight_l0_flag;
      if (data.chroma_weight_l0_flag !== undefined) this.chroma_weight_l0_flag = data.chroma_weight_l0_flag;
      if (data.luma_weight_l1_flag !== undefined) this.luma_weight_l1_flag = data.luma_weight_l1_flag;
      if (data.chroma_weight_l1_flag !== undefined) this.chroma_weight_l1_flag = data.chroma_weight_l1_flag;
    }
  }
  
  get luma_weight_l0_flag() {
    return this.#view.getUint16(0, LE);
  }
  
  set luma_weight_l0_flag(value: number) {
    this.#view.setUint16(0, Number(value), LE);
  }
  
  get chroma_weight_l0_flag() {
    return this.#view.getUint16(2, LE);
  }
  
  set chroma_weight_l0_flag(value: number) {
    this.#view.setUint16(2, Number(value), LE);
  }
  
  get luma_weight_l1_flag() {
    return this.#view.getUint16(4, LE);
  }
  
  set luma_weight_l1_flag(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get chroma_weight_l1_flag() {
    return this.#view.getUint16(6, LE);
  }
  
  set chroma_weight_l1_flag(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265WeightTable {
  flags?: StdVideoEncodeH265WeightTableFlags;
  luma_log2_weight_denom?: number;
  delta_chroma_log2_weight_denom?: number;
  delta_luma_weight_l0?: number[];
  luma_offset_l0?: number[];
  delta_chroma_weight_l0?: number[];
  delta_chroma_offset_l0?: number[];
  delta_luma_weight_l1?: number[];
  luma_offset_l1?: number[];
  delta_chroma_weight_l1?: number[];
  delta_chroma_offset_l1?: number[];
}

export class StdVideoEncodeH265WeightTable implements BaseStruct {
  static size = 190;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265WeightTable);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265WeightTable) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265WeightTable.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265WeightTable.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265WeightTable.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.luma_log2_weight_denom !== undefined) this.luma_log2_weight_denom = data.luma_log2_weight_denom;
      if (data.delta_chroma_log2_weight_denom !== undefined) this.delta_chroma_log2_weight_denom = data.delta_chroma_log2_weight_denom;
      if (data.delta_luma_weight_l0 !== undefined) this.delta_luma_weight_l0 = data.delta_luma_weight_l0;
      if (data.luma_offset_l0 !== undefined) this.luma_offset_l0 = data.luma_offset_l0;
      if (data.delta_chroma_weight_l0 !== undefined) this.delta_chroma_weight_l0 = data.delta_chroma_weight_l0;
      if (data.delta_chroma_offset_l0 !== undefined) this.delta_chroma_offset_l0 = data.delta_chroma_offset_l0;
      if (data.delta_luma_weight_l1 !== undefined) this.delta_luma_weight_l1 = data.delta_luma_weight_l1;
      if (data.luma_offset_l1 !== undefined) this.luma_offset_l1 = data.luma_offset_l1;
      if (data.delta_chroma_weight_l1 !== undefined) this.delta_chroma_weight_l1 = data.delta_chroma_weight_l1;
      if (data.delta_chroma_offset_l1 !== undefined) this.delta_chroma_offset_l1 = data.delta_chroma_offset_l1;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH265WeightTableFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265WeightTableFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265WeightTableFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265WeightTableFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get luma_log2_weight_denom() {
    return this.#view.getUint8(8);
  }
  
  set luma_log2_weight_denom(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get delta_chroma_log2_weight_denom() {
    return this.#view.getInt8(9);
  }
  
  set delta_chroma_log2_weight_denom(value: number) {
    this.#view.setInt8(9, Number(value));
  }
  
  get delta_luma_weight_l0() {
    const result: number[] = [];
    for (let i = 0; i < 15; i++) {
      result.push((() => {
        return this.#view.getInt8(10 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_luma_weight_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(10 + i * 1, Number(value[i]));
    }
  }
  
  get luma_offset_l0() {
    const result: number[] = [];
    for (let i = 0; i < 15; i++) {
      result.push((() => {
        return this.#view.getInt8(25 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_offset_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(25 + i * 1, Number(value[i]));
    }
  }
  
  get delta_chroma_weight_l0() {
    const result: number[] = [];
    for (let i = 0; i < 30; i++) {
      result.push((() => {
        return this.#view.getInt8(40 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_chroma_weight_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(40 + i * 1, Number(value[i]));
    }
  }
  
  get delta_chroma_offset_l0() {
    const result: number[] = [];
    for (let i = 0; i < 30; i++) {
      result.push((() => {
        return this.#view.getInt8(70 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_chroma_offset_l0(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(70 + i * 1, Number(value[i]));
    }
  }
  
  get delta_luma_weight_l1() {
    const result: number[] = [];
    for (let i = 0; i < 15; i++) {
      result.push((() => {
        return this.#view.getInt8(100 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_luma_weight_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(100 + i * 1, Number(value[i]));
    }
  }
  
  get luma_offset_l1() {
    const result: number[] = [];
    for (let i = 0; i < 15; i++) {
      result.push((() => {
        return this.#view.getInt8(115 + i * 1);
      })());
    }
    return result;
  }
  
  set luma_offset_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(115 + i * 1, Number(value[i]));
    }
  }
  
  get delta_chroma_weight_l1() {
    const result: number[] = [];
    for (let i = 0; i < 30; i++) {
      result.push((() => {
        return this.#view.getInt8(130 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_chroma_weight_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(130 + i * 1, Number(value[i]));
    }
  }
  
  get delta_chroma_offset_l1() {
    const result: number[] = [];
    for (let i = 0; i < 30; i++) {
      result.push((() => {
        return this.#view.getInt8(160 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_chroma_offset_l1(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setInt8(160 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoEncodeH265SliceSegmentLongTermRefPics {
  num_long_term_sps?: number;
  num_long_term_pics?: number;
  lt_idx_sps?: number[];
  poc_lsb_lt?: number[];
  used_by_curr_pic_lt_flag?: number;
  delta_poc_msb_present_flag?: number[];
  delta_poc_msb_cycle_lt?: number[];
}

export class StdVideoEncodeH265SliceSegmentLongTermRefPics implements BaseStruct {
  static size = 148;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265SliceSegmentLongTermRefPics);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265SliceSegmentLongTermRefPics) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentLongTermRefPics.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265SliceSegmentLongTermRefPics.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentLongTermRefPics.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.num_long_term_sps !== undefined) this.num_long_term_sps = data.num_long_term_sps;
      if (data.num_long_term_pics !== undefined) this.num_long_term_pics = data.num_long_term_pics;
      if (data.lt_idx_sps !== undefined) this.lt_idx_sps = data.lt_idx_sps;
      if (data.poc_lsb_lt !== undefined) this.poc_lsb_lt = data.poc_lsb_lt;
      if (data.used_by_curr_pic_lt_flag !== undefined) this.used_by_curr_pic_lt_flag = data.used_by_curr_pic_lt_flag;
      if (data.delta_poc_msb_present_flag !== undefined) this.delta_poc_msb_present_flag = data.delta_poc_msb_present_flag;
      if (data.delta_poc_msb_cycle_lt !== undefined) this.delta_poc_msb_cycle_lt = data.delta_poc_msb_cycle_lt;
    }
  }
  
  get num_long_term_sps() {
    return this.#view.getUint8(0);
  }
  
  set num_long_term_sps(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get num_long_term_pics() {
    return this.#view.getUint8(1);
  }
  
  set num_long_term_pics(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get lt_idx_sps() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint8(2 + i * 1);
      })());
    }
    return result;
  }
  
  set lt_idx_sps(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(2 + i * 1, Number(value[i]));
    }
  }
  
  get poc_lsb_lt() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(34 + i * 1);
      })());
    }
    return result;
  }
  
  set poc_lsb_lt(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(34 + i * 1, Number(value[i]));
    }
  }
  
  get used_by_curr_pic_lt_flag() {
    return this.#view.getUint16(50, LE);
  }
  
  set used_by_curr_pic_lt_flag(value: number) {
    this.#view.setUint16(50, Number(value), LE);
  }
  
  get delta_poc_msb_present_flag() {
    const result: number[] = [];
    for (let i = 0; i < 48; i++) {
      result.push((() => {
        return this.#view.getUint8(52 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_poc_msb_present_flag(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(52 + i * 1, Number(value[i]));
    }
  }
  
  get delta_poc_msb_cycle_lt() {
    const result: number[] = [];
    for (let i = 0; i < 48; i++) {
      result.push((() => {
        return this.#view.getUint8(100 + i * 1);
      })());
    }
    return result;
  }
  
  set delta_poc_msb_cycle_lt(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(100 + i * 1, Number(value[i]));
    }
  }
}

export interface InitStdVideoEncodeH265SliceSegmentHeaderFlags {
  first_slice_segment_in_pic_flag?: number;
  no_output_of_prior_pics_flag?: number;
  dependent_slice_segment_flag?: number;
  pic_output_flag?: number;
  short_term_ref_pic_set_sps_flag?: number;
  slice_temporal_mvp_enable_flag?: number;
  slice_sao_luma_flag?: number;
  slice_sao_chroma_flag?: number;
  num_ref_idx_active_override_flag?: number;
  mvd_l1_zero_flag?: number;
  cabac_init_flag?: number;
  cu_chroma_qp_offset_enabled_flag?: number;
  deblocking_filter_override_flag?: number;
  slice_deblocking_filter_disabled_flag?: number;
  collocated_from_l0_flag?: number;
  slice_loop_filter_across_slices_enabled_flag?: number;
}

export class StdVideoEncodeH265SliceSegmentHeaderFlags implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265SliceSegmentHeaderFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265SliceSegmentHeaderFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentHeaderFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265SliceSegmentHeaderFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentHeaderFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.first_slice_segment_in_pic_flag !== undefined) this.first_slice_segment_in_pic_flag = data.first_slice_segment_in_pic_flag;
      if (data.no_output_of_prior_pics_flag !== undefined) this.no_output_of_prior_pics_flag = data.no_output_of_prior_pics_flag;
      if (data.dependent_slice_segment_flag !== undefined) this.dependent_slice_segment_flag = data.dependent_slice_segment_flag;
      if (data.pic_output_flag !== undefined) this.pic_output_flag = data.pic_output_flag;
      if (data.short_term_ref_pic_set_sps_flag !== undefined) this.short_term_ref_pic_set_sps_flag = data.short_term_ref_pic_set_sps_flag;
      if (data.slice_temporal_mvp_enable_flag !== undefined) this.slice_temporal_mvp_enable_flag = data.slice_temporal_mvp_enable_flag;
      if (data.slice_sao_luma_flag !== undefined) this.slice_sao_luma_flag = data.slice_sao_luma_flag;
      if (data.slice_sao_chroma_flag !== undefined) this.slice_sao_chroma_flag = data.slice_sao_chroma_flag;
      if (data.num_ref_idx_active_override_flag !== undefined) this.num_ref_idx_active_override_flag = data.num_ref_idx_active_override_flag;
      if (data.mvd_l1_zero_flag !== undefined) this.mvd_l1_zero_flag = data.mvd_l1_zero_flag;
      if (data.cabac_init_flag !== undefined) this.cabac_init_flag = data.cabac_init_flag;
      if (data.cu_chroma_qp_offset_enabled_flag !== undefined) this.cu_chroma_qp_offset_enabled_flag = data.cu_chroma_qp_offset_enabled_flag;
      if (data.deblocking_filter_override_flag !== undefined) this.deblocking_filter_override_flag = data.deblocking_filter_override_flag;
      if (data.slice_deblocking_filter_disabled_flag !== undefined) this.slice_deblocking_filter_disabled_flag = data.slice_deblocking_filter_disabled_flag;
      if (data.collocated_from_l0_flag !== undefined) this.collocated_from_l0_flag = data.collocated_from_l0_flag;
      if (data.slice_loop_filter_across_slices_enabled_flag !== undefined) this.slice_loop_filter_across_slices_enabled_flag = data.slice_loop_filter_across_slices_enabled_flag;
    }
  }
  
  get first_slice_segment_in_pic_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set first_slice_segment_in_pic_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get no_output_of_prior_pics_flag() {
    return this.#view.getUint32(4, LE);
  }
  
  set no_output_of_prior_pics_flag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dependent_slice_segment_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set dependent_slice_segment_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pic_output_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set pic_output_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get short_term_ref_pic_set_sps_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set short_term_ref_pic_set_sps_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get slice_temporal_mvp_enable_flag() {
    return this.#view.getUint32(20, LE);
  }
  
  set slice_temporal_mvp_enable_flag(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get slice_sao_luma_flag() {
    return this.#view.getUint32(24, LE);
  }
  
  set slice_sao_luma_flag(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get slice_sao_chroma_flag() {
    return this.#view.getUint32(28, LE);
  }
  
  set slice_sao_chroma_flag(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get num_ref_idx_active_override_flag() {
    return this.#view.getUint32(32, LE);
  }
  
  set num_ref_idx_active_override_flag(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get mvd_l1_zero_flag() {
    return this.#view.getUint32(36, LE);
  }
  
  set mvd_l1_zero_flag(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get cabac_init_flag() {
    return this.#view.getUint32(40, LE);
  }
  
  set cabac_init_flag(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get cu_chroma_qp_offset_enabled_flag() {
    return this.#view.getUint32(44, LE);
  }
  
  set cu_chroma_qp_offset_enabled_flag(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get deblocking_filter_override_flag() {
    return this.#view.getUint32(48, LE);
  }
  
  set deblocking_filter_override_flag(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get slice_deblocking_filter_disabled_flag() {
    return this.#view.getUint32(52, LE);
  }
  
  set slice_deblocking_filter_disabled_flag(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get collocated_from_l0_flag() {
    return this.#view.getUint32(56, LE);
  }
  
  set collocated_from_l0_flag(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get slice_loop_filter_across_slices_enabled_flag() {
    return this.#view.getUint32(60, LE);
  }
  
  set slice_loop_filter_across_slices_enabled_flag(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265SliceSegmentHeader {
  flags?: StdVideoEncodeH265SliceSegmentHeaderFlags;
  slice_type?: StdVideoH265SliceType;
  slice_segment_address?: number;
  short_term_ref_pic_set_idx?: number;
  collocated_ref_idx?: number;
  num_ref_idx_l0_active_minus1?: number;
  num_ref_idx_l1_active_minus1?: number;
  MaxNumMergeCand?: number;
  slice_cb_qp_offset?: number;
  slice_cr_qp_offset?: number;
  slice_beta_offset_div2?: number;
  slice_tc_offset_div2?: number;
  slice_act_y_qp_offset?: number;
  slice_act_cb_qp_offset?: number;
  slice_act_cr_qp_offset?: number;
  pShortTermRefPicSet?: AnyPointer;
  pLongTermRefPics?: AnyPointer;
  pWeightTable?: AnyPointer;
}

export class StdVideoEncodeH265SliceSegmentHeader implements BaseStruct {
  static size = 112;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265SliceSegmentHeader);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265SliceSegmentHeader) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentHeader.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265SliceSegmentHeader.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265SliceSegmentHeader.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.slice_type !== undefined) this.slice_type = data.slice_type;
      if (data.slice_segment_address !== undefined) this.slice_segment_address = data.slice_segment_address;
      if (data.short_term_ref_pic_set_idx !== undefined) this.short_term_ref_pic_set_idx = data.short_term_ref_pic_set_idx;
      if (data.collocated_ref_idx !== undefined) this.collocated_ref_idx = data.collocated_ref_idx;
      if (data.num_ref_idx_l0_active_minus1 !== undefined) this.num_ref_idx_l0_active_minus1 = data.num_ref_idx_l0_active_minus1;
      if (data.num_ref_idx_l1_active_minus1 !== undefined) this.num_ref_idx_l1_active_minus1 = data.num_ref_idx_l1_active_minus1;
      if (data.MaxNumMergeCand !== undefined) this.MaxNumMergeCand = data.MaxNumMergeCand;
      if (data.slice_cb_qp_offset !== undefined) this.slice_cb_qp_offset = data.slice_cb_qp_offset;
      if (data.slice_cr_qp_offset !== undefined) this.slice_cr_qp_offset = data.slice_cr_qp_offset;
      if (data.slice_beta_offset_div2 !== undefined) this.slice_beta_offset_div2 = data.slice_beta_offset_div2;
      if (data.slice_tc_offset_div2 !== undefined) this.slice_tc_offset_div2 = data.slice_tc_offset_div2;
      if (data.slice_act_y_qp_offset !== undefined) this.slice_act_y_qp_offset = data.slice_act_y_qp_offset;
      if (data.slice_act_cb_qp_offset !== undefined) this.slice_act_cb_qp_offset = data.slice_act_cb_qp_offset;
      if (data.slice_act_cr_qp_offset !== undefined) this.slice_act_cr_qp_offset = data.slice_act_cr_qp_offset;
      if (data.pShortTermRefPicSet !== undefined) this.pShortTermRefPicSet = data.pShortTermRefPicSet;
      if (data.pLongTermRefPics !== undefined) this.pLongTermRefPics = data.pLongTermRefPics;
      if (data.pWeightTable !== undefined) this.pWeightTable = data.pWeightTable;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH265SliceSegmentHeaderFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265SliceSegmentHeaderFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265SliceSegmentHeaderFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265SliceSegmentHeaderFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get slice_type() {
    return this.#view.getUint32(64, LE);
  }
  
  set slice_type(value: StdVideoH265SliceType) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get slice_segment_address() {
    return this.#view.getUint32(68, LE);
  }
  
  set slice_segment_address(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get short_term_ref_pic_set_idx() {
    return this.#view.getUint8(72);
  }
  
  set short_term_ref_pic_set_idx(value: number) {
    this.#view.setUint8(72, Number(value));
  }
  
  get collocated_ref_idx() {
    return this.#view.getUint8(73);
  }
  
  set collocated_ref_idx(value: number) {
    this.#view.setUint8(73, Number(value));
  }
  
  get num_ref_idx_l0_active_minus1() {
    return this.#view.getUint8(74);
  }
  
  set num_ref_idx_l0_active_minus1(value: number) {
    this.#view.setUint8(74, Number(value));
  }
  
  get num_ref_idx_l1_active_minus1() {
    return this.#view.getUint8(75);
  }
  
  set num_ref_idx_l1_active_minus1(value: number) {
    this.#view.setUint8(75, Number(value));
  }
  
  get MaxNumMergeCand() {
    return this.#view.getUint8(76);
  }
  
  set MaxNumMergeCand(value: number) {
    this.#view.setUint8(76, Number(value));
  }
  
  get slice_cb_qp_offset() {
    return this.#view.getInt8(77);
  }
  
  set slice_cb_qp_offset(value: number) {
    this.#view.setInt8(77, Number(value));
  }
  
  get slice_cr_qp_offset() {
    return this.#view.getInt8(78);
  }
  
  set slice_cr_qp_offset(value: number) {
    this.#view.setInt8(78, Number(value));
  }
  
  get slice_beta_offset_div2() {
    return this.#view.getInt8(79);
  }
  
  set slice_beta_offset_div2(value: number) {
    this.#view.setInt8(79, Number(value));
  }
  
  get slice_tc_offset_div2() {
    return this.#view.getInt8(80);
  }
  
  set slice_tc_offset_div2(value: number) {
    this.#view.setInt8(80, Number(value));
  }
  
  get slice_act_y_qp_offset() {
    return this.#view.getInt8(81);
  }
  
  set slice_act_y_qp_offset(value: number) {
    this.#view.setInt8(81, Number(value));
  }
  
  get slice_act_cb_qp_offset() {
    return this.#view.getInt8(82);
  }
  
  set slice_act_cb_qp_offset(value: number) {
    this.#view.setInt8(82, Number(value));
  }
  
  get slice_act_cr_qp_offset() {
    return this.#view.getInt8(83);
  }
  
  set slice_act_cr_qp_offset(value: number) {
    this.#view.setInt8(83, Number(value));
  }
  
  get pShortTermRefPicSet() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pShortTermRefPicSet(value: AnyPointer) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
  
  get pLongTermRefPics() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pLongTermRefPics(value: AnyPointer) {
    this.#view.setBigUint64(96, BigInt(anyPointer(value)), LE);
  }
  
  get pWeightTable() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set pWeightTable(value: AnyPointer) {
    this.#view.setBigUint64(104, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoEncodeH265ReferenceModificationFlags {
  ref_pic_list_modification_flag_l0?: number;
  ref_pic_list_modification_flag_l1?: number;
}

export class StdVideoEncodeH265ReferenceModificationFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265ReferenceModificationFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265ReferenceModificationFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceModificationFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265ReferenceModificationFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceModificationFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.ref_pic_list_modification_flag_l0 !== undefined) this.ref_pic_list_modification_flag_l0 = data.ref_pic_list_modification_flag_l0;
      if (data.ref_pic_list_modification_flag_l1 !== undefined) this.ref_pic_list_modification_flag_l1 = data.ref_pic_list_modification_flag_l1;
    }
  }
  
  get ref_pic_list_modification_flag_l0() {
    return this.#view.getUint32(0, LE);
  }
  
  set ref_pic_list_modification_flag_l0(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get ref_pic_list_modification_flag_l1() {
    return this.#view.getUint32(4, LE);
  }
  
  set ref_pic_list_modification_flag_l1(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265ReferenceModifications {
  flags?: StdVideoEncodeH265ReferenceModificationFlags;
  referenceList0ModificationsCount?: number;
  pReferenceList0Modifications?: AnyPointer;
  referenceList1ModificationsCount?: number;
  pReferenceList1Modifications?: AnyPointer;
}

export class StdVideoEncodeH265ReferenceModifications implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265ReferenceModifications);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265ReferenceModifications) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceModifications.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265ReferenceModifications.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceModifications.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.referenceList0ModificationsCount !== undefined) this.referenceList0ModificationsCount = data.referenceList0ModificationsCount;
      if (data.pReferenceList0Modifications !== undefined) this.pReferenceList0Modifications = data.pReferenceList0Modifications;
      if (data.referenceList1ModificationsCount !== undefined) this.referenceList1ModificationsCount = data.referenceList1ModificationsCount;
      if (data.pReferenceList1Modifications !== undefined) this.pReferenceList1Modifications = data.pReferenceList1Modifications;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH265ReferenceModificationFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265ReferenceModificationFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265ReferenceModificationFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265ReferenceModificationFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get referenceList0ModificationsCount() {
    return this.#view.getUint8(8);
  }
  
  set referenceList0ModificationsCount(value: number) {
    this.#view.setUint8(8, Number(value));
  }
  
  get pReferenceList0Modifications() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceList0Modifications(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get referenceList1ModificationsCount() {
    return this.#view.getUint8(24);
  }
  
  set referenceList1ModificationsCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pReferenceList1Modifications() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pReferenceList1Modifications(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStdVideoEncodeH265PictureInfoFlags {
  is_reference_flag?: number;
  IrapPicFlag?: number;
  long_term_flag?: number;
  discardable_flag?: number;
  cross_layer_bla_flag?: number;
}

export class StdVideoEncodeH265PictureInfoFlags implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265PictureInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265PictureInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265PictureInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265PictureInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.is_reference_flag !== undefined) this.is_reference_flag = data.is_reference_flag;
      if (data.IrapPicFlag !== undefined) this.IrapPicFlag = data.IrapPicFlag;
      if (data.long_term_flag !== undefined) this.long_term_flag = data.long_term_flag;
      if (data.discardable_flag !== undefined) this.discardable_flag = data.discardable_flag;
      if (data.cross_layer_bla_flag !== undefined) this.cross_layer_bla_flag = data.cross_layer_bla_flag;
    }
  }
  
  get is_reference_flag() {
    return this.#view.getUint32(0, LE);
  }
  
  set is_reference_flag(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get IrapPicFlag() {
    return this.#view.getUint32(4, LE);
  }
  
  set IrapPicFlag(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get long_term_flag() {
    return this.#view.getUint32(8, LE);
  }
  
  set long_term_flag(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get discardable_flag() {
    return this.#view.getUint32(12, LE);
  }
  
  set discardable_flag(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get cross_layer_bla_flag() {
    return this.#view.getUint32(16, LE);
  }
  
  set cross_layer_bla_flag(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265PictureInfo {
  flags?: StdVideoEncodeH265PictureInfoFlags;
  PictureType?: StdVideoH265PictureType;
  sps_video_parameter_set_id?: number;
  pps_seq_parameter_set_id?: number;
  pps_pic_parameter_set_id?: number;
  PicOrderCntVal?: number;
  TemporalId?: number;
}

export class StdVideoEncodeH265PictureInfo implements BaseStruct {
  static size = 36;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265PictureInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265PictureInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265PictureInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265PictureInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.PictureType !== undefined) this.PictureType = data.PictureType;
      if (data.sps_video_parameter_set_id !== undefined) this.sps_video_parameter_set_id = data.sps_video_parameter_set_id;
      if (data.pps_seq_parameter_set_id !== undefined) this.pps_seq_parameter_set_id = data.pps_seq_parameter_set_id;
      if (data.pps_pic_parameter_set_id !== undefined) this.pps_pic_parameter_set_id = data.pps_pic_parameter_set_id;
      if (data.PicOrderCntVal !== undefined) this.PicOrderCntVal = data.PicOrderCntVal;
      if (data.TemporalId !== undefined) this.TemporalId = data.TemporalId;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH265PictureInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265PictureInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265PictureInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265PictureInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PictureType() {
    return this.#view.getUint32(20, LE);
  }
  
  set PictureType(value: StdVideoH265PictureType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sps_video_parameter_set_id() {
    return this.#view.getUint8(24);
  }
  
  set sps_video_parameter_set_id(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pps_seq_parameter_set_id() {
    return this.#view.getUint8(25);
  }
  
  set pps_seq_parameter_set_id(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get pps_pic_parameter_set_id() {
    return this.#view.getUint8(26);
  }
  
  set pps_pic_parameter_set_id(value: number) {
    this.#view.setUint8(26, Number(value));
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(28, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(28, Number(value), LE);
  }
  
  get TemporalId() {
    return this.#view.getUint8(32);
  }
  
  set TemporalId(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export interface InitStdVideoEncodeH265ReferenceInfoFlags {
  used_for_long_term_reference?: number;
  unused_for_reference?: number;
}

export class StdVideoEncodeH265ReferenceInfoFlags implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265ReferenceInfoFlags);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265ReferenceInfoFlags) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265ReferenceInfoFlags.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceInfoFlags.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.used_for_long_term_reference !== undefined) this.used_for_long_term_reference = data.used_for_long_term_reference;
      if (data.unused_for_reference !== undefined) this.unused_for_reference = data.unused_for_reference;
    }
  }
  
  get used_for_long_term_reference() {
    return this.#view.getUint32(0, LE);
  }
  
  set used_for_long_term_reference(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get unused_for_reference() {
    return this.#view.getUint32(4, LE);
  }
  
  set unused_for_reference(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitStdVideoEncodeH265ReferenceInfo {
  flags?: StdVideoEncodeH265ReferenceInfoFlags;
  PicOrderCntVal?: number;
  TemporalId?: number;
}

export class StdVideoEncodeH265ReferenceInfo implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStdVideoEncodeH265ReferenceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStdVideoEncodeH265ReferenceInfo) {
    if (!data) {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StdVideoEncodeH265ReferenceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StdVideoEncodeH265ReferenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.PicOrderCntVal !== undefined) this.PicOrderCntVal = data.PicOrderCntVal;
      if (data.TemporalId !== undefined) this.TemporalId = data.TemporalId;
    }
  }
  
  get flags() {
    return new StdVideoEncodeH265ReferenceInfoFlags(this.#data.subarray(0, 0 + StdVideoEncodeH265ReferenceInfoFlags.size));
  }
  
  set flags(value: StdVideoEncodeH265ReferenceInfoFlags) {
    if (value[BUFFER].byteLength < StdVideoEncodeH265ReferenceInfoFlags.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get PicOrderCntVal() {
    return this.#view.getInt32(8, LE);
  }
  
  set PicOrderCntVal(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
  
  get TemporalId() {
    return this.#view.getUint8(12);
  }
  
  set TemporalId(value: number) {
    this.#view.setUint8(12, Number(value));
  }
}

export interface InitBaseOutStructure {
  sType?: StructureType;
  pNext?: AnyPointer;
}

export class BaseOutStructure implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBaseOutStructure);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBaseOutStructure) {
    if (!data) {
      this.#data = new Uint8Array(BaseOutStructure.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BaseOutStructure.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BaseOutStructure.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.sType !== undefined) this.sType = data.sType;
      if (data.pNext !== undefined) this.pNext = data.pNext;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBaseInStructure {
  sType?: StructureType;
  pNext?: AnyPointer;
}

export class BaseInStructure implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBaseInStructure);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBaseInStructure) {
    if (!data) {
      this.#data = new Uint8Array(BaseInStructure.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BaseInStructure.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BaseInStructure.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.sType !== undefined) this.sType = data.sType;
      if (data.pNext !== undefined) this.pNext = data.pNext;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitOffset2D {
  x?: number;
  y?: number;
}

export class Offset2D implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOffset2D);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOffset2D) {
    if (!data) {
      this.#data = new Uint8Array(Offset2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Offset2D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Offset2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
    }
  }
  
  get x() {
    return this.#view.getInt32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getInt32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
}

export interface InitOffset3D {
  x?: number;
  y?: number;
  z?: number;
}

export class Offset3D implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOffset3D);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOffset3D) {
    if (!data) {
      this.#data = new Uint8Array(Offset3D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Offset3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Offset3D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
      if (data.z !== undefined) this.z = data.z;
    }
  }
  
  get x() {
    return this.#view.getInt32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getInt32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getInt32(8, LE);
  }
  
  set z(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export interface InitExtent2D {
  width?: number;
  height?: number;
}

export class Extent2D implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExtent2D);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExtent2D) {
    if (!data) {
      this.#data = new Uint8Array(Extent2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Extent2D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Extent2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
    }
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitExtent3D {
  width?: number;
  height?: number;
  depth?: number;
}

export class Extent3D implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExtent3D);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExtent3D) {
    if (!data) {
      this.#data = new Uint8Array(Extent3D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Extent3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Extent3D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.depth !== undefined) this.depth = data.depth;
    }
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(8, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitViewport {
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  minDepth?: number;
  maxDepth?: number;
}

export class Viewport implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitViewport);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitViewport) {
    if (!data) {
      this.#data = new Uint8Array(Viewport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Viewport.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Viewport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.minDepth !== undefined) this.minDepth = data.minDepth;
      if (data.maxDepth !== undefined) this.maxDepth = data.maxDepth;
    }
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get width() {
    return this.#view.getFloat32(8, LE);
  }
  
  set width(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get height() {
    return this.#view.getFloat32(12, LE);
  }
  
  set height(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get minDepth() {
    return this.#view.getFloat32(16, LE);
  }
  
  set minDepth(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxDepth() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxDepth(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
}

export interface InitRect2D {
  offset?: Offset2D;
  extent?: Extent2D;
}

export class Rect2D implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRect2D);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRect2D) {
    if (!data) {
      this.#data = new Uint8Array(Rect2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Rect2D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Rect2D.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.extent !== undefined) this.extent = data.extent;
    }
  }
  
  get offset() {
    return new Offset2D(this.#data.subarray(0, 0 + Offset2D.size));
  }
  
  set offset(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get extent() {
    return new Extent2D(this.#data.subarray(8, 8 + Extent2D.size));
  }
  
  set extent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
}

export interface InitClearRect {
  rect?: Rect2D;
  baseArrayLayer?: number;
  layerCount?: number;
}

export class ClearRect implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitClearRect);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitClearRect) {
    if (!data) {
      this.#data = new Uint8Array(ClearRect.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ClearRect.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ClearRect.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.rect !== undefined) this.rect = data.rect;
      if (data.baseArrayLayer !== undefined) this.baseArrayLayer = data.baseArrayLayer;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
    }
  }
  
  get rect() {
    return new Rect2D(this.#data.subarray(0, 0 + Rect2D.size));
  }
  
  set rect(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(16, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitComponentMapping {
  r?: ComponentSwizzle;
  g?: ComponentSwizzle;
  b?: ComponentSwizzle;
  a?: ComponentSwizzle;
}

export class ComponentMapping implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitComponentMapping);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitComponentMapping) {
    if (!data) {
      this.#data = new Uint8Array(ComponentMapping.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ComponentMapping.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ComponentMapping.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.r !== undefined) this.r = data.r;
      if (data.g !== undefined) this.g = data.g;
      if (data.b !== undefined) this.b = data.b;
      if (data.a !== undefined) this.a = data.a;
    }
  }
  
  get r() {
    return this.#view.getUint32(0, LE);
  }
  
  set r(value: ComponentSwizzle) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get g() {
    return this.#view.getUint32(4, LE);
  }
  
  set g(value: ComponentSwizzle) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get b() {
    return this.#view.getUint32(8, LE);
  }
  
  set b(value: ComponentSwizzle) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get a() {
    return this.#view.getUint32(12, LE);
  }
  
  set a(value: ComponentSwizzle) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitPhysicalDeviceProperties {
  apiVersion?: number;
  driverVersion?: number;
  vendorID?: number;
  deviceID?: number;
  deviceType?: PhysicalDeviceType;
  deviceName?: number[];
  pipelineCacheUUID?: number[];
  limits?: PhysicalDeviceLimits;
  sparseProperties?: PhysicalDeviceSparseProperties;
}

export class PhysicalDeviceProperties implements BaseStruct {
  static size = 784;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.apiVersion !== undefined) this.apiVersion = data.apiVersion;
      if (data.driverVersion !== undefined) this.driverVersion = data.driverVersion;
      if (data.vendorID !== undefined) this.vendorID = data.vendorID;
      if (data.deviceID !== undefined) this.deviceID = data.deviceID;
      if (data.deviceType !== undefined) this.deviceType = data.deviceType;
      if (data.deviceName !== undefined) this.deviceName = data.deviceName;
      if (data.pipelineCacheUUID !== undefined) this.pipelineCacheUUID = data.pipelineCacheUUID;
      if (data.limits !== undefined) this.limits = data.limits;
      if (data.sparseProperties !== undefined) this.sparseProperties = data.sparseProperties;
    }
  }
  
  get apiVersion() {
    return this.#view.getUint32(0, LE);
  }
  
  set apiVersion(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get driverVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set driverVersion(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get deviceType() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceType(value: PhysicalDeviceType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceName() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set deviceName(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get pipelineCacheUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(276 + i * 1);
      })());
    }
    return result;
  }
  
  set pipelineCacheUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(276 + i * 1, Number(value[i]));
    }
  }
  
  get limits() {
    return new PhysicalDeviceLimits(this.#data.subarray(292, 292 + PhysicalDeviceLimits.size));
  }
  
  set limits(value: PhysicalDeviceLimits) {
    if (value[BUFFER].byteLength < PhysicalDeviceLimits.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 292);
  }
  
  get sparseProperties() {
    return new PhysicalDeviceSparseProperties(this.#data.subarray(764, 764 + PhysicalDeviceSparseProperties.size));
  }
  
  set sparseProperties(value: PhysicalDeviceSparseProperties) {
    if (value[BUFFER].byteLength < PhysicalDeviceSparseProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 764);
  }
}

export interface InitExtensionProperties {
  extensionName?: number[];
  specVersion?: number;
}

export class ExtensionProperties implements BaseStruct {
  static size = 260;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExtensionProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExtensionProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExtensionProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExtensionProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExtensionProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.extensionName !== undefined) this.extensionName = data.extensionName;
      if (data.specVersion !== undefined) this.specVersion = data.specVersion;
    }
  }
  
  get extensionName() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(0 + i * 1);
      })());
    }
    return result;
  }
  
  set extensionName(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(0 + i * 1, Number(value[i]));
    }
  }
  
  get specVersion() {
    return this.#view.getUint32(256, LE);
  }
  
  set specVersion(value: number) {
    this.#view.setUint32(256, Number(value), LE);
  }
}

export interface InitLayerProperties {
  layerName?: number[];
  specVersion?: number;
  implementationVersion?: number;
  description?: number[];
}

export class LayerProperties implements BaseStruct {
  static size = 520;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitLayerProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitLayerProperties) {
    if (!data) {
      this.#data = new Uint8Array(LayerProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < LayerProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(LayerProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.layerName !== undefined) this.layerName = data.layerName;
      if (data.specVersion !== undefined) this.specVersion = data.specVersion;
      if (data.implementationVersion !== undefined) this.implementationVersion = data.implementationVersion;
      if (data.description !== undefined) this.description = data.description;
    }
  }
  
  get layerName() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(0 + i * 1);
      })());
    }
    return result;
  }
  
  set layerName(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(0 + i * 1, Number(value[i]));
    }
  }
  
  get specVersion() {
    return this.#view.getUint32(256, LE);
  }
  
  set specVersion(value: number) {
    this.#view.setUint32(256, Number(value), LE);
  }
  
  get implementationVersion() {
    return this.#view.getUint32(260, LE);
  }
  
  set implementationVersion(value: number) {
    this.#view.setUint32(260, Number(value), LE);
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(264 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(264 + i * 1, Number(value[i]));
    }
  }
}

export interface InitApplicationInfo {
  pNext?: AnyPointer;
  pApplicationName?: AnyPointer;
  applicationVersion?: number;
  pEngineName?: AnyPointer;
  engineVersion?: number;
  apiVersion?: number;
}

export class ApplicationInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitApplicationInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitApplicationInfo) {
    if (!data) {
      this.#data = new Uint8Array(ApplicationInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ApplicationInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ApplicationInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_APPLICATION_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pApplicationName !== undefined) this.pApplicationName = data.pApplicationName;
      if (data.applicationVersion !== undefined) this.applicationVersion = data.applicationVersion;
      if (data.pEngineName !== undefined) this.pEngineName = data.pEngineName;
      if (data.engineVersion !== undefined) this.engineVersion = data.engineVersion;
      if (data.apiVersion !== undefined) this.apiVersion = data.apiVersion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pApplicationName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pApplicationName(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get applicationVersion() {
    return this.#view.getUint32(24, LE);
  }
  
  set applicationVersion(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pEngineName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pEngineName(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get engineVersion() {
    return this.#view.getUint32(40, LE);
  }
  
  set engineVersion(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get apiVersion() {
    return this.#view.getUint32(44, LE);
  }
  
  set apiVersion(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitAllocationCallbacks {
  pUserData?: AnyPointer;
  pfnAllocation?: Deno.PointerValue;
  pfnReallocation?: Deno.PointerValue;
  pfnFree?: Deno.PointerValue;
  pfnInternalAllocation?: Deno.PointerValue;
  pfnInternalFree?: Deno.PointerValue;
}

export class AllocationCallbacks implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAllocationCallbacks);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAllocationCallbacks) {
    if (!data) {
      this.#data = new Uint8Array(AllocationCallbacks.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AllocationCallbacks.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AllocationCallbacks.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.pUserData !== undefined) this.pUserData = data.pUserData;
      if (data.pfnAllocation !== undefined) this.pfnAllocation = data.pfnAllocation;
      if (data.pfnReallocation !== undefined) this.pfnReallocation = data.pfnReallocation;
      if (data.pfnFree !== undefined) this.pfnFree = data.pfnFree;
      if (data.pfnInternalAllocation !== undefined) this.pfnInternalAllocation = data.pfnInternalAllocation;
      if (data.pfnInternalFree !== undefined) this.pfnInternalFree = data.pfnInternalFree;
    }
  }
  
  get pUserData() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set pUserData(value: AnyPointer) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get pfnAllocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnAllocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnReallocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnReallocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnFree() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnFree(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnInternalAllocation() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnInternalAllocation(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pfnInternalFree() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnInternalFree(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
}

export interface InitDeviceQueueCreateInfo {
  pNext?: AnyPointer;
  flags?: DeviceQueueCreateFlags;
  queueFamilyIndex?: number;
  queueCount?: number;
  pQueuePriorities?: AnyPointer;
}

export class DeviceQueueCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceQueueCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceQueueCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceQueueCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceQueueCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceQueueCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.queueFamilyIndex !== undefined) this.queueFamilyIndex = data.queueFamilyIndex;
      if (data.queueCount !== undefined) this.queueCount = data.queueCount;
      if (data.pQueuePriorities !== undefined) this.pQueuePriorities = data.pQueuePriorities;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceQueueCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queueCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set queueCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pQueuePriorities() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pQueuePriorities(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceCreateInfo {
  pNext?: AnyPointer;
  flags?: DeviceCreateFlags;
  queueCreateInfoCount?: number;
  pQueueCreateInfos?: AnyPointer;
  enabledLayerCount?: number;
  ppEnabledLayerNames?: AnyPointer;
  enabledExtensionCount?: number;
  ppEnabledExtensionNames?: AnyPointer;
  pEnabledFeatures?: AnyPointer;
}

export class DeviceCreateInfo implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.queueCreateInfoCount !== undefined) this.queueCreateInfoCount = data.queueCreateInfoCount;
      if (data.pQueueCreateInfos !== undefined) this.pQueueCreateInfos = data.pQueueCreateInfos;
      if (data.enabledLayerCount !== undefined) this.enabledLayerCount = data.enabledLayerCount;
      if (data.ppEnabledLayerNames !== undefined) this.ppEnabledLayerNames = data.ppEnabledLayerNames;
      if (data.enabledExtensionCount !== undefined) this.enabledExtensionCount = data.enabledExtensionCount;
      if (data.ppEnabledExtensionNames !== undefined) this.ppEnabledExtensionNames = data.ppEnabledExtensionNames;
      if (data.pEnabledFeatures !== undefined) this.pEnabledFeatures = data.pEnabledFeatures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueCreateInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueCreateInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pQueueCreateInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pQueueCreateInfos(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get enabledLayerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set enabledLayerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get ppEnabledLayerNames() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set ppEnabledLayerNames(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get enabledExtensionCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set enabledExtensionCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get ppEnabledExtensionNames() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppEnabledExtensionNames(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pEnabledFeatures() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pEnabledFeatures(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitInstanceCreateInfo {
  pNext?: AnyPointer;
  flags?: InstanceCreateFlags;
  pApplicationInfo?: AnyPointer;
  enabledLayerCount?: number;
  ppEnabledLayerNames?: AnyPointer;
  enabledExtensionCount?: number;
  ppEnabledExtensionNames?: AnyPointer;
}

export class InstanceCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitInstanceCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitInstanceCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(InstanceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < InstanceCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(InstanceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pApplicationInfo !== undefined) this.pApplicationInfo = data.pApplicationInfo;
      if (data.enabledLayerCount !== undefined) this.enabledLayerCount = data.enabledLayerCount;
      if (data.ppEnabledLayerNames !== undefined) this.ppEnabledLayerNames = data.ppEnabledLayerNames;
      if (data.enabledExtensionCount !== undefined) this.enabledExtensionCount = data.enabledExtensionCount;
      if (data.ppEnabledExtensionNames !== undefined) this.ppEnabledExtensionNames = data.ppEnabledExtensionNames;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: InstanceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pApplicationInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pApplicationInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get enabledLayerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set enabledLayerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get ppEnabledLayerNames() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set ppEnabledLayerNames(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get enabledExtensionCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set enabledExtensionCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get ppEnabledExtensionNames() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppEnabledExtensionNames(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitQueueFamilyProperties {
  queueFlags?: QueueFlags;
  queueCount?: number;
  timestampValidBits?: number;
  minImageTransferGranularity?: Extent3D;
}

export class QueueFamilyProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyProperties) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.queueFlags !== undefined) this.queueFlags = data.queueFlags;
      if (data.queueCount !== undefined) this.queueCount = data.queueCount;
      if (data.timestampValidBits !== undefined) this.timestampValidBits = data.timestampValidBits;
      if (data.minImageTransferGranularity !== undefined) this.minImageTransferGranularity = data.minImageTransferGranularity;
    }
  }
  
  get queueFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set queueFlags(value: QueueFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get queueCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set queueCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get timestampValidBits() {
    return this.#view.getUint32(8, LE);
  }
  
  set timestampValidBits(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get minImageTransferGranularity() {
    return new Extent3D(this.#data.subarray(12, 12 + Extent3D.size));
  }
  
  set minImageTransferGranularity(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
}

export interface InitPhysicalDeviceMemoryProperties {
  memoryTypeCount?: number;
  memoryTypes?: MemoryType[];
  memoryHeapCount?: number;
  memoryHeaps?: MemoryHeap[];
}

export class PhysicalDeviceMemoryProperties implements BaseStruct {
  static size = 520;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.memoryTypeCount !== undefined) this.memoryTypeCount = data.memoryTypeCount;
      if (data.memoryTypes !== undefined) this.memoryTypes = data.memoryTypes;
      if (data.memoryHeapCount !== undefined) this.memoryHeapCount = data.memoryHeapCount;
      if (data.memoryHeaps !== undefined) this.memoryHeaps = data.memoryHeaps;
    }
  }
  
  get memoryTypeCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set memoryTypeCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get memoryTypes() {
    const result: MemoryType[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return new MemoryType(this.#data.subarray(4 + i * 8, 4 + i * 8 + MemoryType.size));
      })());
    }
    return result;
  }
  
  set memoryTypes(value: MemoryType[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < MemoryType.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 4 + i * 8);
    }
  }
  
  get memoryHeapCount() {
    return this.#view.getUint32(260, LE);
  }
  
  set memoryHeapCount(value: number) {
    this.#view.setUint32(260, Number(value), LE);
  }
  
  get memoryHeaps() {
    const result: MemoryHeap[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return new MemoryHeap(this.#data.subarray(264 + i * 16, 264 + i * 16 + MemoryHeap.size));
      })());
    }
    return result;
  }
  
  set memoryHeaps(value: MemoryHeap[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < MemoryHeap.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 264 + i * 16);
    }
  }
}

export interface InitMemoryAllocateInfo {
  pNext?: AnyPointer;
  allocationSize?: DeviceSize;
  memoryTypeIndex?: number;
}

export class MemoryAllocateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(MemoryAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.allocationSize !== undefined) this.allocationSize = data.allocationSize;
      if (data.memoryTypeIndex !== undefined) this.memoryTypeIndex = data.memoryTypeIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get allocationSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set allocationSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memoryTypeIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set memoryTypeIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitMemoryRequirements {
  size?: DeviceSize;
  alignment?: DeviceSize;
  memoryTypeBits?: number;
}

export class MemoryRequirements implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryRequirements);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryRequirements) {
    if (!data) {
      this.#data = new Uint8Array(MemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryRequirements.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.size !== undefined) this.size = data.size;
      if (data.alignment !== undefined) this.alignment = data.alignment;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get size() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get alignment() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set alignment(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSparseImageFormatProperties {
  aspectMask?: ImageAspectFlags;
  imageGranularity?: Extent3D;
  flags?: SparseImageFormatFlags;
}

export class SparseImageFormatProperties implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageFormatProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageFormatProperties) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageFormatProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
      if (data.imageGranularity !== undefined) this.imageGranularity = data.imageGranularity;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get imageGranularity() {
    return new Extent3D(this.#data.subarray(4, 4 + Extent3D.size));
  }
  
  set imageGranularity(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SparseImageFormatFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSparseImageMemoryRequirements {
  formatProperties?: SparseImageFormatProperties;
  imageMipTailFirstLod?: number;
  imageMipTailSize?: DeviceSize;
  imageMipTailOffset?: DeviceSize;
  imageMipTailStride?: DeviceSize;
}

export class SparseImageMemoryRequirements implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageMemoryRequirements);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageMemoryRequirements) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageMemoryRequirements.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.formatProperties !== undefined) this.formatProperties = data.formatProperties;
      if (data.imageMipTailFirstLod !== undefined) this.imageMipTailFirstLod = data.imageMipTailFirstLod;
      if (data.imageMipTailSize !== undefined) this.imageMipTailSize = data.imageMipTailSize;
      if (data.imageMipTailOffset !== undefined) this.imageMipTailOffset = data.imageMipTailOffset;
      if (data.imageMipTailStride !== undefined) this.imageMipTailStride = data.imageMipTailStride;
    }
  }
  
  get formatProperties() {
    return new SparseImageFormatProperties(this.#data.subarray(0, 0 + SparseImageFormatProperties.size));
  }
  
  set formatProperties(value: SparseImageFormatProperties) {
    if (value[BUFFER].byteLength < SparseImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get imageMipTailFirstLod() {
    return this.#view.getUint32(20, LE);
  }
  
  set imageMipTailFirstLod(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get imageMipTailSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set imageMipTailSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get imageMipTailOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set imageMipTailOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get imageMipTailStride() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set imageMipTailStride(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export interface InitMemoryType {
  propertyFlags?: MemoryPropertyFlags;
  heapIndex?: number;
}

export class MemoryType implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryType);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryType) {
    if (!data) {
      this.#data = new Uint8Array(MemoryType.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryType.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryType.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.propertyFlags !== undefined) this.propertyFlags = data.propertyFlags;
      if (data.heapIndex !== undefined) this.heapIndex = data.heapIndex;
    }
  }
  
  get propertyFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set propertyFlags(value: MemoryPropertyFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get heapIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set heapIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitMemoryHeap {
  size?: DeviceSize;
  flags?: MemoryHeapFlags;
}

export class MemoryHeap implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryHeap);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryHeap) {
    if (!data) {
      this.#data = new Uint8Array(MemoryHeap.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryHeap.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryHeap.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.size !== undefined) this.size = data.size;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get size() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(8, LE);
  }
  
  set flags(value: MemoryHeapFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitMappedMemoryRange {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  offset?: DeviceSize;
  size?: DeviceSize;
}

export class MappedMemoryRange implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMappedMemoryRange);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMappedMemoryRange) {
    if (!data) {
      this.#data = new Uint8Array(MappedMemoryRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MappedMemoryRange.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MappedMemoryRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitFormatProperties {
  linearTilingFeatures?: FormatFeatureFlags;
  optimalTilingFeatures?: FormatFeatureFlags;
  bufferFeatures?: FormatFeatureFlags;
}

export class FormatProperties implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFormatProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFormatProperties) {
    if (!data) {
      this.#data = new Uint8Array(FormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FormatProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.linearTilingFeatures !== undefined) this.linearTilingFeatures = data.linearTilingFeatures;
      if (data.optimalTilingFeatures !== undefined) this.optimalTilingFeatures = data.optimalTilingFeatures;
      if (data.bufferFeatures !== undefined) this.bufferFeatures = data.bufferFeatures;
    }
  }
  
  get linearTilingFeatures() {
    return this.#view.getUint32(0, LE);
  }
  
  set linearTilingFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get optimalTilingFeatures() {
    return this.#view.getUint32(4, LE);
  }
  
  set optimalTilingFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get bufferFeatures() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitImageFormatProperties {
  maxExtent?: Extent3D;
  maxMipLevels?: number;
  maxArrayLayers?: number;
  sampleCounts?: SampleCountFlags;
  maxResourceSize?: DeviceSize;
}

export class ImageFormatProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageFormatProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageFormatProperties) {
    if (!data) {
      this.#data = new Uint8Array(ImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageFormatProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.maxExtent !== undefined) this.maxExtent = data.maxExtent;
      if (data.maxMipLevels !== undefined) this.maxMipLevels = data.maxMipLevels;
      if (data.maxArrayLayers !== undefined) this.maxArrayLayers = data.maxArrayLayers;
      if (data.sampleCounts !== undefined) this.sampleCounts = data.sampleCounts;
      if (data.maxResourceSize !== undefined) this.maxResourceSize = data.maxResourceSize;
    }
  }
  
  get maxExtent() {
    return new Extent3D(this.#data.subarray(0, 0 + Extent3D.size));
  }
  
  set maxExtent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get maxMipLevels() {
    return this.#view.getUint32(12, LE);
  }
  
  set maxMipLevels(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get maxArrayLayers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxArrayLayers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleCounts() {
    return this.#view.getUint32(20, LE);
  }
  
  set sampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxResourceSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxResourceSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitDescriptorBufferInfo {
  buffer?: Buffer;
  offset?: DeviceSize;
  range?: DeviceSize;
}

export class DescriptorBufferInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorBufferInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorBufferInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorBufferInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorBufferInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorBufferInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.range !== undefined) this.range = data.range;
    }
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set range(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitDescriptorImageInfo {
  sampler?: Sampler;
  imageView?: ImageView;
  imageLayout?: ImageLayout;
}

export class DescriptorImageInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorImageInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorImageInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorImageInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorImageInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorImageInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.sampler !== undefined) this.sampler = data.sampler;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.imageLayout !== undefined) this.imageLayout = data.imageLayout;
    }
  }
  
  get sampler() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set sampler(value: Sampler) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageLayout(value: ImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitWriteDescriptorSet {
  pNext?: AnyPointer;
  dstSet?: DescriptorSet;
  dstBinding?: number;
  dstArrayElement?: number;
  descriptorCount?: number;
  descriptorType?: DescriptorType;
  pImageInfo?: AnyPointer;
  pBufferInfo?: AnyPointer;
  pTexelBufferView?: AnyPointer;
}

export class WriteDescriptorSet implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWriteDescriptorSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWriteDescriptorSet) {
    if (!data) {
      this.#data = new Uint8Array(WriteDescriptorSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < WriteDescriptorSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(WriteDescriptorSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dstSet !== undefined) this.dstSet = data.dstSet;
      if (data.dstBinding !== undefined) this.dstBinding = data.dstBinding;
      if (data.dstArrayElement !== undefined) this.dstArrayElement = data.dstArrayElement;
      if (data.descriptorCount !== undefined) this.descriptorCount = data.descriptorCount;
      if (data.descriptorType !== undefined) this.descriptorType = data.descriptorType;
      if (data.pImageInfo !== undefined) this.pImageInfo = data.pImageInfo;
      if (data.pBufferInfo !== undefined) this.pBufferInfo = data.pBufferInfo;
      if (data.pTexelBufferView !== undefined) this.pTexelBufferView = data.pTexelBufferView;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dstSet() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dstSet(value: DescriptorSet) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dstBinding() {
    return this.#view.getUint32(24, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(36, LE);
  }
  
  set descriptorType(value: DescriptorType) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pImageInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pImageInfo(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pBufferInfo() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pBufferInfo(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pTexelBufferView() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pTexelBufferView(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCopyDescriptorSet {
  pNext?: AnyPointer;
  srcSet?: DescriptorSet;
  srcBinding?: number;
  srcArrayElement?: number;
  dstSet?: DescriptorSet;
  dstBinding?: number;
  dstArrayElement?: number;
  descriptorCount?: number;
}

export class CopyDescriptorSet implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyDescriptorSet);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyDescriptorSet) {
    if (!data) {
      this.#data = new Uint8Array(CopyDescriptorSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyDescriptorSet.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyDescriptorSet.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcSet !== undefined) this.srcSet = data.srcSet;
      if (data.srcBinding !== undefined) this.srcBinding = data.srcBinding;
      if (data.srcArrayElement !== undefined) this.srcArrayElement = data.srcArrayElement;
      if (data.dstSet !== undefined) this.dstSet = data.dstSet;
      if (data.dstBinding !== undefined) this.dstBinding = data.dstBinding;
      if (data.dstArrayElement !== undefined) this.dstArrayElement = data.dstArrayElement;
      if (data.descriptorCount !== undefined) this.descriptorCount = data.descriptorCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcSet() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcSet(value: DescriptorSet) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get srcBinding() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcBinding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get srcArrayElement() {
    return this.#view.getUint32(28, LE);
  }
  
  set srcArrayElement(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get dstSet() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstSet(value: DescriptorSet) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get dstBinding() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(44, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitBufferCreateInfo {
  pNext?: AnyPointer;
  flags?: BufferCreateFlags;
  size?: DeviceSize;
  usage?: BufferUsageFlags;
  sharingMode?: SharingMode;
  queueFamilyIndexCount?: number;
  pQueueFamilyIndices?: AnyPointer;
}

export class BufferCreateInfo implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(BufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.size !== undefined) this.size = data.size;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.sharingMode !== undefined) this.sharingMode = data.sharingMode;
      if (data.queueFamilyIndexCount !== undefined) this.queueFamilyIndexCount = data.queueFamilyIndexCount;
      if (data.pQueueFamilyIndices !== undefined) this.pQueueFamilyIndices = data.pQueueFamilyIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: BufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(32, LE);
  }
  
  set usage(value: BufferUsageFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(36, LE);
  }
  
  set sharingMode(value: SharingMode) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pQueueFamilyIndices(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBufferViewCreateInfo {
  pNext?: AnyPointer;
  flags?: BufferViewCreateFlags;
  buffer?: Buffer;
  format?: Format;
  offset?: DeviceSize;
  range?: DeviceSize;
}

export class BufferViewCreateInfo implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferViewCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferViewCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(BufferViewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferViewCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferViewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.format !== undefined) this.format = data.format;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.range !== undefined) this.range = data.range;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: BufferViewCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(32, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set range(value: DeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export interface InitImageSubresource {
  aspectMask?: ImageAspectFlags;
  mipLevel?: number;
  arrayLayer?: number;
}

export class ImageSubresource implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSubresource);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSubresource) {
    if (!data) {
      this.#data = new Uint8Array(ImageSubresource.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSubresource.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSubresource.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
      if (data.mipLevel !== undefined) this.mipLevel = data.mipLevel;
      if (data.arrayLayer !== undefined) this.arrayLayer = data.arrayLayer;
    }
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get mipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set mipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get arrayLayer() {
    return this.#view.getUint32(8, LE);
  }
  
  set arrayLayer(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitImageSubresourceLayers {
  aspectMask?: ImageAspectFlags;
  mipLevel?: number;
  baseArrayLayer?: number;
  layerCount?: number;
}

export class ImageSubresourceLayers implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSubresourceLayers);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSubresourceLayers) {
    if (!data) {
      this.#data = new Uint8Array(ImageSubresourceLayers.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSubresourceLayers.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSubresourceLayers.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
      if (data.mipLevel !== undefined) this.mipLevel = data.mipLevel;
      if (data.baseArrayLayer !== undefined) this.baseArrayLayer = data.baseArrayLayer;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
    }
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get mipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set mipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(8, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(12, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitImageSubresourceRange {
  aspectMask?: ImageAspectFlags;
  baseMipLevel?: number;
  levelCount?: number;
  baseArrayLayer?: number;
  layerCount?: number;
}

export class ImageSubresourceRange implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSubresourceRange);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSubresourceRange) {
    if (!data) {
      this.#data = new Uint8Array(ImageSubresourceRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSubresourceRange.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSubresourceRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
      if (data.baseMipLevel !== undefined) this.baseMipLevel = data.baseMipLevel;
      if (data.levelCount !== undefined) this.levelCount = data.levelCount;
      if (data.baseArrayLayer !== undefined) this.baseArrayLayer = data.baseArrayLayer;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
    }
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get baseMipLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set baseMipLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get levelCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set levelCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(12, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryBarrier {
  pNext?: AnyPointer;
  srcAccessMask?: AccessFlags;
  dstAccessMask?: AccessFlags;
}

export class MemoryBarrier implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryBarrier);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryBarrier) {
    if (!data) {
      this.#data = new Uint8Array(MemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryBarrier.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_BARRIER;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: AccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: AccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitBufferMemoryBarrier {
  pNext?: AnyPointer;
  srcAccessMask?: AccessFlags;
  dstAccessMask?: AccessFlags;
  srcQueueFamilyIndex?: number;
  dstQueueFamilyIndex?: number;
  buffer?: Buffer;
  offset?: DeviceSize;
  size?: DeviceSize;
}

export class BufferMemoryBarrier implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferMemoryBarrier);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferMemoryBarrier) {
    if (!data) {
      this.#data = new Uint8Array(BufferMemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferMemoryBarrier.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferMemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.srcQueueFamilyIndex !== undefined) this.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
      if (data.dstQueueFamilyIndex !== undefined) this.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: AccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: AccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
}

export interface InitImageMemoryBarrier {
  pNext?: AnyPointer;
  srcAccessMask?: AccessFlags;
  dstAccessMask?: AccessFlags;
  oldLayout?: ImageLayout;
  newLayout?: ImageLayout;
  srcQueueFamilyIndex?: number;
  dstQueueFamilyIndex?: number;
  image?: Image;
  subresourceRange?: ImageSubresourceRange;
}

export class ImageMemoryBarrier implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageMemoryBarrier);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageMemoryBarrier) {
    if (!data) {
      this.#data = new Uint8Array(ImageMemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageMemoryBarrier.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageMemoryBarrier.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.oldLayout !== undefined) this.oldLayout = data.oldLayout;
      if (data.newLayout !== undefined) this.newLayout = data.newLayout;
      if (data.srcQueueFamilyIndex !== undefined) this.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
      if (data.dstQueueFamilyIndex !== undefined) this.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
      if (data.image !== undefined) this.image = data.image;
      if (data.subresourceRange !== undefined) this.subresourceRange = data.subresourceRange;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: AccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: AccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get oldLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set oldLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get newLayout() {
    return this.#view.getUint32(28, LE);
  }
  
  set newLayout(value: ImageLayout) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(32, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(36, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get subresourceRange() {
    return new ImageSubresourceRange(this.#data.subarray(48, 48 + ImageSubresourceRange.size));
  }
  
  set subresourceRange(value: ImageSubresourceRange) {
    if (value[BUFFER].byteLength < ImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
}

export interface InitImageCreateInfo {
  pNext?: AnyPointer;
  flags?: ImageCreateFlags;
  imageType?: ImageType;
  format?: Format;
  extent?: Extent3D;
  mipLevels?: number;
  arrayLayers?: number;
  samples?: SampleCountFlagBits;
  tiling?: ImageTiling;
  usage?: ImageUsageFlags;
  sharingMode?: SharingMode;
  queueFamilyIndexCount?: number;
  pQueueFamilyIndices?: AnyPointer;
  initialLayout?: ImageLayout;
}

export class ImageCreateInfo implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.imageType !== undefined) this.imageType = data.imageType;
      if (data.format !== undefined) this.format = data.format;
      if (data.extent !== undefined) this.extent = data.extent;
      if (data.mipLevels !== undefined) this.mipLevels = data.mipLevels;
      if (data.arrayLayers !== undefined) this.arrayLayers = data.arrayLayers;
      if (data.samples !== undefined) this.samples = data.samples;
      if (data.tiling !== undefined) this.tiling = data.tiling;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.sharingMode !== undefined) this.sharingMode = data.sharingMode;
      if (data.queueFamilyIndexCount !== undefined) this.queueFamilyIndexCount = data.queueFamilyIndexCount;
      if (data.pQueueFamilyIndices !== undefined) this.pQueueFamilyIndices = data.pQueueFamilyIndices;
      if (data.initialLayout !== undefined) this.initialLayout = data.initialLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ImageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imageType() {
    return this.#view.getUint32(20, LE);
  }
  
  set imageType(value: ImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(24, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(28, 28 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get mipLevels() {
    return this.#view.getUint32(40, LE);
  }
  
  set mipLevels(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get arrayLayers() {
    return this.#view.getUint32(44, LE);
  }
  
  set arrayLayers(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(48, LE);
  }
  
  set samples(value: SampleCountFlagBits) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(52, LE);
  }
  
  set tiling(value: ImageTiling) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(56, LE);
  }
  
  set usage(value: ImageUsageFlags) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(60, LE);
  }
  
  set sharingMode(value: SharingMode) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pQueueFamilyIndices(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(80, LE);
  }
  
  set initialLayout(value: ImageLayout) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export interface InitSubresourceLayout {
  offset?: DeviceSize;
  size?: DeviceSize;
  rowPitch?: DeviceSize;
  arrayPitch?: DeviceSize;
  depthPitch?: DeviceSize;
}

export class SubresourceLayout implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubresourceLayout);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubresourceLayout) {
    if (!data) {
      this.#data = new Uint8Array(SubresourceLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubresourceLayout.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubresourceLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
      if (data.rowPitch !== undefined) this.rowPitch = data.rowPitch;
      if (data.arrayPitch !== undefined) this.arrayPitch = data.arrayPitch;
      if (data.depthPitch !== undefined) this.depthPitch = data.depthPitch;
    }
  }
  
  get offset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get rowPitch() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set rowPitch(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get arrayPitch() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set arrayPitch(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get depthPitch() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set depthPitch(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitImageViewCreateInfo {
  pNext?: AnyPointer;
  flags?: ImageViewCreateFlags;
  image?: Image;
  viewType?: ImageViewType;
  format?: Format;
  components?: ComponentMapping;
  subresourceRange?: ImageSubresourceRange;
}

export class ImageViewCreateInfo implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.image !== undefined) this.image = data.image;
      if (data.viewType !== undefined) this.viewType = data.viewType;
      if (data.format !== undefined) this.format = data.format;
      if (data.components !== undefined) this.components = data.components;
      if (data.subresourceRange !== undefined) this.subresourceRange = data.subresourceRange;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ImageViewCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get viewType() {
    return this.#view.getUint32(32, LE);
  }
  
  set viewType(value: ImageViewType) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(36, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get components() {
    return new ComponentMapping(this.#data.subarray(40, 40 + ComponentMapping.size));
  }
  
  set components(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get subresourceRange() {
    return new ImageSubresourceRange(this.#data.subarray(56, 56 + ImageSubresourceRange.size));
  }
  
  set subresourceRange(value: ImageSubresourceRange) {
    if (value[BUFFER].byteLength < ImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
}

export interface InitBufferCopy {
  srcOffset?: DeviceSize;
  dstOffset?: DeviceSize;
  size?: DeviceSize;
}

export class BufferCopy implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCopy);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCopy) {
    if (!data) {
      this.#data = new Uint8Array(BufferCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCopy.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get srcOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcOffset(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstOffset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstOffset(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitSparseMemoryBind {
  resourceOffset?: DeviceSize;
  size?: DeviceSize;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
  flags?: SparseMemoryBindFlags;
}

export class SparseMemoryBind implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseMemoryBind);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseMemoryBind) {
    if (!data) {
      this.#data = new Uint8Array(SparseMemoryBind.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseMemoryBind.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseMemoryBind.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.resourceOffset !== undefined) this.resourceOffset = data.resourceOffset;
      if (data.size !== undefined) this.size = data.size;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get resourceOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set resourceOffset(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: SparseMemoryBindFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitSparseImageMemoryBind {
  subresource?: ImageSubresource;
  offset?: Offset3D;
  extent?: Extent3D;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
  flags?: SparseMemoryBindFlags;
}

export class SparseImageMemoryBind implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageMemoryBind);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageMemoryBind) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageMemoryBind.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageMemoryBind.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageMemoryBind.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.subresource !== undefined) this.subresource = data.subresource;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.extent !== undefined) this.extent = data.extent;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get subresource() {
    return new ImageSubresource(this.#data.subarray(0, 0 + ImageSubresource.size));
  }
  
  set subresource(value: ImageSubresource) {
    if (value[BUFFER].byteLength < ImageSubresource.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get offset() {
    return new Offset3D(this.#data.subarray(12, 12 + Offset3D.size));
  }
  
  set offset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(24, 24 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get memory() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(56, LE);
  }
  
  set flags(value: SparseMemoryBindFlags) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitSparseBufferMemoryBindInfo {
  buffer?: Buffer;
  bindCount?: number;
  pBinds?: AnyPointer;
}

export class SparseBufferMemoryBindInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseBufferMemoryBindInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseBufferMemoryBindInfo) {
    if (!data) {
      this.#data = new Uint8Array(SparseBufferMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseBufferMemoryBindInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseBufferMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.bindCount !== undefined) this.bindCount = data.bindCount;
      if (data.pBinds !== undefined) this.pBinds = data.pBinds;
    }
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSparseImageOpaqueMemoryBindInfo {
  image?: Image;
  bindCount?: number;
  pBinds?: AnyPointer;
}

export class SparseImageOpaqueMemoryBindInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageOpaqueMemoryBindInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageOpaqueMemoryBindInfo) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageOpaqueMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageOpaqueMemoryBindInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageOpaqueMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.image !== undefined) this.image = data.image;
      if (data.bindCount !== undefined) this.bindCount = data.bindCount;
      if (data.pBinds !== undefined) this.pBinds = data.pBinds;
    }
  }
  
  get image() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSparseImageMemoryBindInfo {
  image?: Image;
  bindCount?: number;
  pBinds?: AnyPointer;
}

export class SparseImageMemoryBindInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageMemoryBindInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageMemoryBindInfo) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageMemoryBindInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageMemoryBindInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.image !== undefined) this.image = data.image;
      if (data.bindCount !== undefined) this.bindCount = data.bindCount;
      if (data.pBinds !== undefined) this.pBinds = data.pBinds;
    }
  }
  
  get image() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get bindCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set bindCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pBinds() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pBinds(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBindSparseInfo {
  pNext?: AnyPointer;
  waitSemaphoreCount?: number;
  pWaitSemaphores?: AnyPointer;
  bufferBindCount?: number;
  pBufferBinds?: AnyPointer;
  imageOpaqueBindCount?: number;
  pImageOpaqueBinds?: AnyPointer;
  imageBindCount?: number;
  pImageBinds?: AnyPointer;
  signalSemaphoreCount?: number;
  pSignalSemaphores?: AnyPointer;
}

export class BindSparseInfo implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindSparseInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindSparseInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindSparseInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindSparseInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindSparseInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_SPARSE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreCount !== undefined) this.waitSemaphoreCount = data.waitSemaphoreCount;
      if (data.pWaitSemaphores !== undefined) this.pWaitSemaphores = data.pWaitSemaphores;
      if (data.bufferBindCount !== undefined) this.bufferBindCount = data.bufferBindCount;
      if (data.pBufferBinds !== undefined) this.pBufferBinds = data.pBufferBinds;
      if (data.imageOpaqueBindCount !== undefined) this.imageOpaqueBindCount = data.imageOpaqueBindCount;
      if (data.pImageOpaqueBinds !== undefined) this.pImageOpaqueBinds = data.pImageOpaqueBinds;
      if (data.imageBindCount !== undefined) this.imageBindCount = data.imageBindCount;
      if (data.pImageBinds !== undefined) this.pImageBinds = data.pImageBinds;
      if (data.signalSemaphoreCount !== undefined) this.signalSemaphoreCount = data.signalSemaphoreCount;
      if (data.pSignalSemaphores !== undefined) this.pSignalSemaphores = data.pSignalSemaphores;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get bufferBindCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set bufferBindCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pBufferBinds() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pBufferBinds(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get imageOpaqueBindCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageOpaqueBindCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pImageOpaqueBinds() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pImageOpaqueBinds(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get imageBindCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set imageBindCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pImageBinds() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pImageBinds(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(80, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get pSignalSemaphores() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pSignalSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageCopy {
  srcSubresource?: ImageSubresourceLayers;
  srcOffset?: Offset3D;
  dstSubresource?: ImageSubresourceLayers;
  dstOffset?: Offset3D;
  extent?: Extent3D;
}

export class ImageCopy implements BaseStruct {
  static size = 68;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCopy);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCopy) {
    if (!data) {
      this.#data = new Uint8Array(ImageCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCopy.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.extent !== undefined) this.extent = data.extent;
    }
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(0, 0 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffset() {
    return new Offset3D(this.#data.subarray(16, 16 + Offset3D.size));
  }
  
  set srcOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(28, 28 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get dstOffset() {
    return new Offset3D(this.#data.subarray(44, 44 + Offset3D.size));
  }
  
  set dstOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(56, 56 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
}

export interface InitImageBlit {
  srcSubresource?: ImageSubresourceLayers;
  srcOffsets?: Offset3D[];
  dstSubresource?: ImageSubresourceLayers;
  dstOffsets?: Offset3D[];
}

export class ImageBlit implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageBlit);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageBlit) {
    if (!data) {
      this.#data = new Uint8Array(ImageBlit.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageBlit.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageBlit.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffsets !== undefined) this.srcOffsets = data.srcOffsets;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffsets !== undefined) this.dstOffsets = data.dstOffsets;
    }
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(0, 0 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffsets() {
    const result: Offset3D[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return new Offset3D(this.#data.subarray(16 + i * 12, 16 + i * 12 + Offset3D.size));
      })());
    }
    return result;
  }
  
  set srcOffsets(value: Offset3D[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < Offset3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 16 + i * 12);
    }
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(40, 40 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get dstOffsets() {
    const result: Offset3D[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return new Offset3D(this.#data.subarray(56 + i * 12, 56 + i * 12 + Offset3D.size));
      })());
    }
    return result;
  }
  
  set dstOffsets(value: Offset3D[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < Offset3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 56 + i * 12);
    }
  }
}

export interface InitBufferImageCopy {
  bufferOffset?: DeviceSize;
  bufferRowLength?: number;
  bufferImageHeight?: number;
  imageSubresource?: ImageSubresourceLayers;
  imageOffset?: Offset3D;
  imageExtent?: Extent3D;
}

export class BufferImageCopy implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferImageCopy);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferImageCopy) {
    if (!data) {
      this.#data = new Uint8Array(BufferImageCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferImageCopy.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferImageCopy.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.bufferOffset !== undefined) this.bufferOffset = data.bufferOffset;
      if (data.bufferRowLength !== undefined) this.bufferRowLength = data.bufferRowLength;
      if (data.bufferImageHeight !== undefined) this.bufferImageHeight = data.bufferImageHeight;
      if (data.imageSubresource !== undefined) this.imageSubresource = data.imageSubresource;
      if (data.imageOffset !== undefined) this.imageOffset = data.imageOffset;
      if (data.imageExtent !== undefined) this.imageExtent = data.imageExtent;
    }
  }
  
  get bufferOffset() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferOffset(value: DeviceSize) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(12, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get imageSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(16, 16 + ImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get imageOffset() {
    return new Offset3D(this.#data.subarray(32, 32 + Offset3D.size));
  }
  
  set imageOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get imageExtent() {
    return new Extent3D(this.#data.subarray(44, 44 + Extent3D.size));
  }
  
  set imageExtent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
}

export interface InitCopyMemoryIndirectCommandNV {
  srcAddress?: DeviceAddress;
  dstAddress?: DeviceAddress;
  size?: DeviceSize;
}

export class CopyMemoryIndirectCommandNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMemoryIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMemoryIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(CopyMemoryIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMemoryIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMemoryIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcAddress !== undefined) this.srcAddress = data.srcAddress;
      if (data.dstAddress !== undefined) this.dstAddress = data.dstAddress;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstAddress(value: DeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitCopyMemoryToImageIndirectCommandNV {
  srcAddress?: DeviceAddress;
  bufferRowLength?: number;
  bufferImageHeight?: number;
  imageSubresource?: ImageSubresourceLayers;
  imageOffset?: Offset3D;
  imageExtent?: Extent3D;
}

export class CopyMemoryToImageIndirectCommandNV implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMemoryToImageIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMemoryToImageIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(CopyMemoryToImageIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMemoryToImageIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMemoryToImageIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcAddress !== undefined) this.srcAddress = data.srcAddress;
      if (data.bufferRowLength !== undefined) this.bufferRowLength = data.bufferRowLength;
      if (data.bufferImageHeight !== undefined) this.bufferImageHeight = data.bufferImageHeight;
      if (data.imageSubresource !== undefined) this.imageSubresource = data.imageSubresource;
      if (data.imageOffset !== undefined) this.imageOffset = data.imageOffset;
      if (data.imageExtent !== undefined) this.imageExtent = data.imageExtent;
    }
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(8, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(12, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get imageSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(16, 16 + ImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get imageOffset() {
    return new Offset3D(this.#data.subarray(32, 32 + Offset3D.size));
  }
  
  set imageOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get imageExtent() {
    return new Extent3D(this.#data.subarray(44, 44 + Extent3D.size));
  }
  
  set imageExtent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
}

export interface InitImageResolve {
  srcSubresource?: ImageSubresourceLayers;
  srcOffset?: Offset3D;
  dstSubresource?: ImageSubresourceLayers;
  dstOffset?: Offset3D;
  extent?: Extent3D;
}

export class ImageResolve implements BaseStruct {
  static size = 68;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageResolve);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageResolve) {
    if (!data) {
      this.#data = new Uint8Array(ImageResolve.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageResolve.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageResolve.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.extent !== undefined) this.extent = data.extent;
    }
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(0, 0 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get srcOffset() {
    return new Offset3D(this.#data.subarray(16, 16 + Offset3D.size));
  }
  
  set srcOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(28, 28 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get dstOffset() {
    return new Offset3D(this.#data.subarray(44, 44 + Offset3D.size));
  }
  
  set dstOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(56, 56 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
}

export interface InitShaderModuleCreateInfo {
  pNext?: AnyPointer;
  flags?: ShaderModuleCreateFlags;
  codeSize?: Deno.PointerValue;
  pCode?: AnyPointer;
}

export class ShaderModuleCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShaderModuleCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShaderModuleCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ShaderModuleCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShaderModuleCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShaderModuleCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.codeSize !== undefined) this.codeSize = data.codeSize;
      if (data.pCode !== undefined) this.pCode = data.pCode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ShaderModuleCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get codeSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set codeSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pCode() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pCode(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorSetLayoutBinding {
  binding?: number;
  descriptorType?: DescriptorType;
  descriptorCount?: number;
  stageFlags?: ShaderStageFlags;
  pImmutableSamplers?: AnyPointer;
}

export class DescriptorSetLayoutBinding implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetLayoutBinding);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetLayoutBinding) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetLayoutBinding.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetLayoutBinding.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetLayoutBinding.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.descriptorType !== undefined) this.descriptorType = data.descriptorType;
      if (data.descriptorCount !== undefined) this.descriptorCount = data.descriptorCount;
      if (data.stageFlags !== undefined) this.stageFlags = data.stageFlags;
      if (data.pImmutableSamplers !== undefined) this.pImmutableSamplers = data.pImmutableSamplers;
    }
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(4, LE);
  }
  
  set descriptorType(value: DescriptorType) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get stageFlags() {
    return this.#view.getUint32(12, LE);
  }
  
  set stageFlags(value: ShaderStageFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get pImmutableSamplers() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pImmutableSamplers(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorSetLayoutCreateInfo {
  pNext?: AnyPointer;
  flags?: DescriptorSetLayoutCreateFlags;
  bindingCount?: number;
  pBindings?: AnyPointer;
}

export class DescriptorSetLayoutCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetLayoutCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetLayoutCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetLayoutCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetLayoutCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetLayoutCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.bindingCount !== undefined) this.bindingCount = data.bindingCount;
      if (data.pBindings !== undefined) this.pBindings = data.pBindings;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DescriptorSetLayoutCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bindingCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set bindingCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pBindings() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pBindings(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorPoolSize {
  type?: DescriptorType;
  descriptorCount?: number;
}

export class DescriptorPoolSize implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorPoolSize);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorPoolSize) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorPoolSize.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorPoolSize.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorPoolSize.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.type !== undefined) this.type = data.type;
      if (data.descriptorCount !== undefined) this.descriptorCount = data.descriptorCount;
    }
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: DescriptorType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitDescriptorPoolCreateInfo {
  pNext?: AnyPointer;
  flags?: DescriptorPoolCreateFlags;
  maxSets?: number;
  poolSizeCount?: number;
  pPoolSizes?: AnyPointer;
}

export class DescriptorPoolCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorPoolCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorPoolCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorPoolCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.maxSets !== undefined) this.maxSets = data.maxSets;
      if (data.poolSizeCount !== undefined) this.poolSizeCount = data.poolSizeCount;
      if (data.pPoolSizes !== undefined) this.pPoolSizes = data.pPoolSizes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DescriptorPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSets() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSets(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get poolSizeCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set poolSizeCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPoolSizes() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPoolSizes(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorSetAllocateInfo {
  pNext?: AnyPointer;
  descriptorPool?: DescriptorPool;
  descriptorSetCount?: number;
  pSetLayouts?: AnyPointer;
}

export class DescriptorSetAllocateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorPool !== undefined) this.descriptorPool = data.descriptorPool;
      if (data.descriptorSetCount !== undefined) this.descriptorSetCount = data.descriptorSetCount;
      if (data.pSetLayouts !== undefined) this.pSetLayouts = data.pSetLayouts;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorPool() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorPool(value: DescriptorPool) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorSetCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorSetCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSetLayouts() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSetLayouts(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSpecializationMapEntry {
  constantID?: number;
  offset?: number;
  size?: Deno.PointerValue;
}

export class SpecializationMapEntry implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSpecializationMapEntry);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSpecializationMapEntry) {
    if (!data) {
      this.#data = new Uint8Array(SpecializationMapEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SpecializationMapEntry.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SpecializationMapEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.constantID !== undefined) this.constantID = data.constantID;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get constantID() {
    return this.#view.getUint32(0, LE);
  }
  
  set constantID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(4, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set size(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export interface InitSpecializationInfo {
  mapEntryCount?: number;
  pMapEntries?: AnyPointer;
  dataSize?: Deno.PointerValue;
  pData?: AnyPointer;
}

export class SpecializationInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSpecializationInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSpecializationInfo) {
    if (!data) {
      this.#data = new Uint8Array(SpecializationInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SpecializationInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SpecializationInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.mapEntryCount !== undefined) this.mapEntryCount = data.mapEntryCount;
      if (data.pMapEntries !== undefined) this.pMapEntries = data.pMapEntries;
      if (data.dataSize !== undefined) this.dataSize = data.dataSize;
      if (data.pData !== undefined) this.pData = data.pData;
    }
  }
  
  get mapEntryCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set mapEntryCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pMapEntries() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pMapEntries(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineShaderStageCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineShaderStageCreateFlags;
  stage?: ShaderStageFlagBits;
  module?: ShaderModule;
  pName?: AnyPointer;
  pSpecializationInfo?: AnyPointer;
}

export class PipelineShaderStageCreateInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineShaderStageCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineShaderStageCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineShaderStageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineShaderStageCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineShaderStageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.stage !== undefined) this.stage = data.stage;
      if (data.module !== undefined) this.module = data.module;
      if (data.pName !== undefined) this.pName = data.pName;
      if (data.pSpecializationInfo !== undefined) this.pSpecializationInfo = data.pSpecializationInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineShaderStageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stage() {
    return this.#view.getUint32(20, LE);
  }
  
  set stage(value: ShaderStageFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get module() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set module(value: ShaderModule) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pName(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pSpecializationInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSpecializationInfo(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitComputePipelineCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineCreateFlags;
  stage?: PipelineShaderStageCreateInfo;
  layout?: PipelineLayout;
  basePipelineHandle?: Pipeline;
  basePipelineIndex?: number;
}

export class ComputePipelineCreateInfo implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitComputePipelineCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitComputePipelineCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ComputePipelineCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ComputePipelineCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ComputePipelineCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.stage !== undefined) this.stage = data.stage;
      if (data.layout !== undefined) this.layout = data.layout;
      if (data.basePipelineHandle !== undefined) this.basePipelineHandle = data.basePipelineHandle;
      if (data.basePipelineIndex !== undefined) this.basePipelineIndex = data.basePipelineIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stage() {
    return new PipelineShaderStageCreateInfo(this.#data.subarray(20, 20 + PipelineShaderStageCreateInfo.size));
  }
  
  set stage(value: PipelineShaderStageCreateInfo) {
    if (value[BUFFER].byteLength < PipelineShaderStageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get layout() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set layout(value: PipelineLayout) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set basePipelineHandle(value: Pipeline) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(88, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(88, Number(value), LE);
  }
}

export interface InitVertexInputBindingDescription {
  binding?: number;
  stride?: number;
  inputRate?: VertexInputRate;
}

export class VertexInputBindingDescription implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVertexInputBindingDescription);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVertexInputBindingDescription) {
    if (!data) {
      this.#data = new Uint8Array(VertexInputBindingDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VertexInputBindingDescription.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VertexInputBindingDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.stride !== undefined) this.stride = data.stride;
      if (data.inputRate !== undefined) this.inputRate = data.inputRate;
    }
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(4, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get inputRate() {
    return this.#view.getUint32(8, LE);
  }
  
  set inputRate(value: VertexInputRate) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitVertexInputAttributeDescription {
  location?: number;
  binding?: number;
  format?: Format;
  offset?: number;
}

export class VertexInputAttributeDescription implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVertexInputAttributeDescription);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVertexInputAttributeDescription) {
    if (!data) {
      this.#data = new Uint8Array(VertexInputAttributeDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VertexInputAttributeDescription.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VertexInputAttributeDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.location !== undefined) this.location = data.location;
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.format !== undefined) this.format = data.format;
      if (data.offset !== undefined) this.offset = data.offset;
    }
  }
  
  get location() {
    return this.#view.getUint32(0, LE);
  }
  
  set location(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(4, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(8, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(12, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitPipelineVertexInputStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineVertexInputStateCreateFlags;
  vertexBindingDescriptionCount?: number;
  pVertexBindingDescriptions?: AnyPointer;
  vertexAttributeDescriptionCount?: number;
  pVertexAttributeDescriptions?: AnyPointer;
}

export class PipelineVertexInputStateCreateInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineVertexInputStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineVertexInputStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineVertexInputStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineVertexInputStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineVertexInputStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.vertexBindingDescriptionCount !== undefined) this.vertexBindingDescriptionCount = data.vertexBindingDescriptionCount;
      if (data.pVertexBindingDescriptions !== undefined) this.pVertexBindingDescriptions = data.pVertexBindingDescriptions;
      if (data.vertexAttributeDescriptionCount !== undefined) this.vertexAttributeDescriptionCount = data.vertexAttributeDescriptionCount;
      if (data.pVertexAttributeDescriptions !== undefined) this.pVertexAttributeDescriptions = data.pVertexAttributeDescriptions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineVertexInputStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexBindingDescriptionCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set vertexBindingDescriptionCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pVertexBindingDescriptions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVertexBindingDescriptions(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get vertexAttributeDescriptionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexAttributeDescriptionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pVertexAttributeDescriptions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pVertexAttributeDescriptions(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineInputAssemblyStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineInputAssemblyStateCreateFlags;
  topology?: PrimitiveTopology;
  primitiveRestartEnable?: Bool32;
}

export class PipelineInputAssemblyStateCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineInputAssemblyStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineInputAssemblyStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineInputAssemblyStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineInputAssemblyStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineInputAssemblyStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.topology !== undefined) this.topology = data.topology;
      if (data.primitiveRestartEnable !== undefined) this.primitiveRestartEnable = data.primitiveRestartEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineInputAssemblyStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get topology() {
    return this.#view.getUint32(20, LE);
  }
  
  set topology(value: PrimitiveTopology) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primitiveRestartEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set primitiveRestartEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPipelineTessellationStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineTessellationStateCreateFlags;
  patchControlPoints?: number;
}

export class PipelineTessellationStateCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineTessellationStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineTessellationStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineTessellationStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineTessellationStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineTessellationStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.patchControlPoints !== undefined) this.patchControlPoints = data.patchControlPoints;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineTessellationStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get patchControlPoints() {
    return this.#view.getUint32(20, LE);
  }
  
  set patchControlPoints(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPipelineViewportStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineViewportStateCreateFlags;
  viewportCount?: number;
  pViewports?: AnyPointer;
  scissorCount?: number;
  pScissors?: AnyPointer;
}

export class PipelineViewportStateCreateInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.viewportCount !== undefined) this.viewportCount = data.viewportCount;
      if (data.pViewports !== undefined) this.pViewports = data.pViewports;
      if (data.scissorCount !== undefined) this.scissorCount = data.scissorCount;
      if (data.pScissors !== undefined) this.pScissors = data.pScissors;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineViewportStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewports() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewports(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get scissorCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set scissorCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pScissors() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pScissors(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineRasterizationStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineRasterizationStateCreateFlags;
  depthClampEnable?: Bool32;
  rasterizerDiscardEnable?: Bool32;
  polygonMode?: PolygonMode;
  cullMode?: CullModeFlags;
  frontFace?: FrontFace;
  depthBiasEnable?: Bool32;
  depthBiasConstantFactor?: number;
  depthBiasClamp?: number;
  depthBiasSlopeFactor?: number;
  lineWidth?: number;
}

export class PipelineRasterizationStateCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.depthClampEnable !== undefined) this.depthClampEnable = data.depthClampEnable;
      if (data.rasterizerDiscardEnable !== undefined) this.rasterizerDiscardEnable = data.rasterizerDiscardEnable;
      if (data.polygonMode !== undefined) this.polygonMode = data.polygonMode;
      if (data.cullMode !== undefined) this.cullMode = data.cullMode;
      if (data.frontFace !== undefined) this.frontFace = data.frontFace;
      if (data.depthBiasEnable !== undefined) this.depthBiasEnable = data.depthBiasEnable;
      if (data.depthBiasConstantFactor !== undefined) this.depthBiasConstantFactor = data.depthBiasConstantFactor;
      if (data.depthBiasClamp !== undefined) this.depthBiasClamp = data.depthBiasClamp;
      if (data.depthBiasSlopeFactor !== undefined) this.depthBiasSlopeFactor = data.depthBiasSlopeFactor;
      if (data.lineWidth !== undefined) this.lineWidth = data.lineWidth;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineRasterizationStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthClampEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthClampEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rasterizerDiscardEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set rasterizerDiscardEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get polygonMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set polygonMode(value: PolygonMode) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get cullMode() {
    return this.#view.getUint32(32, LE);
  }
  
  set cullMode(value: CullModeFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get frontFace() {
    return this.#view.getUint32(36, LE);
  }
  
  set frontFace(value: FrontFace) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get depthBiasEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set depthBiasEnable(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get depthBiasConstantFactor() {
    return this.#view.getFloat32(44, LE);
  }
  
  set depthBiasConstantFactor(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get depthBiasClamp() {
    return this.#view.getFloat32(48, LE);
  }
  
  set depthBiasClamp(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get depthBiasSlopeFactor() {
    return this.#view.getFloat32(52, LE);
  }
  
  set depthBiasSlopeFactor(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get lineWidth() {
    return this.#view.getFloat32(56, LE);
  }
  
  set lineWidth(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
}

export interface InitPipelineMultisampleStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineMultisampleStateCreateFlags;
  rasterizationSamples?: SampleCountFlagBits;
  sampleShadingEnable?: Bool32;
  minSampleShading?: number;
  pSampleMask?: AnyPointer;
  alphaToCoverageEnable?: Bool32;
  alphaToOneEnable?: Bool32;
}

export class PipelineMultisampleStateCreateInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineMultisampleStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineMultisampleStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineMultisampleStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineMultisampleStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineMultisampleStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.rasterizationSamples !== undefined) this.rasterizationSamples = data.rasterizationSamples;
      if (data.sampleShadingEnable !== undefined) this.sampleShadingEnable = data.sampleShadingEnable;
      if (data.minSampleShading !== undefined) this.minSampleShading = data.minSampleShading;
      if (data.pSampleMask !== undefined) this.pSampleMask = data.pSampleMask;
      if (data.alphaToCoverageEnable !== undefined) this.alphaToCoverageEnable = data.alphaToCoverageEnable;
      if (data.alphaToOneEnable !== undefined) this.alphaToOneEnable = data.alphaToOneEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineMultisampleStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sampleShadingEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set sampleShadingEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get minSampleShading() {
    return this.#view.getFloat32(28, LE);
  }
  
  set minSampleShading(value: number) {
    this.#view.setFloat32(28, Number(value), LE);
  }
  
  get pSampleMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSampleMask(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get alphaToCoverageEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set alphaToCoverageEnable(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get alphaToOneEnable() {
    return this.#view.getUint32(44, LE);
  }
  
  set alphaToOneEnable(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitPipelineColorBlendAttachmentState {
  blendEnable?: Bool32;
  srcColorBlendFactor?: BlendFactor;
  dstColorBlendFactor?: BlendFactor;
  colorBlendOp?: BlendOp;
  srcAlphaBlendFactor?: BlendFactor;
  dstAlphaBlendFactor?: BlendFactor;
  alphaBlendOp?: BlendOp;
  colorWriteMask?: ColorComponentFlags;
}

export class PipelineColorBlendAttachmentState implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineColorBlendAttachmentState);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineColorBlendAttachmentState) {
    if (!data) {
      this.#data = new Uint8Array(PipelineColorBlendAttachmentState.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineColorBlendAttachmentState.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineColorBlendAttachmentState.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.blendEnable !== undefined) this.blendEnable = data.blendEnable;
      if (data.srcColorBlendFactor !== undefined) this.srcColorBlendFactor = data.srcColorBlendFactor;
      if (data.dstColorBlendFactor !== undefined) this.dstColorBlendFactor = data.dstColorBlendFactor;
      if (data.colorBlendOp !== undefined) this.colorBlendOp = data.colorBlendOp;
      if (data.srcAlphaBlendFactor !== undefined) this.srcAlphaBlendFactor = data.srcAlphaBlendFactor;
      if (data.dstAlphaBlendFactor !== undefined) this.dstAlphaBlendFactor = data.dstAlphaBlendFactor;
      if (data.alphaBlendOp !== undefined) this.alphaBlendOp = data.alphaBlendOp;
      if (data.colorWriteMask !== undefined) this.colorWriteMask = data.colorWriteMask;
    }
  }
  
  get blendEnable() {
    return this.#view.getUint32(0, LE);
  }
  
  set blendEnable(value: Bool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get srcColorBlendFactor() {
    return this.#view.getUint32(4, LE);
  }
  
  set srcColorBlendFactor(value: BlendFactor) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dstColorBlendFactor() {
    return this.#view.getUint32(8, LE);
  }
  
  set dstColorBlendFactor(value: BlendFactor) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get colorBlendOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set colorBlendOp(value: BlendOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get srcAlphaBlendFactor() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAlphaBlendFactor(value: BlendFactor) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAlphaBlendFactor() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAlphaBlendFactor(value: BlendFactor) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get alphaBlendOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set alphaBlendOp(value: BlendOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get colorWriteMask() {
    return this.#view.getUint32(28, LE);
  }
  
  set colorWriteMask(value: ColorComponentFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPipelineColorBlendStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineColorBlendStateCreateFlags;
  logicOpEnable?: Bool32;
  logicOp?: LogicOp;
  attachmentCount?: number;
  pAttachments?: AnyPointer;
  blendConstants?: number[];
}

export class PipelineColorBlendStateCreateInfo implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineColorBlendStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineColorBlendStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineColorBlendStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineColorBlendStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineColorBlendStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.logicOpEnable !== undefined) this.logicOpEnable = data.logicOpEnable;
      if (data.logicOp !== undefined) this.logicOp = data.logicOp;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pAttachments !== undefined) this.pAttachments = data.pAttachments;
      if (data.blendConstants !== undefined) this.blendConstants = data.blendConstants;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineColorBlendStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get logicOpEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set logicOpEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get logicOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set logicOp(value: LogicOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAttachments(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get blendConstants() {
    const result: number[] = [];
    for (let i = 0; i < 4; i++) {
      result.push((() => {
        return this.#view.getFloat32(40 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set blendConstants(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(40 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitPipelineDynamicStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineDynamicStateCreateFlags;
  dynamicStateCount?: number;
  pDynamicStates?: AnyPointer;
}

export class PipelineDynamicStateCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineDynamicStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineDynamicStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineDynamicStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineDynamicStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineDynamicStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.dynamicStateCount !== undefined) this.dynamicStateCount = data.dynamicStateCount;
      if (data.pDynamicStates !== undefined) this.pDynamicStates = data.pDynamicStates;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineDynamicStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dynamicStateCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set dynamicStateCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDynamicStates() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDynamicStates(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStencilOpState {
  failOp?: StencilOp;
  passOp?: StencilOp;
  depthFailOp?: StencilOp;
  compareOp?: CompareOp;
  compareMask?: number;
  writeMask?: number;
  reference?: number;
}

export class StencilOpState implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStencilOpState);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStencilOpState) {
    if (!data) {
      this.#data = new Uint8Array(StencilOpState.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StencilOpState.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StencilOpState.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.failOp !== undefined) this.failOp = data.failOp;
      if (data.passOp !== undefined) this.passOp = data.passOp;
      if (data.depthFailOp !== undefined) this.depthFailOp = data.depthFailOp;
      if (data.compareOp !== undefined) this.compareOp = data.compareOp;
      if (data.compareMask !== undefined) this.compareMask = data.compareMask;
      if (data.writeMask !== undefined) this.writeMask = data.writeMask;
      if (data.reference !== undefined) this.reference = data.reference;
    }
  }
  
  get failOp() {
    return this.#view.getUint32(0, LE);
  }
  
  set failOp(value: StencilOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get passOp() {
    return this.#view.getUint32(4, LE);
  }
  
  set passOp(value: StencilOp) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depthFailOp() {
    return this.#view.getUint32(8, LE);
  }
  
  set depthFailOp(value: StencilOp) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get compareOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set compareOp(value: CompareOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get compareMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set compareMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get writeMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set writeMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get reference() {
    return this.#view.getUint32(24, LE);
  }
  
  set reference(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPipelineDepthStencilStateCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineDepthStencilStateCreateFlags;
  depthTestEnable?: Bool32;
  depthWriteEnable?: Bool32;
  depthCompareOp?: CompareOp;
  depthBoundsTestEnable?: Bool32;
  stencilTestEnable?: Bool32;
  front?: StencilOpState;
  back?: StencilOpState;
  minDepthBounds?: number;
  maxDepthBounds?: number;
}

export class PipelineDepthStencilStateCreateInfo implements BaseStruct {
  static size = 104;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineDepthStencilStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineDepthStencilStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineDepthStencilStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineDepthStencilStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineDepthStencilStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.depthTestEnable !== undefined) this.depthTestEnable = data.depthTestEnable;
      if (data.depthWriteEnable !== undefined) this.depthWriteEnable = data.depthWriteEnable;
      if (data.depthCompareOp !== undefined) this.depthCompareOp = data.depthCompareOp;
      if (data.depthBoundsTestEnable !== undefined) this.depthBoundsTestEnable = data.depthBoundsTestEnable;
      if (data.stencilTestEnable !== undefined) this.stencilTestEnable = data.stencilTestEnable;
      if (data.front !== undefined) this.front = data.front;
      if (data.back !== undefined) this.back = data.back;
      if (data.minDepthBounds !== undefined) this.minDepthBounds = data.minDepthBounds;
      if (data.maxDepthBounds !== undefined) this.maxDepthBounds = data.maxDepthBounds;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineDepthStencilStateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthTestEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthTestEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get depthWriteEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set depthWriteEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get depthCompareOp() {
    return this.#view.getUint32(28, LE);
  }
  
  set depthCompareOp(value: CompareOp) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get depthBoundsTestEnable() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthBoundsTestEnable(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilTestEnable() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilTestEnable(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get front() {
    return new StencilOpState(this.#data.subarray(40, 40 + StencilOpState.size));
  }
  
  set front(value: StencilOpState) {
    if (value[BUFFER].byteLength < StencilOpState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get back() {
    return new StencilOpState(this.#data.subarray(68, 68 + StencilOpState.size));
  }
  
  set back(value: StencilOpState) {
    if (value[BUFFER].byteLength < StencilOpState.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 68);
  }
  
  get minDepthBounds() {
    return this.#view.getFloat32(96, LE);
  }
  
  set minDepthBounds(value: number) {
    this.#view.setFloat32(96, Number(value), LE);
  }
  
  get maxDepthBounds() {
    return this.#view.getFloat32(100, LE);
  }
  
  set maxDepthBounds(value: number) {
    this.#view.setFloat32(100, Number(value), LE);
  }
}

export interface InitGraphicsPipelineCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineCreateFlags;
  stageCount?: number;
  pStages?: AnyPointer;
  pVertexInputState?: AnyPointer;
  pInputAssemblyState?: AnyPointer;
  pTessellationState?: AnyPointer;
  pViewportState?: AnyPointer;
  pRasterizationState?: AnyPointer;
  pMultisampleState?: AnyPointer;
  pDepthStencilState?: AnyPointer;
  pColorBlendState?: AnyPointer;
  pDynamicState?: AnyPointer;
  layout?: PipelineLayout;
  renderPass?: RenderPass;
  subpass?: number;
  basePipelineHandle?: Pipeline;
  basePipelineIndex?: number;
}

export class GraphicsPipelineCreateInfo implements BaseStruct {
  static size = 144;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGraphicsPipelineCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGraphicsPipelineCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(GraphicsPipelineCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GraphicsPipelineCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GraphicsPipelineCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.stageCount !== undefined) this.stageCount = data.stageCount;
      if (data.pStages !== undefined) this.pStages = data.pStages;
      if (data.pVertexInputState !== undefined) this.pVertexInputState = data.pVertexInputState;
      if (data.pInputAssemblyState !== undefined) this.pInputAssemblyState = data.pInputAssemblyState;
      if (data.pTessellationState !== undefined) this.pTessellationState = data.pTessellationState;
      if (data.pViewportState !== undefined) this.pViewportState = data.pViewportState;
      if (data.pRasterizationState !== undefined) this.pRasterizationState = data.pRasterizationState;
      if (data.pMultisampleState !== undefined) this.pMultisampleState = data.pMultisampleState;
      if (data.pDepthStencilState !== undefined) this.pDepthStencilState = data.pDepthStencilState;
      if (data.pColorBlendState !== undefined) this.pColorBlendState = data.pColorBlendState;
      if (data.pDynamicState !== undefined) this.pDynamicState = data.pDynamicState;
      if (data.layout !== undefined) this.layout = data.layout;
      if (data.renderPass !== undefined) this.renderPass = data.renderPass;
      if (data.subpass !== undefined) this.subpass = data.subpass;
      if (data.basePipelineHandle !== undefined) this.basePipelineHandle = data.basePipelineHandle;
      if (data.basePipelineIndex !== undefined) this.basePipelineIndex = data.basePipelineIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pVertexInputState() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pVertexInputState(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pInputAssemblyState() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pInputAssemblyState(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pTessellationState() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTessellationState(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pViewportState() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pViewportState(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pRasterizationState() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pRasterizationState(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get pMultisampleState() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pMultisampleState(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get pDepthStencilState() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pDepthStencilState(value: AnyPointer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
  
  get pColorBlendState() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pColorBlendState(value: AnyPointer) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
  
  get pDynamicState() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pDynamicState(value: AnyPointer) {
    this.#view.setBigUint64(96, BigInt(anyPointer(value)), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set layout(value: PipelineLayout) {
    this.#view.setBigUint64(104, BigInt(anyPointer(value)), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set renderPass(value: RenderPass) {
    this.#view.setBigUint64(112, BigInt(anyPointer(value)), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(120, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set basePipelineHandle(value: Pipeline) {
    this.#view.setBigUint64(128, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(136, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(136, Number(value), LE);
  }
}

export interface InitPipelineCacheCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineCacheCreateFlags;
  initialDataSize?: Deno.PointerValue;
  pInitialData?: AnyPointer;
}

export class PipelineCacheCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCacheCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCacheCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCacheCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCacheCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCacheCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.initialDataSize !== undefined) this.initialDataSize = data.initialDataSize;
      if (data.pInitialData !== undefined) this.pInitialData = data.pInitialData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCacheCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialDataSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pInitialData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInitialData(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineCacheHeaderVersionOne {
  headerSize?: number;
  headerVersion?: PipelineCacheHeaderVersion;
  vendorID?: number;
  deviceID?: number;
  pipelineCacheUUID?: number[];
}

export class PipelineCacheHeaderVersionOne implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCacheHeaderVersionOne);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCacheHeaderVersionOne) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCacheHeaderVersionOne.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCacheHeaderVersionOne.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCacheHeaderVersionOne.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.headerSize !== undefined) this.headerSize = data.headerSize;
      if (data.headerVersion !== undefined) this.headerVersion = data.headerVersion;
      if (data.vendorID !== undefined) this.vendorID = data.vendorID;
      if (data.deviceID !== undefined) this.deviceID = data.deviceID;
      if (data.pipelineCacheUUID !== undefined) this.pipelineCacheUUID = data.pipelineCacheUUID;
    }
  }
  
  get headerSize() {
    return this.#view.getUint32(0, LE);
  }
  
  set headerSize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get headerVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set headerVersion(value: PipelineCacheHeaderVersion) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get pipelineCacheUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set pipelineCacheUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
}

export interface InitPushConstantRange {
  stageFlags?: ShaderStageFlags;
  offset?: number;
  size?: number;
}

export class PushConstantRange implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPushConstantRange);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPushConstantRange) {
    if (!data) {
      this.#data = new Uint8Array(PushConstantRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PushConstantRange.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PushConstantRange.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.stageFlags !== undefined) this.stageFlags = data.stageFlags;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get stageFlags() {
    return this.#view.getUint32(0, LE);
  }
  
  set stageFlags(value: ShaderStageFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(4, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitPipelineLayoutCreateInfo {
  pNext?: AnyPointer;
  flags?: PipelineLayoutCreateFlags;
  setLayoutCount?: number;
  pSetLayouts?: AnyPointer;
  pushConstantRangeCount?: number;
  pPushConstantRanges?: AnyPointer;
}

export class PipelineLayoutCreateInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineLayoutCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineLayoutCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineLayoutCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineLayoutCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineLayoutCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.setLayoutCount !== undefined) this.setLayoutCount = data.setLayoutCount;
      if (data.pSetLayouts !== undefined) this.pSetLayouts = data.pSetLayouts;
      if (data.pushConstantRangeCount !== undefined) this.pushConstantRangeCount = data.pushConstantRangeCount;
      if (data.pPushConstantRanges !== undefined) this.pPushConstantRanges = data.pPushConstantRanges;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineLayoutCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get setLayoutCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set setLayoutCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pSetLayouts() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pSetLayouts(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pushConstantRangeCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set pushConstantRangeCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPushConstantRanges() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPushConstantRanges(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSamplerCreateInfo {
  pNext?: AnyPointer;
  flags?: SamplerCreateFlags;
  magFilter?: Filter;
  minFilter?: Filter;
  mipmapMode?: SamplerMipmapMode;
  addressModeU?: SamplerAddressMode;
  addressModeV?: SamplerAddressMode;
  addressModeW?: SamplerAddressMode;
  mipLodBias?: number;
  anisotropyEnable?: Bool32;
  maxAnisotropy?: number;
  compareEnable?: Bool32;
  compareOp?: CompareOp;
  minLod?: number;
  maxLod?: number;
  borderColor?: BorderColor;
  unnormalizedCoordinates?: Bool32;
}

export class SamplerCreateInfo implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(SamplerCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.magFilter !== undefined) this.magFilter = data.magFilter;
      if (data.minFilter !== undefined) this.minFilter = data.minFilter;
      if (data.mipmapMode !== undefined) this.mipmapMode = data.mipmapMode;
      if (data.addressModeU !== undefined) this.addressModeU = data.addressModeU;
      if (data.addressModeV !== undefined) this.addressModeV = data.addressModeV;
      if (data.addressModeW !== undefined) this.addressModeW = data.addressModeW;
      if (data.mipLodBias !== undefined) this.mipLodBias = data.mipLodBias;
      if (data.anisotropyEnable !== undefined) this.anisotropyEnable = data.anisotropyEnable;
      if (data.maxAnisotropy !== undefined) this.maxAnisotropy = data.maxAnisotropy;
      if (data.compareEnable !== undefined) this.compareEnable = data.compareEnable;
      if (data.compareOp !== undefined) this.compareOp = data.compareOp;
      if (data.minLod !== undefined) this.minLod = data.minLod;
      if (data.maxLod !== undefined) this.maxLod = data.maxLod;
      if (data.borderColor !== undefined) this.borderColor = data.borderColor;
      if (data.unnormalizedCoordinates !== undefined) this.unnormalizedCoordinates = data.unnormalizedCoordinates;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SamplerCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get magFilter() {
    return this.#view.getUint32(20, LE);
  }
  
  set magFilter(value: Filter) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get minFilter() {
    return this.#view.getUint32(24, LE);
  }
  
  set minFilter(value: Filter) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get mipmapMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set mipmapMode(value: SamplerMipmapMode) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get addressModeU() {
    return this.#view.getUint32(32, LE);
  }
  
  set addressModeU(value: SamplerAddressMode) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get addressModeV() {
    return this.#view.getUint32(36, LE);
  }
  
  set addressModeV(value: SamplerAddressMode) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get addressModeW() {
    return this.#view.getUint32(40, LE);
  }
  
  set addressModeW(value: SamplerAddressMode) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get mipLodBias() {
    return this.#view.getFloat32(44, LE);
  }
  
  set mipLodBias(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get anisotropyEnable() {
    return this.#view.getUint32(48, LE);
  }
  
  set anisotropyEnable(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxAnisotropy() {
    return this.#view.getFloat32(52, LE);
  }
  
  set maxAnisotropy(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get compareEnable() {
    return this.#view.getUint32(56, LE);
  }
  
  set compareEnable(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get compareOp() {
    return this.#view.getUint32(60, LE);
  }
  
  set compareOp(value: CompareOp) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get minLod() {
    return this.#view.getFloat32(64, LE);
  }
  
  set minLod(value: number) {
    this.#view.setFloat32(64, Number(value), LE);
  }
  
  get maxLod() {
    return this.#view.getFloat32(68, LE);
  }
  
  set maxLod(value: number) {
    this.#view.setFloat32(68, Number(value), LE);
  }
  
  get borderColor() {
    return this.#view.getUint32(72, LE);
  }
  
  set borderColor(value: BorderColor) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get unnormalizedCoordinates() {
    return this.#view.getUint32(76, LE);
  }
  
  set unnormalizedCoordinates(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
}

export interface InitCommandPoolCreateInfo {
  pNext?: AnyPointer;
  flags?: CommandPoolCreateFlags;
  queueFamilyIndex?: number;
}

export class CommandPoolCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandPoolCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandPoolCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandPoolCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.queueFamilyIndex !== undefined) this.queueFamilyIndex = data.queueFamilyIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: CommandPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitCommandBufferAllocateInfo {
  pNext?: AnyPointer;
  commandPool?: CommandPool;
  level?: CommandBufferLevel;
  commandBufferCount?: number;
}

export class CommandBufferAllocateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.commandPool !== undefined) this.commandPool = data.commandPool;
      if (data.level !== undefined) this.level = data.level;
      if (data.commandBufferCount !== undefined) this.commandBufferCount = data.commandBufferCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get commandPool() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set commandPool(value: CommandPool) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get level() {
    return this.#view.getUint32(24, LE);
  }
  
  set level(value: CommandBufferLevel) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitCommandBufferInheritanceInfo {
  pNext?: AnyPointer;
  renderPass?: RenderPass;
  subpass?: number;
  framebuffer?: Framebuffer;
  occlusionQueryEnable?: Bool32;
  queryFlags?: QueryControlFlags;
  pipelineStatistics?: QueryPipelineStatisticFlags;
}

export class CommandBufferInheritanceInfo implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferInheritanceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferInheritanceInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferInheritanceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferInheritanceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferInheritanceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.renderPass !== undefined) this.renderPass = data.renderPass;
      if (data.subpass !== undefined) this.subpass = data.subpass;
      if (data.framebuffer !== undefined) this.framebuffer = data.framebuffer;
      if (data.occlusionQueryEnable !== undefined) this.occlusionQueryEnable = data.occlusionQueryEnable;
      if (data.queryFlags !== undefined) this.queryFlags = data.queryFlags;
      if (data.pipelineStatistics !== undefined) this.pipelineStatistics = data.pipelineStatistics;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: RenderPass) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(24, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get framebuffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set framebuffer(value: Framebuffer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get occlusionQueryEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set occlusionQueryEnable(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get queryFlags() {
    return this.#view.getUint32(44, LE);
  }
  
  set queryFlags(value: QueryControlFlags) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pipelineStatistics() {
    return this.#view.getUint32(48, LE);
  }
  
  set pipelineStatistics(value: QueryPipelineStatisticFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitCommandBufferBeginInfo {
  pNext?: AnyPointer;
  flags?: CommandBufferUsageFlags;
  pInheritanceInfo?: AnyPointer;
}

export class CommandBufferBeginInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pInheritanceInfo !== undefined) this.pInheritanceInfo = data.pInheritanceInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: CommandBufferUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pInheritanceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pInheritanceInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRenderPassBeginInfo {
  pNext?: AnyPointer;
  renderPass?: RenderPass;
  framebuffer?: Framebuffer;
  renderArea?: Rect2D;
  clearValueCount?: number;
  pClearValues?: AnyPointer;
}

export class RenderPassBeginInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.renderPass !== undefined) this.renderPass = data.renderPass;
      if (data.framebuffer !== undefined) this.framebuffer = data.framebuffer;
      if (data.renderArea !== undefined) this.renderArea = data.renderArea;
      if (data.clearValueCount !== undefined) this.clearValueCount = data.clearValueCount;
      if (data.pClearValues !== undefined) this.pClearValues = data.pClearValues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: RenderPass) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get framebuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set framebuffer(value: Framebuffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get renderArea() {
    return new Rect2D(this.#data.subarray(32, 32 + Rect2D.size));
  }
  
  set renderArea(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get clearValueCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set clearValueCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pClearValues() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pClearValues(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitClearDepthStencilValue {
  depth?: number;
  stencil?: number;
}

export class ClearDepthStencilValue implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitClearDepthStencilValue);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitClearDepthStencilValue) {
    if (!data) {
      this.#data = new Uint8Array(ClearDepthStencilValue.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ClearDepthStencilValue.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ClearDepthStencilValue.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.depth !== undefined) this.depth = data.depth;
      if (data.stencil !== undefined) this.stencil = data.stencil;
    }
  }
  
  get depth() {
    return this.#view.getFloat32(0, LE);
  }
  
  set depth(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get stencil() {
    return this.#view.getUint32(4, LE);
  }
  
  set stencil(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitClearAttachment {
  aspectMask?: ImageAspectFlags;
  colorAttachment?: number;
  clearValue?: ClearValue;
}

export class ClearAttachment implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitClearAttachment);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitClearAttachment) {
    if (!data) {
      this.#data = new Uint8Array(ClearAttachment.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ClearAttachment.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ClearAttachment.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
      if (data.colorAttachment !== undefined) this.colorAttachment = data.colorAttachment;
      if (data.clearValue !== undefined) this.clearValue = data.clearValue;
    }
  }
  
  get aspectMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get colorAttachment() {
    return this.#view.getUint32(4, LE);
  }
  
  set colorAttachment(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get clearValue() {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
  
  set clearValue(value: ClearValue) {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
}

export interface InitAttachmentDescription {
  flags?: AttachmentDescriptionFlags;
  format?: Format;
  samples?: SampleCountFlagBits;
  loadOp?: AttachmentLoadOp;
  storeOp?: AttachmentStoreOp;
  stencilLoadOp?: AttachmentLoadOp;
  stencilStoreOp?: AttachmentStoreOp;
  initialLayout?: ImageLayout;
  finalLayout?: ImageLayout;
}

export class AttachmentDescription implements BaseStruct {
  static size = 36;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentDescription);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentDescription) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentDescription.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.format !== undefined) this.format = data.format;
      if (data.samples !== undefined) this.samples = data.samples;
      if (data.loadOp !== undefined) this.loadOp = data.loadOp;
      if (data.storeOp !== undefined) this.storeOp = data.storeOp;
      if (data.stencilLoadOp !== undefined) this.stencilLoadOp = data.stencilLoadOp;
      if (data.stencilStoreOp !== undefined) this.stencilStoreOp = data.stencilStoreOp;
      if (data.initialLayout !== undefined) this.initialLayout = data.initialLayout;
      if (data.finalLayout !== undefined) this.finalLayout = data.finalLayout;
    }
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: AttachmentDescriptionFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(4, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(8, LE);
  }
  
  set samples(value: SampleCountFlagBits) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(12, LE);
  }
  
  set loadOp(value: AttachmentLoadOp) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(16, LE);
  }
  
  set storeOp(value: AttachmentStoreOp) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilLoadOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilLoadOp(value: AttachmentLoadOp) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get stencilStoreOp() {
    return this.#view.getUint32(24, LE);
  }
  
  set stencilStoreOp(value: AttachmentStoreOp) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(28, LE);
  }
  
  set initialLayout(value: ImageLayout) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get finalLayout() {
    return this.#view.getUint32(32, LE);
  }
  
  set finalLayout(value: ImageLayout) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitAttachmentReference {
  attachment?: number;
  layout?: ImageLayout;
}

export class AttachmentReference implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentReference);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentReference) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentReference.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentReference.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentReference.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.attachment !== undefined) this.attachment = data.attachment;
      if (data.layout !== undefined) this.layout = data.layout;
    }
  }
  
  get attachment() {
    return this.#view.getUint32(0, LE);
  }
  
  set attachment(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getUint32(4, LE);
  }
  
  set layout(value: ImageLayout) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitSubpassDescription {
  flags?: SubpassDescriptionFlags;
  pipelineBindPoint?: PipelineBindPoint;
  inputAttachmentCount?: number;
  pInputAttachments?: AnyPointer;
  colorAttachmentCount?: number;
  pColorAttachments?: AnyPointer;
  pResolveAttachments?: AnyPointer;
  pDepthStencilAttachment?: AnyPointer;
  preserveAttachmentCount?: number;
  pPreserveAttachments?: AnyPointer;
}

export class SubpassDescription implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassDescription);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassDescription) {
    if (!data) {
      this.#data = new Uint8Array(SubpassDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassDescription.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassDescription.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.inputAttachmentCount !== undefined) this.inputAttachmentCount = data.inputAttachmentCount;
      if (data.pInputAttachments !== undefined) this.pInputAttachments = data.pInputAttachments;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachments !== undefined) this.pColorAttachments = data.pColorAttachments;
      if (data.pResolveAttachments !== undefined) this.pResolveAttachments = data.pResolveAttachments;
      if (data.pDepthStencilAttachment !== undefined) this.pDepthStencilAttachment = data.pDepthStencilAttachment;
      if (data.preserveAttachmentCount !== undefined) this.preserveAttachmentCount = data.preserveAttachmentCount;
      if (data.pPreserveAttachments !== undefined) this.pPreserveAttachments = data.pPreserveAttachments;
    }
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: SubpassDescriptionFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(4, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get inputAttachmentCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set inputAttachmentCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pInputAttachments() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pInputAttachments(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pColorAttachments(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pResolveAttachments() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pResolveAttachments(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pDepthStencilAttachment() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pDepthStencilAttachment(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get preserveAttachmentCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set preserveAttachmentCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pPreserveAttachments() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pPreserveAttachments(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSubpassDependency {
  srcSubpass?: number;
  dstSubpass?: number;
  srcStageMask?: PipelineStageFlags;
  dstStageMask?: PipelineStageFlags;
  srcAccessMask?: AccessFlags;
  dstAccessMask?: AccessFlags;
  dependencyFlags?: DependencyFlags;
}

export class SubpassDependency implements BaseStruct {
  static size = 28;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassDependency);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassDependency) {
    if (!data) {
      this.#data = new Uint8Array(SubpassDependency.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassDependency.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassDependency.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcSubpass !== undefined) this.srcSubpass = data.srcSubpass;
      if (data.dstSubpass !== undefined) this.dstSubpass = data.dstSubpass;
      if (data.srcStageMask !== undefined) this.srcStageMask = data.srcStageMask;
      if (data.dstStageMask !== undefined) this.dstStageMask = data.dstStageMask;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.dependencyFlags !== undefined) this.dependencyFlags = data.dependencyFlags;
    }
  }
  
  get srcSubpass() {
    return this.#view.getUint32(0, LE);
  }
  
  set srcSubpass(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstSubpass() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstSubpass(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getUint32(8, LE);
  }
  
  set srcStageMask(value: PipelineStageFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getUint32(12, LE);
  }
  
  set dstStageMask(value: PipelineStageFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcAccessMask(value: AccessFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstAccessMask(value: AccessFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set dependencyFlags(value: DependencyFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitRenderPassCreateInfo {
  pNext?: AnyPointer;
  flags?: RenderPassCreateFlags;
  attachmentCount?: number;
  pAttachments?: AnyPointer;
  subpassCount?: number;
  pSubpasses?: AnyPointer;
  dependencyCount?: number;
  pDependencies?: AnyPointer;
}

export class RenderPassCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pAttachments !== undefined) this.pAttachments = data.pAttachments;
      if (data.subpassCount !== undefined) this.subpassCount = data.subpassCount;
      if (data.pSubpasses !== undefined) this.pSubpasses = data.pSubpasses;
      if (data.dependencyCount !== undefined) this.dependencyCount = data.dependencyCount;
      if (data.pDependencies !== undefined) this.pDependencies = data.pDependencies;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: RenderPassCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSubpasses() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSubpasses(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pDependencies() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pDependencies(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitEventCreateInfo {
  pNext?: AnyPointer;
  flags?: EventCreateFlags;
}

export class EventCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitEventCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitEventCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(EventCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < EventCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(EventCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EVENT_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: EventCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitFenceCreateInfo {
  pNext?: AnyPointer;
  flags?: FenceCreateFlags;
}

export class FenceCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFenceCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFenceCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(FenceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FenceCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FenceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FENCE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: FenceCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFeatures {
  robustBufferAccess?: Bool32;
  fullDrawIndexUint32?: Bool32;
  imageCubeArray?: Bool32;
  independentBlend?: Bool32;
  geometryShader?: Bool32;
  tessellationShader?: Bool32;
  sampleRateShading?: Bool32;
  dualSrcBlend?: Bool32;
  logicOp?: Bool32;
  multiDrawIndirect?: Bool32;
  drawIndirectFirstInstance?: Bool32;
  depthClamp?: Bool32;
  depthBiasClamp?: Bool32;
  fillModeNonSolid?: Bool32;
  depthBounds?: Bool32;
  wideLines?: Bool32;
  largePoints?: Bool32;
  alphaToOne?: Bool32;
  multiViewport?: Bool32;
  samplerAnisotropy?: Bool32;
  textureCompressionETC2?: Bool32;
  textureCompressionASTC_LDR?: Bool32;
  textureCompressionBC?: Bool32;
  occlusionQueryPrecise?: Bool32;
  pipelineStatisticsQuery?: Bool32;
  vertexPipelineStoresAndAtomics?: Bool32;
  fragmentStoresAndAtomics?: Bool32;
  shaderTessellationAndGeometryPointSize?: Bool32;
  shaderImageGatherExtended?: Bool32;
  shaderStorageImageExtendedFormats?: Bool32;
  shaderStorageImageMultisample?: Bool32;
  shaderStorageImageReadWithoutFormat?: Bool32;
  shaderStorageImageWriteWithoutFormat?: Bool32;
  shaderUniformBufferArrayDynamicIndexing?: Bool32;
  shaderSampledImageArrayDynamicIndexing?: Bool32;
  shaderStorageBufferArrayDynamicIndexing?: Bool32;
  shaderStorageImageArrayDynamicIndexing?: Bool32;
  shaderClipDistance?: Bool32;
  shaderCullDistance?: Bool32;
  shaderFloat64?: Bool32;
  shaderInt64?: Bool32;
  shaderInt16?: Bool32;
  shaderResourceResidency?: Bool32;
  shaderResourceMinLod?: Bool32;
  sparseBinding?: Bool32;
  sparseResidencyBuffer?: Bool32;
  sparseResidencyImage2D?: Bool32;
  sparseResidencyImage3D?: Bool32;
  sparseResidency2Samples?: Bool32;
  sparseResidency4Samples?: Bool32;
  sparseResidency8Samples?: Bool32;
  sparseResidency16Samples?: Bool32;
  sparseResidencyAliased?: Bool32;
  variableMultisampleRate?: Bool32;
  inheritedQueries?: Bool32;
}

export class PhysicalDeviceFeatures implements BaseStruct {
  static size = 220;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.robustBufferAccess !== undefined) this.robustBufferAccess = data.robustBufferAccess;
      if (data.fullDrawIndexUint32 !== undefined) this.fullDrawIndexUint32 = data.fullDrawIndexUint32;
      if (data.imageCubeArray !== undefined) this.imageCubeArray = data.imageCubeArray;
      if (data.independentBlend !== undefined) this.independentBlend = data.independentBlend;
      if (data.geometryShader !== undefined) this.geometryShader = data.geometryShader;
      if (data.tessellationShader !== undefined) this.tessellationShader = data.tessellationShader;
      if (data.sampleRateShading !== undefined) this.sampleRateShading = data.sampleRateShading;
      if (data.dualSrcBlend !== undefined) this.dualSrcBlend = data.dualSrcBlend;
      if (data.logicOp !== undefined) this.logicOp = data.logicOp;
      if (data.multiDrawIndirect !== undefined) this.multiDrawIndirect = data.multiDrawIndirect;
      if (data.drawIndirectFirstInstance !== undefined) this.drawIndirectFirstInstance = data.drawIndirectFirstInstance;
      if (data.depthClamp !== undefined) this.depthClamp = data.depthClamp;
      if (data.depthBiasClamp !== undefined) this.depthBiasClamp = data.depthBiasClamp;
      if (data.fillModeNonSolid !== undefined) this.fillModeNonSolid = data.fillModeNonSolid;
      if (data.depthBounds !== undefined) this.depthBounds = data.depthBounds;
      if (data.wideLines !== undefined) this.wideLines = data.wideLines;
      if (data.largePoints !== undefined) this.largePoints = data.largePoints;
      if (data.alphaToOne !== undefined) this.alphaToOne = data.alphaToOne;
      if (data.multiViewport !== undefined) this.multiViewport = data.multiViewport;
      if (data.samplerAnisotropy !== undefined) this.samplerAnisotropy = data.samplerAnisotropy;
      if (data.textureCompressionETC2 !== undefined) this.textureCompressionETC2 = data.textureCompressionETC2;
      if (data.textureCompressionASTC_LDR !== undefined) this.textureCompressionASTC_LDR = data.textureCompressionASTC_LDR;
      if (data.textureCompressionBC !== undefined) this.textureCompressionBC = data.textureCompressionBC;
      if (data.occlusionQueryPrecise !== undefined) this.occlusionQueryPrecise = data.occlusionQueryPrecise;
      if (data.pipelineStatisticsQuery !== undefined) this.pipelineStatisticsQuery = data.pipelineStatisticsQuery;
      if (data.vertexPipelineStoresAndAtomics !== undefined) this.vertexPipelineStoresAndAtomics = data.vertexPipelineStoresAndAtomics;
      if (data.fragmentStoresAndAtomics !== undefined) this.fragmentStoresAndAtomics = data.fragmentStoresAndAtomics;
      if (data.shaderTessellationAndGeometryPointSize !== undefined) this.shaderTessellationAndGeometryPointSize = data.shaderTessellationAndGeometryPointSize;
      if (data.shaderImageGatherExtended !== undefined) this.shaderImageGatherExtended = data.shaderImageGatherExtended;
      if (data.shaderStorageImageExtendedFormats !== undefined) this.shaderStorageImageExtendedFormats = data.shaderStorageImageExtendedFormats;
      if (data.shaderStorageImageMultisample !== undefined) this.shaderStorageImageMultisample = data.shaderStorageImageMultisample;
      if (data.shaderStorageImageReadWithoutFormat !== undefined) this.shaderStorageImageReadWithoutFormat = data.shaderStorageImageReadWithoutFormat;
      if (data.shaderStorageImageWriteWithoutFormat !== undefined) this.shaderStorageImageWriteWithoutFormat = data.shaderStorageImageWriteWithoutFormat;
      if (data.shaderUniformBufferArrayDynamicIndexing !== undefined) this.shaderUniformBufferArrayDynamicIndexing = data.shaderUniformBufferArrayDynamicIndexing;
      if (data.shaderSampledImageArrayDynamicIndexing !== undefined) this.shaderSampledImageArrayDynamicIndexing = data.shaderSampledImageArrayDynamicIndexing;
      if (data.shaderStorageBufferArrayDynamicIndexing !== undefined) this.shaderStorageBufferArrayDynamicIndexing = data.shaderStorageBufferArrayDynamicIndexing;
      if (data.shaderStorageImageArrayDynamicIndexing !== undefined) this.shaderStorageImageArrayDynamicIndexing = data.shaderStorageImageArrayDynamicIndexing;
      if (data.shaderClipDistance !== undefined) this.shaderClipDistance = data.shaderClipDistance;
      if (data.shaderCullDistance !== undefined) this.shaderCullDistance = data.shaderCullDistance;
      if (data.shaderFloat64 !== undefined) this.shaderFloat64 = data.shaderFloat64;
      if (data.shaderInt64 !== undefined) this.shaderInt64 = data.shaderInt64;
      if (data.shaderInt16 !== undefined) this.shaderInt16 = data.shaderInt16;
      if (data.shaderResourceResidency !== undefined) this.shaderResourceResidency = data.shaderResourceResidency;
      if (data.shaderResourceMinLod !== undefined) this.shaderResourceMinLod = data.shaderResourceMinLod;
      if (data.sparseBinding !== undefined) this.sparseBinding = data.sparseBinding;
      if (data.sparseResidencyBuffer !== undefined) this.sparseResidencyBuffer = data.sparseResidencyBuffer;
      if (data.sparseResidencyImage2D !== undefined) this.sparseResidencyImage2D = data.sparseResidencyImage2D;
      if (data.sparseResidencyImage3D !== undefined) this.sparseResidencyImage3D = data.sparseResidencyImage3D;
      if (data.sparseResidency2Samples !== undefined) this.sparseResidency2Samples = data.sparseResidency2Samples;
      if (data.sparseResidency4Samples !== undefined) this.sparseResidency4Samples = data.sparseResidency4Samples;
      if (data.sparseResidency8Samples !== undefined) this.sparseResidency8Samples = data.sparseResidency8Samples;
      if (data.sparseResidency16Samples !== undefined) this.sparseResidency16Samples = data.sparseResidency16Samples;
      if (data.sparseResidencyAliased !== undefined) this.sparseResidencyAliased = data.sparseResidencyAliased;
      if (data.variableMultisampleRate !== undefined) this.variableMultisampleRate = data.variableMultisampleRate;
      if (data.inheritedQueries !== undefined) this.inheritedQueries = data.inheritedQueries;
    }
  }
  
  get robustBufferAccess() {
    return this.#view.getUint32(0, LE);
  }
  
  set robustBufferAccess(value: Bool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get fullDrawIndexUint32() {
    return this.#view.getUint32(4, LE);
  }
  
  set fullDrawIndexUint32(value: Bool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get imageCubeArray() {
    return this.#view.getUint32(8, LE);
  }
  
  set imageCubeArray(value: Bool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get independentBlend() {
    return this.#view.getUint32(12, LE);
  }
  
  set independentBlend(value: Bool32) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get geometryShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryShader(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get tessellationShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set tessellationShader(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get sampleRateShading() {
    return this.#view.getUint32(24, LE);
  }
  
  set sampleRateShading(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dualSrcBlend() {
    return this.#view.getUint32(28, LE);
  }
  
  set dualSrcBlend(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get logicOp() {
    return this.#view.getUint32(32, LE);
  }
  
  set logicOp(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multiDrawIndirect() {
    return this.#view.getUint32(36, LE);
  }
  
  set multiDrawIndirect(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get drawIndirectFirstInstance() {
    return this.#view.getUint32(40, LE);
  }
  
  set drawIndirectFirstInstance(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get depthClamp() {
    return this.#view.getUint32(44, LE);
  }
  
  set depthClamp(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get depthBiasClamp() {
    return this.#view.getUint32(48, LE);
  }
  
  set depthBiasClamp(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get fillModeNonSolid() {
    return this.#view.getUint32(52, LE);
  }
  
  set fillModeNonSolid(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get depthBounds() {
    return this.#view.getUint32(56, LE);
  }
  
  set depthBounds(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get wideLines() {
    return this.#view.getUint32(60, LE);
  }
  
  set wideLines(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get largePoints() {
    return this.#view.getUint32(64, LE);
  }
  
  set largePoints(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get alphaToOne() {
    return this.#view.getUint32(68, LE);
  }
  
  set alphaToOne(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get multiViewport() {
    return this.#view.getUint32(72, LE);
  }
  
  set multiViewport(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get samplerAnisotropy() {
    return this.#view.getUint32(76, LE);
  }
  
  set samplerAnisotropy(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get textureCompressionETC2() {
    return this.#view.getUint32(80, LE);
  }
  
  set textureCompressionETC2(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get textureCompressionASTC_LDR() {
    return this.#view.getUint32(84, LE);
  }
  
  set textureCompressionASTC_LDR(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get textureCompressionBC() {
    return this.#view.getUint32(88, LE);
  }
  
  set textureCompressionBC(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get occlusionQueryPrecise() {
    return this.#view.getUint32(92, LE);
  }
  
  set occlusionQueryPrecise(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get pipelineStatisticsQuery() {
    return this.#view.getUint32(96, LE);
  }
  
  set pipelineStatisticsQuery(value: Bool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get vertexPipelineStoresAndAtomics() {
    return this.#view.getUint32(100, LE);
  }
  
  set vertexPipelineStoresAndAtomics(value: Bool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get fragmentStoresAndAtomics() {
    return this.#view.getUint32(104, LE);
  }
  
  set fragmentStoresAndAtomics(value: Bool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get shaderTessellationAndGeometryPointSize() {
    return this.#view.getUint32(108, LE);
  }
  
  set shaderTessellationAndGeometryPointSize(value: Bool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get shaderImageGatherExtended() {
    return this.#view.getUint32(112, LE);
  }
  
  set shaderImageGatherExtended(value: Bool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get shaderStorageImageExtendedFormats() {
    return this.#view.getUint32(116, LE);
  }
  
  set shaderStorageImageExtendedFormats(value: Bool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get shaderStorageImageMultisample() {
    return this.#view.getUint32(120, LE);
  }
  
  set shaderStorageImageMultisample(value: Bool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get shaderStorageImageReadWithoutFormat() {
    return this.#view.getUint32(124, LE);
  }
  
  set shaderStorageImageReadWithoutFormat(value: Bool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get shaderStorageImageWriteWithoutFormat() {
    return this.#view.getUint32(128, LE);
  }
  
  set shaderStorageImageWriteWithoutFormat(value: Bool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get shaderUniformBufferArrayDynamicIndexing() {
    return this.#view.getUint32(132, LE);
  }
  
  set shaderUniformBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get shaderSampledImageArrayDynamicIndexing() {
    return this.#view.getUint32(136, LE);
  }
  
  set shaderSampledImageArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get shaderStorageBufferArrayDynamicIndexing() {
    return this.#view.getUint32(140, LE);
  }
  
  set shaderStorageBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get shaderStorageImageArrayDynamicIndexing() {
    return this.#view.getUint32(144, LE);
  }
  
  set shaderStorageImageArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get shaderClipDistance() {
    return this.#view.getUint32(148, LE);
  }
  
  set shaderClipDistance(value: Bool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get shaderCullDistance() {
    return this.#view.getUint32(152, LE);
  }
  
  set shaderCullDistance(value: Bool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get shaderFloat64() {
    return this.#view.getUint32(156, LE);
  }
  
  set shaderFloat64(value: Bool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get shaderInt64() {
    return this.#view.getUint32(160, LE);
  }
  
  set shaderInt64(value: Bool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get shaderInt16() {
    return this.#view.getUint32(164, LE);
  }
  
  set shaderInt16(value: Bool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get shaderResourceResidency() {
    return this.#view.getUint32(168, LE);
  }
  
  set shaderResourceResidency(value: Bool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get shaderResourceMinLod() {
    return this.#view.getUint32(172, LE);
  }
  
  set shaderResourceMinLod(value: Bool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get sparseBinding() {
    return this.#view.getUint32(176, LE);
  }
  
  set sparseBinding(value: Bool32) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get sparseResidencyBuffer() {
    return this.#view.getUint32(180, LE);
  }
  
  set sparseResidencyBuffer(value: Bool32) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get sparseResidencyImage2D() {
    return this.#view.getUint32(184, LE);
  }
  
  set sparseResidencyImage2D(value: Bool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get sparseResidencyImage3D() {
    return this.#view.getUint32(188, LE);
  }
  
  set sparseResidencyImage3D(value: Bool32) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get sparseResidency2Samples() {
    return this.#view.getUint32(192, LE);
  }
  
  set sparseResidency2Samples(value: Bool32) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get sparseResidency4Samples() {
    return this.#view.getUint32(196, LE);
  }
  
  set sparseResidency4Samples(value: Bool32) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get sparseResidency8Samples() {
    return this.#view.getUint32(200, LE);
  }
  
  set sparseResidency8Samples(value: Bool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get sparseResidency16Samples() {
    return this.#view.getUint32(204, LE);
  }
  
  set sparseResidency16Samples(value: Bool32) {
    this.#view.setUint32(204, Number(value), LE);
  }
  
  get sparseResidencyAliased() {
    return this.#view.getUint32(208, LE);
  }
  
  set sparseResidencyAliased(value: Bool32) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get variableMultisampleRate() {
    return this.#view.getUint32(212, LE);
  }
  
  set variableMultisampleRate(value: Bool32) {
    this.#view.setUint32(212, Number(value), LE);
  }
  
  get inheritedQueries() {
    return this.#view.getUint32(216, LE);
  }
  
  set inheritedQueries(value: Bool32) {
    this.#view.setUint32(216, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSparseProperties {
  residencyStandard2DBlockShape?: Bool32;
  residencyStandard2DMultisampleBlockShape?: Bool32;
  residencyStandard3DBlockShape?: Bool32;
  residencyAlignedMipSize?: Bool32;
  residencyNonResidentStrict?: Bool32;
}

export class PhysicalDeviceSparseProperties implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSparseProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSparseProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSparseProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSparseProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSparseProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.residencyStandard2DBlockShape !== undefined) this.residencyStandard2DBlockShape = data.residencyStandard2DBlockShape;
      if (data.residencyStandard2DMultisampleBlockShape !== undefined) this.residencyStandard2DMultisampleBlockShape = data.residencyStandard2DMultisampleBlockShape;
      if (data.residencyStandard3DBlockShape !== undefined) this.residencyStandard3DBlockShape = data.residencyStandard3DBlockShape;
      if (data.residencyAlignedMipSize !== undefined) this.residencyAlignedMipSize = data.residencyAlignedMipSize;
      if (data.residencyNonResidentStrict !== undefined) this.residencyNonResidentStrict = data.residencyNonResidentStrict;
    }
  }
  
  get residencyStandard2DBlockShape() {
    return this.#view.getUint32(0, LE);
  }
  
  set residencyStandard2DBlockShape(value: Bool32) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get residencyStandard2DMultisampleBlockShape() {
    return this.#view.getUint32(4, LE);
  }
  
  set residencyStandard2DMultisampleBlockShape(value: Bool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get residencyStandard3DBlockShape() {
    return this.#view.getUint32(8, LE);
  }
  
  set residencyStandard3DBlockShape(value: Bool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get residencyAlignedMipSize() {
    return this.#view.getUint32(12, LE);
  }
  
  set residencyAlignedMipSize(value: Bool32) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get residencyNonResidentStrict() {
    return this.#view.getUint32(16, LE);
  }
  
  set residencyNonResidentStrict(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceLimits {
  maxImageDimension1D?: number;
  maxImageDimension2D?: number;
  maxImageDimension3D?: number;
  maxImageDimensionCube?: number;
  maxImageArrayLayers?: number;
  maxTexelBufferElements?: number;
  maxUniformBufferRange?: number;
  maxStorageBufferRange?: number;
  maxPushConstantsSize?: number;
  maxMemoryAllocationCount?: number;
  maxSamplerAllocationCount?: number;
  bufferImageGranularity?: DeviceSize;
  sparseAddressSpaceSize?: DeviceSize;
  maxBoundDescriptorSets?: number;
  maxPerStageDescriptorSamplers?: number;
  maxPerStageDescriptorUniformBuffers?: number;
  maxPerStageDescriptorStorageBuffers?: number;
  maxPerStageDescriptorSampledImages?: number;
  maxPerStageDescriptorStorageImages?: number;
  maxPerStageDescriptorInputAttachments?: number;
  maxPerStageResources?: number;
  maxDescriptorSetSamplers?: number;
  maxDescriptorSetUniformBuffers?: number;
  maxDescriptorSetUniformBuffersDynamic?: number;
  maxDescriptorSetStorageBuffers?: number;
  maxDescriptorSetStorageBuffersDynamic?: number;
  maxDescriptorSetSampledImages?: number;
  maxDescriptorSetStorageImages?: number;
  maxDescriptorSetInputAttachments?: number;
  maxVertexInputAttributes?: number;
  maxVertexInputBindings?: number;
  maxVertexInputAttributeOffset?: number;
  maxVertexInputBindingStride?: number;
  maxVertexOutputComponents?: number;
  maxTessellationGenerationLevel?: number;
  maxTessellationPatchSize?: number;
  maxTessellationControlPerVertexInputComponents?: number;
  maxTessellationControlPerVertexOutputComponents?: number;
  maxTessellationControlPerPatchOutputComponents?: number;
  maxTessellationControlTotalOutputComponents?: number;
  maxTessellationEvaluationInputComponents?: number;
  maxTessellationEvaluationOutputComponents?: number;
  maxGeometryShaderInvocations?: number;
  maxGeometryInputComponents?: number;
  maxGeometryOutputComponents?: number;
  maxGeometryOutputVertices?: number;
  maxGeometryTotalOutputComponents?: number;
  maxFragmentInputComponents?: number;
  maxFragmentOutputAttachments?: number;
  maxFragmentDualSrcAttachments?: number;
  maxFragmentCombinedOutputResources?: number;
  maxComputeSharedMemorySize?: number;
  maxComputeWorkGroupCount?: number[];
  maxComputeWorkGroupInvocations?: number;
  maxComputeWorkGroupSize?: number[];
  subPixelPrecisionBits?: number;
  subTexelPrecisionBits?: number;
  mipmapPrecisionBits?: number;
  maxDrawIndexedIndexValue?: number;
  maxDrawIndirectCount?: number;
  maxSamplerLodBias?: number;
  maxSamplerAnisotropy?: number;
  maxViewports?: number;
  maxViewportDimensions?: number[];
  viewportBoundsRange?: number[];
  viewportSubPixelBits?: number;
  minMemoryMapAlignment?: Deno.PointerValue;
  minTexelBufferOffsetAlignment?: DeviceSize;
  minUniformBufferOffsetAlignment?: DeviceSize;
  minStorageBufferOffsetAlignment?: DeviceSize;
  minTexelOffset?: number;
  maxTexelOffset?: number;
  minTexelGatherOffset?: number;
  maxTexelGatherOffset?: number;
  minInterpolationOffset?: number;
  maxInterpolationOffset?: number;
  subPixelInterpolationOffsetBits?: number;
  maxFramebufferWidth?: number;
  maxFramebufferHeight?: number;
  maxFramebufferLayers?: number;
  framebufferColorSampleCounts?: SampleCountFlags;
  framebufferDepthSampleCounts?: SampleCountFlags;
  framebufferStencilSampleCounts?: SampleCountFlags;
  framebufferNoAttachmentsSampleCounts?: SampleCountFlags;
  maxColorAttachments?: number;
  sampledImageColorSampleCounts?: SampleCountFlags;
  sampledImageIntegerSampleCounts?: SampleCountFlags;
  sampledImageDepthSampleCounts?: SampleCountFlags;
  sampledImageStencilSampleCounts?: SampleCountFlags;
  storageImageSampleCounts?: SampleCountFlags;
  maxSampleMaskWords?: number;
  timestampComputeAndGraphics?: Bool32;
  timestampPeriod?: number;
  maxClipDistances?: number;
  maxCullDistances?: number;
  maxCombinedClipAndCullDistances?: number;
  discreteQueuePriorities?: number;
  pointSizeRange?: number[];
  lineWidthRange?: number[];
  pointSizeGranularity?: number;
  lineWidthGranularity?: number;
  strictLines?: Bool32;
  standardSampleLocations?: Bool32;
  optimalBufferCopyOffsetAlignment?: DeviceSize;
  optimalBufferCopyRowPitchAlignment?: DeviceSize;
  nonCoherentAtomSize?: DeviceSize;
}

export class PhysicalDeviceLimits implements BaseStruct {
  static size = 504;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceLimits);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceLimits) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceLimits.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceLimits.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceLimits.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.maxImageDimension1D !== undefined) this.maxImageDimension1D = data.maxImageDimension1D;
      if (data.maxImageDimension2D !== undefined) this.maxImageDimension2D = data.maxImageDimension2D;
      if (data.maxImageDimension3D !== undefined) this.maxImageDimension3D = data.maxImageDimension3D;
      if (data.maxImageDimensionCube !== undefined) this.maxImageDimensionCube = data.maxImageDimensionCube;
      if (data.maxImageArrayLayers !== undefined) this.maxImageArrayLayers = data.maxImageArrayLayers;
      if (data.maxTexelBufferElements !== undefined) this.maxTexelBufferElements = data.maxTexelBufferElements;
      if (data.maxUniformBufferRange !== undefined) this.maxUniformBufferRange = data.maxUniformBufferRange;
      if (data.maxStorageBufferRange !== undefined) this.maxStorageBufferRange = data.maxStorageBufferRange;
      if (data.maxPushConstantsSize !== undefined) this.maxPushConstantsSize = data.maxPushConstantsSize;
      if (data.maxMemoryAllocationCount !== undefined) this.maxMemoryAllocationCount = data.maxMemoryAllocationCount;
      if (data.maxSamplerAllocationCount !== undefined) this.maxSamplerAllocationCount = data.maxSamplerAllocationCount;
      if (data.bufferImageGranularity !== undefined) this.bufferImageGranularity = data.bufferImageGranularity;
      if (data.sparseAddressSpaceSize !== undefined) this.sparseAddressSpaceSize = data.sparseAddressSpaceSize;
      if (data.maxBoundDescriptorSets !== undefined) this.maxBoundDescriptorSets = data.maxBoundDescriptorSets;
      if (data.maxPerStageDescriptorSamplers !== undefined) this.maxPerStageDescriptorSamplers = data.maxPerStageDescriptorSamplers;
      if (data.maxPerStageDescriptorUniformBuffers !== undefined) this.maxPerStageDescriptorUniformBuffers = data.maxPerStageDescriptorUniformBuffers;
      if (data.maxPerStageDescriptorStorageBuffers !== undefined) this.maxPerStageDescriptorStorageBuffers = data.maxPerStageDescriptorStorageBuffers;
      if (data.maxPerStageDescriptorSampledImages !== undefined) this.maxPerStageDescriptorSampledImages = data.maxPerStageDescriptorSampledImages;
      if (data.maxPerStageDescriptorStorageImages !== undefined) this.maxPerStageDescriptorStorageImages = data.maxPerStageDescriptorStorageImages;
      if (data.maxPerStageDescriptorInputAttachments !== undefined) this.maxPerStageDescriptorInputAttachments = data.maxPerStageDescriptorInputAttachments;
      if (data.maxPerStageResources !== undefined) this.maxPerStageResources = data.maxPerStageResources;
      if (data.maxDescriptorSetSamplers !== undefined) this.maxDescriptorSetSamplers = data.maxDescriptorSetSamplers;
      if (data.maxDescriptorSetUniformBuffers !== undefined) this.maxDescriptorSetUniformBuffers = data.maxDescriptorSetUniformBuffers;
      if (data.maxDescriptorSetUniformBuffersDynamic !== undefined) this.maxDescriptorSetUniformBuffersDynamic = data.maxDescriptorSetUniformBuffersDynamic;
      if (data.maxDescriptorSetStorageBuffers !== undefined) this.maxDescriptorSetStorageBuffers = data.maxDescriptorSetStorageBuffers;
      if (data.maxDescriptorSetStorageBuffersDynamic !== undefined) this.maxDescriptorSetStorageBuffersDynamic = data.maxDescriptorSetStorageBuffersDynamic;
      if (data.maxDescriptorSetSampledImages !== undefined) this.maxDescriptorSetSampledImages = data.maxDescriptorSetSampledImages;
      if (data.maxDescriptorSetStorageImages !== undefined) this.maxDescriptorSetStorageImages = data.maxDescriptorSetStorageImages;
      if (data.maxDescriptorSetInputAttachments !== undefined) this.maxDescriptorSetInputAttachments = data.maxDescriptorSetInputAttachments;
      if (data.maxVertexInputAttributes !== undefined) this.maxVertexInputAttributes = data.maxVertexInputAttributes;
      if (data.maxVertexInputBindings !== undefined) this.maxVertexInputBindings = data.maxVertexInputBindings;
      if (data.maxVertexInputAttributeOffset !== undefined) this.maxVertexInputAttributeOffset = data.maxVertexInputAttributeOffset;
      if (data.maxVertexInputBindingStride !== undefined) this.maxVertexInputBindingStride = data.maxVertexInputBindingStride;
      if (data.maxVertexOutputComponents !== undefined) this.maxVertexOutputComponents = data.maxVertexOutputComponents;
      if (data.maxTessellationGenerationLevel !== undefined) this.maxTessellationGenerationLevel = data.maxTessellationGenerationLevel;
      if (data.maxTessellationPatchSize !== undefined) this.maxTessellationPatchSize = data.maxTessellationPatchSize;
      if (data.maxTessellationControlPerVertexInputComponents !== undefined) this.maxTessellationControlPerVertexInputComponents = data.maxTessellationControlPerVertexInputComponents;
      if (data.maxTessellationControlPerVertexOutputComponents !== undefined) this.maxTessellationControlPerVertexOutputComponents = data.maxTessellationControlPerVertexOutputComponents;
      if (data.maxTessellationControlPerPatchOutputComponents !== undefined) this.maxTessellationControlPerPatchOutputComponents = data.maxTessellationControlPerPatchOutputComponents;
      if (data.maxTessellationControlTotalOutputComponents !== undefined) this.maxTessellationControlTotalOutputComponents = data.maxTessellationControlTotalOutputComponents;
      if (data.maxTessellationEvaluationInputComponents !== undefined) this.maxTessellationEvaluationInputComponents = data.maxTessellationEvaluationInputComponents;
      if (data.maxTessellationEvaluationOutputComponents !== undefined) this.maxTessellationEvaluationOutputComponents = data.maxTessellationEvaluationOutputComponents;
      if (data.maxGeometryShaderInvocations !== undefined) this.maxGeometryShaderInvocations = data.maxGeometryShaderInvocations;
      if (data.maxGeometryInputComponents !== undefined) this.maxGeometryInputComponents = data.maxGeometryInputComponents;
      if (data.maxGeometryOutputComponents !== undefined) this.maxGeometryOutputComponents = data.maxGeometryOutputComponents;
      if (data.maxGeometryOutputVertices !== undefined) this.maxGeometryOutputVertices = data.maxGeometryOutputVertices;
      if (data.maxGeometryTotalOutputComponents !== undefined) this.maxGeometryTotalOutputComponents = data.maxGeometryTotalOutputComponents;
      if (data.maxFragmentInputComponents !== undefined) this.maxFragmentInputComponents = data.maxFragmentInputComponents;
      if (data.maxFragmentOutputAttachments !== undefined) this.maxFragmentOutputAttachments = data.maxFragmentOutputAttachments;
      if (data.maxFragmentDualSrcAttachments !== undefined) this.maxFragmentDualSrcAttachments = data.maxFragmentDualSrcAttachments;
      if (data.maxFragmentCombinedOutputResources !== undefined) this.maxFragmentCombinedOutputResources = data.maxFragmentCombinedOutputResources;
      if (data.maxComputeSharedMemorySize !== undefined) this.maxComputeSharedMemorySize = data.maxComputeSharedMemorySize;
      if (data.maxComputeWorkGroupCount !== undefined) this.maxComputeWorkGroupCount = data.maxComputeWorkGroupCount;
      if (data.maxComputeWorkGroupInvocations !== undefined) this.maxComputeWorkGroupInvocations = data.maxComputeWorkGroupInvocations;
      if (data.maxComputeWorkGroupSize !== undefined) this.maxComputeWorkGroupSize = data.maxComputeWorkGroupSize;
      if (data.subPixelPrecisionBits !== undefined) this.subPixelPrecisionBits = data.subPixelPrecisionBits;
      if (data.subTexelPrecisionBits !== undefined) this.subTexelPrecisionBits = data.subTexelPrecisionBits;
      if (data.mipmapPrecisionBits !== undefined) this.mipmapPrecisionBits = data.mipmapPrecisionBits;
      if (data.maxDrawIndexedIndexValue !== undefined) this.maxDrawIndexedIndexValue = data.maxDrawIndexedIndexValue;
      if (data.maxDrawIndirectCount !== undefined) this.maxDrawIndirectCount = data.maxDrawIndirectCount;
      if (data.maxSamplerLodBias !== undefined) this.maxSamplerLodBias = data.maxSamplerLodBias;
      if (data.maxSamplerAnisotropy !== undefined) this.maxSamplerAnisotropy = data.maxSamplerAnisotropy;
      if (data.maxViewports !== undefined) this.maxViewports = data.maxViewports;
      if (data.maxViewportDimensions !== undefined) this.maxViewportDimensions = data.maxViewportDimensions;
      if (data.viewportBoundsRange !== undefined) this.viewportBoundsRange = data.viewportBoundsRange;
      if (data.viewportSubPixelBits !== undefined) this.viewportSubPixelBits = data.viewportSubPixelBits;
      if (data.minMemoryMapAlignment !== undefined) this.minMemoryMapAlignment = data.minMemoryMapAlignment;
      if (data.minTexelBufferOffsetAlignment !== undefined) this.minTexelBufferOffsetAlignment = data.minTexelBufferOffsetAlignment;
      if (data.minUniformBufferOffsetAlignment !== undefined) this.minUniformBufferOffsetAlignment = data.minUniformBufferOffsetAlignment;
      if (data.minStorageBufferOffsetAlignment !== undefined) this.minStorageBufferOffsetAlignment = data.minStorageBufferOffsetAlignment;
      if (data.minTexelOffset !== undefined) this.minTexelOffset = data.minTexelOffset;
      if (data.maxTexelOffset !== undefined) this.maxTexelOffset = data.maxTexelOffset;
      if (data.minTexelGatherOffset !== undefined) this.minTexelGatherOffset = data.minTexelGatherOffset;
      if (data.maxTexelGatherOffset !== undefined) this.maxTexelGatherOffset = data.maxTexelGatherOffset;
      if (data.minInterpolationOffset !== undefined) this.minInterpolationOffset = data.minInterpolationOffset;
      if (data.maxInterpolationOffset !== undefined) this.maxInterpolationOffset = data.maxInterpolationOffset;
      if (data.subPixelInterpolationOffsetBits !== undefined) this.subPixelInterpolationOffsetBits = data.subPixelInterpolationOffsetBits;
      if (data.maxFramebufferWidth !== undefined) this.maxFramebufferWidth = data.maxFramebufferWidth;
      if (data.maxFramebufferHeight !== undefined) this.maxFramebufferHeight = data.maxFramebufferHeight;
      if (data.maxFramebufferLayers !== undefined) this.maxFramebufferLayers = data.maxFramebufferLayers;
      if (data.framebufferColorSampleCounts !== undefined) this.framebufferColorSampleCounts = data.framebufferColorSampleCounts;
      if (data.framebufferDepthSampleCounts !== undefined) this.framebufferDepthSampleCounts = data.framebufferDepthSampleCounts;
      if (data.framebufferStencilSampleCounts !== undefined) this.framebufferStencilSampleCounts = data.framebufferStencilSampleCounts;
      if (data.framebufferNoAttachmentsSampleCounts !== undefined) this.framebufferNoAttachmentsSampleCounts = data.framebufferNoAttachmentsSampleCounts;
      if (data.maxColorAttachments !== undefined) this.maxColorAttachments = data.maxColorAttachments;
      if (data.sampledImageColorSampleCounts !== undefined) this.sampledImageColorSampleCounts = data.sampledImageColorSampleCounts;
      if (data.sampledImageIntegerSampleCounts !== undefined) this.sampledImageIntegerSampleCounts = data.sampledImageIntegerSampleCounts;
      if (data.sampledImageDepthSampleCounts !== undefined) this.sampledImageDepthSampleCounts = data.sampledImageDepthSampleCounts;
      if (data.sampledImageStencilSampleCounts !== undefined) this.sampledImageStencilSampleCounts = data.sampledImageStencilSampleCounts;
      if (data.storageImageSampleCounts !== undefined) this.storageImageSampleCounts = data.storageImageSampleCounts;
      if (data.maxSampleMaskWords !== undefined) this.maxSampleMaskWords = data.maxSampleMaskWords;
      if (data.timestampComputeAndGraphics !== undefined) this.timestampComputeAndGraphics = data.timestampComputeAndGraphics;
      if (data.timestampPeriod !== undefined) this.timestampPeriod = data.timestampPeriod;
      if (data.maxClipDistances !== undefined) this.maxClipDistances = data.maxClipDistances;
      if (data.maxCullDistances !== undefined) this.maxCullDistances = data.maxCullDistances;
      if (data.maxCombinedClipAndCullDistances !== undefined) this.maxCombinedClipAndCullDistances = data.maxCombinedClipAndCullDistances;
      if (data.discreteQueuePriorities !== undefined) this.discreteQueuePriorities = data.discreteQueuePriorities;
      if (data.pointSizeRange !== undefined) this.pointSizeRange = data.pointSizeRange;
      if (data.lineWidthRange !== undefined) this.lineWidthRange = data.lineWidthRange;
      if (data.pointSizeGranularity !== undefined) this.pointSizeGranularity = data.pointSizeGranularity;
      if (data.lineWidthGranularity !== undefined) this.lineWidthGranularity = data.lineWidthGranularity;
      if (data.strictLines !== undefined) this.strictLines = data.strictLines;
      if (data.standardSampleLocations !== undefined) this.standardSampleLocations = data.standardSampleLocations;
      if (data.optimalBufferCopyOffsetAlignment !== undefined) this.optimalBufferCopyOffsetAlignment = data.optimalBufferCopyOffsetAlignment;
      if (data.optimalBufferCopyRowPitchAlignment !== undefined) this.optimalBufferCopyRowPitchAlignment = data.optimalBufferCopyRowPitchAlignment;
      if (data.nonCoherentAtomSize !== undefined) this.nonCoherentAtomSize = data.nonCoherentAtomSize;
    }
  }
  
  get maxImageDimension1D() {
    return this.#view.getUint32(0, LE);
  }
  
  set maxImageDimension1D(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get maxImageDimension2D() {
    return this.#view.getUint32(4, LE);
  }
  
  set maxImageDimension2D(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get maxImageDimension3D() {
    return this.#view.getUint32(8, LE);
  }
  
  set maxImageDimension3D(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get maxImageDimensionCube() {
    return this.#view.getUint32(12, LE);
  }
  
  set maxImageDimensionCube(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTexelBufferElements() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTexelBufferElements(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxUniformBufferRange() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxUniformBufferRange(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxStorageBufferRange() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxStorageBufferRange(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxPushConstantsSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxPushConstantsSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxMemoryAllocationCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxMemoryAllocationCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxSamplerAllocationCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxSamplerAllocationCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get bufferImageGranularity() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set bufferImageGranularity(value: DeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get sparseAddressSpaceSize() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set sparseAddressSpaceSize(value: DeviceSize) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get maxBoundDescriptorSets() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxBoundDescriptorSets(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxPerStageDescriptorSamplers() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxPerStageDescriptorSamplers(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxPerStageDescriptorUniformBuffers() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxPerStageDescriptorUniformBuffers(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get maxPerStageDescriptorStorageBuffers() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxPerStageDescriptorStorageBuffers(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxPerStageDescriptorSampledImages() {
    return this.#view.getUint32(80, LE);
  }
  
  set maxPerStageDescriptorSampledImages(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxPerStageDescriptorStorageImages() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxPerStageDescriptorStorageImages(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxPerStageDescriptorInputAttachments() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxPerStageDescriptorInputAttachments(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get maxPerStageResources() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxPerStageResources(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxDescriptorSetSamplers() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxDescriptorSetSamplers(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxDescriptorSetUniformBuffers() {
    return this.#view.getUint32(100, LE);
  }
  
  set maxDescriptorSetUniformBuffers(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxDescriptorSetUniformBuffersDynamic() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxDescriptorSetUniformBuffersDynamic(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get maxDescriptorSetStorageBuffers() {
    return this.#view.getUint32(108, LE);
  }
  
  set maxDescriptorSetStorageBuffers(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get maxDescriptorSetStorageBuffersDynamic() {
    return this.#view.getUint32(112, LE);
  }
  
  set maxDescriptorSetStorageBuffersDynamic(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get maxDescriptorSetSampledImages() {
    return this.#view.getUint32(116, LE);
  }
  
  set maxDescriptorSetSampledImages(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get maxDescriptorSetStorageImages() {
    return this.#view.getUint32(120, LE);
  }
  
  set maxDescriptorSetStorageImages(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get maxDescriptorSetInputAttachments() {
    return this.#view.getUint32(124, LE);
  }
  
  set maxDescriptorSetInputAttachments(value: number) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get maxVertexInputAttributes() {
    return this.#view.getUint32(128, LE);
  }
  
  set maxVertexInputAttributes(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get maxVertexInputBindings() {
    return this.#view.getUint32(132, LE);
  }
  
  set maxVertexInputBindings(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get maxVertexInputAttributeOffset() {
    return this.#view.getUint32(136, LE);
  }
  
  set maxVertexInputAttributeOffset(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get maxVertexInputBindingStride() {
    return this.#view.getUint32(140, LE);
  }
  
  set maxVertexInputBindingStride(value: number) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get maxVertexOutputComponents() {
    return this.#view.getUint32(144, LE);
  }
  
  set maxVertexOutputComponents(value: number) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get maxTessellationGenerationLevel() {
    return this.#view.getUint32(148, LE);
  }
  
  set maxTessellationGenerationLevel(value: number) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get maxTessellationPatchSize() {
    return this.#view.getUint32(152, LE);
  }
  
  set maxTessellationPatchSize(value: number) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get maxTessellationControlPerVertexInputComponents() {
    return this.#view.getUint32(156, LE);
  }
  
  set maxTessellationControlPerVertexInputComponents(value: number) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get maxTessellationControlPerVertexOutputComponents() {
    return this.#view.getUint32(160, LE);
  }
  
  set maxTessellationControlPerVertexOutputComponents(value: number) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get maxTessellationControlPerPatchOutputComponents() {
    return this.#view.getUint32(164, LE);
  }
  
  set maxTessellationControlPerPatchOutputComponents(value: number) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get maxTessellationControlTotalOutputComponents() {
    return this.#view.getUint32(168, LE);
  }
  
  set maxTessellationControlTotalOutputComponents(value: number) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get maxTessellationEvaluationInputComponents() {
    return this.#view.getUint32(172, LE);
  }
  
  set maxTessellationEvaluationInputComponents(value: number) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get maxTessellationEvaluationOutputComponents() {
    return this.#view.getUint32(176, LE);
  }
  
  set maxTessellationEvaluationOutputComponents(value: number) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get maxGeometryShaderInvocations() {
    return this.#view.getUint32(180, LE);
  }
  
  set maxGeometryShaderInvocations(value: number) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get maxGeometryInputComponents() {
    return this.#view.getUint32(184, LE);
  }
  
  set maxGeometryInputComponents(value: number) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get maxGeometryOutputComponents() {
    return this.#view.getUint32(188, LE);
  }
  
  set maxGeometryOutputComponents(value: number) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get maxGeometryOutputVertices() {
    return this.#view.getUint32(192, LE);
  }
  
  set maxGeometryOutputVertices(value: number) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get maxGeometryTotalOutputComponents() {
    return this.#view.getUint32(196, LE);
  }
  
  set maxGeometryTotalOutputComponents(value: number) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get maxFragmentInputComponents() {
    return this.#view.getUint32(200, LE);
  }
  
  set maxFragmentInputComponents(value: number) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get maxFragmentOutputAttachments() {
    return this.#view.getUint32(204, LE);
  }
  
  set maxFragmentOutputAttachments(value: number) {
    this.#view.setUint32(204, Number(value), LE);
  }
  
  get maxFragmentDualSrcAttachments() {
    return this.#view.getUint32(208, LE);
  }
  
  set maxFragmentDualSrcAttachments(value: number) {
    this.#view.setUint32(208, Number(value), LE);
  }
  
  get maxFragmentCombinedOutputResources() {
    return this.#view.getUint32(212, LE);
  }
  
  set maxFragmentCombinedOutputResources(value: number) {
    this.#view.setUint32(212, Number(value), LE);
  }
  
  get maxComputeSharedMemorySize() {
    return this.#view.getUint32(216, LE);
  }
  
  set maxComputeSharedMemorySize(value: number) {
    this.#view.setUint32(216, Number(value), LE);
  }
  
  get maxComputeWorkGroupCount() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(220 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxComputeWorkGroupCount(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(220 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxComputeWorkGroupInvocations() {
    return this.#view.getUint32(232, LE);
  }
  
  set maxComputeWorkGroupInvocations(value: number) {
    this.#view.setUint32(232, Number(value), LE);
  }
  
  get maxComputeWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(236 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxComputeWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(236 + i * 4, Number(value[i]), LE);
    }
  }
  
  get subPixelPrecisionBits() {
    return this.#view.getUint32(248, LE);
  }
  
  set subPixelPrecisionBits(value: number) {
    this.#view.setUint32(248, Number(value), LE);
  }
  
  get subTexelPrecisionBits() {
    return this.#view.getUint32(252, LE);
  }
  
  set subTexelPrecisionBits(value: number) {
    this.#view.setUint32(252, Number(value), LE);
  }
  
  get mipmapPrecisionBits() {
    return this.#view.getUint32(256, LE);
  }
  
  set mipmapPrecisionBits(value: number) {
    this.#view.setUint32(256, Number(value), LE);
  }
  
  get maxDrawIndexedIndexValue() {
    return this.#view.getUint32(260, LE);
  }
  
  set maxDrawIndexedIndexValue(value: number) {
    this.#view.setUint32(260, Number(value), LE);
  }
  
  get maxDrawIndirectCount() {
    return this.#view.getUint32(264, LE);
  }
  
  set maxDrawIndirectCount(value: number) {
    this.#view.setUint32(264, Number(value), LE);
  }
  
  get maxSamplerLodBias() {
    return this.#view.getFloat32(268, LE);
  }
  
  set maxSamplerLodBias(value: number) {
    this.#view.setFloat32(268, Number(value), LE);
  }
  
  get maxSamplerAnisotropy() {
    return this.#view.getFloat32(272, LE);
  }
  
  set maxSamplerAnisotropy(value: number) {
    this.#view.setFloat32(272, Number(value), LE);
  }
  
  get maxViewports() {
    return this.#view.getUint32(276, LE);
  }
  
  set maxViewports(value: number) {
    this.#view.setUint32(276, Number(value), LE);
  }
  
  get maxViewportDimensions() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getUint32(280 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxViewportDimensions(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(280 + i * 4, Number(value[i]), LE);
    }
  }
  
  get viewportBoundsRange() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getFloat32(288 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set viewportBoundsRange(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(288 + i * 4, Number(value[i]), LE);
    }
  }
  
  get viewportSubPixelBits() {
    return this.#view.getUint32(296, LE);
  }
  
  set viewportSubPixelBits(value: number) {
    this.#view.setUint32(296, Number(value), LE);
  }
  
  get minMemoryMapAlignment() {
    return this.#view.getBigUint64(304, LE);
  }
  
  set minMemoryMapAlignment(value: Deno.PointerValue) {
    this.#view.setBigUint64(304, BigInt(value), LE);
  }
  
  get minTexelBufferOffsetAlignment() {
    return this.#view.getBigUint64(312, LE);
  }
  
  set minTexelBufferOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(312, BigInt(value), LE);
  }
  
  get minUniformBufferOffsetAlignment() {
    return this.#view.getBigUint64(320, LE);
  }
  
  set minUniformBufferOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(320, BigInt(value), LE);
  }
  
  get minStorageBufferOffsetAlignment() {
    return this.#view.getBigUint64(328, LE);
  }
  
  set minStorageBufferOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(328, BigInt(value), LE);
  }
  
  get minTexelOffset() {
    return this.#view.getInt32(336, LE);
  }
  
  set minTexelOffset(value: number) {
    this.#view.setInt32(336, Number(value), LE);
  }
  
  get maxTexelOffset() {
    return this.#view.getUint32(340, LE);
  }
  
  set maxTexelOffset(value: number) {
    this.#view.setUint32(340, Number(value), LE);
  }
  
  get minTexelGatherOffset() {
    return this.#view.getInt32(344, LE);
  }
  
  set minTexelGatherOffset(value: number) {
    this.#view.setInt32(344, Number(value), LE);
  }
  
  get maxTexelGatherOffset() {
    return this.#view.getUint32(348, LE);
  }
  
  set maxTexelGatherOffset(value: number) {
    this.#view.setUint32(348, Number(value), LE);
  }
  
  get minInterpolationOffset() {
    return this.#view.getFloat32(352, LE);
  }
  
  set minInterpolationOffset(value: number) {
    this.#view.setFloat32(352, Number(value), LE);
  }
  
  get maxInterpolationOffset() {
    return this.#view.getFloat32(356, LE);
  }
  
  set maxInterpolationOffset(value: number) {
    this.#view.setFloat32(356, Number(value), LE);
  }
  
  get subPixelInterpolationOffsetBits() {
    return this.#view.getUint32(360, LE);
  }
  
  set subPixelInterpolationOffsetBits(value: number) {
    this.#view.setUint32(360, Number(value), LE);
  }
  
  get maxFramebufferWidth() {
    return this.#view.getUint32(364, LE);
  }
  
  set maxFramebufferWidth(value: number) {
    this.#view.setUint32(364, Number(value), LE);
  }
  
  get maxFramebufferHeight() {
    return this.#view.getUint32(368, LE);
  }
  
  set maxFramebufferHeight(value: number) {
    this.#view.setUint32(368, Number(value), LE);
  }
  
  get maxFramebufferLayers() {
    return this.#view.getUint32(372, LE);
  }
  
  set maxFramebufferLayers(value: number) {
    this.#view.setUint32(372, Number(value), LE);
  }
  
  get framebufferColorSampleCounts() {
    return this.#view.getUint32(376, LE);
  }
  
  set framebufferColorSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(376, Number(value), LE);
  }
  
  get framebufferDepthSampleCounts() {
    return this.#view.getUint32(380, LE);
  }
  
  set framebufferDepthSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(380, Number(value), LE);
  }
  
  get framebufferStencilSampleCounts() {
    return this.#view.getUint32(384, LE);
  }
  
  set framebufferStencilSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(384, Number(value), LE);
  }
  
  get framebufferNoAttachmentsSampleCounts() {
    return this.#view.getUint32(388, LE);
  }
  
  set framebufferNoAttachmentsSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(388, Number(value), LE);
  }
  
  get maxColorAttachments() {
    return this.#view.getUint32(392, LE);
  }
  
  set maxColorAttachments(value: number) {
    this.#view.setUint32(392, Number(value), LE);
  }
  
  get sampledImageColorSampleCounts() {
    return this.#view.getUint32(396, LE);
  }
  
  set sampledImageColorSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(396, Number(value), LE);
  }
  
  get sampledImageIntegerSampleCounts() {
    return this.#view.getUint32(400, LE);
  }
  
  set sampledImageIntegerSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(400, Number(value), LE);
  }
  
  get sampledImageDepthSampleCounts() {
    return this.#view.getUint32(404, LE);
  }
  
  set sampledImageDepthSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(404, Number(value), LE);
  }
  
  get sampledImageStencilSampleCounts() {
    return this.#view.getUint32(408, LE);
  }
  
  set sampledImageStencilSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(408, Number(value), LE);
  }
  
  get storageImageSampleCounts() {
    return this.#view.getUint32(412, LE);
  }
  
  set storageImageSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(412, Number(value), LE);
  }
  
  get maxSampleMaskWords() {
    return this.#view.getUint32(416, LE);
  }
  
  set maxSampleMaskWords(value: number) {
    this.#view.setUint32(416, Number(value), LE);
  }
  
  get timestampComputeAndGraphics() {
    return this.#view.getUint32(420, LE);
  }
  
  set timestampComputeAndGraphics(value: Bool32) {
    this.#view.setUint32(420, Number(value), LE);
  }
  
  get timestampPeriod() {
    return this.#view.getFloat32(424, LE);
  }
  
  set timestampPeriod(value: number) {
    this.#view.setFloat32(424, Number(value), LE);
  }
  
  get maxClipDistances() {
    return this.#view.getUint32(428, LE);
  }
  
  set maxClipDistances(value: number) {
    this.#view.setUint32(428, Number(value), LE);
  }
  
  get maxCullDistances() {
    return this.#view.getUint32(432, LE);
  }
  
  set maxCullDistances(value: number) {
    this.#view.setUint32(432, Number(value), LE);
  }
  
  get maxCombinedClipAndCullDistances() {
    return this.#view.getUint32(436, LE);
  }
  
  set maxCombinedClipAndCullDistances(value: number) {
    this.#view.setUint32(436, Number(value), LE);
  }
  
  get discreteQueuePriorities() {
    return this.#view.getUint32(440, LE);
  }
  
  set discreteQueuePriorities(value: number) {
    this.#view.setUint32(440, Number(value), LE);
  }
  
  get pointSizeRange() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getFloat32(444 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set pointSizeRange(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(444 + i * 4, Number(value[i]), LE);
    }
  }
  
  get lineWidthRange() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getFloat32(452 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set lineWidthRange(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(452 + i * 4, Number(value[i]), LE);
    }
  }
  
  get pointSizeGranularity() {
    return this.#view.getFloat32(460, LE);
  }
  
  set pointSizeGranularity(value: number) {
    this.#view.setFloat32(460, Number(value), LE);
  }
  
  get lineWidthGranularity() {
    return this.#view.getFloat32(464, LE);
  }
  
  set lineWidthGranularity(value: number) {
    this.#view.setFloat32(464, Number(value), LE);
  }
  
  get strictLines() {
    return this.#view.getUint32(468, LE);
  }
  
  set strictLines(value: Bool32) {
    this.#view.setUint32(468, Number(value), LE);
  }
  
  get standardSampleLocations() {
    return this.#view.getUint32(472, LE);
  }
  
  set standardSampleLocations(value: Bool32) {
    this.#view.setUint32(472, Number(value), LE);
  }
  
  get optimalBufferCopyOffsetAlignment() {
    return this.#view.getBigUint64(480, LE);
  }
  
  set optimalBufferCopyOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(480, BigInt(value), LE);
  }
  
  get optimalBufferCopyRowPitchAlignment() {
    return this.#view.getBigUint64(488, LE);
  }
  
  set optimalBufferCopyRowPitchAlignment(value: DeviceSize) {
    this.#view.setBigUint64(488, BigInt(value), LE);
  }
  
  get nonCoherentAtomSize() {
    return this.#view.getBigUint64(496, LE);
  }
  
  set nonCoherentAtomSize(value: DeviceSize) {
    this.#view.setBigUint64(496, BigInt(value), LE);
  }
}

export interface InitSemaphoreCreateInfo {
  pNext?: AnyPointer;
  flags?: SemaphoreCreateFlags;
}

export class SemaphoreCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SemaphoreCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitQueryPoolCreateInfo {
  pNext?: AnyPointer;
  flags?: QueryPoolCreateFlags;
  queryType?: QueryType;
  queryCount?: number;
  pipelineStatistics?: QueryPipelineStatisticFlags;
}

export class QueryPoolCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueryPoolCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueryPoolCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(QueryPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueryPoolCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueryPoolCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.queryType !== undefined) this.queryType = data.queryType;
      if (data.queryCount !== undefined) this.queryCount = data.queryCount;
      if (data.pipelineStatistics !== undefined) this.pipelineStatistics = data.pipelineStatistics;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: QueryPoolCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queryType() {
    return this.#view.getUint32(20, LE);
  }
  
  set queryType(value: QueryType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set queryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pipelineStatistics() {
    return this.#view.getUint32(28, LE);
  }
  
  set pipelineStatistics(value: QueryPipelineStatisticFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitFramebufferCreateInfo {
  pNext?: AnyPointer;
  flags?: FramebufferCreateFlags;
  renderPass?: RenderPass;
  attachmentCount?: number;
  pAttachments?: AnyPointer;
  width?: number;
  height?: number;
  layers?: number;
}

export class FramebufferCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFramebufferCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFramebufferCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(FramebufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FramebufferCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FramebufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.renderPass !== undefined) this.renderPass = data.renderPass;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pAttachments !== undefined) this.pAttachments = data.pAttachments;
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.layers !== undefined) this.layers = data.layers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: FramebufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set renderPass(value: RenderPass) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAttachments(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get width() {
    return this.#view.getUint32(48, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(52, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get layers() {
    return this.#view.getUint32(56, LE);
  }
  
  set layers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitDrawIndirectCommand {
  vertexCount?: number;
  instanceCount?: number;
  firstVertex?: number;
  firstInstance?: number;
}

export class DrawIndirectCommand implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrawIndirectCommand);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrawIndirectCommand) {
    if (!data) {
      this.#data = new Uint8Array(DrawIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrawIndirectCommand.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrawIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.vertexCount !== undefined) this.vertexCount = data.vertexCount;
      if (data.instanceCount !== undefined) this.instanceCount = data.instanceCount;
      if (data.firstVertex !== undefined) this.firstVertex = data.firstVertex;
      if (data.firstInstance !== undefined) this.firstInstance = data.firstInstance;
    }
  }
  
  get vertexCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstVertex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get firstInstance() {
    return this.#view.getUint32(12, LE);
  }
  
  set firstInstance(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitDrawIndexedIndirectCommand {
  indexCount?: number;
  instanceCount?: number;
  firstIndex?: number;
  vertexOffset?: number;
  firstInstance?: number;
}

export class DrawIndexedIndirectCommand implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrawIndexedIndirectCommand);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrawIndexedIndirectCommand) {
    if (!data) {
      this.#data = new Uint8Array(DrawIndexedIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrawIndexedIndirectCommand.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrawIndexedIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.indexCount !== undefined) this.indexCount = data.indexCount;
      if (data.instanceCount !== undefined) this.instanceCount = data.instanceCount;
      if (data.firstIndex !== undefined) this.firstIndex = data.firstIndex;
      if (data.vertexOffset !== undefined) this.vertexOffset = data.vertexOffset;
      if (data.firstInstance !== undefined) this.firstInstance = data.firstInstance;
    }
  }
  
  get indexCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get vertexOffset() {
    return this.#view.getInt32(12, LE);
  }
  
  set vertexOffset(value: number) {
    this.#view.setInt32(12, Number(value), LE);
  }
  
  get firstInstance() {
    return this.#view.getUint32(16, LE);
  }
  
  set firstInstance(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDispatchIndirectCommand {
  x?: number;
  y?: number;
  z?: number;
}

export class DispatchIndirectCommand implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDispatchIndirectCommand);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDispatchIndirectCommand) {
    if (!data) {
      this.#data = new Uint8Array(DispatchIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DispatchIndirectCommand.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DispatchIndirectCommand.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
      if (data.z !== undefined) this.z = data.z;
    }
  }
  
  get x() {
    return this.#view.getUint32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getUint32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getUint32(8, LE);
  }
  
  set z(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitMultiDrawInfoEXT {
  firstVertex?: number;
  vertexCount?: number;
}

export class MultiDrawInfoEXT implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMultiDrawInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMultiDrawInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MultiDrawInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MultiDrawInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MultiDrawInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.firstVertex !== undefined) this.firstVertex = data.firstVertex;
      if (data.vertexCount !== undefined) this.vertexCount = data.vertexCount;
    }
  }
  
  get firstVertex() {
    return this.#view.getUint32(0, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get vertexCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitMultiDrawIndexedInfoEXT {
  firstIndex?: number;
  indexCount?: number;
  vertexOffset?: number;
}

export class MultiDrawIndexedInfoEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMultiDrawIndexedInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMultiDrawIndexedInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MultiDrawIndexedInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MultiDrawIndexedInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MultiDrawIndexedInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.firstIndex !== undefined) this.firstIndex = data.firstIndex;
      if (data.indexCount !== undefined) this.indexCount = data.indexCount;
      if (data.vertexOffset !== undefined) this.vertexOffset = data.vertexOffset;
    }
  }
  
  get firstIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set firstIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get indexCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vertexOffset() {
    return this.#view.getInt32(8, LE);
  }
  
  set vertexOffset(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export interface InitSubmitInfo {
  pNext?: AnyPointer;
  waitSemaphoreCount?: number;
  pWaitSemaphores?: AnyPointer;
  pWaitDstStageMask?: AnyPointer;
  commandBufferCount?: number;
  pCommandBuffers?: AnyPointer;
  signalSemaphoreCount?: number;
  pSignalSemaphores?: AnyPointer;
}

export class SubmitInfo implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(SubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreCount !== undefined) this.waitSemaphoreCount = data.waitSemaphoreCount;
      if (data.pWaitSemaphores !== undefined) this.pWaitSemaphores = data.pWaitSemaphores;
      if (data.pWaitDstStageMask !== undefined) this.pWaitDstStageMask = data.pWaitDstStageMask;
      if (data.commandBufferCount !== undefined) this.commandBufferCount = data.commandBufferCount;
      if (data.pCommandBuffers !== undefined) this.pCommandBuffers = data.pCommandBuffers;
      if (data.signalSemaphoreCount !== undefined) this.signalSemaphoreCount = data.signalSemaphoreCount;
      if (data.pSignalSemaphores !== undefined) this.pSignalSemaphores = data.pSignalSemaphores;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pWaitDstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pWaitDstStageMask(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pCommandBuffers() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pCommandBuffers(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get pSignalSemaphores() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pSignalSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDisplayPropertiesKHR {
  display?: DisplayKHR;
  displayName?: AnyPointer;
  physicalDimensions?: Extent2D;
  physicalResolution?: Extent2D;
  supportedTransforms?: SurfaceTransformFlagsKHR;
  planeReorderPossible?: Bool32;
  persistentContent?: Bool32;
}

export class DisplayPropertiesKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.display !== undefined) this.display = data.display;
      if (data.displayName !== undefined) this.displayName = data.displayName;
      if (data.physicalDimensions !== undefined) this.physicalDimensions = data.physicalDimensions;
      if (data.physicalResolution !== undefined) this.physicalResolution = data.physicalResolution;
      if (data.supportedTransforms !== undefined) this.supportedTransforms = data.supportedTransforms;
      if (data.planeReorderPossible !== undefined) this.planeReorderPossible = data.planeReorderPossible;
      if (data.persistentContent !== undefined) this.persistentContent = data.persistentContent;
    }
  }
  
  get display() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set display(value: DisplayKHR) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get displayName() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set displayName(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get physicalDimensions() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set physicalDimensions(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get physicalResolution() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set physicalResolution(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(32, LE);
  }
  
  set supportedTransforms(value: SurfaceTransformFlagsKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get planeReorderPossible() {
    return this.#view.getUint32(36, LE);
  }
  
  set planeReorderPossible(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get persistentContent() {
    return this.#view.getUint32(40, LE);
  }
  
  set persistentContent(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitDisplayPlanePropertiesKHR {
  currentDisplay?: DisplayKHR;
  currentStackIndex?: number;
}

export class DisplayPlanePropertiesKHR implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPlanePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPlanePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPlanePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPlanePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPlanePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.currentDisplay !== undefined) this.currentDisplay = data.currentDisplay;
      if (data.currentStackIndex !== undefined) this.currentStackIndex = data.currentStackIndex;
    }
  }
  
  get currentDisplay() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set currentDisplay(value: DisplayKHR) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get currentStackIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set currentStackIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitDisplayModeParametersKHR {
  visibleRegion?: Extent2D;
  refreshRate?: number;
}

export class DisplayModeParametersKHR implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayModeParametersKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayModeParametersKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayModeParametersKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayModeParametersKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayModeParametersKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.visibleRegion !== undefined) this.visibleRegion = data.visibleRegion;
      if (data.refreshRate !== undefined) this.refreshRate = data.refreshRate;
    }
  }
  
  get visibleRegion() {
    return new Extent2D(this.#data.subarray(0, 0 + Extent2D.size));
  }
  
  set visibleRegion(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get refreshRate() {
    return this.#view.getUint32(8, LE);
  }
  
  set refreshRate(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitDisplayModePropertiesKHR {
  displayMode?: DisplayModeKHR;
  parameters?: DisplayModeParametersKHR;
}

export class DisplayModePropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayModePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayModePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayModePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayModePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayModePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.displayMode !== undefined) this.displayMode = data.displayMode;
      if (data.parameters !== undefined) this.parameters = data.parameters;
    }
  }
  
  get displayMode() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set displayMode(value: DisplayModeKHR) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get parameters() {
    return new DisplayModeParametersKHR(this.#data.subarray(8, 8 + DisplayModeParametersKHR.size));
  }
  
  set parameters(value: DisplayModeParametersKHR) {
    if (value[BUFFER].byteLength < DisplayModeParametersKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
}

export interface InitDisplayModeCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: DisplayModeCreateFlagsKHR;
  parameters?: DisplayModeParametersKHR;
}

export class DisplayModeCreateInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayModeCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayModeCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayModeCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayModeCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayModeCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.parameters !== undefined) this.parameters = data.parameters;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DisplayModeCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get parameters() {
    return new DisplayModeParametersKHR(this.#data.subarray(20, 20 + DisplayModeParametersKHR.size));
  }
  
  set parameters(value: DisplayModeParametersKHR) {
    if (value[BUFFER].byteLength < DisplayModeParametersKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
}

export interface InitDisplayPlaneCapabilitiesKHR {
  supportedAlpha?: DisplayPlaneAlphaFlagsKHR;
  minSrcPosition?: Offset2D;
  maxSrcPosition?: Offset2D;
  minSrcExtent?: Extent2D;
  maxSrcExtent?: Extent2D;
  minDstPosition?: Offset2D;
  maxDstPosition?: Offset2D;
  minDstExtent?: Extent2D;
  maxDstExtent?: Extent2D;
}

export class DisplayPlaneCapabilitiesKHR implements BaseStruct {
  static size = 68;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPlaneCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPlaneCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPlaneCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPlaneCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPlaneCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.supportedAlpha !== undefined) this.supportedAlpha = data.supportedAlpha;
      if (data.minSrcPosition !== undefined) this.minSrcPosition = data.minSrcPosition;
      if (data.maxSrcPosition !== undefined) this.maxSrcPosition = data.maxSrcPosition;
      if (data.minSrcExtent !== undefined) this.minSrcExtent = data.minSrcExtent;
      if (data.maxSrcExtent !== undefined) this.maxSrcExtent = data.maxSrcExtent;
      if (data.minDstPosition !== undefined) this.minDstPosition = data.minDstPosition;
      if (data.maxDstPosition !== undefined) this.maxDstPosition = data.maxDstPosition;
      if (data.minDstExtent !== undefined) this.minDstExtent = data.minDstExtent;
      if (data.maxDstExtent !== undefined) this.maxDstExtent = data.maxDstExtent;
    }
  }
  
  get supportedAlpha() {
    return this.#view.getUint32(0, LE);
  }
  
  set supportedAlpha(value: DisplayPlaneAlphaFlagsKHR) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get minSrcPosition() {
    return new Offset2D(this.#data.subarray(4, 4 + Offset2D.size));
  }
  
  set minSrcPosition(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
  
  get maxSrcPosition() {
    return new Offset2D(this.#data.subarray(12, 12 + Offset2D.size));
  }
  
  set maxSrcPosition(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 12);
  }
  
  get minSrcExtent() {
    return new Extent2D(this.#data.subarray(20, 20 + Extent2D.size));
  }
  
  set minSrcExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get maxSrcExtent() {
    return new Extent2D(this.#data.subarray(28, 28 + Extent2D.size));
  }
  
  set maxSrcExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get minDstPosition() {
    return new Offset2D(this.#data.subarray(36, 36 + Offset2D.size));
  }
  
  set minDstPosition(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get maxDstPosition() {
    return new Offset2D(this.#data.subarray(44, 44 + Offset2D.size));
  }
  
  set maxDstPosition(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get minDstExtent() {
    return new Extent2D(this.#data.subarray(52, 52 + Extent2D.size));
  }
  
  set minDstExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 52);
  }
  
  get maxDstExtent() {
    return new Extent2D(this.#data.subarray(60, 60 + Extent2D.size));
  }
  
  set maxDstExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
}

export interface InitDisplaySurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: DisplaySurfaceCreateFlagsKHR;
  displayMode?: DisplayModeKHR;
  planeIndex?: number;
  planeStackIndex?: number;
  transform?: SurfaceTransformFlagBitsKHR;
  globalAlpha?: number;
  alphaMode?: DisplayPlaneAlphaFlagBitsKHR;
  imageExtent?: Extent2D;
}

export class DisplaySurfaceCreateInfoKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplaySurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplaySurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplaySurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplaySurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplaySurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.displayMode !== undefined) this.displayMode = data.displayMode;
      if (data.planeIndex !== undefined) this.planeIndex = data.planeIndex;
      if (data.planeStackIndex !== undefined) this.planeStackIndex = data.planeStackIndex;
      if (data.transform !== undefined) this.transform = data.transform;
      if (data.globalAlpha !== undefined) this.globalAlpha = data.globalAlpha;
      if (data.alphaMode !== undefined) this.alphaMode = data.alphaMode;
      if (data.imageExtent !== undefined) this.imageExtent = data.imageExtent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DisplaySurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get displayMode() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set displayMode(value: DisplayModeKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get planeIndex() {
    return this.#view.getUint32(32, LE);
  }
  
  set planeIndex(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get planeStackIndex() {
    return this.#view.getUint32(36, LE);
  }
  
  set planeStackIndex(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get transform() {
    return this.#view.getUint32(40, LE);
  }
  
  set transform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get globalAlpha() {
    return this.#view.getFloat32(44, LE);
  }
  
  set globalAlpha(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get alphaMode() {
    return this.#view.getUint32(48, LE);
  }
  
  set alphaMode(value: DisplayPlaneAlphaFlagBitsKHR) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get imageExtent() {
    return new Extent2D(this.#data.subarray(52, 52 + Extent2D.size));
  }
  
  set imageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 52);
  }
}

export interface InitDisplayPresentInfoKHR {
  pNext?: AnyPointer;
  srcRect?: Rect2D;
  dstRect?: Rect2D;
  persistent?: Bool32;
}

export class DisplayPresentInfoKHR implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPresentInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPresentInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPresentInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcRect !== undefined) this.srcRect = data.srcRect;
      if (data.dstRect !== undefined) this.dstRect = data.dstRect;
      if (data.persistent !== undefined) this.persistent = data.persistent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcRect() {
    return new Rect2D(this.#data.subarray(16, 16 + Rect2D.size));
  }
  
  set srcRect(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get dstRect() {
    return new Rect2D(this.#data.subarray(32, 32 + Rect2D.size));
  }
  
  set dstRect(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get persistent() {
    return this.#view.getUint32(48, LE);
  }
  
  set persistent(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitSurfaceCapabilitiesKHR {
  minImageCount?: number;
  maxImageCount?: number;
  currentExtent?: Extent2D;
  minImageExtent?: Extent2D;
  maxImageExtent?: Extent2D;
  maxImageArrayLayers?: number;
  supportedTransforms?: SurfaceTransformFlagsKHR;
  currentTransform?: SurfaceTransformFlagBitsKHR;
  supportedCompositeAlpha?: CompositeAlphaFlagsKHR;
  supportedUsageFlags?: ImageUsageFlags;
}

export class SurfaceCapabilitiesKHR implements BaseStruct {
  static size = 52;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.minImageCount !== undefined) this.minImageCount = data.minImageCount;
      if (data.maxImageCount !== undefined) this.maxImageCount = data.maxImageCount;
      if (data.currentExtent !== undefined) this.currentExtent = data.currentExtent;
      if (data.minImageExtent !== undefined) this.minImageExtent = data.minImageExtent;
      if (data.maxImageExtent !== undefined) this.maxImageExtent = data.maxImageExtent;
      if (data.maxImageArrayLayers !== undefined) this.maxImageArrayLayers = data.maxImageArrayLayers;
      if (data.supportedTransforms !== undefined) this.supportedTransforms = data.supportedTransforms;
      if (data.currentTransform !== undefined) this.currentTransform = data.currentTransform;
      if (data.supportedCompositeAlpha !== undefined) this.supportedCompositeAlpha = data.supportedCompositeAlpha;
      if (data.supportedUsageFlags !== undefined) this.supportedUsageFlags = data.supportedUsageFlags;
    }
  }
  
  get minImageCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get maxImageCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set maxImageCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get currentExtent() {
    return new Extent2D(this.#data.subarray(8, 8 + Extent2D.size));
  }
  
  set currentExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get minImageExtent() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set minImageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxImageExtent() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set maxImageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(36, LE);
  }
  
  set supportedTransforms(value: SurfaceTransformFlagsKHR) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get currentTransform() {
    return this.#view.getUint32(40, LE);
  }
  
  set currentTransform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get supportedCompositeAlpha() {
    return this.#view.getUint32(44, LE);
  }
  
  set supportedCompositeAlpha(value: CompositeAlphaFlagsKHR) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get supportedUsageFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set supportedUsageFlags(value: ImageUsageFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitAndroidSurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: AndroidSurfaceCreateFlagsKHR;
  window?: AnyPointer;
}

export class AndroidSurfaceCreateInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAndroidSurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAndroidSurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AndroidSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AndroidSurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AndroidSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.window !== undefined) this.window = data.window;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: AndroidSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set window(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitViSurfaceCreateInfoNN {
  pNext?: AnyPointer;
  flags?: ViSurfaceCreateFlagsNN;
  window?: AnyPointer;
}

export class ViSurfaceCreateInfoNN implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitViSurfaceCreateInfoNN);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitViSurfaceCreateInfoNN) {
    if (!data) {
      this.#data = new Uint8Array(ViSurfaceCreateInfoNN.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ViSurfaceCreateInfoNN.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ViSurfaceCreateInfoNN.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.window !== undefined) this.window = data.window;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ViSurfaceCreateFlagsNN) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set window(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitWaylandSurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: WaylandSurfaceCreateFlagsKHR;
  display?: AnyPointer;
  surface?: AnyPointer;
}

export class WaylandSurfaceCreateInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWaylandSurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWaylandSurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(WaylandSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < WaylandSurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(WaylandSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.display !== undefined) this.display = data.display;
      if (data.surface !== undefined) this.surface = data.surface;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: WaylandSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get display() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set display(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set surface(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitWin32SurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: Win32SurfaceCreateFlagsKHR;
  hinstance?: Deno.PointerValue;
  hwnd?: Deno.PointerValue;
}

export class Win32SurfaceCreateInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWin32SurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWin32SurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(Win32SurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Win32SurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Win32SurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.hinstance !== undefined) this.hinstance = data.hinstance;
      if (data.hwnd !== undefined) this.hwnd = data.hwnd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: Win32SurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get hinstance() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set hinstance(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get hwnd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set hwnd(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitXlibSurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: XlibSurfaceCreateFlagsKHR;
  dpy?: AnyPointer;
  window?: Deno.PointerValue;
}

export class XlibSurfaceCreateInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitXlibSurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitXlibSurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(XlibSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < XlibSurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(XlibSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.dpy !== undefined) this.dpy = data.dpy;
      if (data.window !== undefined) this.window = data.window;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: XlibSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dpy() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dpy(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitXcbSurfaceCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: XcbSurfaceCreateFlagsKHR;
  connection?: AnyPointer;
  window?: Deno.PointerValue;
}

export class XcbSurfaceCreateInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitXcbSurfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitXcbSurfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(XcbSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < XcbSurfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(XcbSurfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.connection !== undefined) this.connection = data.connection;
      if (data.window !== undefined) this.window = data.window;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: XcbSurfaceCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get connection() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set connection(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDirectFBSurfaceCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: DirectFBSurfaceCreateFlagsEXT;
  dfb?: AnyPointer;
  surface?: AnyPointer;
}

export class DirectFBSurfaceCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDirectFBSurfaceCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDirectFBSurfaceCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DirectFBSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DirectFBSurfaceCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DirectFBSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.dfb !== undefined) this.dfb = data.dfb;
      if (data.surface !== undefined) this.surface = data.surface;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DirectFBSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dfb() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dfb(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set surface(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImagePipeSurfaceCreateInfoFUCHSIA {
  pNext?: AnyPointer;
  flags?: ImagePipeSurfaceCreateFlagsFUCHSIA;
  imagePipeHandle?: Deno.PointerValue;
}

export class ImagePipeSurfaceCreateInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImagePipeSurfaceCreateInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImagePipeSurfaceCreateInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImagePipeSurfaceCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImagePipeSurfaceCreateInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImagePipeSurfaceCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.imagePipeHandle !== undefined) this.imagePipeHandle = data.imagePipeHandle;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ImagePipeSurfaceCreateFlagsFUCHSIA) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imagePipeHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set imagePipeHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitStreamDescriptorSurfaceCreateInfoGGP {
  pNext?: AnyPointer;
  flags?: StreamDescriptorSurfaceCreateFlagsGGP;
  streamDescriptor?: Deno.PointerValue;
}

export class StreamDescriptorSurfaceCreateInfoGGP implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStreamDescriptorSurfaceCreateInfoGGP);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStreamDescriptorSurfaceCreateInfoGGP) {
    if (!data) {
      this.#data = new Uint8Array(StreamDescriptorSurfaceCreateInfoGGP.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StreamDescriptorSurfaceCreateInfoGGP.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StreamDescriptorSurfaceCreateInfoGGP.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.streamDescriptor !== undefined) this.streamDescriptor = data.streamDescriptor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: StreamDescriptorSurfaceCreateFlagsGGP) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get streamDescriptor() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set streamDescriptor(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitScreenSurfaceCreateInfoQNX {
  pNext?: AnyPointer;
  flags?: ScreenSurfaceCreateFlagsQNX;
  context?: AnyPointer;
  window?: AnyPointer;
}

export class ScreenSurfaceCreateInfoQNX implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitScreenSurfaceCreateInfoQNX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitScreenSurfaceCreateInfoQNX) {
    if (!data) {
      this.#data = new Uint8Array(ScreenSurfaceCreateInfoQNX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ScreenSurfaceCreateInfoQNX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ScreenSurfaceCreateInfoQNX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.context !== undefined) this.context = data.context;
      if (data.window !== undefined) this.window = data.window;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ScreenSurfaceCreateFlagsQNX) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get context() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set context(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get window() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set window(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSurfaceFormatKHR {
  format?: Format;
  colorSpace?: ColorSpaceKHR;
}

export class SurfaceFormatKHR implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceFormatKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceFormatKHR) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceFormatKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceFormatKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceFormatKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.format !== undefined) this.format = data.format;
      if (data.colorSpace !== undefined) this.colorSpace = data.colorSpace;
    }
  }
  
  get format() {
    return this.#view.getUint32(0, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get colorSpace() {
    return this.#view.getUint32(4, LE);
  }
  
  set colorSpace(value: ColorSpaceKHR) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitSwapchainCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: SwapchainCreateFlagsKHR;
  surface?: SurfaceKHR;
  minImageCount?: number;
  imageFormat?: Format;
  imageColorSpace?: ColorSpaceKHR;
  imageExtent?: Extent2D;
  imageArrayLayers?: number;
  imageUsage?: ImageUsageFlags;
  imageSharingMode?: SharingMode;
  queueFamilyIndexCount?: number;
  pQueueFamilyIndices?: AnyPointer;
  preTransform?: SurfaceTransformFlagBitsKHR;
  compositeAlpha?: CompositeAlphaFlagBitsKHR;
  presentMode?: PresentModeKHR;
  clipped?: Bool32;
  oldSwapchain?: SwapchainKHR;
}

export class SwapchainCreateInfoKHR implements BaseStruct {
  static size = 104;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSwapchainCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSwapchainCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(SwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SwapchainCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.surface !== undefined) this.surface = data.surface;
      if (data.minImageCount !== undefined) this.minImageCount = data.minImageCount;
      if (data.imageFormat !== undefined) this.imageFormat = data.imageFormat;
      if (data.imageColorSpace !== undefined) this.imageColorSpace = data.imageColorSpace;
      if (data.imageExtent !== undefined) this.imageExtent = data.imageExtent;
      if (data.imageArrayLayers !== undefined) this.imageArrayLayers = data.imageArrayLayers;
      if (data.imageUsage !== undefined) this.imageUsage = data.imageUsage;
      if (data.imageSharingMode !== undefined) this.imageSharingMode = data.imageSharingMode;
      if (data.queueFamilyIndexCount !== undefined) this.queueFamilyIndexCount = data.queueFamilyIndexCount;
      if (data.pQueueFamilyIndices !== undefined) this.pQueueFamilyIndices = data.pQueueFamilyIndices;
      if (data.preTransform !== undefined) this.preTransform = data.preTransform;
      if (data.compositeAlpha !== undefined) this.compositeAlpha = data.compositeAlpha;
      if (data.presentMode !== undefined) this.presentMode = data.presentMode;
      if (data.clipped !== undefined) this.clipped = data.clipped;
      if (data.oldSwapchain !== undefined) this.oldSwapchain = data.oldSwapchain;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SwapchainCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set surface(value: SurfaceKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get minImageCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get imageFormat() {
    return this.#view.getUint32(36, LE);
  }
  
  set imageFormat(value: Format) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get imageColorSpace() {
    return this.#view.getUint32(40, LE);
  }
  
  set imageColorSpace(value: ColorSpaceKHR) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get imageExtent() {
    return new Extent2D(this.#data.subarray(44, 44 + Extent2D.size));
  }
  
  set imageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get imageArrayLayers() {
    return this.#view.getUint32(52, LE);
  }
  
  set imageArrayLayers(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get imageUsage() {
    return this.#view.getUint32(56, LE);
  }
  
  set imageUsage(value: ImageUsageFlags) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get imageSharingMode() {
    return this.#view.getUint32(60, LE);
  }
  
  set imageSharingMode(value: SharingMode) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pQueueFamilyIndices(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get preTransform() {
    return this.#view.getUint32(80, LE);
  }
  
  set preTransform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get compositeAlpha() {
    return this.#view.getUint32(84, LE);
  }
  
  set compositeAlpha(value: CompositeAlphaFlagBitsKHR) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get presentMode() {
    return this.#view.getUint32(88, LE);
  }
  
  set presentMode(value: PresentModeKHR) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get clipped() {
    return this.#view.getUint32(92, LE);
  }
  
  set clipped(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get oldSwapchain() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set oldSwapchain(value: SwapchainKHR) {
    this.#view.setBigUint64(96, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPresentInfoKHR {
  pNext?: AnyPointer;
  waitSemaphoreCount?: number;
  pWaitSemaphores?: AnyPointer;
  swapchainCount?: number;
  pSwapchains?: AnyPointer;
  pImageIndices?: AnyPointer;
  pResults?: AnyPointer;
}

export class PresentInfoKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRESENT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreCount !== undefined) this.waitSemaphoreCount = data.waitSemaphoreCount;
      if (data.pWaitSemaphores !== undefined) this.pWaitSemaphores = data.pWaitSemaphores;
      if (data.swapchainCount !== undefined) this.swapchainCount = data.swapchainCount;
      if (data.pSwapchains !== undefined) this.pSwapchains = data.pSwapchains;
      if (data.pImageIndices !== undefined) this.pImageIndices = data.pImageIndices;
      if (data.pResults !== undefined) this.pResults = data.pResults;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSwapchains() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSwapchains(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pImageIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pImageIndices(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pResults() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pResults(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugReportCallbackCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: DebugReportFlagsEXT;
  pfnCallback?: Deno.PointerValue;
  pUserData?: AnyPointer;
}

export class DebugReportCallbackCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugReportCallbackCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugReportCallbackCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugReportCallbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugReportCallbackCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugReportCallbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pfnCallback !== undefined) this.pfnCallback = data.pfnCallback;
      if (data.pUserData !== undefined) this.pUserData = data.pUserData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DebugReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pfnCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pUserData(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitValidationFlagsEXT {
  pNext?: AnyPointer;
  disabledValidationCheckCount?: number;
  pDisabledValidationChecks?: AnyPointer;
}

export class ValidationFlagsEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitValidationFlagsEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitValidationFlagsEXT) {
    if (!data) {
      this.#data = new Uint8Array(ValidationFlagsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ValidationFlagsEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ValidationFlagsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.disabledValidationCheckCount !== undefined) this.disabledValidationCheckCount = data.disabledValidationCheckCount;
      if (data.pDisabledValidationChecks !== undefined) this.pDisabledValidationChecks = data.pDisabledValidationChecks;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get disabledValidationCheckCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set disabledValidationCheckCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDisabledValidationChecks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDisabledValidationChecks(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitValidationFeaturesEXT {
  pNext?: AnyPointer;
  enabledValidationFeatureCount?: number;
  pEnabledValidationFeatures?: AnyPointer;
  disabledValidationFeatureCount?: number;
  pDisabledValidationFeatures?: AnyPointer;
}

export class ValidationFeaturesEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitValidationFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitValidationFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(ValidationFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ValidationFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ValidationFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.enabledValidationFeatureCount !== undefined) this.enabledValidationFeatureCount = data.enabledValidationFeatureCount;
      if (data.pEnabledValidationFeatures !== undefined) this.pEnabledValidationFeatures = data.pEnabledValidationFeatures;
      if (data.disabledValidationFeatureCount !== undefined) this.disabledValidationFeatureCount = data.disabledValidationFeatureCount;
      if (data.pDisabledValidationFeatures !== undefined) this.pDisabledValidationFeatures = data.pDisabledValidationFeatures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get enabledValidationFeatureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set enabledValidationFeatureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pEnabledValidationFeatures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pEnabledValidationFeatures(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get disabledValidationFeatureCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set disabledValidationFeatureCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pDisabledValidationFeatures() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pDisabledValidationFeatures(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineRasterizationStateRasterizationOrderAMD {
  pNext?: AnyPointer;
  rasterizationOrder?: RasterizationOrderAMD;
}

export class PipelineRasterizationStateRasterizationOrderAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationStateRasterizationOrderAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationStateRasterizationOrderAMD) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationStateRasterizationOrderAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationStateRasterizationOrderAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationStateRasterizationOrderAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rasterizationOrder !== undefined) this.rasterizationOrder = data.rasterizationOrder;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rasterizationOrder() {
    return this.#view.getUint32(16, LE);
  }
  
  set rasterizationOrder(value: RasterizationOrderAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDebugMarkerObjectNameInfoEXT {
  pNext?: AnyPointer;
  objectType?: DebugReportObjectTypeEXT;
  object?: Deno.PointerValue;
  pObjectName?: AnyPointer;
}

export class DebugMarkerObjectNameInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugMarkerObjectNameInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugMarkerObjectNameInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugMarkerObjectNameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugMarkerObjectNameInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugMarkerObjectNameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.objectType !== undefined) this.objectType = data.objectType;
      if (data.object !== undefined) this.object = data.object;
      if (data.pObjectName !== undefined) this.pObjectName = data.pObjectName;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: DebugReportObjectTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get object() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set object(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pObjectName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pObjectName(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugMarkerObjectTagInfoEXT {
  pNext?: AnyPointer;
  objectType?: DebugReportObjectTypeEXT;
  object?: Deno.PointerValue;
  tagName?: Deno.PointerValue;
  tagSize?: Deno.PointerValue;
  pTag?: AnyPointer;
}

export class DebugMarkerObjectTagInfoEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugMarkerObjectTagInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugMarkerObjectTagInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugMarkerObjectTagInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugMarkerObjectTagInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugMarkerObjectTagInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.objectType !== undefined) this.objectType = data.objectType;
      if (data.object !== undefined) this.object = data.object;
      if (data.tagName !== undefined) this.tagName = data.tagName;
      if (data.tagSize !== undefined) this.tagSize = data.tagSize;
      if (data.pTag !== undefined) this.pTag = data.pTag;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: DebugReportObjectTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get object() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set object(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get tagName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set tagName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get tagSize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set tagSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pTag() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTag(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugMarkerMarkerInfoEXT {
  pNext?: AnyPointer;
  pMarkerName?: AnyPointer;
  color?: number[];
}

export class DebugMarkerMarkerInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugMarkerMarkerInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugMarkerMarkerInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugMarkerMarkerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugMarkerMarkerInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugMarkerMarkerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pMarkerName !== undefined) this.pMarkerName = data.pMarkerName;
      if (data.color !== undefined) this.color = data.color;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pMarkerName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pMarkerName(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get color() {
    const result: number[] = [];
    for (let i = 0; i < 4; i++) {
      result.push((() => {
        return this.#view.getFloat32(24 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set color(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(24 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitDedicatedAllocationImageCreateInfoNV {
  pNext?: AnyPointer;
  dedicatedAllocation?: Bool32;
}

export class DedicatedAllocationImageCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDedicatedAllocationImageCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDedicatedAllocationImageCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(DedicatedAllocationImageCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DedicatedAllocationImageCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DedicatedAllocationImageCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dedicatedAllocation !== undefined) this.dedicatedAllocation = data.dedicatedAllocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocation(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDedicatedAllocationBufferCreateInfoNV {
  pNext?: AnyPointer;
  dedicatedAllocation?: Bool32;
}

export class DedicatedAllocationBufferCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDedicatedAllocationBufferCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDedicatedAllocationBufferCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(DedicatedAllocationBufferCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DedicatedAllocationBufferCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DedicatedAllocationBufferCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dedicatedAllocation !== undefined) this.dedicatedAllocation = data.dedicatedAllocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocation(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDedicatedAllocationMemoryAllocateInfoNV {
  pNext?: AnyPointer;
  image?: Image;
  buffer?: Buffer;
}

export class DedicatedAllocationMemoryAllocateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDedicatedAllocationMemoryAllocateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDedicatedAllocationMemoryAllocateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(DedicatedAllocationMemoryAllocateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DedicatedAllocationMemoryAllocateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DedicatedAllocationMemoryAllocateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExternalImageFormatPropertiesNV {
  imageFormatProperties?: ImageFormatProperties;
  externalMemoryFeatures?: ExternalMemoryFeatureFlagsNV;
  exportFromImportedHandleTypes?: ExternalMemoryHandleTypeFlagsNV;
  compatibleHandleTypes?: ExternalMemoryHandleTypeFlagsNV;
}

export class ExternalImageFormatPropertiesNV implements BaseStruct {
  static size = 44;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalImageFormatPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalImageFormatPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(ExternalImageFormatPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalImageFormatPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalImageFormatPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.imageFormatProperties !== undefined) this.imageFormatProperties = data.imageFormatProperties;
      if (data.externalMemoryFeatures !== undefined) this.externalMemoryFeatures = data.externalMemoryFeatures;
      if (data.exportFromImportedHandleTypes !== undefined) this.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
      if (data.compatibleHandleTypes !== undefined) this.compatibleHandleTypes = data.compatibleHandleTypes;
    }
  }
  
  get imageFormatProperties() {
    return new ImageFormatProperties(this.#data.subarray(0, 0 + ImageFormatProperties.size));
  }
  
  set imageFormatProperties(value: ImageFormatProperties) {
    if (value[BUFFER].byteLength < ImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get externalMemoryFeatures() {
    return this.#view.getUint32(32, LE);
  }
  
  set externalMemoryFeatures(value: ExternalMemoryFeatureFlagsNV) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(36, LE);
  }
  
  set exportFromImportedHandleTypes(value: ExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(40, LE);
  }
  
  set compatibleHandleTypes(value: ExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitExternalMemoryImageCreateInfoNV {
  pNext?: AnyPointer;
  handleTypes?: ExternalMemoryHandleTypeFlagsNV;
}

export class ExternalMemoryImageCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalMemoryImageCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalMemoryImageCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(ExternalMemoryImageCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalMemoryImageCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalMemoryImageCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExportMemoryAllocateInfoNV {
  pNext?: AnyPointer;
  handleTypes?: ExternalMemoryHandleTypeFlagsNV;
}

export class ExportMemoryAllocateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMemoryAllocateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMemoryAllocateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(ExportMemoryAllocateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMemoryAllocateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMemoryAllocateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImportMemoryWin32HandleInfoNV {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagsNV;
  handle?: Deno.PointerValue;
}

export class ImportMemoryWin32HandleInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryWin32HandleInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryWin32HandleInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryWin32HandleInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryWin32HandleInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryWin32HandleInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.handle !== undefined) this.handle = data.handle;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMemoryWin32HandleInfoNV {
  pNext?: AnyPointer;
  pAttributes?: AnyPointer;
  dwAccess?: number;
}

export class ExportMemoryWin32HandleInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMemoryWin32HandleInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMemoryWin32HandleInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(ExportMemoryWin32HandleInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMemoryWin32HandleInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMemoryWin32HandleInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pAttributes !== undefined) this.pAttributes = data.pAttributes;
      if (data.dwAccess !== undefined) this.dwAccess = data.dwAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitWin32KeyedMutexAcquireReleaseInfoNV {
  pNext?: AnyPointer;
  acquireCount?: number;
  pAcquireSyncs?: AnyPointer;
  pAcquireKeys?: AnyPointer;
  pAcquireTimeoutMilliseconds?: AnyPointer;
  releaseCount?: number;
  pReleaseSyncs?: AnyPointer;
  pReleaseKeys?: AnyPointer;
}

export class Win32KeyedMutexAcquireReleaseInfoNV implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWin32KeyedMutexAcquireReleaseInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWin32KeyedMutexAcquireReleaseInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(Win32KeyedMutexAcquireReleaseInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Win32KeyedMutexAcquireReleaseInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Win32KeyedMutexAcquireReleaseInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.acquireCount !== undefined) this.acquireCount = data.acquireCount;
      if (data.pAcquireSyncs !== undefined) this.pAcquireSyncs = data.pAcquireSyncs;
      if (data.pAcquireKeys !== undefined) this.pAcquireKeys = data.pAcquireKeys;
      if (data.pAcquireTimeoutMilliseconds !== undefined) this.pAcquireTimeoutMilliseconds = data.pAcquireTimeoutMilliseconds;
      if (data.releaseCount !== undefined) this.releaseCount = data.releaseCount;
      if (data.pReleaseSyncs !== undefined) this.pReleaseSyncs = data.pReleaseSyncs;
      if (data.pReleaseKeys !== undefined) this.pReleaseKeys = data.pReleaseKeys;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get acquireCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set acquireCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAcquireSyncs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAcquireSyncs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pAcquireKeys() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAcquireKeys(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pAcquireTimeoutMilliseconds() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAcquireTimeoutMilliseconds(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get releaseCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set releaseCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pReleaseSyncs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pReleaseSyncs(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pReleaseKeys() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pReleaseKeys(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
  pNext?: AnyPointer;
  deviceGeneratedCommands?: Bool32;
}

export class PhysicalDeviceDeviceGeneratedCommandsFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDeviceGeneratedCommandsFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceGeneratedCommands !== undefined) this.deviceGeneratedCommands = data.deviceGeneratedCommands;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceGeneratedCommands() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceGeneratedCommands(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDevicePrivateDataCreateInfo {
  pNext?: AnyPointer;
  privateDataSlotRequestCount?: number;
}

export class DevicePrivateDataCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDevicePrivateDataCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDevicePrivateDataCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DevicePrivateDataCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DevicePrivateDataCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DevicePrivateDataCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.privateDataSlotRequestCount !== undefined) this.privateDataSlotRequestCount = data.privateDataSlotRequestCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get privateDataSlotRequestCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set privateDataSlotRequestCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPrivateDataSlotCreateInfo {
  pNext?: AnyPointer;
  flags?: PrivateDataSlotCreateFlags;
}

export class PrivateDataSlotCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPrivateDataSlotCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPrivateDataSlotCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PrivateDataSlotCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PrivateDataSlotCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PrivateDataSlotCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PrivateDataSlotCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePrivateDataFeatures {
  pNext?: AnyPointer;
  privateData?: Bool32;
}

export class PhysicalDevicePrivateDataFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePrivateDataFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePrivateDataFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePrivateDataFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePrivateDataFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePrivateDataFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.privateData !== undefined) this.privateData = data.privateData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get privateData() {
    return this.#view.getUint32(16, LE);
  }
  
  set privateData(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
  pNext?: AnyPointer;
  maxGraphicsShaderGroupCount?: number;
  maxIndirectSequenceCount?: number;
  maxIndirectCommandsTokenCount?: number;
  maxIndirectCommandsStreamCount?: number;
  maxIndirectCommandsTokenOffset?: number;
  maxIndirectCommandsStreamStride?: number;
  minSequencesCountBufferOffsetAlignment?: number;
  minSequencesIndexBufferOffsetAlignment?: number;
  minIndirectCommandsBufferOffsetAlignment?: number;
}

export class PhysicalDeviceDeviceGeneratedCommandsPropertiesNV implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDeviceGeneratedCommandsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDeviceGeneratedCommandsPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDeviceGeneratedCommandsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxGraphicsShaderGroupCount !== undefined) this.maxGraphicsShaderGroupCount = data.maxGraphicsShaderGroupCount;
      if (data.maxIndirectSequenceCount !== undefined) this.maxIndirectSequenceCount = data.maxIndirectSequenceCount;
      if (data.maxIndirectCommandsTokenCount !== undefined) this.maxIndirectCommandsTokenCount = data.maxIndirectCommandsTokenCount;
      if (data.maxIndirectCommandsStreamCount !== undefined) this.maxIndirectCommandsStreamCount = data.maxIndirectCommandsStreamCount;
      if (data.maxIndirectCommandsTokenOffset !== undefined) this.maxIndirectCommandsTokenOffset = data.maxIndirectCommandsTokenOffset;
      if (data.maxIndirectCommandsStreamStride !== undefined) this.maxIndirectCommandsStreamStride = data.maxIndirectCommandsStreamStride;
      if (data.minSequencesCountBufferOffsetAlignment !== undefined) this.minSequencesCountBufferOffsetAlignment = data.minSequencesCountBufferOffsetAlignment;
      if (data.minSequencesIndexBufferOffsetAlignment !== undefined) this.minSequencesIndexBufferOffsetAlignment = data.minSequencesIndexBufferOffsetAlignment;
      if (data.minIndirectCommandsBufferOffsetAlignment !== undefined) this.minIndirectCommandsBufferOffsetAlignment = data.minIndirectCommandsBufferOffsetAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxGraphicsShaderGroupCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxGraphicsShaderGroupCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxIndirectSequenceCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxIndirectSequenceCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxIndirectCommandsTokenCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxIndirectCommandsTokenCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxIndirectCommandsStreamCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxIndirectCommandsStreamCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxIndirectCommandsTokenOffset() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxIndirectCommandsTokenOffset(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxIndirectCommandsStreamStride() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxIndirectCommandsStreamStride(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minSequencesCountBufferOffsetAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set minSequencesCountBufferOffsetAlignment(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minSequencesIndexBufferOffsetAlignment() {
    return this.#view.getUint32(44, LE);
  }
  
  set minSequencesIndexBufferOffsetAlignment(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get minIndirectCommandsBufferOffsetAlignment() {
    return this.#view.getUint32(48, LE);
  }
  
  set minIndirectCommandsBufferOffsetAlignment(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMultiDrawPropertiesEXT {
  pNext?: AnyPointer;
  maxMultiDrawCount?: number;
}

export class PhysicalDeviceMultiDrawPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultiDrawPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultiDrawPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultiDrawPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultiDrawPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultiDrawPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxMultiDrawCount !== undefined) this.maxMultiDrawCount = data.maxMultiDrawCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxMultiDrawCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxMultiDrawCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitGraphicsShaderGroupCreateInfoNV {
  pNext?: AnyPointer;
  stageCount?: number;
  pStages?: AnyPointer;
  pVertexInputState?: AnyPointer;
  pTessellationState?: AnyPointer;
}

export class GraphicsShaderGroupCreateInfoNV implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGraphicsShaderGroupCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGraphicsShaderGroupCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(GraphicsShaderGroupCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GraphicsShaderGroupCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GraphicsShaderGroupCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stageCount !== undefined) this.stageCount = data.stageCount;
      if (data.pStages !== undefined) this.pStages = data.pStages;
      if (data.pVertexInputState !== undefined) this.pVertexInputState = data.pVertexInputState;
      if (data.pTessellationState !== undefined) this.pTessellationState = data.pTessellationState;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pVertexInputState() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pVertexInputState(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pTessellationState() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pTessellationState(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitGraphicsPipelineShaderGroupsCreateInfoNV {
  pNext?: AnyPointer;
  groupCount?: number;
  pGroups?: AnyPointer;
  pipelineCount?: number;
  pPipelines?: AnyPointer;
}

export class GraphicsPipelineShaderGroupsCreateInfoNV implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGraphicsPipelineShaderGroupsCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGraphicsPipelineShaderGroupsCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(GraphicsPipelineShaderGroupsCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GraphicsPipelineShaderGroupsCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GraphicsPipelineShaderGroupsCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.groupCount !== undefined) this.groupCount = data.groupCount;
      if (data.pGroups !== undefined) this.pGroups = data.pGroups;
      if (data.pipelineCount !== undefined) this.pipelineCount = data.pipelineCount;
      if (data.pPipelines !== undefined) this.pPipelines = data.pPipelines;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pGroups(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set pipelineCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPipelines() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPipelines(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBindShaderGroupIndirectCommandNV {
  groupIndex?: number;
}

export class BindShaderGroupIndirectCommandNV implements BaseStruct {
  static size = 4;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindShaderGroupIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindShaderGroupIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(BindShaderGroupIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindShaderGroupIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindShaderGroupIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.groupIndex !== undefined) this.groupIndex = data.groupIndex;
    }
  }
  
  get groupIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set groupIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export interface InitBindIndexBufferIndirectCommandNV {
  bufferAddress?: DeviceAddress;
  size?: number;
  indexType?: IndexType;
}

export class BindIndexBufferIndirectCommandNV implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindIndexBufferIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindIndexBufferIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(BindIndexBufferIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindIndexBufferIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindIndexBufferIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.bufferAddress !== undefined) this.bufferAddress = data.bufferAddress;
      if (data.size !== undefined) this.size = data.size;
      if (data.indexType !== undefined) this.indexType = data.indexType;
    }
  }
  
  get bufferAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(12, LE);
  }
  
  set indexType(value: IndexType) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitBindVertexBufferIndirectCommandNV {
  bufferAddress?: DeviceAddress;
  size?: number;
  stride?: number;
}

export class BindVertexBufferIndirectCommandNV implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindVertexBufferIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindVertexBufferIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(BindVertexBufferIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindVertexBufferIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindVertexBufferIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.bufferAddress !== undefined) this.bufferAddress = data.bufferAddress;
      if (data.size !== undefined) this.size = data.size;
      if (data.stride !== undefined) this.stride = data.stride;
    }
  }
  
  get bufferAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set bufferAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(8, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(12, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitSetStateFlagsIndirectCommandNV {
  data?: number;
}

export class SetStateFlagsIndirectCommandNV implements BaseStruct {
  static size = 4;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSetStateFlagsIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSetStateFlagsIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(SetStateFlagsIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SetStateFlagsIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SetStateFlagsIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.data !== undefined) this.data = data.data;
    }
  }
  
  get data() {
    return this.#view.getUint32(0, LE);
  }
  
  set data(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export interface InitIndirectCommandsStreamNV {
  buffer?: Buffer;
  offset?: DeviceSize;
}

export class IndirectCommandsStreamNV implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitIndirectCommandsStreamNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitIndirectCommandsStreamNV) {
    if (!data) {
      this.#data = new Uint8Array(IndirectCommandsStreamNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < IndirectCommandsStreamNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(IndirectCommandsStreamNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
    }
  }
  
  get buffer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(0, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export interface InitIndirectCommandsLayoutTokenNV {
  pNext?: AnyPointer;
  tokenType?: IndirectCommandsTokenTypeNV;
  stream?: number;
  offset?: number;
  vertexBindingUnit?: number;
  vertexDynamicStride?: Bool32;
  pushconstantPipelineLayout?: PipelineLayout;
  pushconstantShaderStageFlags?: ShaderStageFlags;
  pushconstantOffset?: number;
  pushconstantSize?: number;
  indirectStateFlags?: IndirectStateFlagsNV;
  indexTypeCount?: number;
  pIndexTypes?: AnyPointer;
  pIndexTypeValues?: AnyPointer;
}

export class IndirectCommandsLayoutTokenNV implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitIndirectCommandsLayoutTokenNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitIndirectCommandsLayoutTokenNV) {
    if (!data) {
      this.#data = new Uint8Array(IndirectCommandsLayoutTokenNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < IndirectCommandsLayoutTokenNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(IndirectCommandsLayoutTokenNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.tokenType !== undefined) this.tokenType = data.tokenType;
      if (data.stream !== undefined) this.stream = data.stream;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.vertexBindingUnit !== undefined) this.vertexBindingUnit = data.vertexBindingUnit;
      if (data.vertexDynamicStride !== undefined) this.vertexDynamicStride = data.vertexDynamicStride;
      if (data.pushconstantPipelineLayout !== undefined) this.pushconstantPipelineLayout = data.pushconstantPipelineLayout;
      if (data.pushconstantShaderStageFlags !== undefined) this.pushconstantShaderStageFlags = data.pushconstantShaderStageFlags;
      if (data.pushconstantOffset !== undefined) this.pushconstantOffset = data.pushconstantOffset;
      if (data.pushconstantSize !== undefined) this.pushconstantSize = data.pushconstantSize;
      if (data.indirectStateFlags !== undefined) this.indirectStateFlags = data.indirectStateFlags;
      if (data.indexTypeCount !== undefined) this.indexTypeCount = data.indexTypeCount;
      if (data.pIndexTypes !== undefined) this.pIndexTypes = data.pIndexTypes;
      if (data.pIndexTypeValues !== undefined) this.pIndexTypeValues = data.pIndexTypeValues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get tokenType() {
    return this.#view.getUint32(16, LE);
  }
  
  set tokenType(value: IndirectCommandsTokenTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stream() {
    return this.#view.getUint32(20, LE);
  }
  
  set stream(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(24, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get vertexBindingUnit() {
    return this.#view.getUint32(28, LE);
  }
  
  set vertexBindingUnit(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get vertexDynamicStride() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexDynamicStride(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pushconstantPipelineLayout() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pushconstantPipelineLayout(value: PipelineLayout) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pushconstantShaderStageFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set pushconstantShaderStageFlags(value: ShaderStageFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pushconstantOffset() {
    return this.#view.getUint32(52, LE);
  }
  
  set pushconstantOffset(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get pushconstantSize() {
    return this.#view.getUint32(56, LE);
  }
  
  set pushconstantSize(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get indirectStateFlags() {
    return this.#view.getUint32(60, LE);
  }
  
  set indirectStateFlags(value: IndirectStateFlagsNV) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get indexTypeCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set indexTypeCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pIndexTypes() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pIndexTypes(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get pIndexTypeValues() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pIndexTypeValues(value: AnyPointer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
}

export interface InitIndirectCommandsLayoutCreateInfoNV {
  pNext?: AnyPointer;
  flags?: IndirectCommandsLayoutUsageFlagsNV;
  pipelineBindPoint?: PipelineBindPoint;
  tokenCount?: number;
  pTokens?: AnyPointer;
  streamCount?: number;
  pStreamStrides?: AnyPointer;
}

export class IndirectCommandsLayoutCreateInfoNV implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitIndirectCommandsLayoutCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitIndirectCommandsLayoutCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(IndirectCommandsLayoutCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < IndirectCommandsLayoutCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(IndirectCommandsLayoutCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.tokenCount !== undefined) this.tokenCount = data.tokenCount;
      if (data.pTokens !== undefined) this.pTokens = data.pTokens;
      if (data.streamCount !== undefined) this.streamCount = data.streamCount;
      if (data.pStreamStrides !== undefined) this.pStreamStrides = data.pStreamStrides;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: IndirectCommandsLayoutUsageFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(20, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tokenCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set tokenCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pTokens() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pTokens(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get streamCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set streamCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pStreamStrides() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pStreamStrides(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitGeneratedCommandsInfoNV {
  pNext?: AnyPointer;
  pipelineBindPoint?: PipelineBindPoint;
  pipeline?: Pipeline;
  indirectCommandsLayout?: IndirectCommandsLayoutNV;
  streamCount?: number;
  pStreams?: AnyPointer;
  sequencesCount?: number;
  preprocessBuffer?: Buffer;
  preprocessOffset?: DeviceSize;
  preprocessSize?: DeviceSize;
  sequencesCountBuffer?: Buffer;
  sequencesCountOffset?: DeviceSize;
  sequencesIndexBuffer?: Buffer;
  sequencesIndexOffset?: DeviceSize;
}

export class GeneratedCommandsInfoNV implements BaseStruct {
  static size = 120;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeneratedCommandsInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeneratedCommandsInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(GeneratedCommandsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeneratedCommandsInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeneratedCommandsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.pipeline !== undefined) this.pipeline = data.pipeline;
      if (data.indirectCommandsLayout !== undefined) this.indirectCommandsLayout = data.indirectCommandsLayout;
      if (data.streamCount !== undefined) this.streamCount = data.streamCount;
      if (data.pStreams !== undefined) this.pStreams = data.pStreams;
      if (data.sequencesCount !== undefined) this.sequencesCount = data.sequencesCount;
      if (data.preprocessBuffer !== undefined) this.preprocessBuffer = data.preprocessBuffer;
      if (data.preprocessOffset !== undefined) this.preprocessOffset = data.preprocessOffset;
      if (data.preprocessSize !== undefined) this.preprocessSize = data.preprocessSize;
      if (data.sequencesCountBuffer !== undefined) this.sequencesCountBuffer = data.sequencesCountBuffer;
      if (data.sequencesCountOffset !== undefined) this.sequencesCountOffset = data.sequencesCountOffset;
      if (data.sequencesIndexBuffer !== undefined) this.sequencesIndexBuffer = data.sequencesIndexBuffer;
      if (data.sequencesIndexOffset !== undefined) this.sequencesIndexOffset = data.sequencesIndexOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pipeline(value: Pipeline) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get indirectCommandsLayout() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indirectCommandsLayout(value: IndirectCommandsLayoutNV) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get streamCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set streamCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pStreams() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pStreams(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get sequencesCount() {
    return this.#view.getUint32(56, LE);
  }
  
  set sequencesCount(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get preprocessBuffer() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set preprocessBuffer(value: Buffer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get preprocessOffset() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set preprocessOffset(value: DeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get preprocessSize() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set preprocessSize(value: DeviceSize) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get sequencesCountBuffer() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set sequencesCountBuffer(value: Buffer) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
  
  get sequencesCountOffset() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set sequencesCountOffset(value: DeviceSize) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get sequencesIndexBuffer() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set sequencesIndexBuffer(value: Buffer) {
    this.#view.setBigUint64(104, BigInt(anyPointer(value)), LE);
  }
  
  get sequencesIndexOffset() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set sequencesIndexOffset(value: DeviceSize) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
}

export interface InitGeneratedCommandsMemoryRequirementsInfoNV {
  pNext?: AnyPointer;
  pipelineBindPoint?: PipelineBindPoint;
  pipeline?: Pipeline;
  indirectCommandsLayout?: IndirectCommandsLayoutNV;
  maxSequencesCount?: number;
}

export class GeneratedCommandsMemoryRequirementsInfoNV implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeneratedCommandsMemoryRequirementsInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeneratedCommandsMemoryRequirementsInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(GeneratedCommandsMemoryRequirementsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeneratedCommandsMemoryRequirementsInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeneratedCommandsMemoryRequirementsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.pipeline !== undefined) this.pipeline = data.pipeline;
      if (data.indirectCommandsLayout !== undefined) this.indirectCommandsLayout = data.indirectCommandsLayout;
      if (data.maxSequencesCount !== undefined) this.maxSequencesCount = data.maxSequencesCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pipeline(value: Pipeline) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get indirectCommandsLayout() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indirectCommandsLayout(value: IndirectCommandsLayoutNV) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get maxSequencesCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxSequencesCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFeatures2 {
  pNext?: AnyPointer;
  features?: PhysicalDeviceFeatures;
}

export class PhysicalDeviceFeatures2 implements BaseStruct {
  static size = 240;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFeatures2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFeatures2) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFeatures2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFeatures2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFeatures2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.features !== undefined) this.features = data.features;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get features() {
    return new PhysicalDeviceFeatures(this.#data.subarray(16, 16 + PhysicalDeviceFeatures.size));
  }
  
  set features(value: PhysicalDeviceFeatures) {
    if (value[BUFFER].byteLength < PhysicalDeviceFeatures.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceProperties2 {
  pNext?: AnyPointer;
  properties?: PhysicalDeviceProperties;
}

export class PhysicalDeviceProperties2 implements BaseStruct {
  static size = 536;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProperties2) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.properties !== undefined) this.properties = data.properties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get properties() {
    return new PhysicalDeviceProperties(this.#data.subarray(16, 16 + PhysicalDeviceProperties.size));
  }
  
  set properties(value: PhysicalDeviceProperties) {
    if (value[BUFFER].byteLength < PhysicalDeviceProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitFormatProperties2 {
  pNext?: AnyPointer;
  formatProperties?: FormatProperties;
}

export class FormatProperties2 implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFormatProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFormatProperties2) {
    if (!data) {
      this.#data = new Uint8Array(FormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FormatProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.formatProperties !== undefined) this.formatProperties = data.formatProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get formatProperties() {
    return new FormatProperties(this.#data.subarray(16, 16 + FormatProperties.size));
  }
  
  set formatProperties(value: FormatProperties) {
    if (value[BUFFER].byteLength < FormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitImageFormatProperties2 {
  pNext?: AnyPointer;
  imageFormatProperties?: ImageFormatProperties;
}

export class ImageFormatProperties2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageFormatProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageFormatProperties2) {
    if (!data) {
      this.#data = new Uint8Array(ImageFormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageFormatProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageFormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageFormatProperties !== undefined) this.imageFormatProperties = data.imageFormatProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageFormatProperties() {
    return new ImageFormatProperties(this.#data.subarray(16, 16 + ImageFormatProperties.size));
  }
  
  set imageFormatProperties(value: ImageFormatProperties) {
    if (value[BUFFER].byteLength < ImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceImageFormatInfo2 {
  pNext?: AnyPointer;
  format?: Format;
  type?: ImageType;
  tiling?: ImageTiling;
  usage?: ImageUsageFlags;
  flags?: ImageCreateFlags;
}

export class PhysicalDeviceImageFormatInfo2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageFormatInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageFormatInfo2) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageFormatInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageFormatInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageFormatInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.type !== undefined) this.type = data.type;
      if (data.tiling !== undefined) this.tiling = data.tiling;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: ImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(24, LE);
  }
  
  set tiling(value: ImageTiling) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(28, LE);
  }
  
  set usage(value: ImageUsageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: ImageCreateFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitQueueFamilyProperties2 {
  pNext?: AnyPointer;
  queueFamilyProperties?: QueueFamilyProperties;
}

export class QueueFamilyProperties2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyProperties2) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.queueFamilyProperties !== undefined) this.queueFamilyProperties = data.queueFamilyProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get queueFamilyProperties() {
    return new QueueFamilyProperties(this.#data.subarray(16, 16 + QueueFamilyProperties.size));
  }
  
  set queueFamilyProperties(value: QueueFamilyProperties) {
    if (value[BUFFER].byteLength < QueueFamilyProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceMemoryProperties2 {
  pNext?: AnyPointer;
  memoryProperties?: PhysicalDeviceMemoryProperties;
}

export class PhysicalDeviceMemoryProperties2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryProperties2) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryProperties !== undefined) this.memoryProperties = data.memoryProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryProperties() {
    return new PhysicalDeviceMemoryProperties(this.#data.subarray(16, 16 + PhysicalDeviceMemoryProperties.size));
  }
  
  set memoryProperties(value: PhysicalDeviceMemoryProperties) {
    if (value[BUFFER].byteLength < PhysicalDeviceMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSparseImageFormatProperties2 {
  pNext?: AnyPointer;
  properties?: SparseImageFormatProperties;
}

export class SparseImageFormatProperties2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageFormatProperties2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageFormatProperties2) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageFormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageFormatProperties2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageFormatProperties2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.properties !== undefined) this.properties = data.properties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get properties() {
    return new SparseImageFormatProperties(this.#data.subarray(16, 16 + SparseImageFormatProperties.size));
  }
  
  set properties(value: SparseImageFormatProperties) {
    if (value[BUFFER].byteLength < SparseImageFormatProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceSparseImageFormatInfo2 {
  pNext?: AnyPointer;
  format?: Format;
  type?: ImageType;
  samples?: SampleCountFlagBits;
  usage?: ImageUsageFlags;
  tiling?: ImageTiling;
}

export class PhysicalDeviceSparseImageFormatInfo2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSparseImageFormatInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSparseImageFormatInfo2) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSparseImageFormatInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSparseImageFormatInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSparseImageFormatInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.type !== undefined) this.type = data.type;
      if (data.samples !== undefined) this.samples = data.samples;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.tiling !== undefined) this.tiling = data.tiling;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: ImageType) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(24, LE);
  }
  
  set samples(value: SampleCountFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(28, LE);
  }
  
  set usage(value: ImageUsageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get tiling() {
    return this.#view.getUint32(32, LE);
  }
  
  set tiling(value: ImageTiling) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDevicePushDescriptorPropertiesKHR {
  pNext?: AnyPointer;
  maxPushDescriptors?: number;
}

export class PhysicalDevicePushDescriptorPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePushDescriptorPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePushDescriptorPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePushDescriptorPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePushDescriptorPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePushDescriptorPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxPushDescriptors !== undefined) this.maxPushDescriptors = data.maxPushDescriptors;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxPushDescriptors() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPushDescriptors(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitConformanceVersion {
  major?: number;
  minor?: number;
  subminor?: number;
  patch?: number;
}

export class ConformanceVersion implements BaseStruct {
  static size = 4;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitConformanceVersion);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitConformanceVersion) {
    if (!data) {
      this.#data = new Uint8Array(ConformanceVersion.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ConformanceVersion.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ConformanceVersion.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.major !== undefined) this.major = data.major;
      if (data.minor !== undefined) this.minor = data.minor;
      if (data.subminor !== undefined) this.subminor = data.subminor;
      if (data.patch !== undefined) this.patch = data.patch;
    }
  }
  
  get major() {
    return this.#view.getUint8(0);
  }
  
  set major(value: number) {
    this.#view.setUint8(0, Number(value));
  }
  
  get minor() {
    return this.#view.getUint8(1);
  }
  
  set minor(value: number) {
    this.#view.setUint8(1, Number(value));
  }
  
  get subminor() {
    return this.#view.getUint8(2);
  }
  
  set subminor(value: number) {
    this.#view.setUint8(2, Number(value));
  }
  
  get patch() {
    return this.#view.getUint8(3);
  }
  
  set patch(value: number) {
    this.#view.setUint8(3, Number(value));
  }
}

export interface InitPhysicalDeviceDriverProperties {
  pNext?: AnyPointer;
  driverID?: DriverId;
  driverName?: number[];
  driverInfo?: number[];
  conformanceVersion?: ConformanceVersion;
}

export class PhysicalDeviceDriverProperties implements BaseStruct {
  static size = 536;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDriverProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDriverProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDriverProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDriverProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDriverProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.driverID !== undefined) this.driverID = data.driverID;
      if (data.driverName !== undefined) this.driverName = data.driverName;
      if (data.driverInfo !== undefined) this.driverInfo = data.driverInfo;
      if (data.conformanceVersion !== undefined) this.conformanceVersion = data.conformanceVersion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get driverID() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverID(value: DriverId) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get driverName() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set driverName(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get driverInfo() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(276 + i * 1);
      })());
    }
    return result;
  }
  
  set driverInfo(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(276 + i * 1, Number(value[i]));
    }
  }
  
  get conformanceVersion() {
    return new ConformanceVersion(this.#data.subarray(532, 532 + ConformanceVersion.size));
  }
  
  set conformanceVersion(value: ConformanceVersion) {
    if (value[BUFFER].byteLength < ConformanceVersion.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 532);
  }
}

export interface InitPresentRegionsKHR {
  pNext?: AnyPointer;
  swapchainCount?: number;
  pRegions?: AnyPointer;
}

export class PresentRegionsKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentRegionsKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentRegionsKHR) {
    if (!data) {
      this.#data = new Uint8Array(PresentRegionsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentRegionsKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentRegionsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchainCount !== undefined) this.swapchainCount = data.swapchainCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPresentRegionKHR {
  rectangleCount?: number;
  pRectangles?: AnyPointer;
}

export class PresentRegionKHR implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentRegionKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentRegionKHR) {
    if (!data) {
      this.#data = new Uint8Array(PresentRegionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentRegionKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentRegionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.rectangleCount !== undefined) this.rectangleCount = data.rectangleCount;
      if (data.pRectangles !== undefined) this.pRectangles = data.pRectangles;
    }
  }
  
  get rectangleCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set rectangleCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pRectangles() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pRectangles(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRectLayerKHR {
  offset?: Offset2D;
  extent?: Extent2D;
  layer?: number;
}

export class RectLayerKHR implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRectLayerKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRectLayerKHR) {
    if (!data) {
      this.#data = new Uint8Array(RectLayerKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RectLayerKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RectLayerKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.extent !== undefined) this.extent = data.extent;
      if (data.layer !== undefined) this.layer = data.layer;
    }
  }
  
  get offset() {
    return new Offset2D(this.#data.subarray(0, 0 + Offset2D.size));
  }
  
  set offset(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get extent() {
    return new Extent2D(this.#data.subarray(8, 8 + Extent2D.size));
  }
  
  set extent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 8);
  }
  
  get layer() {
    return this.#view.getUint32(16, LE);
  }
  
  set layer(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVariablePointersFeatures {
  pNext?: AnyPointer;
  variablePointersStorageBuffer?: Bool32;
  variablePointers?: Bool32;
}

export class PhysicalDeviceVariablePointersFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVariablePointersFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVariablePointersFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVariablePointersFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVariablePointersFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVariablePointersFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.variablePointersStorageBuffer !== undefined) this.variablePointersStorageBuffer = data.variablePointersStorageBuffer;
      if (data.variablePointers !== undefined) this.variablePointers = data.variablePointers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get variablePointersStorageBuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set variablePointersStorageBuffer(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get variablePointers() {
    return this.#view.getUint32(20, LE);
  }
  
  set variablePointers(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitExternalMemoryProperties {
  externalMemoryFeatures?: ExternalMemoryFeatureFlags;
  exportFromImportedHandleTypes?: ExternalMemoryHandleTypeFlags;
  compatibleHandleTypes?: ExternalMemoryHandleTypeFlags;
}

export class ExternalMemoryProperties implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalMemoryProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalMemoryProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExternalMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalMemoryProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.externalMemoryFeatures !== undefined) this.externalMemoryFeatures = data.externalMemoryFeatures;
      if (data.exportFromImportedHandleTypes !== undefined) this.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
      if (data.compatibleHandleTypes !== undefined) this.compatibleHandleTypes = data.compatibleHandleTypes;
    }
  }
  
  get externalMemoryFeatures() {
    return this.#view.getUint32(0, LE);
  }
  
  set externalMemoryFeatures(value: ExternalMemoryFeatureFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(4, LE);
  }
  
  set exportFromImportedHandleTypes(value: ExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(8, LE);
  }
  
  set compatibleHandleTypes(value: ExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExternalImageFormatInfo {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class PhysicalDeviceExternalImageFormatInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalImageFormatInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalImageFormatInfo) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalImageFormatInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalImageFormatInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalImageFormatInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExternalImageFormatProperties {
  pNext?: AnyPointer;
  externalMemoryProperties?: ExternalMemoryProperties;
}

export class ExternalImageFormatProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalImageFormatProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalImageFormatProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExternalImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalImageFormatProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.externalMemoryProperties !== undefined) this.externalMemoryProperties = data.externalMemoryProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get externalMemoryProperties() {
    return new ExternalMemoryProperties(this.#data.subarray(16, 16 + ExternalMemoryProperties.size));
  }
  
  set externalMemoryProperties(value: ExternalMemoryProperties) {
    if (value[BUFFER].byteLength < ExternalMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceExternalBufferInfo {
  pNext?: AnyPointer;
  flags?: BufferCreateFlags;
  usage?: BufferUsageFlags;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class PhysicalDeviceExternalBufferInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalBufferInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalBufferInfo) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalBufferInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalBufferInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalBufferInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: BufferCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(20, LE);
  }
  
  set usage(value: BufferUsageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitExternalBufferProperties {
  pNext?: AnyPointer;
  externalMemoryProperties?: ExternalMemoryProperties;
}

export class ExternalBufferProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalBufferProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalBufferProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExternalBufferProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalBufferProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalBufferProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.externalMemoryProperties !== undefined) this.externalMemoryProperties = data.externalMemoryProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get externalMemoryProperties() {
    return new ExternalMemoryProperties(this.#data.subarray(16, 16 + ExternalMemoryProperties.size));
  }
  
  set externalMemoryProperties(value: ExternalMemoryProperties) {
    if (value[BUFFER].byteLength < ExternalMemoryProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDeviceIDProperties {
  pNext?: AnyPointer;
  deviceUUID?: number[];
  driverUUID?: number[];
  deviceLUID?: number[];
  deviceNodeMask?: number;
  deviceLUIDValid?: Bool32;
}

export class PhysicalDeviceIDProperties implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceIDProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceIDProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceIDProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceIDProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceIDProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceUUID !== undefined) this.deviceUUID = data.deviceUUID;
      if (data.driverUUID !== undefined) this.driverUUID = data.driverUUID;
      if (data.deviceLUID !== undefined) this.deviceLUID = data.deviceLUID;
      if (data.deviceNodeMask !== undefined) this.deviceNodeMask = data.deviceNodeMask;
      if (data.deviceLUIDValid !== undefined) this.deviceLUIDValid = data.deviceLUIDValid;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set deviceUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get driverUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(32 + i * 1);
      })());
    }
    return result;
  }
  
  set driverUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(32 + i * 1, Number(value[i]));
    }
  }
  
  get deviceLUID() {
    const result: number[] = [];
    for (let i = 0; i < 8; i++) {
      result.push((() => {
        return this.#view.getUint8(48 + i * 1);
      })());
    }
    return result;
  }
  
  set deviceLUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(48 + i * 1, Number(value[i]));
    }
  }
  
  get deviceNodeMask() {
    return this.#view.getUint32(56, LE);
  }
  
  set deviceNodeMask(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get deviceLUIDValid() {
    return this.#view.getUint32(60, LE);
  }
  
  set deviceLUIDValid(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitExternalMemoryImageCreateInfo {
  pNext?: AnyPointer;
  handleTypes?: ExternalMemoryHandleTypeFlags;
}

export class ExternalMemoryImageCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalMemoryImageCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalMemoryImageCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ExternalMemoryImageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalMemoryImageCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalMemoryImageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExternalMemoryBufferCreateInfo {
  pNext?: AnyPointer;
  handleTypes?: ExternalMemoryHandleTypeFlags;
}

export class ExternalMemoryBufferCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalMemoryBufferCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalMemoryBufferCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ExternalMemoryBufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalMemoryBufferCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalMemoryBufferCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExportMemoryAllocateInfo {
  pNext?: AnyPointer;
  handleTypes?: ExternalMemoryHandleTypeFlags;
}

export class ExportMemoryAllocateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMemoryAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMemoryAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ExportMemoryAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMemoryAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMemoryAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalMemoryHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImportMemoryWin32HandleInfoKHR {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagBits;
  handle?: Deno.PointerValue;
  name?: Deno.PointerValue;
}

export class ImportMemoryWin32HandleInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.handle !== undefined) this.handle = data.handle;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMemoryWin32HandleInfoKHR {
  pNext?: AnyPointer;
  pAttributes?: AnyPointer;
  dwAccess?: number;
  name?: Deno.PointerValue;
}

export class ExportMemoryWin32HandleInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMemoryWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMemoryWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ExportMemoryWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMemoryWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMemoryWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pAttributes !== undefined) this.pAttributes = data.pAttributes;
      if (data.dwAccess !== undefined) this.dwAccess = data.dwAccess;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImportMemoryZirconHandleInfoFUCHSIA {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagBits;
  handle?: Deno.PointerValue;
}

export class ImportMemoryZirconHandleInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryZirconHandleInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryZirconHandleInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryZirconHandleInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.handle !== undefined) this.handle = data.handle;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMemoryZirconHandlePropertiesFUCHSIA {
  pNext?: AnyPointer;
  memoryTypeBits?: number;
}

export class MemoryZirconHandlePropertiesFUCHSIA implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryZirconHandlePropertiesFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryZirconHandlePropertiesFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(MemoryZirconHandlePropertiesFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryZirconHandlePropertiesFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryZirconHandlePropertiesFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryGetZirconHandleInfoFUCHSIA {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class MemoryGetZirconHandleInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryGetZirconHandleInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryGetZirconHandleInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(MemoryGetZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryGetZirconHandleInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryGetZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitMemoryWin32HandlePropertiesKHR {
  pNext?: AnyPointer;
  memoryTypeBits?: number;
}

export class MemoryWin32HandlePropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryWin32HandlePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryWin32HandlePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(MemoryWin32HandlePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryWin32HandlePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryWin32HandlePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryGetWin32HandleInfoKHR {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class MemoryGetWin32HandleInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryGetWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryGetWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(MemoryGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryGetWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitImportMemoryFdInfoKHR {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagBits;
  fd?: number;
}

export class ImportMemoryFdInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.fd !== undefined) this.fd = data.fd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(20, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(20, Number(value), LE);
  }
}

export interface InitMemoryFdPropertiesKHR {
  pNext?: AnyPointer;
  memoryTypeBits?: number;
}

export class MemoryFdPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryFdPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryFdPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(MemoryFdPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryFdPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryFdPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryGetFdInfoKHR {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class MemoryGetFdInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryGetFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryGetFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(MemoryGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryGetFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitWin32KeyedMutexAcquireReleaseInfoKHR {
  pNext?: AnyPointer;
  acquireCount?: number;
  pAcquireSyncs?: AnyPointer;
  pAcquireKeys?: AnyPointer;
  pAcquireTimeouts?: AnyPointer;
  releaseCount?: number;
  pReleaseSyncs?: AnyPointer;
  pReleaseKeys?: AnyPointer;
}

export class Win32KeyedMutexAcquireReleaseInfoKHR implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWin32KeyedMutexAcquireReleaseInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWin32KeyedMutexAcquireReleaseInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(Win32KeyedMutexAcquireReleaseInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < Win32KeyedMutexAcquireReleaseInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(Win32KeyedMutexAcquireReleaseInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.acquireCount !== undefined) this.acquireCount = data.acquireCount;
      if (data.pAcquireSyncs !== undefined) this.pAcquireSyncs = data.pAcquireSyncs;
      if (data.pAcquireKeys !== undefined) this.pAcquireKeys = data.pAcquireKeys;
      if (data.pAcquireTimeouts !== undefined) this.pAcquireTimeouts = data.pAcquireTimeouts;
      if (data.releaseCount !== undefined) this.releaseCount = data.releaseCount;
      if (data.pReleaseSyncs !== undefined) this.pReleaseSyncs = data.pReleaseSyncs;
      if (data.pReleaseKeys !== undefined) this.pReleaseKeys = data.pReleaseKeys;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get acquireCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set acquireCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAcquireSyncs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAcquireSyncs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pAcquireKeys() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pAcquireKeys(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pAcquireTimeouts() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pAcquireTimeouts(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get releaseCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set releaseCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pReleaseSyncs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pReleaseSyncs(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pReleaseKeys() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pReleaseKeys(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceExternalSemaphoreInfo {
  pNext?: AnyPointer;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
}

export class PhysicalDeviceExternalSemaphoreInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalSemaphoreInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalSemaphoreInfo) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalSemaphoreInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalSemaphoreInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalSemaphoreInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExternalSemaphoreProperties {
  pNext?: AnyPointer;
  exportFromImportedHandleTypes?: ExternalSemaphoreHandleTypeFlags;
  compatibleHandleTypes?: ExternalSemaphoreHandleTypeFlags;
  externalSemaphoreFeatures?: ExternalSemaphoreFeatureFlags;
}

export class ExternalSemaphoreProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalSemaphoreProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalSemaphoreProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExternalSemaphoreProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalSemaphoreProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalSemaphoreProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.exportFromImportedHandleTypes !== undefined) this.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
      if (data.compatibleHandleTypes !== undefined) this.compatibleHandleTypes = data.compatibleHandleTypes;
      if (data.externalSemaphoreFeatures !== undefined) this.externalSemaphoreFeatures = data.externalSemaphoreFeatures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportFromImportedHandleTypes(value: ExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(20, LE);
  }
  
  set compatibleHandleTypes(value: ExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get externalSemaphoreFeatures() {
    return this.#view.getUint32(24, LE);
  }
  
  set externalSemaphoreFeatures(value: ExternalSemaphoreFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitExportSemaphoreCreateInfo {
  pNext?: AnyPointer;
  handleTypes?: ExternalSemaphoreHandleTypeFlags;
}

export class ExportSemaphoreCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportSemaphoreCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportSemaphoreCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ExportSemaphoreCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportSemaphoreCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportSemaphoreCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalSemaphoreHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImportSemaphoreWin32HandleInfoKHR {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  flags?: SemaphoreImportFlags;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
  handle?: Deno.PointerValue;
  name?: Deno.PointerValue;
}

export class ImportSemaphoreWin32HandleInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportSemaphoreWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportSemaphoreWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportSemaphoreWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportSemaphoreWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportSemaphoreWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.handle !== undefined) this.handle = data.handle;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: SemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportSemaphoreWin32HandleInfoKHR {
  pNext?: AnyPointer;
  pAttributes?: AnyPointer;
  dwAccess?: number;
  name?: Deno.PointerValue;
}

export class ExportSemaphoreWin32HandleInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportSemaphoreWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportSemaphoreWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ExportSemaphoreWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportSemaphoreWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportSemaphoreWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pAttributes !== undefined) this.pAttributes = data.pAttributes;
      if (data.dwAccess !== undefined) this.dwAccess = data.dwAccess;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitD3D12FenceSubmitInfoKHR {
  pNext?: AnyPointer;
  waitSemaphoreValuesCount?: number;
  pWaitSemaphoreValues?: AnyPointer;
  signalSemaphoreValuesCount?: number;
  pSignalSemaphoreValues?: AnyPointer;
}

export class D3D12FenceSubmitInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitD3D12FenceSubmitInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitD3D12FenceSubmitInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(D3D12FenceSubmitInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < D3D12FenceSubmitInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(D3D12FenceSubmitInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreValuesCount !== undefined) this.waitSemaphoreValuesCount = data.waitSemaphoreValuesCount;
      if (data.pWaitSemaphoreValues !== undefined) this.pWaitSemaphoreValues = data.pWaitSemaphoreValues;
      if (data.signalSemaphoreValuesCount !== undefined) this.signalSemaphoreValuesCount = data.signalSemaphoreValuesCount;
      if (data.pSignalSemaphoreValues !== undefined) this.pSignalSemaphoreValues = data.pSignalSemaphoreValues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreValuesCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreValuesCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreValues() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreValues(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreValuesCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set signalSemaphoreValuesCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSignalSemaphoreValues() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSignalSemaphoreValues(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSemaphoreGetWin32HandleInfoKHR {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
}

export class SemaphoreGetWin32HandleInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreGetWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreGetWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreGetWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitImportSemaphoreFdInfoKHR {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  flags?: SemaphoreImportFlags;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
  fd?: number;
}

export class ImportSemaphoreFdInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportSemaphoreFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportSemaphoreFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportSemaphoreFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportSemaphoreFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportSemaphoreFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.fd !== undefined) this.fd = data.fd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: SemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(32, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
}

export interface InitSemaphoreGetFdInfoKHR {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
}

export class SemaphoreGetFdInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreGetFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreGetFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreGetFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitImportSemaphoreZirconHandleInfoFUCHSIA {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  flags?: SemaphoreImportFlags;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
  zirconHandle?: Deno.PointerValue;
}

export class ImportSemaphoreZirconHandleInfoFUCHSIA implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportSemaphoreZirconHandleInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportSemaphoreZirconHandleInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImportSemaphoreZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportSemaphoreZirconHandleInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportSemaphoreZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.zirconHandle !== undefined) this.zirconHandle = data.zirconHandle;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: SemaphoreImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get zirconHandle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set zirconHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSemaphoreGetZirconHandleInfoFUCHSIA {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  handleType?: ExternalSemaphoreHandleTypeFlagBits;
}

export class SemaphoreGetZirconHandleInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreGetZirconHandleInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreGetZirconHandleInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreGetZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreGetZirconHandleInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreGetZirconHandleInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalSemaphoreHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExternalFenceInfo {
  pNext?: AnyPointer;
  handleType?: ExternalFenceHandleTypeFlagBits;
}

export class PhysicalDeviceExternalFenceInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalFenceInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalFenceInfo) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalFenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalFenceInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalFenceInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExternalFenceProperties {
  pNext?: AnyPointer;
  exportFromImportedHandleTypes?: ExternalFenceHandleTypeFlags;
  compatibleHandleTypes?: ExternalFenceHandleTypeFlags;
  externalFenceFeatures?: ExternalFenceFeatureFlags;
}

export class ExternalFenceProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalFenceProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalFenceProperties) {
    if (!data) {
      this.#data = new Uint8Array(ExternalFenceProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalFenceProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalFenceProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.exportFromImportedHandleTypes !== undefined) this.exportFromImportedHandleTypes = data.exportFromImportedHandleTypes;
      if (data.compatibleHandleTypes !== undefined) this.compatibleHandleTypes = data.compatibleHandleTypes;
      if (data.externalFenceFeatures !== undefined) this.externalFenceFeatures = data.externalFenceFeatures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get exportFromImportedHandleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportFromImportedHandleTypes(value: ExternalFenceHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compatibleHandleTypes() {
    return this.#view.getUint32(20, LE);
  }
  
  set compatibleHandleTypes(value: ExternalFenceHandleTypeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get externalFenceFeatures() {
    return this.#view.getUint32(24, LE);
  }
  
  set externalFenceFeatures(value: ExternalFenceFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitExportFenceCreateInfo {
  pNext?: AnyPointer;
  handleTypes?: ExternalFenceHandleTypeFlags;
}

export class ExportFenceCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportFenceCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportFenceCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ExportFenceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportFenceCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportFenceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleTypes !== undefined) this.handleTypes = data.handleTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleTypes(value: ExternalFenceHandleTypeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImportFenceWin32HandleInfoKHR {
  pNext?: AnyPointer;
  fence?: Fence;
  flags?: FenceImportFlags;
  handleType?: ExternalFenceHandleTypeFlagBits;
  handle?: Deno.PointerValue;
  name?: Deno.PointerValue;
}

export class ImportFenceWin32HandleInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportFenceWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportFenceWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportFenceWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportFenceWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportFenceWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fence !== undefined) this.fence = data.fence;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.handle !== undefined) this.handle = data.handle;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: Fence) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: FenceImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: ExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set handle(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportFenceWin32HandleInfoKHR {
  pNext?: AnyPointer;
  pAttributes?: AnyPointer;
  dwAccess?: number;
  name?: Deno.PointerValue;
}

export class ExportFenceWin32HandleInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportFenceWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportFenceWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ExportFenceWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportFenceWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportFenceWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pAttributes !== undefined) this.pAttributes = data.pAttributes;
      if (data.dwAccess !== undefined) this.dwAccess = data.dwAccess;
      if (data.name !== undefined) this.name = data.name;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pAttributes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pAttributes(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dwAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set dwAccess(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get name() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set name(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitFenceGetWin32HandleInfoKHR {
  pNext?: AnyPointer;
  fence?: Fence;
  handleType?: ExternalFenceHandleTypeFlagBits;
}

export class FenceGetWin32HandleInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFenceGetWin32HandleInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFenceGetWin32HandleInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(FenceGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FenceGetWin32HandleInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FenceGetWin32HandleInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fence !== undefined) this.fence = data.fence;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: Fence) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitImportFenceFdInfoKHR {
  pNext?: AnyPointer;
  fence?: Fence;
  flags?: FenceImportFlags;
  handleType?: ExternalFenceHandleTypeFlagBits;
  fd?: number;
}

export class ImportFenceFdInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportFenceFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportFenceFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImportFenceFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportFenceFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportFenceFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fence !== undefined) this.fence = data.fence;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.fd !== undefined) this.fd = data.fd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: Fence) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(24, LE);
  }
  
  set flags(value: FenceImportFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(28, LE);
  }
  
  set handleType(value: ExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get fd() {
    return this.#view.getInt32(32, LE);
  }
  
  set fd(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
}

export interface InitFenceGetFdInfoKHR {
  pNext?: AnyPointer;
  fence?: Fence;
  handleType?: ExternalFenceHandleTypeFlagBits;
}

export class FenceGetFdInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFenceGetFdInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFenceGetFdInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(FenceGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FenceGetFdInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FenceGetFdInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fence !== undefined) this.fence = data.fence;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set fence(value: Fence) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalFenceHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMultiviewFeatures {
  pNext?: AnyPointer;
  multiview?: Bool32;
  multiviewGeometryShader?: Bool32;
  multiviewTessellationShader?: Bool32;
}

export class PhysicalDeviceMultiviewFeatures implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultiviewFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultiviewFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultiviewFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.multiview !== undefined) this.multiview = data.multiview;
      if (data.multiviewGeometryShader !== undefined) this.multiviewGeometryShader = data.multiviewGeometryShader;
      if (data.multiviewTessellationShader !== undefined) this.multiviewTessellationShader = data.multiviewTessellationShader;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get multiview() {
    return this.#view.getUint32(16, LE);
  }
  
  set multiview(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get multiviewGeometryShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set multiviewGeometryShader(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get multiviewTessellationShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set multiviewTessellationShader(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMultiviewProperties {
  pNext?: AnyPointer;
  maxMultiviewViewCount?: number;
  maxMultiviewInstanceIndex?: number;
}

export class PhysicalDeviceMultiviewProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultiviewProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultiviewProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultiviewProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxMultiviewViewCount !== undefined) this.maxMultiviewViewCount = data.maxMultiviewViewCount;
      if (data.maxMultiviewInstanceIndex !== undefined) this.maxMultiviewInstanceIndex = data.maxMultiviewInstanceIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxMultiviewViewCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxMultiviewViewCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxMultiviewInstanceIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxMultiviewInstanceIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitRenderPassMultiviewCreateInfo {
  pNext?: AnyPointer;
  subpassCount?: number;
  pViewMasks?: AnyPointer;
  dependencyCount?: number;
  pViewOffsets?: AnyPointer;
  correlationMaskCount?: number;
  pCorrelationMasks?: AnyPointer;
}

export class RenderPassMultiviewCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassMultiviewCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassMultiviewCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassMultiviewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassMultiviewCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassMultiviewCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subpassCount !== undefined) this.subpassCount = data.subpassCount;
      if (data.pViewMasks !== undefined) this.pViewMasks = data.pViewMasks;
      if (data.dependencyCount !== undefined) this.dependencyCount = data.dependencyCount;
      if (data.pViewOffsets !== undefined) this.pViewOffsets = data.pViewOffsets;
      if (data.correlationMaskCount !== undefined) this.correlationMaskCount = data.correlationMaskCount;
      if (data.pCorrelationMasks !== undefined) this.pCorrelationMasks = data.pCorrelationMasks;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pViewMasks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewMasks(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pViewOffsets() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pViewOffsets(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get correlationMaskCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set correlationMaskCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pCorrelationMasks() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pCorrelationMasks(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSurfaceCapabilities2EXT {
  pNext?: AnyPointer;
  minImageCount?: number;
  maxImageCount?: number;
  currentExtent?: Extent2D;
  minImageExtent?: Extent2D;
  maxImageExtent?: Extent2D;
  maxImageArrayLayers?: number;
  supportedTransforms?: SurfaceTransformFlagsKHR;
  currentTransform?: SurfaceTransformFlagBitsKHR;
  supportedCompositeAlpha?: CompositeAlphaFlagsKHR;
  supportedUsageFlags?: ImageUsageFlags;
  supportedSurfaceCounters?: SurfaceCounterFlagsEXT;
}

export class SurfaceCapabilities2EXT implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceCapabilities2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceCapabilities2EXT) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceCapabilities2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceCapabilities2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceCapabilities2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minImageCount !== undefined) this.minImageCount = data.minImageCount;
      if (data.maxImageCount !== undefined) this.maxImageCount = data.maxImageCount;
      if (data.currentExtent !== undefined) this.currentExtent = data.currentExtent;
      if (data.minImageExtent !== undefined) this.minImageExtent = data.minImageExtent;
      if (data.maxImageExtent !== undefined) this.maxImageExtent = data.maxImageExtent;
      if (data.maxImageArrayLayers !== undefined) this.maxImageArrayLayers = data.maxImageArrayLayers;
      if (data.supportedTransforms !== undefined) this.supportedTransforms = data.supportedTransforms;
      if (data.currentTransform !== undefined) this.currentTransform = data.currentTransform;
      if (data.supportedCompositeAlpha !== undefined) this.supportedCompositeAlpha = data.supportedCompositeAlpha;
      if (data.supportedUsageFlags !== undefined) this.supportedUsageFlags = data.supportedUsageFlags;
      if (data.supportedSurfaceCounters !== undefined) this.supportedSurfaceCounters = data.supportedSurfaceCounters;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minImageCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set minImageCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxImageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxImageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get currentExtent() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set currentExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get minImageExtent() {
    return new Extent2D(this.#data.subarray(32, 32 + Extent2D.size));
  }
  
  set minImageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get maxImageExtent() {
    return new Extent2D(this.#data.subarray(40, 40 + Extent2D.size));
  }
  
  set maxImageExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get maxImageArrayLayers() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxImageArrayLayers(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get supportedTransforms() {
    return this.#view.getUint32(52, LE);
  }
  
  set supportedTransforms(value: SurfaceTransformFlagsKHR) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get currentTransform() {
    return this.#view.getUint32(56, LE);
  }
  
  set currentTransform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get supportedCompositeAlpha() {
    return this.#view.getUint32(60, LE);
  }
  
  set supportedCompositeAlpha(value: CompositeAlphaFlagsKHR) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get supportedUsageFlags() {
    return this.#view.getUint32(64, LE);
  }
  
  set supportedUsageFlags(value: ImageUsageFlags) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get supportedSurfaceCounters() {
    return this.#view.getUint32(68, LE);
  }
  
  set supportedSurfaceCounters(value: SurfaceCounterFlagsEXT) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export interface InitDisplayPowerInfoEXT {
  pNext?: AnyPointer;
  powerState?: DisplayPowerStateEXT;
}

export class DisplayPowerInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPowerInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPowerInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPowerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPowerInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPowerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.powerState !== undefined) this.powerState = data.powerState;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get powerState() {
    return this.#view.getUint32(16, LE);
  }
  
  set powerState(value: DisplayPowerStateEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceEventInfoEXT {
  pNext?: AnyPointer;
  deviceEvent?: DeviceEventTypeEXT;
}

export class DeviceEventInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceEventInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceEventInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceEventInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceEvent !== undefined) this.deviceEvent = data.deviceEvent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceEvent() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceEvent(value: DeviceEventTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDisplayEventInfoEXT {
  pNext?: AnyPointer;
  displayEvent?: DisplayEventTypeEXT;
}

export class DisplayEventInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayEventInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayEventInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DisplayEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayEventInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.displayEvent !== undefined) this.displayEvent = data.displayEvent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get displayEvent() {
    return this.#view.getUint32(16, LE);
  }
  
  set displayEvent(value: DisplayEventTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSwapchainCounterCreateInfoEXT {
  pNext?: AnyPointer;
  surfaceCounters?: SurfaceCounterFlagsEXT;
}

export class SwapchainCounterCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSwapchainCounterCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSwapchainCounterCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SwapchainCounterCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SwapchainCounterCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SwapchainCounterCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.surfaceCounters !== undefined) this.surfaceCounters = data.surfaceCounters;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get surfaceCounters() {
    return this.#view.getUint32(16, LE);
  }
  
  set surfaceCounters(value: SurfaceCounterFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceGroupProperties {
  pNext?: AnyPointer;
  physicalDeviceCount?: number;
  physicalDevices?: PhysicalDevice[];
  subsetAllocation?: Bool32;
}

export class PhysicalDeviceGroupProperties implements BaseStruct {
  static size = 288;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceGroupProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceGroupProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceGroupProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceGroupProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceGroupProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.physicalDeviceCount !== undefined) this.physicalDeviceCount = data.physicalDeviceCount;
      if (data.physicalDevices !== undefined) this.physicalDevices = data.physicalDevices;
      if (data.subsetAllocation !== undefined) this.subsetAllocation = data.subsetAllocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get physicalDeviceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set physicalDeviceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get physicalDevices() {
    const result: PhysicalDevice[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getBigUint64(24 + i * 8, LE);
      })());
    }
    return result;
  }
  
  set physicalDevices(value: PhysicalDevice[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setBigUint64(24 + i * 8, BigInt(anyPointer(value[i])), LE);
    }
  }
  
  get subsetAllocation() {
    return this.#view.getUint32(280, LE);
  }
  
  set subsetAllocation(value: Bool32) {
    this.#view.setUint32(280, Number(value), LE);
  }
}

export interface InitMemoryAllocateFlagsInfo {
  pNext?: AnyPointer;
  flags?: MemoryAllocateFlags;
  deviceMask?: number;
}

export class MemoryAllocateFlagsInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryAllocateFlagsInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryAllocateFlagsInfo) {
    if (!data) {
      this.#data = new Uint8Array(MemoryAllocateFlagsInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryAllocateFlagsInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryAllocateFlagsInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.deviceMask !== undefined) this.deviceMask = data.deviceMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: MemoryAllocateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitBindBufferMemoryInfo {
  pNext?: AnyPointer;
  buffer?: Buffer;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
}

export class BindBufferMemoryInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindBufferMemoryInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindBufferMemoryInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindBufferMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindBufferMemoryInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindBufferMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitBindBufferMemoryDeviceGroupInfo {
  pNext?: AnyPointer;
  deviceIndexCount?: number;
  pDeviceIndices?: AnyPointer;
}

export class BindBufferMemoryDeviceGroupInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindBufferMemoryDeviceGroupInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindBufferMemoryDeviceGroupInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindBufferMemoryDeviceGroupInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindBufferMemoryDeviceGroupInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindBufferMemoryDeviceGroupInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceIndexCount !== undefined) this.deviceIndexCount = data.deviceIndexCount;
      if (data.pDeviceIndices !== undefined) this.pDeviceIndices = data.pDeviceIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceIndices(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBindImageMemoryInfo {
  pNext?: AnyPointer;
  image?: Image;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
}

export class BindImageMemoryInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindImageMemoryInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindImageMemoryInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindImageMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindImageMemoryInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindImageMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitBindImageMemoryDeviceGroupInfo {
  pNext?: AnyPointer;
  deviceIndexCount?: number;
  pDeviceIndices?: AnyPointer;
  splitInstanceBindRegionCount?: number;
  pSplitInstanceBindRegions?: AnyPointer;
}

export class BindImageMemoryDeviceGroupInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindImageMemoryDeviceGroupInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindImageMemoryDeviceGroupInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindImageMemoryDeviceGroupInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindImageMemoryDeviceGroupInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindImageMemoryDeviceGroupInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceIndexCount !== undefined) this.deviceIndexCount = data.deviceIndexCount;
      if (data.pDeviceIndices !== undefined) this.pDeviceIndices = data.pDeviceIndices;
      if (data.splitInstanceBindRegionCount !== undefined) this.splitInstanceBindRegionCount = data.splitInstanceBindRegionCount;
      if (data.pSplitInstanceBindRegions !== undefined) this.pSplitInstanceBindRegions = data.pSplitInstanceBindRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceIndices(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get splitInstanceBindRegionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set splitInstanceBindRegionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSplitInstanceBindRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSplitInstanceBindRegions(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceGroupRenderPassBeginInfo {
  pNext?: AnyPointer;
  deviceMask?: number;
  deviceRenderAreaCount?: number;
  pDeviceRenderAreas?: AnyPointer;
}

export class DeviceGroupRenderPassBeginInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupRenderPassBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupRenderPassBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupRenderPassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupRenderPassBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupRenderPassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceMask !== undefined) this.deviceMask = data.deviceMask;
      if (data.deviceRenderAreaCount !== undefined) this.deviceRenderAreaCount = data.deviceRenderAreaCount;
      if (data.pDeviceRenderAreas !== undefined) this.pDeviceRenderAreas = data.pDeviceRenderAreas;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceRenderAreaCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceRenderAreaCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDeviceRenderAreas() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceRenderAreas(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceGroupCommandBufferBeginInfo {
  pNext?: AnyPointer;
  deviceMask?: number;
}

export class DeviceGroupCommandBufferBeginInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupCommandBufferBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupCommandBufferBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupCommandBufferBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupCommandBufferBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupCommandBufferBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceMask !== undefined) this.deviceMask = data.deviceMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceGroupSubmitInfo {
  pNext?: AnyPointer;
  waitSemaphoreCount?: number;
  pWaitSemaphoreDeviceIndices?: AnyPointer;
  commandBufferCount?: number;
  pCommandBufferDeviceMasks?: AnyPointer;
  signalSemaphoreCount?: number;
  pSignalSemaphoreDeviceIndices?: AnyPointer;
}

export class DeviceGroupSubmitInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupSubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreCount !== undefined) this.waitSemaphoreCount = data.waitSemaphoreCount;
      if (data.pWaitSemaphoreDeviceIndices !== undefined) this.pWaitSemaphoreDeviceIndices = data.pWaitSemaphoreDeviceIndices;
      if (data.commandBufferCount !== undefined) this.commandBufferCount = data.commandBufferCount;
      if (data.pCommandBufferDeviceMasks !== undefined) this.pCommandBufferDeviceMasks = data.pCommandBufferDeviceMasks;
      if (data.signalSemaphoreCount !== undefined) this.signalSemaphoreCount = data.signalSemaphoreCount;
      if (data.pSignalSemaphoreDeviceIndices !== undefined) this.pSignalSemaphoreDeviceIndices = data.pSignalSemaphoreDeviceIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreDeviceIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreDeviceIndices(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get commandBufferCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set commandBufferCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pCommandBufferDeviceMasks() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCommandBufferDeviceMasks(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set signalSemaphoreCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pSignalSemaphoreDeviceIndices() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pSignalSemaphoreDeviceIndices(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceGroupBindSparseInfo {
  pNext?: AnyPointer;
  resourceDeviceIndex?: number;
  memoryDeviceIndex?: number;
}

export class DeviceGroupBindSparseInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupBindSparseInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupBindSparseInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupBindSparseInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupBindSparseInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupBindSparseInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.resourceDeviceIndex !== undefined) this.resourceDeviceIndex = data.resourceDeviceIndex;
      if (data.memoryDeviceIndex !== undefined) this.memoryDeviceIndex = data.memoryDeviceIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get resourceDeviceIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set resourceDeviceIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryDeviceIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set memoryDeviceIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitDeviceGroupPresentCapabilitiesKHR {
  pNext?: AnyPointer;
  presentMask?: number[];
  modes?: DeviceGroupPresentModeFlagsKHR;
}

export class DeviceGroupPresentCapabilitiesKHR implements BaseStruct {
  static size = 152;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupPresentCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupPresentCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupPresentCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupPresentCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupPresentCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentMask !== undefined) this.presentMask = data.presentMask;
      if (data.modes !== undefined) this.modes = data.modes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentMask() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint32(16 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set presentMask(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(16 + i * 4, Number(value[i]), LE);
    }
  }
  
  get modes() {
    return this.#view.getUint32(144, LE);
  }
  
  set modes(value: DeviceGroupPresentModeFlagsKHR) {
    this.#view.setUint32(144, Number(value), LE);
  }
}

export interface InitImageSwapchainCreateInfoKHR {
  pNext?: AnyPointer;
  swapchain?: SwapchainKHR;
}

export class ImageSwapchainCreateInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSwapchainCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSwapchainCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(ImageSwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSwapchainCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchain !== undefined) this.swapchain = data.swapchain;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: SwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBindImageMemorySwapchainInfoKHR {
  pNext?: AnyPointer;
  swapchain?: SwapchainKHR;
  imageIndex?: number;
}

export class BindImageMemorySwapchainInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindImageMemorySwapchainInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindImageMemorySwapchainInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(BindImageMemorySwapchainInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindImageMemorySwapchainInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindImageMemorySwapchainInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchain !== undefined) this.swapchain = data.swapchain;
      if (data.imageIndex !== undefined) this.imageIndex = data.imageIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: SwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get imageIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitAcquireNextImageInfoKHR {
  pNext?: AnyPointer;
  swapchain?: SwapchainKHR;
  timeout?: Deno.PointerValue;
  semaphore?: Semaphore;
  fence?: Fence;
  deviceMask?: number;
}

export class AcquireNextImageInfoKHR implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAcquireNextImageInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAcquireNextImageInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AcquireNextImageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AcquireNextImageInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AcquireNextImageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchain !== undefined) this.swapchain = data.swapchain;
      if (data.timeout !== undefined) this.timeout = data.timeout;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.fence !== undefined) this.fence = data.fence;
      if (data.deviceMask !== undefined) this.deviceMask = data.deviceMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchain() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set swapchain(value: SwapchainKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get timeout() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set timeout(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get fence() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set fence(value: Fence) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(48, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitDeviceGroupPresentInfoKHR {
  pNext?: AnyPointer;
  swapchainCount?: number;
  pDeviceMasks?: AnyPointer;
  mode?: DeviceGroupPresentModeFlagBitsKHR;
}

export class DeviceGroupPresentInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupPresentInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupPresentInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupPresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupPresentInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupPresentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchainCount !== undefined) this.swapchainCount = data.swapchainCount;
      if (data.pDeviceMasks !== undefined) this.pDeviceMasks = data.pDeviceMasks;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDeviceMasks() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDeviceMasks(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: DeviceGroupPresentModeFlagBitsKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitDeviceGroupDeviceCreateInfo {
  pNext?: AnyPointer;
  physicalDeviceCount?: number;
  pPhysicalDevices?: AnyPointer;
}

export class DeviceGroupDeviceCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupDeviceCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupDeviceCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupDeviceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupDeviceCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupDeviceCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.physicalDeviceCount !== undefined) this.physicalDeviceCount = data.physicalDeviceCount;
      if (data.pPhysicalDevices !== undefined) this.pPhysicalDevices = data.pPhysicalDevices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get physicalDeviceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set physicalDeviceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pPhysicalDevices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPhysicalDevices(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceGroupSwapchainCreateInfoKHR {
  pNext?: AnyPointer;
  modes?: DeviceGroupPresentModeFlagsKHR;
}

export class DeviceGroupSwapchainCreateInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceGroupSwapchainCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceGroupSwapchainCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DeviceGroupSwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceGroupSwapchainCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceGroupSwapchainCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.modes !== undefined) this.modes = data.modes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get modes() {
    return this.#view.getUint32(16, LE);
  }
  
  set modes(value: DeviceGroupPresentModeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDescriptorUpdateTemplateEntry {
  dstBinding?: number;
  dstArrayElement?: number;
  descriptorCount?: number;
  descriptorType?: DescriptorType;
  offset?: Deno.PointerValue;
  stride?: Deno.PointerValue;
}

export class DescriptorUpdateTemplateEntry implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorUpdateTemplateEntry);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorUpdateTemplateEntry) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorUpdateTemplateEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorUpdateTemplateEntry.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorUpdateTemplateEntry.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.dstBinding !== undefined) this.dstBinding = data.dstBinding;
      if (data.dstArrayElement !== undefined) this.dstArrayElement = data.dstArrayElement;
      if (data.descriptorCount !== undefined) this.descriptorCount = data.descriptorCount;
      if (data.descriptorType !== undefined) this.descriptorType = data.descriptorType;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.stride !== undefined) this.stride = data.stride;
    }
  }
  
  get dstBinding() {
    return this.#view.getUint32(0, LE);
  }
  
  set dstBinding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstArrayElement() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstArrayElement(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get descriptorCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set descriptorCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(12, LE);
  }
  
  set descriptorType(value: DescriptorType) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set offset(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get stride() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set stride(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitDescriptorUpdateTemplateCreateInfo {
  pNext?: AnyPointer;
  flags?: DescriptorUpdateTemplateCreateFlags;
  descriptorUpdateEntryCount?: number;
  pDescriptorUpdateEntries?: AnyPointer;
  templateType?: DescriptorUpdateTemplateType;
  descriptorSetLayout?: DescriptorSetLayout;
  pipelineBindPoint?: PipelineBindPoint;
  pipelineLayout?: PipelineLayout;
  set?: number;
}

export class DescriptorUpdateTemplateCreateInfo implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorUpdateTemplateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorUpdateTemplateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorUpdateTemplateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorUpdateTemplateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorUpdateTemplateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.descriptorUpdateEntryCount !== undefined) this.descriptorUpdateEntryCount = data.descriptorUpdateEntryCount;
      if (data.pDescriptorUpdateEntries !== undefined) this.pDescriptorUpdateEntries = data.pDescriptorUpdateEntries;
      if (data.templateType !== undefined) this.templateType = data.templateType;
      if (data.descriptorSetLayout !== undefined) this.descriptorSetLayout = data.descriptorSetLayout;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.pipelineLayout !== undefined) this.pipelineLayout = data.pipelineLayout;
      if (data.set !== undefined) this.set = data.set;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DescriptorUpdateTemplateCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorUpdateEntryCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorUpdateEntryCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDescriptorUpdateEntries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDescriptorUpdateEntries(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get templateType() {
    return this.#view.getUint32(32, LE);
  }
  
  set templateType(value: DescriptorUpdateTemplateType) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get descriptorSetLayout() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set descriptorSetLayout(value: DescriptorSetLayout) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(48, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pipelineLayout() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pipelineLayout(value: PipelineLayout) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get set() {
    return this.#view.getUint32(64, LE);
  }
  
  set set(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
}

export interface InitXYColorEXT {
  x?: number;
  y?: number;
}

/** Chromaticity coordinate */
export class XYColorEXT implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitXYColorEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitXYColorEXT) {
    if (!data) {
      this.#data = new Uint8Array(XYColorEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < XYColorEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(XYColorEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
    }
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export interface InitPhysicalDevicePresentIdFeaturesKHR {
  pNext?: AnyPointer;
  presentId?: Bool32;
}

export class PhysicalDevicePresentIdFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePresentIdFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePresentIdFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePresentIdFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePresentIdFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePresentIdFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentId !== undefined) this.presentId = data.presentId;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentId() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentId(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPresentIdKHR {
  pNext?: AnyPointer;
  swapchainCount?: number;
  pPresentIds?: AnyPointer;
}

export class PresentIdKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentIdKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentIdKHR) {
    if (!data) {
      this.#data = new Uint8Array(PresentIdKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentIdKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentIdKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRESENT_ID_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchainCount !== undefined) this.swapchainCount = data.swapchainCount;
      if (data.pPresentIds !== undefined) this.pPresentIds = data.pPresentIds;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pPresentIds() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPresentIds(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDevicePresentWaitFeaturesKHR {
  pNext?: AnyPointer;
  presentWait?: Bool32;
}

export class PhysicalDevicePresentWaitFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePresentWaitFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePresentWaitFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePresentWaitFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePresentWaitFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePresentWaitFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentWait !== undefined) this.presentWait = data.presentWait;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentWait() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentWait(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitHdrMetadataEXT {
  pNext?: AnyPointer;
  displayPrimaryRed?: XYColorEXT;
  displayPrimaryGreen?: XYColorEXT;
  displayPrimaryBlue?: XYColorEXT;
  whitePoint?: XYColorEXT;
  maxLuminance?: number;
  minLuminance?: number;
  maxContentLightLevel?: number;
  maxFrameAverageLightLevel?: number;
}

export class HdrMetadataEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitHdrMetadataEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitHdrMetadataEXT) {
    if (!data) {
      this.#data = new Uint8Array(HdrMetadataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < HdrMetadataEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(HdrMetadataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_HDR_METADATA_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.displayPrimaryRed !== undefined) this.displayPrimaryRed = data.displayPrimaryRed;
      if (data.displayPrimaryGreen !== undefined) this.displayPrimaryGreen = data.displayPrimaryGreen;
      if (data.displayPrimaryBlue !== undefined) this.displayPrimaryBlue = data.displayPrimaryBlue;
      if (data.whitePoint !== undefined) this.whitePoint = data.whitePoint;
      if (data.maxLuminance !== undefined) this.maxLuminance = data.maxLuminance;
      if (data.minLuminance !== undefined) this.minLuminance = data.minLuminance;
      if (data.maxContentLightLevel !== undefined) this.maxContentLightLevel = data.maxContentLightLevel;
      if (data.maxFrameAverageLightLevel !== undefined) this.maxFrameAverageLightLevel = data.maxFrameAverageLightLevel;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get displayPrimaryRed() {
    return new XYColorEXT(this.#data.subarray(16, 16 + XYColorEXT.size));
  }
  
  set displayPrimaryRed(value: XYColorEXT) {
    if (value[BUFFER].byteLength < XYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get displayPrimaryGreen() {
    return new XYColorEXT(this.#data.subarray(24, 24 + XYColorEXT.size));
  }
  
  set displayPrimaryGreen(value: XYColorEXT) {
    if (value[BUFFER].byteLength < XYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get displayPrimaryBlue() {
    return new XYColorEXT(this.#data.subarray(32, 32 + XYColorEXT.size));
  }
  
  set displayPrimaryBlue(value: XYColorEXT) {
    if (value[BUFFER].byteLength < XYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get whitePoint() {
    return new XYColorEXT(this.#data.subarray(40, 40 + XYColorEXT.size));
  }
  
  set whitePoint(value: XYColorEXT) {
    if (value[BUFFER].byteLength < XYColorEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get maxLuminance() {
    return this.#view.getFloat32(48, LE);
  }
  
  set maxLuminance(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get minLuminance() {
    return this.#view.getFloat32(52, LE);
  }
  
  set minLuminance(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get maxContentLightLevel() {
    return this.#view.getFloat32(56, LE);
  }
  
  set maxContentLightLevel(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
  
  get maxFrameAverageLightLevel() {
    return this.#view.getFloat32(60, LE);
  }
  
  set maxFrameAverageLightLevel(value: number) {
    this.#view.setFloat32(60, Number(value), LE);
  }
}

export interface InitDisplayNativeHdrSurfaceCapabilitiesAMD {
  pNext?: AnyPointer;
  localDimmingSupport?: Bool32;
}

export class DisplayNativeHdrSurfaceCapabilitiesAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayNativeHdrSurfaceCapabilitiesAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayNativeHdrSurfaceCapabilitiesAMD) {
    if (!data) {
      this.#data = new Uint8Array(DisplayNativeHdrSurfaceCapabilitiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayNativeHdrSurfaceCapabilitiesAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayNativeHdrSurfaceCapabilitiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.localDimmingSupport !== undefined) this.localDimmingSupport = data.localDimmingSupport;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get localDimmingSupport() {
    return this.#view.getUint32(16, LE);
  }
  
  set localDimmingSupport(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSwapchainDisplayNativeHdrCreateInfoAMD {
  pNext?: AnyPointer;
  localDimmingEnable?: Bool32;
}

export class SwapchainDisplayNativeHdrCreateInfoAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSwapchainDisplayNativeHdrCreateInfoAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSwapchainDisplayNativeHdrCreateInfoAMD) {
    if (!data) {
      this.#data = new Uint8Array(SwapchainDisplayNativeHdrCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SwapchainDisplayNativeHdrCreateInfoAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SwapchainDisplayNativeHdrCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.localDimmingEnable !== undefined) this.localDimmingEnable = data.localDimmingEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get localDimmingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set localDimmingEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitRefreshCycleDurationGOOGLE {
  refreshDuration?: Deno.PointerValue;
}

export class RefreshCycleDurationGOOGLE implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRefreshCycleDurationGOOGLE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRefreshCycleDurationGOOGLE) {
    if (!data) {
      this.#data = new Uint8Array(RefreshCycleDurationGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RefreshCycleDurationGOOGLE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RefreshCycleDurationGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.refreshDuration !== undefined) this.refreshDuration = data.refreshDuration;
    }
  }
  
  get refreshDuration() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set refreshDuration(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
}

export interface InitPastPresentationTimingGOOGLE {
  presentID?: number;
  desiredPresentTime?: Deno.PointerValue;
  actualPresentTime?: Deno.PointerValue;
  earliestPresentTime?: Deno.PointerValue;
  presentMargin?: Deno.PointerValue;
}

export class PastPresentationTimingGOOGLE implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPastPresentationTimingGOOGLE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPastPresentationTimingGOOGLE) {
    if (!data) {
      this.#data = new Uint8Array(PastPresentationTimingGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PastPresentationTimingGOOGLE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PastPresentationTimingGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.presentID !== undefined) this.presentID = data.presentID;
      if (data.desiredPresentTime !== undefined) this.desiredPresentTime = data.desiredPresentTime;
      if (data.actualPresentTime !== undefined) this.actualPresentTime = data.actualPresentTime;
      if (data.earliestPresentTime !== undefined) this.earliestPresentTime = data.earliestPresentTime;
      if (data.presentMargin !== undefined) this.presentMargin = data.presentMargin;
    }
  }
  
  get presentID() {
    return this.#view.getUint32(0, LE);
  }
  
  set presentID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get desiredPresentTime() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set desiredPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get actualPresentTime() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set actualPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get earliestPresentTime() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set earliestPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get presentMargin() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set presentMargin(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitPresentTimesInfoGOOGLE {
  pNext?: AnyPointer;
  swapchainCount?: number;
  pTimes?: AnyPointer;
}

export class PresentTimesInfoGOOGLE implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentTimesInfoGOOGLE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentTimesInfoGOOGLE) {
    if (!data) {
      this.#data = new Uint8Array(PresentTimesInfoGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentTimesInfoGOOGLE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentTimesInfoGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.swapchainCount !== undefined) this.swapchainCount = data.swapchainCount;
      if (data.pTimes !== undefined) this.pTimes = data.pTimes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get swapchainCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set swapchainCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pTimes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pTimes(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPresentTimeGOOGLE {
  presentID?: number;
  desiredPresentTime?: Deno.PointerValue;
}

export class PresentTimeGOOGLE implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentTimeGOOGLE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentTimeGOOGLE) {
    if (!data) {
      this.#data = new Uint8Array(PresentTimeGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentTimeGOOGLE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentTimeGOOGLE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.presentID !== undefined) this.presentID = data.presentID;
      if (data.desiredPresentTime !== undefined) this.desiredPresentTime = data.desiredPresentTime;
    }
  }
  
  get presentID() {
    return this.#view.getUint32(0, LE);
  }
  
  set presentID(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get desiredPresentTime() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set desiredPresentTime(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export interface InitIOSSurfaceCreateInfoMVK {
  pNext?: AnyPointer;
  flags?: IOSSurfaceCreateFlagsMVK;
  pView?: AnyPointer;
}

export class IOSSurfaceCreateInfoMVK implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitIOSSurfaceCreateInfoMVK);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitIOSSurfaceCreateInfoMVK) {
    if (!data) {
      this.#data = new Uint8Array(IOSSurfaceCreateInfoMVK.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < IOSSurfaceCreateInfoMVK.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(IOSSurfaceCreateInfoMVK.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pView !== undefined) this.pView = data.pView;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: IOSSurfaceCreateFlagsMVK) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pView(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMacOSSurfaceCreateInfoMVK {
  pNext?: AnyPointer;
  flags?: MacOSSurfaceCreateFlagsMVK;
  pView?: AnyPointer;
}

export class MacOSSurfaceCreateInfoMVK implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMacOSSurfaceCreateInfoMVK);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMacOSSurfaceCreateInfoMVK) {
    if (!data) {
      this.#data = new Uint8Array(MacOSSurfaceCreateInfoMVK.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MacOSSurfaceCreateInfoMVK.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MacOSSurfaceCreateInfoMVK.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pView !== undefined) this.pView = data.pView;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: MacOSSurfaceCreateFlagsMVK) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pView(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMetalSurfaceCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: MetalSurfaceCreateFlagsEXT;
  pLayer?: AnyPointer;
}

export class MetalSurfaceCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMetalSurfaceCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMetalSurfaceCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MetalSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MetalSurfaceCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MetalSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pLayer !== undefined) this.pLayer = data.pLayer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: MetalSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pLayer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pLayer(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitViewportWScalingNV {
  xcoeff?: number;
  ycoeff?: number;
}

export class ViewportWScalingNV implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitViewportWScalingNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitViewportWScalingNV) {
    if (!data) {
      this.#data = new Uint8Array(ViewportWScalingNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ViewportWScalingNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ViewportWScalingNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.xcoeff !== undefined) this.xcoeff = data.xcoeff;
      if (data.ycoeff !== undefined) this.ycoeff = data.ycoeff;
    }
  }
  
  get xcoeff() {
    return this.#view.getFloat32(0, LE);
  }
  
  set xcoeff(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get ycoeff() {
    return this.#view.getFloat32(4, LE);
  }
  
  set ycoeff(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export interface InitPipelineViewportWScalingStateCreateInfoNV {
  pNext?: AnyPointer;
  viewportWScalingEnable?: Bool32;
  viewportCount?: number;
  pViewportWScalings?: AnyPointer;
}

export class PipelineViewportWScalingStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportWScalingStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportWScalingStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportWScalingStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportWScalingStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportWScalingStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.viewportWScalingEnable !== undefined) this.viewportWScalingEnable = data.viewportWScalingEnable;
      if (data.viewportCount !== undefined) this.viewportCount = data.viewportCount;
      if (data.pViewportWScalings !== undefined) this.pViewportWScalings = data.pViewportWScalings;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get viewportWScalingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewportWScalingEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportWScalings() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportWScalings(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitViewportSwizzleNV {
  x?: ViewportCoordinateSwizzleNV;
  y?: ViewportCoordinateSwizzleNV;
  z?: ViewportCoordinateSwizzleNV;
  w?: ViewportCoordinateSwizzleNV;
}

export class ViewportSwizzleNV implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitViewportSwizzleNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitViewportSwizzleNV) {
    if (!data) {
      this.#data = new Uint8Array(ViewportSwizzleNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ViewportSwizzleNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ViewportSwizzleNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
      if (data.z !== undefined) this.z = data.z;
      if (data.w !== undefined) this.w = data.w;
    }
  }
  
  get x() {
    return this.#view.getUint32(0, LE);
  }
  
  set x(value: ViewportCoordinateSwizzleNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getUint32(4, LE);
  }
  
  set y(value: ViewportCoordinateSwizzleNV) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get z() {
    return this.#view.getUint32(8, LE);
  }
  
  set z(value: ViewportCoordinateSwizzleNV) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get w() {
    return this.#view.getUint32(12, LE);
  }
  
  set w(value: ViewportCoordinateSwizzleNV) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitPipelineViewportSwizzleStateCreateInfoNV {
  pNext?: AnyPointer;
  flags?: PipelineViewportSwizzleStateCreateFlagsNV;
  viewportCount?: number;
  pViewportSwizzles?: AnyPointer;
}

export class PipelineViewportSwizzleStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportSwizzleStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportSwizzleStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportSwizzleStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportSwizzleStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportSwizzleStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.viewportCount !== undefined) this.viewportCount = data.viewportCount;
      if (data.pViewportSwizzles !== undefined) this.pViewportSwizzles = data.pViewportSwizzles;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineViewportSwizzleStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportSwizzles() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportSwizzles(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDiscardRectanglePropertiesEXT {
  pNext?: AnyPointer;
  maxDiscardRectangles?: number;
}

export class PhysicalDeviceDiscardRectanglePropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDiscardRectanglePropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDiscardRectanglePropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDiscardRectanglePropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDiscardRectanglePropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDiscardRectanglePropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxDiscardRectangles !== undefined) this.maxDiscardRectangles = data.maxDiscardRectangles;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxDiscardRectangles() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxDiscardRectangles(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineDiscardRectangleStateCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: PipelineDiscardRectangleStateCreateFlagsEXT;
  discardRectangleMode?: DiscardRectangleModeEXT;
  discardRectangleCount?: number;
  pDiscardRectangles?: AnyPointer;
}

export class PipelineDiscardRectangleStateCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineDiscardRectangleStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineDiscardRectangleStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineDiscardRectangleStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineDiscardRectangleStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineDiscardRectangleStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.discardRectangleMode !== undefined) this.discardRectangleMode = data.discardRectangleMode;
      if (data.discardRectangleCount !== undefined) this.discardRectangleCount = data.discardRectangleCount;
      if (data.pDiscardRectangles !== undefined) this.pDiscardRectangles = data.pDiscardRectangles;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineDiscardRectangleStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get discardRectangleMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set discardRectangleMode(value: DiscardRectangleModeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get discardRectangleCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set discardRectangleCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pDiscardRectangles() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pDiscardRectangles(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  pNext?: AnyPointer;
  perViewPositionAllComponents?: Bool32;
}

export class PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.perViewPositionAllComponents !== undefined) this.perViewPositionAllComponents = data.perViewPositionAllComponents;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get perViewPositionAllComponents() {
    return this.#view.getUint32(16, LE);
  }
  
  set perViewPositionAllComponents(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitInputAttachmentAspectReference {
  subpass?: number;
  inputAttachmentIndex?: number;
  aspectMask?: ImageAspectFlags;
}

export class InputAttachmentAspectReference implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitInputAttachmentAspectReference);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitInputAttachmentAspectReference) {
    if (!data) {
      this.#data = new Uint8Array(InputAttachmentAspectReference.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < InputAttachmentAspectReference.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(InputAttachmentAspectReference.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.subpass !== undefined) this.subpass = data.subpass;
      if (data.inputAttachmentIndex !== undefined) this.inputAttachmentIndex = data.inputAttachmentIndex;
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
    }
  }
  
  get subpass() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get inputAttachmentIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set inputAttachmentIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get aspectMask() {
    return this.#view.getUint32(8, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitRenderPassInputAttachmentAspectCreateInfo {
  pNext?: AnyPointer;
  aspectReferenceCount?: number;
  pAspectReferences?: AnyPointer;
}

export class RenderPassInputAttachmentAspectCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassInputAttachmentAspectCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassInputAttachmentAspectCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassInputAttachmentAspectCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassInputAttachmentAspectCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassInputAttachmentAspectCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.aspectReferenceCount !== undefined) this.aspectReferenceCount = data.aspectReferenceCount;
      if (data.pAspectReferences !== undefined) this.pAspectReferences = data.pAspectReferences;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get aspectReferenceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set aspectReferenceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAspectReferences() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAspectReferences(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceSurfaceInfo2KHR {
  pNext?: AnyPointer;
  surface?: SurfaceKHR;
}

export class PhysicalDeviceSurfaceInfo2KHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSurfaceInfo2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSurfaceInfo2KHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSurfaceInfo2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSurfaceInfo2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSurfaceInfo2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.surface !== undefined) this.surface = data.surface;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get surface() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set surface(value: SurfaceKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSurfaceCapabilities2KHR {
  pNext?: AnyPointer;
  surfaceCapabilities?: SurfaceCapabilitiesKHR;
}

export class SurfaceCapabilities2KHR implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceCapabilities2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceCapabilities2KHR) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceCapabilities2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceCapabilities2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceCapabilities2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.surfaceCapabilities !== undefined) this.surfaceCapabilities = data.surfaceCapabilities;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get surfaceCapabilities() {
    return new SurfaceCapabilitiesKHR(this.#data.subarray(16, 16 + SurfaceCapabilitiesKHR.size));
  }
  
  set surfaceCapabilities(value: SurfaceCapabilitiesKHR) {
    if (value[BUFFER].byteLength < SurfaceCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSurfaceFormat2KHR {
  pNext?: AnyPointer;
  surfaceFormat?: SurfaceFormatKHR;
}

export class SurfaceFormat2KHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceFormat2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceFormat2KHR) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceFormat2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceFormat2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceFormat2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.surfaceFormat !== undefined) this.surfaceFormat = data.surfaceFormat;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get surfaceFormat() {
    return new SurfaceFormatKHR(this.#data.subarray(16, 16 + SurfaceFormatKHR.size));
  }
  
  set surfaceFormat(value: SurfaceFormatKHR) {
    if (value[BUFFER].byteLength < SurfaceFormatKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitDisplayProperties2KHR {
  pNext?: AnyPointer;
  displayProperties?: DisplayPropertiesKHR;
}

export class DisplayProperties2KHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayProperties2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayProperties2KHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayProperties2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.displayProperties !== undefined) this.displayProperties = data.displayProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get displayProperties() {
    return new DisplayPropertiesKHR(this.#data.subarray(16, 16 + DisplayPropertiesKHR.size));
  }
  
  set displayProperties(value: DisplayPropertiesKHR) {
    if (value[BUFFER].byteLength < DisplayPropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitDisplayPlaneProperties2KHR {
  pNext?: AnyPointer;
  displayPlaneProperties?: DisplayPlanePropertiesKHR;
}

export class DisplayPlaneProperties2KHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPlaneProperties2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPlaneProperties2KHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPlaneProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPlaneProperties2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPlaneProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.displayPlaneProperties !== undefined) this.displayPlaneProperties = data.displayPlaneProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get displayPlaneProperties() {
    return new DisplayPlanePropertiesKHR(this.#data.subarray(16, 16 + DisplayPlanePropertiesKHR.size));
  }
  
  set displayPlaneProperties(value: DisplayPlanePropertiesKHR) {
    if (value[BUFFER].byteLength < DisplayPlanePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitDisplayModeProperties2KHR {
  pNext?: AnyPointer;
  displayModeProperties?: DisplayModePropertiesKHR;
}

export class DisplayModeProperties2KHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayModeProperties2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayModeProperties2KHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayModeProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayModeProperties2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayModeProperties2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.displayModeProperties !== undefined) this.displayModeProperties = data.displayModeProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get displayModeProperties() {
    return new DisplayModePropertiesKHR(this.#data.subarray(16, 16 + DisplayModePropertiesKHR.size));
  }
  
  set displayModeProperties(value: DisplayModePropertiesKHR) {
    if (value[BUFFER].byteLength < DisplayModePropertiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitDisplayPlaneInfo2KHR {
  pNext?: AnyPointer;
  mode?: DisplayModeKHR;
  planeIndex?: number;
}

export class DisplayPlaneInfo2KHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPlaneInfo2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPlaneInfo2KHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPlaneInfo2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPlaneInfo2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPlaneInfo2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mode !== undefined) this.mode = data.mode;
      if (data.planeIndex !== undefined) this.planeIndex = data.planeIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mode(value: DisplayModeKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get planeIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set planeIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitDisplayPlaneCapabilities2KHR {
  pNext?: AnyPointer;
  capabilities?: DisplayPlaneCapabilitiesKHR;
}

export class DisplayPlaneCapabilities2KHR implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDisplayPlaneCapabilities2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDisplayPlaneCapabilities2KHR) {
    if (!data) {
      this.#data = new Uint8Array(DisplayPlaneCapabilities2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DisplayPlaneCapabilities2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DisplayPlaneCapabilities2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.capabilities !== undefined) this.capabilities = data.capabilities;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get capabilities() {
    return new DisplayPlaneCapabilitiesKHR(this.#data.subarray(16, 16 + DisplayPlaneCapabilitiesKHR.size));
  }
  
  set capabilities(value: DisplayPlaneCapabilitiesKHR) {
    if (value[BUFFER].byteLength < DisplayPlaneCapabilitiesKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSharedPresentSurfaceCapabilitiesKHR {
  pNext?: AnyPointer;
  sharedPresentSupportedUsageFlags?: ImageUsageFlags;
}

export class SharedPresentSurfaceCapabilitiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSharedPresentSurfaceCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSharedPresentSurfaceCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(SharedPresentSurfaceCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SharedPresentSurfaceCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SharedPresentSurfaceCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sharedPresentSupportedUsageFlags !== undefined) this.sharedPresentSupportedUsageFlags = data.sharedPresentSupportedUsageFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sharedPresentSupportedUsageFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set sharedPresentSupportedUsageFlags(value: ImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevice16BitStorageFeatures {
  pNext?: AnyPointer;
  storageBuffer16BitAccess?: Bool32;
  uniformAndStorageBuffer16BitAccess?: Bool32;
  storagePushConstant16?: Bool32;
  storageInputOutput16?: Bool32;
}

export class PhysicalDevice16BitStorageFeatures implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevice16BitStorageFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevice16BitStorageFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevice16BitStorageFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevice16BitStorageFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevice16BitStorageFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.storageBuffer16BitAccess !== undefined) this.storageBuffer16BitAccess = data.storageBuffer16BitAccess;
      if (data.uniformAndStorageBuffer16BitAccess !== undefined) this.uniformAndStorageBuffer16BitAccess = data.uniformAndStorageBuffer16BitAccess;
      if (data.storagePushConstant16 !== undefined) this.storagePushConstant16 = data.storagePushConstant16;
      if (data.storageInputOutput16 !== undefined) this.storageInputOutput16 = data.storageInputOutput16;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get storageBuffer16BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer16BitAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer16BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer16BitAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant16() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant16(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get storageInputOutput16() {
    return this.#view.getUint32(28, LE);
  }
  
  set storageInputOutput16(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSubgroupProperties {
  pNext?: AnyPointer;
  subgroupSize?: number;
  supportedStages?: ShaderStageFlags;
  supportedOperations?: SubgroupFeatureFlags;
  quadOperationsInAllStages?: Bool32;
}

export class PhysicalDeviceSubgroupProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubgroupProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubgroupProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubgroupProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subgroupSize !== undefined) this.subgroupSize = data.subgroupSize;
      if (data.supportedStages !== undefined) this.supportedStages = data.supportedStages;
      if (data.supportedOperations !== undefined) this.supportedOperations = data.supportedOperations;
      if (data.quadOperationsInAllStages !== undefined) this.quadOperationsInAllStages = data.quadOperationsInAllStages;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedStages() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedStages(value: ShaderStageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get supportedOperations() {
    return this.#view.getUint32(24, LE);
  }
  
  set supportedOperations(value: SubgroupFeatureFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get quadOperationsInAllStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set quadOperationsInAllStages(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
  pNext?: AnyPointer;
  shaderSubgroupExtendedTypes?: Bool32;
}

export class PhysicalDeviceShaderSubgroupExtendedTypesFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderSubgroupExtendedTypesFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderSubgroupExtendedTypesFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderSubgroupExtendedTypesFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderSubgroupExtendedTypes !== undefined) this.shaderSubgroupExtendedTypes = data.shaderSubgroupExtendedTypes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderSubgroupExtendedTypes() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupExtendedTypes(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitBufferMemoryRequirementsInfo2 {
  pNext?: AnyPointer;
  buffer?: Buffer;
}

export class BufferMemoryRequirementsInfo2 implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferMemoryRequirementsInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferMemoryRequirementsInfo2) {
    if (!data) {
      this.#data = new Uint8Array(BufferMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferMemoryRequirementsInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceBufferMemoryRequirements {
  pNext?: AnyPointer;
  pCreateInfo?: AnyPointer;
}

export class DeviceBufferMemoryRequirements implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceBufferMemoryRequirements);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceBufferMemoryRequirements) {
    if (!data) {
      this.#data = new Uint8Array(DeviceBufferMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceBufferMemoryRequirements.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceBufferMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pCreateInfo !== undefined) this.pCreateInfo = data.pCreateInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pCreateInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pCreateInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageMemoryRequirementsInfo2 {
  pNext?: AnyPointer;
  image?: Image;
}

export class ImageMemoryRequirementsInfo2 implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageMemoryRequirementsInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageMemoryRequirementsInfo2) {
    if (!data) {
      this.#data = new Uint8Array(ImageMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageMemoryRequirementsInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageSparseMemoryRequirementsInfo2 {
  pNext?: AnyPointer;
  image?: Image;
}

export class ImageSparseMemoryRequirementsInfo2 implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSparseMemoryRequirementsInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSparseMemoryRequirementsInfo2) {
    if (!data) {
      this.#data = new Uint8Array(ImageSparseMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSparseMemoryRequirementsInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSparseMemoryRequirementsInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceImageMemoryRequirements {
  pNext?: AnyPointer;
  pCreateInfo?: AnyPointer;
  planeAspect?: ImageAspectFlagBits;
}

export class DeviceImageMemoryRequirements implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceImageMemoryRequirements);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceImageMemoryRequirements) {
    if (!data) {
      this.#data = new Uint8Array(DeviceImageMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceImageMemoryRequirements.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceImageMemoryRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pCreateInfo !== undefined) this.pCreateInfo = data.pCreateInfo;
      if (data.planeAspect !== undefined) this.planeAspect = data.planeAspect;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pCreateInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pCreateInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(24, LE);
  }
  
  set planeAspect(value: ImageAspectFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitMemoryRequirements2 {
  pNext?: AnyPointer;
  memoryRequirements?: MemoryRequirements;
}

export class MemoryRequirements2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryRequirements2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryRequirements2) {
    if (!data) {
      this.#data = new Uint8Array(MemoryRequirements2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryRequirements2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryRequirements2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryRequirements !== undefined) this.memoryRequirements = data.memoryRequirements;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryRequirements() {
    return new MemoryRequirements(this.#data.subarray(16, 16 + MemoryRequirements.size));
  }
  
  set memoryRequirements(value: MemoryRequirements) {
    if (value[BUFFER].byteLength < MemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSparseImageMemoryRequirements2 {
  pNext?: AnyPointer;
  memoryRequirements?: SparseImageMemoryRequirements;
}

export class SparseImageMemoryRequirements2 implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSparseImageMemoryRequirements2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSparseImageMemoryRequirements2) {
    if (!data) {
      this.#data = new Uint8Array(SparseImageMemoryRequirements2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SparseImageMemoryRequirements2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SparseImageMemoryRequirements2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryRequirements !== undefined) this.memoryRequirements = data.memoryRequirements;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryRequirements() {
    return new SparseImageMemoryRequirements(this.#data.subarray(16, 16 + SparseImageMemoryRequirements.size));
  }
  
  set memoryRequirements(value: SparseImageMemoryRequirements) {
    if (value[BUFFER].byteLength < SparseImageMemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitPhysicalDevicePointClippingProperties {
  pNext?: AnyPointer;
  pointClippingBehavior?: PointClippingBehavior;
}

export class PhysicalDevicePointClippingProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePointClippingProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePointClippingProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePointClippingProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePointClippingProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePointClippingProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pointClippingBehavior !== undefined) this.pointClippingBehavior = data.pointClippingBehavior;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pointClippingBehavior() {
    return this.#view.getUint32(16, LE);
  }
  
  set pointClippingBehavior(value: PointClippingBehavior) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryDedicatedRequirements {
  pNext?: AnyPointer;
  prefersDedicatedAllocation?: Bool32;
  requiresDedicatedAllocation?: Bool32;
}

export class MemoryDedicatedRequirements implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryDedicatedRequirements);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryDedicatedRequirements) {
    if (!data) {
      this.#data = new Uint8Array(MemoryDedicatedRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryDedicatedRequirements.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryDedicatedRequirements.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.prefersDedicatedAllocation !== undefined) this.prefersDedicatedAllocation = data.prefersDedicatedAllocation;
      if (data.requiresDedicatedAllocation !== undefined) this.requiresDedicatedAllocation = data.requiresDedicatedAllocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get prefersDedicatedAllocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set prefersDedicatedAllocation(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get requiresDedicatedAllocation() {
    return this.#view.getUint32(20, LE);
  }
  
  set requiresDedicatedAllocation(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitMemoryDedicatedAllocateInfo {
  pNext?: AnyPointer;
  image?: Image;
  buffer?: Buffer;
}

export class MemoryDedicatedAllocateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryDedicatedAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryDedicatedAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(MemoryDedicatedAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryDedicatedAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryDedicatedAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageViewUsageCreateInfo {
  pNext?: AnyPointer;
  usage?: ImageUsageFlags;
}

export class ImageViewUsageCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewUsageCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewUsageCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewUsageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewUsageCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewUsageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.usage !== undefined) this.usage = data.usage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: ImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineTessellationDomainOriginStateCreateInfo {
  pNext?: AnyPointer;
  domainOrigin?: TessellationDomainOrigin;
}

export class PipelineTessellationDomainOriginStateCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineTessellationDomainOriginStateCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineTessellationDomainOriginStateCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineTessellationDomainOriginStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineTessellationDomainOriginStateCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineTessellationDomainOriginStateCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.domainOrigin !== undefined) this.domainOrigin = data.domainOrigin;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get domainOrigin() {
    return this.#view.getUint32(16, LE);
  }
  
  set domainOrigin(value: TessellationDomainOrigin) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSamplerYcbcrConversionInfo {
  pNext?: AnyPointer;
  conversion?: SamplerYcbcrConversion;
}

export class SamplerYcbcrConversionInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerYcbcrConversionInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerYcbcrConversionInfo) {
    if (!data) {
      this.#data = new Uint8Array(SamplerYcbcrConversionInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerYcbcrConversionInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerYcbcrConversionInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.conversion !== undefined) this.conversion = data.conversion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get conversion() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set conversion(value: SamplerYcbcrConversion) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSamplerYcbcrConversionCreateInfo {
  pNext?: AnyPointer;
  format?: Format;
  ycbcrModel?: SamplerYcbcrModelConversion;
  ycbcrRange?: SamplerYcbcrRange;
  components?: ComponentMapping;
  xChromaOffset?: ChromaLocation;
  yChromaOffset?: ChromaLocation;
  chromaFilter?: Filter;
  forceExplicitReconstruction?: Bool32;
}

export class SamplerYcbcrConversionCreateInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerYcbcrConversionCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerYcbcrConversionCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(SamplerYcbcrConversionCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerYcbcrConversionCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerYcbcrConversionCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.ycbcrModel !== undefined) this.ycbcrModel = data.ycbcrModel;
      if (data.ycbcrRange !== undefined) this.ycbcrRange = data.ycbcrRange;
      if (data.components !== undefined) this.components = data.components;
      if (data.xChromaOffset !== undefined) this.xChromaOffset = data.xChromaOffset;
      if (data.yChromaOffset !== undefined) this.yChromaOffset = data.yChromaOffset;
      if (data.chromaFilter !== undefined) this.chromaFilter = data.chromaFilter;
      if (data.forceExplicitReconstruction !== undefined) this.forceExplicitReconstruction = data.forceExplicitReconstruction;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get ycbcrModel() {
    return this.#view.getUint32(20, LE);
  }
  
  set ycbcrModel(value: SamplerYcbcrModelConversion) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get ycbcrRange() {
    return this.#view.getUint32(24, LE);
  }
  
  set ycbcrRange(value: SamplerYcbcrRange) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get components() {
    return new ComponentMapping(this.#data.subarray(28, 28 + ComponentMapping.size));
  }
  
  set components(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get xChromaOffset() {
    return this.#view.getUint32(44, LE);
  }
  
  set xChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get yChromaOffset() {
    return this.#view.getUint32(48, LE);
  }
  
  set yChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get chromaFilter() {
    return this.#view.getUint32(52, LE);
  }
  
  set chromaFilter(value: Filter) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get forceExplicitReconstruction() {
    return this.#view.getUint32(56, LE);
  }
  
  set forceExplicitReconstruction(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitBindImagePlaneMemoryInfo {
  pNext?: AnyPointer;
  planeAspect?: ImageAspectFlagBits;
}

export class BindImagePlaneMemoryInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindImagePlaneMemoryInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindImagePlaneMemoryInfo) {
    if (!data) {
      this.#data = new Uint8Array(BindImagePlaneMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindImagePlaneMemoryInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindImagePlaneMemoryInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.planeAspect !== undefined) this.planeAspect = data.planeAspect;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(16, LE);
  }
  
  set planeAspect(value: ImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImagePlaneMemoryRequirementsInfo {
  pNext?: AnyPointer;
  planeAspect?: ImageAspectFlagBits;
}

export class ImagePlaneMemoryRequirementsInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImagePlaneMemoryRequirementsInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImagePlaneMemoryRequirementsInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImagePlaneMemoryRequirementsInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImagePlaneMemoryRequirementsInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImagePlaneMemoryRequirementsInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.planeAspect !== undefined) this.planeAspect = data.planeAspect;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get planeAspect() {
    return this.#view.getUint32(16, LE);
  }
  
  set planeAspect(value: ImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSamplerYcbcrConversionFeatures {
  pNext?: AnyPointer;
  samplerYcbcrConversion?: Bool32;
}

export class PhysicalDeviceSamplerYcbcrConversionFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSamplerYcbcrConversionFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSamplerYcbcrConversionFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSamplerYcbcrConversionFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSamplerYcbcrConversionFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSamplerYcbcrConversionFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.samplerYcbcrConversion !== undefined) this.samplerYcbcrConversion = data.samplerYcbcrConversion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get samplerYcbcrConversion() {
    return this.#view.getUint32(16, LE);
  }
  
  set samplerYcbcrConversion(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSamplerYcbcrConversionImageFormatProperties {
  pNext?: AnyPointer;
  combinedImageSamplerDescriptorCount?: number;
}

export class SamplerYcbcrConversionImageFormatProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerYcbcrConversionImageFormatProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerYcbcrConversionImageFormatProperties) {
    if (!data) {
      this.#data = new Uint8Array(SamplerYcbcrConversionImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerYcbcrConversionImageFormatProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerYcbcrConversionImageFormatProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.combinedImageSamplerDescriptorCount !== undefined) this.combinedImageSamplerDescriptorCount = data.combinedImageSamplerDescriptorCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get combinedImageSamplerDescriptorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set combinedImageSamplerDescriptorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitTextureLODGatherFormatPropertiesAMD {
  pNext?: AnyPointer;
  supportsTextureGatherLODBiasAMD?: Bool32;
}

export class TextureLODGatherFormatPropertiesAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTextureLODGatherFormatPropertiesAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTextureLODGatherFormatPropertiesAMD) {
    if (!data) {
      this.#data = new Uint8Array(TextureLODGatherFormatPropertiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TextureLODGatherFormatPropertiesAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TextureLODGatherFormatPropertiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supportsTextureGatherLODBiasAMD !== undefined) this.supportsTextureGatherLODBiasAMD = data.supportsTextureGatherLODBiasAMD;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supportsTextureGatherLODBiasAMD() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportsTextureGatherLODBiasAMD(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitConditionalRenderingBeginInfoEXT {
  pNext?: AnyPointer;
  buffer?: Buffer;
  offset?: DeviceSize;
  flags?: ConditionalRenderingFlagsEXT;
}

export class ConditionalRenderingBeginInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitConditionalRenderingBeginInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitConditionalRenderingBeginInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ConditionalRenderingBeginInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ConditionalRenderingBeginInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ConditionalRenderingBeginInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(32, LE);
  }
  
  set flags(value: ConditionalRenderingFlagsEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitProtectedSubmitInfo {
  pNext?: AnyPointer;
  protectedSubmit?: Bool32;
}

export class ProtectedSubmitInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitProtectedSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitProtectedSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(ProtectedSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ProtectedSubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ProtectedSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.protectedSubmit !== undefined) this.protectedSubmit = data.protectedSubmit;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get protectedSubmit() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedSubmit(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceProtectedMemoryFeatures {
  pNext?: AnyPointer;
  protectedMemory?: Bool32;
}

export class PhysicalDeviceProtectedMemoryFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProtectedMemoryFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProtectedMemoryFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProtectedMemoryFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProtectedMemoryFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProtectedMemoryFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.protectedMemory !== undefined) this.protectedMemory = data.protectedMemory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get protectedMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedMemory(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceProtectedMemoryProperties {
  pNext?: AnyPointer;
  protectedNoFault?: Bool32;
}

export class PhysicalDeviceProtectedMemoryProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProtectedMemoryProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProtectedMemoryProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProtectedMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProtectedMemoryProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProtectedMemoryProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.protectedNoFault !== undefined) this.protectedNoFault = data.protectedNoFault;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get protectedNoFault() {
    return this.#view.getUint32(16, LE);
  }
  
  set protectedNoFault(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceQueueInfo2 {
  pNext?: AnyPointer;
  flags?: DeviceQueueCreateFlags;
  queueFamilyIndex?: number;
  queueIndex?: number;
}

export class DeviceQueueInfo2 implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceQueueInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceQueueInfo2) {
    if (!data) {
      this.#data = new Uint8Array(DeviceQueueInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceQueueInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceQueueInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.queueFamilyIndex !== undefined) this.queueFamilyIndex = data.queueFamilyIndex;
      if (data.queueIndex !== undefined) this.queueIndex = data.queueIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceQueueCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(20, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get queueIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set queueIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPipelineCoverageToColorStateCreateInfoNV {
  pNext?: AnyPointer;
  flags?: PipelineCoverageToColorStateCreateFlagsNV;
  coverageToColorEnable?: Bool32;
  coverageToColorLocation?: number;
}

export class PipelineCoverageToColorStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCoverageToColorStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCoverageToColorStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCoverageToColorStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCoverageToColorStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCoverageToColorStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.coverageToColorEnable !== undefined) this.coverageToColorEnable = data.coverageToColorEnable;
      if (data.coverageToColorLocation !== undefined) this.coverageToColorLocation = data.coverageToColorLocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCoverageToColorStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageToColorEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageToColorEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get coverageToColorLocation() {
    return this.#view.getUint32(24, LE);
  }
  
  set coverageToColorLocation(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSamplerFilterMinmaxProperties {
  pNext?: AnyPointer;
  filterMinmaxSingleComponentFormats?: Bool32;
  filterMinmaxImageComponentMapping?: Bool32;
}

export class PhysicalDeviceSamplerFilterMinmaxProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSamplerFilterMinmaxProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSamplerFilterMinmaxProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSamplerFilterMinmaxProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSamplerFilterMinmaxProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSamplerFilterMinmaxProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.filterMinmaxSingleComponentFormats !== undefined) this.filterMinmaxSingleComponentFormats = data.filterMinmaxSingleComponentFormats;
      if (data.filterMinmaxImageComponentMapping !== undefined) this.filterMinmaxImageComponentMapping = data.filterMinmaxImageComponentMapping;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get filterMinmaxSingleComponentFormats() {
    return this.#view.getUint32(16, LE);
  }
  
  set filterMinmaxSingleComponentFormats(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get filterMinmaxImageComponentMapping() {
    return this.#view.getUint32(20, LE);
  }
  
  set filterMinmaxImageComponentMapping(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitSampleLocationEXT {
  x?: number;
  y?: number;
}

export class SampleLocationEXT implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSampleLocationEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSampleLocationEXT) {
    if (!data) {
      this.#data = new Uint8Array(SampleLocationEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SampleLocationEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SampleLocationEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.x !== undefined) this.x = data.x;
      if (data.y !== undefined) this.y = data.y;
    }
  }
  
  get x() {
    return this.#view.getFloat32(0, LE);
  }
  
  set x(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get y() {
    return this.#view.getFloat32(4, LE);
  }
  
  set y(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
}

export interface InitSampleLocationsInfoEXT {
  pNext?: AnyPointer;
  sampleLocationsPerPixel?: SampleCountFlagBits;
  sampleLocationGridSize?: Extent2D;
  sampleLocationsCount?: number;
  pSampleLocations?: AnyPointer;
}

export class SampleLocationsInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSampleLocationsInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSampleLocationsInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SampleLocationsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SampleLocationsInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SampleLocationsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampleLocationsPerPixel !== undefined) this.sampleLocationsPerPixel = data.sampleLocationsPerPixel;
      if (data.sampleLocationGridSize !== undefined) this.sampleLocationGridSize = data.sampleLocationGridSize;
      if (data.sampleLocationsCount !== undefined) this.sampleLocationsCount = data.sampleLocationsCount;
      if (data.pSampleLocations !== undefined) this.pSampleLocations = data.pSampleLocations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampleLocationsPerPixel() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationsPerPixel(value: SampleCountFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleLocationGridSize() {
    return new Extent2D(this.#data.subarray(20, 20 + Extent2D.size));
  }
  
  set sampleLocationGridSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get sampleLocationsCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set sampleLocationsCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pSampleLocations() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSampleLocations(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAttachmentSampleLocationsEXT {
  attachmentIndex?: number;
  sampleLocationsInfo?: SampleLocationsInfoEXT;
}

export class AttachmentSampleLocationsEXT implements BaseStruct {
  static size = 44;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentSampleLocationsEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentSampleLocationsEXT) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentSampleLocationsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentSampleLocationsEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentSampleLocationsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.attachmentIndex !== undefined) this.attachmentIndex = data.attachmentIndex;
      if (data.sampleLocationsInfo !== undefined) this.sampleLocationsInfo = data.sampleLocationsInfo;
    }
  }
  
  get attachmentIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set attachmentIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new SampleLocationsInfoEXT(this.#data.subarray(4, 4 + SampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: SampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < SampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
}

export interface InitSubpassSampleLocationsEXT {
  subpassIndex?: number;
  sampleLocationsInfo?: SampleLocationsInfoEXT;
}

export class SubpassSampleLocationsEXT implements BaseStruct {
  static size = 44;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassSampleLocationsEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassSampleLocationsEXT) {
    if (!data) {
      this.#data = new Uint8Array(SubpassSampleLocationsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassSampleLocationsEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassSampleLocationsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.subpassIndex !== undefined) this.subpassIndex = data.subpassIndex;
      if (data.sampleLocationsInfo !== undefined) this.sampleLocationsInfo = data.sampleLocationsInfo;
    }
  }
  
  get subpassIndex() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpassIndex(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new SampleLocationsInfoEXT(this.#data.subarray(4, 4 + SampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: SampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < SampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
}

export interface InitRenderPassSampleLocationsBeginInfoEXT {
  pNext?: AnyPointer;
  attachmentInitialSampleLocationsCount?: number;
  pAttachmentInitialSampleLocations?: AnyPointer;
  postSubpassSampleLocationsCount?: number;
  pPostSubpassSampleLocations?: AnyPointer;
}

export class RenderPassSampleLocationsBeginInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassSampleLocationsBeginInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassSampleLocationsBeginInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassSampleLocationsBeginInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassSampleLocationsBeginInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassSampleLocationsBeginInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachmentInitialSampleLocationsCount !== undefined) this.attachmentInitialSampleLocationsCount = data.attachmentInitialSampleLocationsCount;
      if (data.pAttachmentInitialSampleLocations !== undefined) this.pAttachmentInitialSampleLocations = data.pAttachmentInitialSampleLocations;
      if (data.postSubpassSampleLocationsCount !== undefined) this.postSubpassSampleLocationsCount = data.postSubpassSampleLocationsCount;
      if (data.pPostSubpassSampleLocations !== undefined) this.pPostSubpassSampleLocations = data.pPostSubpassSampleLocations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentInitialSampleLocationsCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentInitialSampleLocationsCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachmentInitialSampleLocations() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachmentInitialSampleLocations(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get postSubpassSampleLocationsCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set postSubpassSampleLocationsCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pPostSubpassSampleLocations() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pPostSubpassSampleLocations(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineSampleLocationsStateCreateInfoEXT {
  pNext?: AnyPointer;
  sampleLocationsEnable?: Bool32;
  sampleLocationsInfo?: SampleLocationsInfoEXT;
}

export class PipelineSampleLocationsStateCreateInfoEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineSampleLocationsStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineSampleLocationsStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineSampleLocationsStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineSampleLocationsStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineSampleLocationsStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampleLocationsEnable !== undefined) this.sampleLocationsEnable = data.sampleLocationsEnable;
      if (data.sampleLocationsInfo !== undefined) this.sampleLocationsInfo = data.sampleLocationsInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampleLocationsEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationsEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampleLocationsInfo() {
    return new SampleLocationsInfoEXT(this.#data.subarray(20, 20 + SampleLocationsInfoEXT.size));
  }
  
  set sampleLocationsInfo(value: SampleLocationsInfoEXT) {
    if (value[BUFFER].byteLength < SampleLocationsInfoEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
}

export interface InitPhysicalDeviceSampleLocationsPropertiesEXT {
  pNext?: AnyPointer;
  sampleLocationSampleCounts?: SampleCountFlags;
  maxSampleLocationGridSize?: Extent2D;
  sampleLocationCoordinateRange?: number[];
  sampleLocationSubPixelBits?: number;
  variableSampleLocations?: Bool32;
}

export class PhysicalDeviceSampleLocationsPropertiesEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSampleLocationsPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSampleLocationsPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSampleLocationsPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSampleLocationsPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSampleLocationsPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampleLocationSampleCounts !== undefined) this.sampleLocationSampleCounts = data.sampleLocationSampleCounts;
      if (data.maxSampleLocationGridSize !== undefined) this.maxSampleLocationGridSize = data.maxSampleLocationGridSize;
      if (data.sampleLocationCoordinateRange !== undefined) this.sampleLocationCoordinateRange = data.sampleLocationCoordinateRange;
      if (data.sampleLocationSubPixelBits !== undefined) this.sampleLocationSubPixelBits = data.sampleLocationSubPixelBits;
      if (data.variableSampleLocations !== undefined) this.variableSampleLocations = data.variableSampleLocations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampleLocationSampleCounts() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleLocationSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSampleLocationGridSize() {
    return new Extent2D(this.#data.subarray(20, 20 + Extent2D.size));
  }
  
  set maxSampleLocationGridSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get sampleLocationCoordinateRange() {
    const result: number[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getFloat32(28 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set sampleLocationCoordinateRange(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(28 + i * 4, Number(value[i]), LE);
    }
  }
  
  get sampleLocationSubPixelBits() {
    return this.#view.getUint32(36, LE);
  }
  
  set sampleLocationSubPixelBits(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get variableSampleLocations() {
    return this.#view.getUint32(40, LE);
  }
  
  set variableSampleLocations(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitMultisamplePropertiesEXT {
  pNext?: AnyPointer;
  maxSampleLocationGridSize?: Extent2D;
}

export class MultisamplePropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMultisamplePropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMultisamplePropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(MultisamplePropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MultisamplePropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MultisamplePropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxSampleLocationGridSize !== undefined) this.maxSampleLocationGridSize = data.maxSampleLocationGridSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxSampleLocationGridSize() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set maxSampleLocationGridSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSamplerReductionModeCreateInfo {
  pNext?: AnyPointer;
  reductionMode?: SamplerReductionMode;
}

export class SamplerReductionModeCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerReductionModeCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerReductionModeCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(SamplerReductionModeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerReductionModeCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerReductionModeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.reductionMode !== undefined) this.reductionMode = data.reductionMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get reductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set reductionMode(value: SamplerReductionMode) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  pNext?: AnyPointer;
  advancedBlendCoherentOperations?: Bool32;
}

export class PhysicalDeviceBlendOperationAdvancedFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceBlendOperationAdvancedFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceBlendOperationAdvancedFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceBlendOperationAdvancedFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceBlendOperationAdvancedFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.advancedBlendCoherentOperations !== undefined) this.advancedBlendCoherentOperations = data.advancedBlendCoherentOperations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get advancedBlendCoherentOperations() {
    return this.#view.getUint32(16, LE);
  }
  
  set advancedBlendCoherentOperations(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMultiDrawFeaturesEXT {
  pNext?: AnyPointer;
  multiDraw?: Bool32;
}

export class PhysicalDeviceMultiDrawFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultiDrawFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultiDrawFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultiDrawFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultiDrawFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultiDrawFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.multiDraw !== undefined) this.multiDraw = data.multiDraw;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get multiDraw() {
    return this.#view.getUint32(16, LE);
  }
  
  set multiDraw(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  pNext?: AnyPointer;
  advancedBlendMaxColorAttachments?: number;
  advancedBlendIndependentBlend?: Bool32;
  advancedBlendNonPremultipliedSrcColor?: Bool32;
  advancedBlendNonPremultipliedDstColor?: Bool32;
  advancedBlendCorrelatedOverlap?: Bool32;
  advancedBlendAllOperations?: Bool32;
}

export class PhysicalDeviceBlendOperationAdvancedPropertiesEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceBlendOperationAdvancedPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceBlendOperationAdvancedPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceBlendOperationAdvancedPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceBlendOperationAdvancedPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.advancedBlendMaxColorAttachments !== undefined) this.advancedBlendMaxColorAttachments = data.advancedBlendMaxColorAttachments;
      if (data.advancedBlendIndependentBlend !== undefined) this.advancedBlendIndependentBlend = data.advancedBlendIndependentBlend;
      if (data.advancedBlendNonPremultipliedSrcColor !== undefined) this.advancedBlendNonPremultipliedSrcColor = data.advancedBlendNonPremultipliedSrcColor;
      if (data.advancedBlendNonPremultipliedDstColor !== undefined) this.advancedBlendNonPremultipliedDstColor = data.advancedBlendNonPremultipliedDstColor;
      if (data.advancedBlendCorrelatedOverlap !== undefined) this.advancedBlendCorrelatedOverlap = data.advancedBlendCorrelatedOverlap;
      if (data.advancedBlendAllOperations !== undefined) this.advancedBlendAllOperations = data.advancedBlendAllOperations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get advancedBlendMaxColorAttachments() {
    return this.#view.getUint32(16, LE);
  }
  
  set advancedBlendMaxColorAttachments(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get advancedBlendIndependentBlend() {
    return this.#view.getUint32(20, LE);
  }
  
  set advancedBlendIndependentBlend(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get advancedBlendNonPremultipliedSrcColor() {
    return this.#view.getUint32(24, LE);
  }
  
  set advancedBlendNonPremultipliedSrcColor(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get advancedBlendNonPremultipliedDstColor() {
    return this.#view.getUint32(28, LE);
  }
  
  set advancedBlendNonPremultipliedDstColor(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get advancedBlendCorrelatedOverlap() {
    return this.#view.getUint32(32, LE);
  }
  
  set advancedBlendCorrelatedOverlap(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get advancedBlendAllOperations() {
    return this.#view.getUint32(36, LE);
  }
  
  set advancedBlendAllOperations(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export interface InitPipelineColorBlendAdvancedStateCreateInfoEXT {
  pNext?: AnyPointer;
  srcPremultiplied?: Bool32;
  dstPremultiplied?: Bool32;
  blendOverlap?: BlendOverlapEXT;
}

export class PipelineColorBlendAdvancedStateCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineColorBlendAdvancedStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineColorBlendAdvancedStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineColorBlendAdvancedStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineColorBlendAdvancedStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineColorBlendAdvancedStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcPremultiplied !== undefined) this.srcPremultiplied = data.srcPremultiplied;
      if (data.dstPremultiplied !== undefined) this.dstPremultiplied = data.dstPremultiplied;
      if (data.blendOverlap !== undefined) this.blendOverlap = data.blendOverlap;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcPremultiplied() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcPremultiplied(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstPremultiplied() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstPremultiplied(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get blendOverlap() {
    return this.#view.getUint32(24, LE);
  }
  
  set blendOverlap(value: BlendOverlapEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceInlineUniformBlockFeatures {
  pNext?: AnyPointer;
  inlineUniformBlock?: Bool32;
  descriptorBindingInlineUniformBlockUpdateAfterBind?: Bool32;
}

export class PhysicalDeviceInlineUniformBlockFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceInlineUniformBlockFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceInlineUniformBlockFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceInlineUniformBlockFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceInlineUniformBlockFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceInlineUniformBlockFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.inlineUniformBlock !== undefined) this.inlineUniformBlock = data.inlineUniformBlock;
      if (data.descriptorBindingInlineUniformBlockUpdateAfterBind !== undefined) this.descriptorBindingInlineUniformBlockUpdateAfterBind = data.descriptorBindingInlineUniformBlockUpdateAfterBind;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get inlineUniformBlock() {
    return this.#view.getUint32(16, LE);
  }
  
  set inlineUniformBlock(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorBindingInlineUniformBlockUpdateAfterBind() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorBindingInlineUniformBlockUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceInlineUniformBlockProperties {
  pNext?: AnyPointer;
  maxInlineUniformBlockSize?: number;
  maxPerStageDescriptorInlineUniformBlocks?: number;
  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks?: number;
  maxDescriptorSetInlineUniformBlocks?: number;
  maxDescriptorSetUpdateAfterBindInlineUniformBlocks?: number;
}

export class PhysicalDeviceInlineUniformBlockProperties implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceInlineUniformBlockProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceInlineUniformBlockProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceInlineUniformBlockProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceInlineUniformBlockProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceInlineUniformBlockProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxInlineUniformBlockSize !== undefined) this.maxInlineUniformBlockSize = data.maxInlineUniformBlockSize;
      if (data.maxPerStageDescriptorInlineUniformBlocks !== undefined) this.maxPerStageDescriptorInlineUniformBlocks = data.maxPerStageDescriptorInlineUniformBlocks;
      if (data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks !== undefined) this.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
      if (data.maxDescriptorSetInlineUniformBlocks !== undefined) this.maxDescriptorSetInlineUniformBlocks = data.maxDescriptorSetInlineUniformBlocks;
      if (data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks !== undefined) this.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxInlineUniformBlockSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInlineUniformBlockSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxPerStageDescriptorInlineUniformBlocks() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxPerStageDescriptorInlineUniformBlocks(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxDescriptorSetInlineUniformBlocks() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxDescriptorSetInlineUniformBlocks(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitWriteDescriptorSetInlineUniformBlock {
  pNext?: AnyPointer;
  dataSize?: number;
  pData?: AnyPointer;
}

export class WriteDescriptorSetInlineUniformBlock implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWriteDescriptorSetInlineUniformBlock);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWriteDescriptorSetInlineUniformBlock) {
    if (!data) {
      this.#data = new Uint8Array(WriteDescriptorSetInlineUniformBlock.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < WriteDescriptorSetInlineUniformBlock.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(WriteDescriptorSetInlineUniformBlock.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dataSize !== undefined) this.dataSize = data.dataSize;
      if (data.pData !== undefined) this.pData = data.pData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dataSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set dataSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorPoolInlineUniformBlockCreateInfo {
  pNext?: AnyPointer;
  maxInlineUniformBlockBindings?: number;
}

export class DescriptorPoolInlineUniformBlockCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorPoolInlineUniformBlockCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorPoolInlineUniformBlockCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorPoolInlineUniformBlockCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorPoolInlineUniformBlockCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorPoolInlineUniformBlockCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxInlineUniformBlockBindings !== undefined) this.maxInlineUniformBlockBindings = data.maxInlineUniformBlockBindings;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxInlineUniformBlockBindings() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInlineUniformBlockBindings(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineCoverageModulationStateCreateInfoNV {
  pNext?: AnyPointer;
  flags?: PipelineCoverageModulationStateCreateFlagsNV;
  coverageModulationMode?: CoverageModulationModeNV;
  coverageModulationTableEnable?: Bool32;
  coverageModulationTableCount?: number;
  pCoverageModulationTable?: AnyPointer;
}

export class PipelineCoverageModulationStateCreateInfoNV implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCoverageModulationStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCoverageModulationStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCoverageModulationStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCoverageModulationStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCoverageModulationStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.coverageModulationMode !== undefined) this.coverageModulationMode = data.coverageModulationMode;
      if (data.coverageModulationTableEnable !== undefined) this.coverageModulationTableEnable = data.coverageModulationTableEnable;
      if (data.coverageModulationTableCount !== undefined) this.coverageModulationTableCount = data.coverageModulationTableCount;
      if (data.pCoverageModulationTable !== undefined) this.pCoverageModulationTable = data.pCoverageModulationTable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCoverageModulationStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageModulationMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageModulationMode(value: CoverageModulationModeNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get coverageModulationTableEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set coverageModulationTableEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get coverageModulationTableCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set coverageModulationTableCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pCoverageModulationTable() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pCoverageModulationTable(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageFormatListCreateInfo {
  pNext?: AnyPointer;
  viewFormatCount?: number;
  pViewFormats?: AnyPointer;
}

export class ImageFormatListCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageFormatListCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageFormatListCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImageFormatListCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageFormatListCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageFormatListCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.viewFormatCount !== undefined) this.viewFormatCount = data.viewFormatCount;
      if (data.pViewFormats !== undefined) this.pViewFormats = data.pViewFormats;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get viewFormatCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewFormatCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pViewFormats() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewFormats(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitValidationCacheCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: ValidationCacheCreateFlagsEXT;
  initialDataSize?: Deno.PointerValue;
  pInitialData?: AnyPointer;
}

export class ValidationCacheCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitValidationCacheCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitValidationCacheCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ValidationCacheCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ValidationCacheCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ValidationCacheCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.initialDataSize !== undefined) this.initialDataSize = data.initialDataSize;
      if (data.pInitialData !== undefined) this.pInitialData = data.pInitialData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ValidationCacheCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialDataSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pInitialData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInitialData(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitShaderModuleValidationCacheCreateInfoEXT {
  pNext?: AnyPointer;
  validationCache?: ValidationCacheEXT;
}

export class ShaderModuleValidationCacheCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShaderModuleValidationCacheCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShaderModuleValidationCacheCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ShaderModuleValidationCacheCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShaderModuleValidationCacheCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShaderModuleValidationCacheCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.validationCache !== undefined) this.validationCache = data.validationCache;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get validationCache() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set validationCache(value: ValidationCacheEXT) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceMaintenance3Properties {
  pNext?: AnyPointer;
  maxPerSetDescriptors?: number;
  maxMemoryAllocationSize?: DeviceSize;
}

export class PhysicalDeviceMaintenance3Properties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMaintenance3Properties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMaintenance3Properties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance3Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMaintenance3Properties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance3Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxPerSetDescriptors !== undefined) this.maxPerSetDescriptors = data.maxPerSetDescriptors;
      if (data.maxMemoryAllocationSize !== undefined) this.maxMemoryAllocationSize = data.maxMemoryAllocationSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxPerSetDescriptors() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPerSetDescriptors(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxMemoryAllocationSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxMemoryAllocationSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceMaintenance4Features {
  pNext?: AnyPointer;
  maintenance4?: Bool32;
}

export class PhysicalDeviceMaintenance4Features implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMaintenance4Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMaintenance4Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance4Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMaintenance4Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance4Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maintenance4 !== undefined) this.maintenance4 = data.maintenance4;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maintenance4() {
    return this.#view.getUint32(16, LE);
  }
  
  set maintenance4(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMaintenance4Properties {
  pNext?: AnyPointer;
  maxBufferSize?: DeviceSize;
}

export class PhysicalDeviceMaintenance4Properties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMaintenance4Properties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMaintenance4Properties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance4Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMaintenance4Properties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMaintenance4Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxBufferSize !== undefined) this.maxBufferSize = data.maxBufferSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxBufferSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxBufferSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitDescriptorSetLayoutSupport {
  pNext?: AnyPointer;
  supported?: Bool32;
}

export class DescriptorSetLayoutSupport implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetLayoutSupport);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetLayoutSupport) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetLayoutSupport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetLayoutSupport.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetLayoutSupport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supported !== undefined) this.supported = data.supported;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supported() {
    return this.#view.getUint32(16, LE);
  }
  
  set supported(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderDrawParametersFeatures {
  pNext?: AnyPointer;
  shaderDrawParameters?: Bool32;
}

export class PhysicalDeviceShaderDrawParametersFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderDrawParametersFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderDrawParametersFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderDrawParametersFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderDrawParametersFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderDrawParametersFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderDrawParameters !== undefined) this.shaderDrawParameters = data.shaderDrawParameters;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderDrawParameters() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderDrawParameters(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderFloat16Int8Features {
  pNext?: AnyPointer;
  shaderFloat16?: Bool32;
  shaderInt8?: Bool32;
}

export class PhysicalDeviceShaderFloat16Int8Features implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderFloat16Int8Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderFloat16Int8Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderFloat16Int8Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderFloat16Int8Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderFloat16Int8Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderFloat16 !== undefined) this.shaderFloat16 = data.shaderFloat16;
      if (data.shaderInt8 !== undefined) this.shaderInt8 = data.shaderInt8;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderFloat16() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderFloat16(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderInt8() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderInt8(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFloatControlsProperties {
  pNext?: AnyPointer;
  denormBehaviorIndependence?: ShaderFloatControlsIndependence;
  roundingModeIndependence?: ShaderFloatControlsIndependence;
  shaderSignedZeroInfNanPreserveFloat16?: Bool32;
  shaderSignedZeroInfNanPreserveFloat32?: Bool32;
  shaderSignedZeroInfNanPreserveFloat64?: Bool32;
  shaderDenormPreserveFloat16?: Bool32;
  shaderDenormPreserveFloat32?: Bool32;
  shaderDenormPreserveFloat64?: Bool32;
  shaderDenormFlushToZeroFloat16?: Bool32;
  shaderDenormFlushToZeroFloat32?: Bool32;
  shaderDenormFlushToZeroFloat64?: Bool32;
  shaderRoundingModeRTEFloat16?: Bool32;
  shaderRoundingModeRTEFloat32?: Bool32;
  shaderRoundingModeRTEFloat64?: Bool32;
  shaderRoundingModeRTZFloat16?: Bool32;
  shaderRoundingModeRTZFloat32?: Bool32;
  shaderRoundingModeRTZFloat64?: Bool32;
}

export class PhysicalDeviceFloatControlsProperties implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFloatControlsProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFloatControlsProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFloatControlsProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFloatControlsProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFloatControlsProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.denormBehaviorIndependence !== undefined) this.denormBehaviorIndependence = data.denormBehaviorIndependence;
      if (data.roundingModeIndependence !== undefined) this.roundingModeIndependence = data.roundingModeIndependence;
      if (data.shaderSignedZeroInfNanPreserveFloat16 !== undefined) this.shaderSignedZeroInfNanPreserveFloat16 = data.shaderSignedZeroInfNanPreserveFloat16;
      if (data.shaderSignedZeroInfNanPreserveFloat32 !== undefined) this.shaderSignedZeroInfNanPreserveFloat32 = data.shaderSignedZeroInfNanPreserveFloat32;
      if (data.shaderSignedZeroInfNanPreserveFloat64 !== undefined) this.shaderSignedZeroInfNanPreserveFloat64 = data.shaderSignedZeroInfNanPreserveFloat64;
      if (data.shaderDenormPreserveFloat16 !== undefined) this.shaderDenormPreserveFloat16 = data.shaderDenormPreserveFloat16;
      if (data.shaderDenormPreserveFloat32 !== undefined) this.shaderDenormPreserveFloat32 = data.shaderDenormPreserveFloat32;
      if (data.shaderDenormPreserveFloat64 !== undefined) this.shaderDenormPreserveFloat64 = data.shaderDenormPreserveFloat64;
      if (data.shaderDenormFlushToZeroFloat16 !== undefined) this.shaderDenormFlushToZeroFloat16 = data.shaderDenormFlushToZeroFloat16;
      if (data.shaderDenormFlushToZeroFloat32 !== undefined) this.shaderDenormFlushToZeroFloat32 = data.shaderDenormFlushToZeroFloat32;
      if (data.shaderDenormFlushToZeroFloat64 !== undefined) this.shaderDenormFlushToZeroFloat64 = data.shaderDenormFlushToZeroFloat64;
      if (data.shaderRoundingModeRTEFloat16 !== undefined) this.shaderRoundingModeRTEFloat16 = data.shaderRoundingModeRTEFloat16;
      if (data.shaderRoundingModeRTEFloat32 !== undefined) this.shaderRoundingModeRTEFloat32 = data.shaderRoundingModeRTEFloat32;
      if (data.shaderRoundingModeRTEFloat64 !== undefined) this.shaderRoundingModeRTEFloat64 = data.shaderRoundingModeRTEFloat64;
      if (data.shaderRoundingModeRTZFloat16 !== undefined) this.shaderRoundingModeRTZFloat16 = data.shaderRoundingModeRTZFloat16;
      if (data.shaderRoundingModeRTZFloat32 !== undefined) this.shaderRoundingModeRTZFloat32 = data.shaderRoundingModeRTZFloat32;
      if (data.shaderRoundingModeRTZFloat64 !== undefined) this.shaderRoundingModeRTZFloat64 = data.shaderRoundingModeRTZFloat64;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get denormBehaviorIndependence() {
    return this.#view.getUint32(16, LE);
  }
  
  set denormBehaviorIndependence(value: ShaderFloatControlsIndependence) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get roundingModeIndependence() {
    return this.#view.getUint32(20, LE);
  }
  
  set roundingModeIndependence(value: ShaderFloatControlsIndependence) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat16() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat16(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat32() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat32(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat64() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat64(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat16() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderDenormPreserveFloat16(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat32() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderDenormPreserveFloat32(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat64() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderDenormPreserveFloat64(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat16() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderDenormFlushToZeroFloat16(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat32() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderDenormFlushToZeroFloat32(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat64() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderDenormFlushToZeroFloat64(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat16() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderRoundingModeRTEFloat16(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat32() {
    return this.#view.getUint32(64, LE);
  }
  
  set shaderRoundingModeRTEFloat32(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat64() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderRoundingModeRTEFloat64(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat16() {
    return this.#view.getUint32(72, LE);
  }
  
  set shaderRoundingModeRTZFloat16(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat32() {
    return this.#view.getUint32(76, LE);
  }
  
  set shaderRoundingModeRTZFloat32(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat64() {
    return this.#view.getUint32(80, LE);
  }
  
  set shaderRoundingModeRTZFloat64(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export interface InitPhysicalDeviceHostQueryResetFeatures {
  pNext?: AnyPointer;
  hostQueryReset?: Bool32;
}

export class PhysicalDeviceHostQueryResetFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceHostQueryResetFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceHostQueryResetFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceHostQueryResetFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceHostQueryResetFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceHostQueryResetFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.hostQueryReset !== undefined) this.hostQueryReset = data.hostQueryReset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get hostQueryReset() {
    return this.#view.getUint32(16, LE);
  }
  
  set hostQueryReset(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitNativeBufferUsage2ANDROID {
  consumer?: Deno.PointerValue;
  producer?: Deno.PointerValue;
}

export class NativeBufferUsage2ANDROID implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitNativeBufferUsage2ANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitNativeBufferUsage2ANDROID) {
    if (!data) {
      this.#data = new Uint8Array(NativeBufferUsage2ANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < NativeBufferUsage2ANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(NativeBufferUsage2ANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.consumer !== undefined) this.consumer = data.consumer;
      if (data.producer !== undefined) this.producer = data.producer;
    }
  }
  
  get consumer() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set consumer(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get producer() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set producer(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export interface InitNativeBufferANDROID {
  pNext?: AnyPointer;
  handle?: AnyPointer;
  stride?: number;
  format?: number;
  usage?: number;
  usage2?: NativeBufferUsage2ANDROID;
}

export class NativeBufferANDROID implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitNativeBufferANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitNativeBufferANDROID) {
    if (!data) {
      this.#data = new Uint8Array(NativeBufferANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < NativeBufferANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(NativeBufferANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handle !== undefined) this.handle = data.handle;
      if (data.stride !== undefined) this.stride = data.stride;
      if (data.format !== undefined) this.format = data.format;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.usage2 !== undefined) this.usage2 = data.usage2;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handle() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set handle(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get stride() {
    return this.#view.getInt32(24, LE);
  }
  
  set stride(value: number) {
    this.#view.setInt32(24, Number(value), LE);
  }
  
  get format() {
    return this.#view.getInt32(28, LE);
  }
  
  set format(value: number) {
    this.#view.setInt32(28, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getInt32(32, LE);
  }
  
  set usage(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
  
  get usage2() {
    return new NativeBufferUsage2ANDROID(this.#data.subarray(40, 40 + NativeBufferUsage2ANDROID.size));
  }
  
  set usage2(value: NativeBufferUsage2ANDROID) {
    if (value[BUFFER].byteLength < NativeBufferUsage2ANDROID.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
}

export interface InitSwapchainImageCreateInfoANDROID {
  pNext?: AnyPointer;
  usage?: SwapchainImageUsageFlagsANDROID;
}

export class SwapchainImageCreateInfoANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSwapchainImageCreateInfoANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSwapchainImageCreateInfoANDROID) {
    if (!data) {
      this.#data = new Uint8Array(SwapchainImageCreateInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SwapchainImageCreateInfoANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SwapchainImageCreateInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.usage !== undefined) this.usage = data.usage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: SwapchainImageUsageFlagsANDROID) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePresentationPropertiesANDROID {
  pNext?: AnyPointer;
  sharedImage?: Bool32;
}

export class PhysicalDevicePresentationPropertiesANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePresentationPropertiesANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePresentationPropertiesANDROID) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePresentationPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePresentationPropertiesANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePresentationPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sharedImage !== undefined) this.sharedImage = data.sharedImage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sharedImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set sharedImage(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitShaderResourceUsageAMD {
  numUsedVgprs?: number;
  numUsedSgprs?: number;
  ldsSizePerLocalWorkGroup?: number;
  ldsUsageSizeInBytes?: Deno.PointerValue;
  scratchMemUsageInBytes?: Deno.PointerValue;
}

export class ShaderResourceUsageAMD implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShaderResourceUsageAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShaderResourceUsageAMD) {
    if (!data) {
      this.#data = new Uint8Array(ShaderResourceUsageAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShaderResourceUsageAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShaderResourceUsageAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.numUsedVgprs !== undefined) this.numUsedVgprs = data.numUsedVgprs;
      if (data.numUsedSgprs !== undefined) this.numUsedSgprs = data.numUsedSgprs;
      if (data.ldsSizePerLocalWorkGroup !== undefined) this.ldsSizePerLocalWorkGroup = data.ldsSizePerLocalWorkGroup;
      if (data.ldsUsageSizeInBytes !== undefined) this.ldsUsageSizeInBytes = data.ldsUsageSizeInBytes;
      if (data.scratchMemUsageInBytes !== undefined) this.scratchMemUsageInBytes = data.scratchMemUsageInBytes;
    }
  }
  
  get numUsedVgprs() {
    return this.#view.getUint32(0, LE);
  }
  
  set numUsedVgprs(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get numUsedSgprs() {
    return this.#view.getUint32(4, LE);
  }
  
  set numUsedSgprs(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get ldsSizePerLocalWorkGroup() {
    return this.#view.getUint32(8, LE);
  }
  
  set ldsSizePerLocalWorkGroup(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get ldsUsageSizeInBytes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set ldsUsageSizeInBytes(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get scratchMemUsageInBytes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set scratchMemUsageInBytes(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitShaderStatisticsInfoAMD {
  shaderStageMask?: ShaderStageFlags;
  resourceUsage?: ShaderResourceUsageAMD;
  numPhysicalVgprs?: number;
  numPhysicalSgprs?: number;
  numAvailableVgprs?: number;
  numAvailableSgprs?: number;
  computeWorkGroupSize?: number[];
}

export class ShaderStatisticsInfoAMD implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShaderStatisticsInfoAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShaderStatisticsInfoAMD) {
    if (!data) {
      this.#data = new Uint8Array(ShaderStatisticsInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShaderStatisticsInfoAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShaderStatisticsInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.shaderStageMask !== undefined) this.shaderStageMask = data.shaderStageMask;
      if (data.resourceUsage !== undefined) this.resourceUsage = data.resourceUsage;
      if (data.numPhysicalVgprs !== undefined) this.numPhysicalVgprs = data.numPhysicalVgprs;
      if (data.numPhysicalSgprs !== undefined) this.numPhysicalSgprs = data.numPhysicalSgprs;
      if (data.numAvailableVgprs !== undefined) this.numAvailableVgprs = data.numAvailableVgprs;
      if (data.numAvailableSgprs !== undefined) this.numAvailableSgprs = data.numAvailableSgprs;
      if (data.computeWorkGroupSize !== undefined) this.computeWorkGroupSize = data.computeWorkGroupSize;
    }
  }
  
  get shaderStageMask() {
    return this.#view.getUint32(0, LE);
  }
  
  set shaderStageMask(value: ShaderStageFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get resourceUsage() {
    return new ShaderResourceUsageAMD(this.#data.subarray(4, 4 + ShaderResourceUsageAMD.size));
  }
  
  set resourceUsage(value: ShaderResourceUsageAMD) {
    if (value[BUFFER].byteLength < ShaderResourceUsageAMD.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
  
  get numPhysicalVgprs() {
    return this.#view.getUint32(36, LE);
  }
  
  set numPhysicalVgprs(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get numPhysicalSgprs() {
    return this.#view.getUint32(40, LE);
  }
  
  set numPhysicalSgprs(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get numAvailableVgprs() {
    return this.#view.getUint32(44, LE);
  }
  
  set numAvailableVgprs(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get numAvailableSgprs() {
    return this.#view.getUint32(48, LE);
  }
  
  set numAvailableSgprs(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get computeWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(52 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set computeWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(52 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitDeviceQueueGlobalPriorityCreateInfoKHR {
  pNext?: AnyPointer;
  globalPriority?: QueueGlobalPriorityKHR;
}

export class DeviceQueueGlobalPriorityCreateInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceQueueGlobalPriorityCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceQueueGlobalPriorityCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(DeviceQueueGlobalPriorityCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceQueueGlobalPriorityCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceQueueGlobalPriorityCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.globalPriority !== undefined) this.globalPriority = data.globalPriority;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get globalPriority() {
    return this.#view.getUint32(16, LE);
  }
  
  set globalPriority(value: QueueGlobalPriorityKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceGlobalPriorityQueryFeaturesKHR {
  pNext?: AnyPointer;
  globalPriorityQuery?: Bool32;
}

export class PhysicalDeviceGlobalPriorityQueryFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceGlobalPriorityQueryFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceGlobalPriorityQueryFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceGlobalPriorityQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceGlobalPriorityQueryFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceGlobalPriorityQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.globalPriorityQuery !== undefined) this.globalPriorityQuery = data.globalPriorityQuery;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get globalPriorityQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set globalPriorityQuery(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitQueueFamilyGlobalPriorityPropertiesKHR {
  pNext?: AnyPointer;
  priorityCount?: number;
  priorities?: QueueGlobalPriorityKHR[];
}

export class QueueFamilyGlobalPriorityPropertiesKHR implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyGlobalPriorityPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyGlobalPriorityPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyGlobalPriorityPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyGlobalPriorityPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyGlobalPriorityPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.priorityCount !== undefined) this.priorityCount = data.priorityCount;
      if (data.priorities !== undefined) this.priorities = data.priorities;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get priorityCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set priorityCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get priorities() {
    const result: QueueGlobalPriorityKHR[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint32(20 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set priorities(value: QueueGlobalPriorityKHR[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(20 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitDebugUtilsObjectNameInfoEXT {
  pNext?: AnyPointer;
  objectType?: ObjectType;
  objectHandle?: Deno.PointerValue;
  pObjectName?: AnyPointer;
}

export class DebugUtilsObjectNameInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugUtilsObjectNameInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugUtilsObjectNameInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugUtilsObjectNameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugUtilsObjectNameInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugUtilsObjectNameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.objectType !== undefined) this.objectType = data.objectType;
      if (data.objectHandle !== undefined) this.objectHandle = data.objectHandle;
      if (data.pObjectName !== undefined) this.pObjectName = data.pObjectName;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: ObjectType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get pObjectName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pObjectName(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugUtilsObjectTagInfoEXT {
  pNext?: AnyPointer;
  objectType?: ObjectType;
  objectHandle?: Deno.PointerValue;
  tagName?: Deno.PointerValue;
  tagSize?: Deno.PointerValue;
  pTag?: AnyPointer;
}

export class DebugUtilsObjectTagInfoEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugUtilsObjectTagInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugUtilsObjectTagInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugUtilsObjectTagInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugUtilsObjectTagInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugUtilsObjectTagInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.objectType !== undefined) this.objectType = data.objectType;
      if (data.objectHandle !== undefined) this.objectHandle = data.objectHandle;
      if (data.tagName !== undefined) this.tagName = data.tagName;
      if (data.tagSize !== undefined) this.tagSize = data.tagSize;
      if (data.pTag !== undefined) this.pTag = data.pTag;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set objectType(value: ObjectType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get tagName() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set tagName(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get tagSize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set tagSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get pTag() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pTag(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugUtilsLabelEXT {
  pNext?: AnyPointer;
  pLabelName?: AnyPointer;
  color?: number[];
}

export class DebugUtilsLabelEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugUtilsLabelEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugUtilsLabelEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugUtilsLabelEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugUtilsLabelEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugUtilsLabelEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pLabelName !== undefined) this.pLabelName = data.pLabelName;
      if (data.color !== undefined) this.color = data.color;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pLabelName() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pLabelName(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get color() {
    const result: number[] = [];
    for (let i = 0; i < 4; i++) {
      result.push((() => {
        return this.#view.getFloat32(24 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set color(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(24 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitDebugUtilsMessengerCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: DebugUtilsMessengerCreateFlagsEXT;
  messageSeverity?: DebugUtilsMessageSeverityFlagsEXT;
  messageType?: DebugUtilsMessageTypeFlagsEXT;
  pfnUserCallback?: Deno.PointerValue;
  pUserData?: AnyPointer;
}

export class DebugUtilsMessengerCreateInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugUtilsMessengerCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugUtilsMessengerCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugUtilsMessengerCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugUtilsMessengerCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugUtilsMessengerCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.messageSeverity !== undefined) this.messageSeverity = data.messageSeverity;
      if (data.messageType !== undefined) this.messageType = data.messageType;
      if (data.pfnUserCallback !== undefined) this.pfnUserCallback = data.pfnUserCallback;
      if (data.pUserData !== undefined) this.pUserData = data.pUserData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DebugUtilsMessengerCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get messageSeverity() {
    return this.#view.getUint32(20, LE);
  }
  
  set messageSeverity(value: DebugUtilsMessageSeverityFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get messageType() {
    return this.#view.getUint32(24, LE);
  }
  
  set messageType(value: DebugUtilsMessageTypeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pfnUserCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnUserCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pUserData(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDebugUtilsMessengerCallbackDataEXT {
  pNext?: AnyPointer;
  flags?: DebugUtilsMessengerCallbackDataFlagsEXT;
  pMessageIdName?: AnyPointer;
  messageIdNumber?: number;
  pMessage?: AnyPointer;
  queueLabelCount?: number;
  pQueueLabels?: AnyPointer;
  cmdBufLabelCount?: number;
  pCmdBufLabels?: AnyPointer;
  objectCount?: number;
  pObjects?: AnyPointer;
}

export class DebugUtilsMessengerCallbackDataEXT implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDebugUtilsMessengerCallbackDataEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDebugUtilsMessengerCallbackDataEXT) {
    if (!data) {
      this.#data = new Uint8Array(DebugUtilsMessengerCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DebugUtilsMessengerCallbackDataEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DebugUtilsMessengerCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pMessageIdName !== undefined) this.pMessageIdName = data.pMessageIdName;
      if (data.messageIdNumber !== undefined) this.messageIdNumber = data.messageIdNumber;
      if (data.pMessage !== undefined) this.pMessage = data.pMessage;
      if (data.queueLabelCount !== undefined) this.queueLabelCount = data.queueLabelCount;
      if (data.pQueueLabels !== undefined) this.pQueueLabels = data.pQueueLabels;
      if (data.cmdBufLabelCount !== undefined) this.cmdBufLabelCount = data.cmdBufLabelCount;
      if (data.pCmdBufLabels !== undefined) this.pCmdBufLabels = data.pCmdBufLabels;
      if (data.objectCount !== undefined) this.objectCount = data.objectCount;
      if (data.pObjects !== undefined) this.pObjects = data.pObjects;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DebugUtilsMessengerCallbackDataFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pMessageIdName() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMessageIdName(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get messageIdNumber() {
    return this.#view.getInt32(32, LE);
  }
  
  set messageIdNumber(value: number) {
    this.#view.setInt32(32, Number(value), LE);
  }
  
  get pMessage() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pMessage(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get queueLabelCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set queueLabelCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pQueueLabels() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pQueueLabels(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get cmdBufLabelCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set cmdBufLabelCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pCmdBufLabels() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pCmdBufLabels(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get objectCount() {
    return this.#view.getUint32(80, LE);
  }
  
  set objectCount(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get pObjects() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set pObjects(value: AnyPointer) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDeviceMemoryReportFeaturesEXT {
  pNext?: AnyPointer;
  deviceMemoryReport?: Bool32;
}

export class PhysicalDeviceDeviceMemoryReportFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDeviceMemoryReportFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDeviceMemoryReportFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDeviceMemoryReportFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDeviceMemoryReportFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDeviceMemoryReportFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceMemoryReport !== undefined) this.deviceMemoryReport = data.deviceMemoryReport;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceMemoryReport() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceMemoryReport(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceDeviceMemoryReportCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: DeviceMemoryReportFlagsEXT;
  pfnUserCallback?: Deno.PointerValue;
  pUserData?: AnyPointer;
}

export class DeviceDeviceMemoryReportCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceDeviceMemoryReportCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceDeviceMemoryReportCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceDeviceMemoryReportCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceDeviceMemoryReportCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceDeviceMemoryReportCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pfnUserCallback !== undefined) this.pfnUserCallback = data.pfnUserCallback;
      if (data.pUserData !== undefined) this.pUserData = data.pUserData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceMemoryReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pfnUserCallback() {
    throw new Error(`Unknown type: "function"`);
  }
  
  set pfnUserCallback(value: Deno.PointerValue) {
    throw new Error(`Unknown type: "function"`);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pUserData(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceMemoryReportCallbackDataEXT {
  pNext?: AnyPointer;
  flags?: DeviceMemoryReportFlagsEXT;
  type?: DeviceMemoryReportEventTypeEXT;
  memoryObjectId?: Deno.PointerValue;
  size?: DeviceSize;
  objectType?: ObjectType;
  objectHandle?: Deno.PointerValue;
  heapIndex?: number;
}

export class DeviceMemoryReportCallbackDataEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceMemoryReportCallbackDataEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceMemoryReportCallbackDataEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceMemoryReportCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceMemoryReportCallbackDataEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceMemoryReportCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.type !== undefined) this.type = data.type;
      if (data.memoryObjectId !== undefined) this.memoryObjectId = data.memoryObjectId;
      if (data.size !== undefined) this.size = data.size;
      if (data.objectType !== undefined) this.objectType = data.objectType;
      if (data.objectHandle !== undefined) this.objectHandle = data.objectHandle;
      if (data.heapIndex !== undefined) this.heapIndex = data.heapIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceMemoryReportFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(20, LE);
  }
  
  set type(value: DeviceMemoryReportEventTypeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get memoryObjectId() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memoryObjectId(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get objectType() {
    return this.#view.getUint32(40, LE);
  }
  
  set objectType(value: ObjectType) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get objectHandle() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set objectHandle(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get heapIndex() {
    return this.#view.getUint32(56, LE);
  }
  
  set heapIndex(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitImportMemoryHostPointerInfoEXT {
  pNext?: AnyPointer;
  handleType?: ExternalMemoryHandleTypeFlagBits;
  pHostPointer?: AnyPointer;
}

export class ImportMemoryHostPointerInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryHostPointerInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryHostPointerInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryHostPointerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryHostPointerInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryHostPointerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.handleType !== undefined) this.handleType = data.handleType;
      if (data.pHostPointer !== undefined) this.pHostPointer = data.pHostPointer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(16, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pHostPointer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pHostPointer(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMemoryHostPointerPropertiesEXT {
  pNext?: AnyPointer;
  memoryTypeBits?: number;
}

export class MemoryHostPointerPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryHostPointerPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryHostPointerPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(MemoryHostPointerPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryHostPointerPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryHostPointerPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExternalMemoryHostPropertiesEXT {
  pNext?: AnyPointer;
  minImportedHostPointerAlignment?: DeviceSize;
}

export class PhysicalDeviceExternalMemoryHostPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalMemoryHostPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalMemoryHostPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalMemoryHostPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalMemoryHostPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalMemoryHostPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minImportedHostPointerAlignment !== undefined) this.minImportedHostPointerAlignment = data.minImportedHostPointerAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minImportedHostPointerAlignment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set minImportedHostPointerAlignment(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceConservativeRasterizationPropertiesEXT {
  pNext?: AnyPointer;
  primitiveOverestimationSize?: number;
  maxExtraPrimitiveOverestimationSize?: number;
  extraPrimitiveOverestimationSizeGranularity?: number;
  primitiveUnderestimation?: Bool32;
  conservativePointAndLineRasterization?: Bool32;
  degenerateTrianglesRasterized?: Bool32;
  degenerateLinesRasterized?: Bool32;
  fullyCoveredFragmentShaderInputVariable?: Bool32;
  conservativeRasterizationPostDepthCoverage?: Bool32;
}

export class PhysicalDeviceConservativeRasterizationPropertiesEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceConservativeRasterizationPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceConservativeRasterizationPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceConservativeRasterizationPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceConservativeRasterizationPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceConservativeRasterizationPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.primitiveOverestimationSize !== undefined) this.primitiveOverestimationSize = data.primitiveOverestimationSize;
      if (data.maxExtraPrimitiveOverestimationSize !== undefined) this.maxExtraPrimitiveOverestimationSize = data.maxExtraPrimitiveOverestimationSize;
      if (data.extraPrimitiveOverestimationSizeGranularity !== undefined) this.extraPrimitiveOverestimationSizeGranularity = data.extraPrimitiveOverestimationSizeGranularity;
      if (data.primitiveUnderestimation !== undefined) this.primitiveUnderestimation = data.primitiveUnderestimation;
      if (data.conservativePointAndLineRasterization !== undefined) this.conservativePointAndLineRasterization = data.conservativePointAndLineRasterization;
      if (data.degenerateTrianglesRasterized !== undefined) this.degenerateTrianglesRasterized = data.degenerateTrianglesRasterized;
      if (data.degenerateLinesRasterized !== undefined) this.degenerateLinesRasterized = data.degenerateLinesRasterized;
      if (data.fullyCoveredFragmentShaderInputVariable !== undefined) this.fullyCoveredFragmentShaderInputVariable = data.fullyCoveredFragmentShaderInputVariable;
      if (data.conservativeRasterizationPostDepthCoverage !== undefined) this.conservativeRasterizationPostDepthCoverage = data.conservativeRasterizationPostDepthCoverage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get primitiveOverestimationSize() {
    return this.#view.getFloat32(16, LE);
  }
  
  set primitiveOverestimationSize(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxExtraPrimitiveOverestimationSize() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxExtraPrimitiveOverestimationSize(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
  
  get extraPrimitiveOverestimationSizeGranularity() {
    return this.#view.getFloat32(24, LE);
  }
  
  set extraPrimitiveOverestimationSizeGranularity(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
  
  get primitiveUnderestimation() {
    return this.#view.getUint32(28, LE);
  }
  
  set primitiveUnderestimation(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get conservativePointAndLineRasterization() {
    return this.#view.getUint32(32, LE);
  }
  
  set conservativePointAndLineRasterization(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get degenerateTrianglesRasterized() {
    return this.#view.getUint32(36, LE);
  }
  
  set degenerateTrianglesRasterized(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get degenerateLinesRasterized() {
    return this.#view.getUint32(40, LE);
  }
  
  set degenerateLinesRasterized(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get fullyCoveredFragmentShaderInputVariable() {
    return this.#view.getUint32(44, LE);
  }
  
  set fullyCoveredFragmentShaderInputVariable(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get conservativeRasterizationPostDepthCoverage() {
    return this.#view.getUint32(48, LE);
  }
  
  set conservativeRasterizationPostDepthCoverage(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitCalibratedTimestampInfoEXT {
  pNext?: AnyPointer;
  timeDomain?: TimeDomainEXT;
}

export class CalibratedTimestampInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCalibratedTimestampInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCalibratedTimestampInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(CalibratedTimestampInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CalibratedTimestampInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CalibratedTimestampInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.timeDomain !== undefined) this.timeDomain = data.timeDomain;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get timeDomain() {
    return this.#view.getUint32(16, LE);
  }
  
  set timeDomain(value: TimeDomainEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderCorePropertiesAMD {
  pNext?: AnyPointer;
  shaderEngineCount?: number;
  shaderArraysPerEngineCount?: number;
  computeUnitsPerShaderArray?: number;
  simdPerComputeUnit?: number;
  wavefrontsPerSimd?: number;
  wavefrontSize?: number;
  sgprsPerSimd?: number;
  minSgprAllocation?: number;
  maxSgprAllocation?: number;
  sgprAllocationGranularity?: number;
  vgprsPerSimd?: number;
  minVgprAllocation?: number;
  maxVgprAllocation?: number;
  vgprAllocationGranularity?: number;
}

export class PhysicalDeviceShaderCorePropertiesAMD implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderCorePropertiesAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderCorePropertiesAMD) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderCorePropertiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderCorePropertiesAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderCorePropertiesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderEngineCount !== undefined) this.shaderEngineCount = data.shaderEngineCount;
      if (data.shaderArraysPerEngineCount !== undefined) this.shaderArraysPerEngineCount = data.shaderArraysPerEngineCount;
      if (data.computeUnitsPerShaderArray !== undefined) this.computeUnitsPerShaderArray = data.computeUnitsPerShaderArray;
      if (data.simdPerComputeUnit !== undefined) this.simdPerComputeUnit = data.simdPerComputeUnit;
      if (data.wavefrontsPerSimd !== undefined) this.wavefrontsPerSimd = data.wavefrontsPerSimd;
      if (data.wavefrontSize !== undefined) this.wavefrontSize = data.wavefrontSize;
      if (data.sgprsPerSimd !== undefined) this.sgprsPerSimd = data.sgprsPerSimd;
      if (data.minSgprAllocation !== undefined) this.minSgprAllocation = data.minSgprAllocation;
      if (data.maxSgprAllocation !== undefined) this.maxSgprAllocation = data.maxSgprAllocation;
      if (data.sgprAllocationGranularity !== undefined) this.sgprAllocationGranularity = data.sgprAllocationGranularity;
      if (data.vgprsPerSimd !== undefined) this.vgprsPerSimd = data.vgprsPerSimd;
      if (data.minVgprAllocation !== undefined) this.minVgprAllocation = data.minVgprAllocation;
      if (data.maxVgprAllocation !== undefined) this.maxVgprAllocation = data.maxVgprAllocation;
      if (data.vgprAllocationGranularity !== undefined) this.vgprAllocationGranularity = data.vgprAllocationGranularity;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderEngineCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderEngineCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderArraysPerEngineCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderArraysPerEngineCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get computeUnitsPerShaderArray() {
    return this.#view.getUint32(24, LE);
  }
  
  set computeUnitsPerShaderArray(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get simdPerComputeUnit() {
    return this.#view.getUint32(28, LE);
  }
  
  set simdPerComputeUnit(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get wavefrontsPerSimd() {
    return this.#view.getUint32(32, LE);
  }
  
  set wavefrontsPerSimd(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get wavefrontSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set wavefrontSize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get sgprsPerSimd() {
    return this.#view.getUint32(40, LE);
  }
  
  set sgprsPerSimd(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minSgprAllocation() {
    return this.#view.getUint32(44, LE);
  }
  
  set minSgprAllocation(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxSgprAllocation() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxSgprAllocation(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get sgprAllocationGranularity() {
    return this.#view.getUint32(52, LE);
  }
  
  set sgprAllocationGranularity(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get vgprsPerSimd() {
    return this.#view.getUint32(56, LE);
  }
  
  set vgprsPerSimd(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get minVgprAllocation() {
    return this.#view.getUint32(60, LE);
  }
  
  set minVgprAllocation(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxVgprAllocation() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxVgprAllocation(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get vgprAllocationGranularity() {
    return this.#view.getUint32(68, LE);
  }
  
  set vgprAllocationGranularity(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderCoreProperties2AMD {
  pNext?: AnyPointer;
  shaderCoreFeatures?: ShaderCorePropertiesFlagsAMD;
  activeComputeUnitCount?: number;
}

export class PhysicalDeviceShaderCoreProperties2AMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderCoreProperties2AMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderCoreProperties2AMD) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreProperties2AMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderCoreProperties2AMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreProperties2AMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderCoreFeatures !== undefined) this.shaderCoreFeatures = data.shaderCoreFeatures;
      if (data.activeComputeUnitCount !== undefined) this.activeComputeUnitCount = data.activeComputeUnitCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderCoreFeatures() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderCoreFeatures(value: ShaderCorePropertiesFlagsAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get activeComputeUnitCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set activeComputeUnitCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPipelineRasterizationConservativeStateCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: PipelineRasterizationConservativeStateCreateFlagsEXT;
  conservativeRasterizationMode?: ConservativeRasterizationModeEXT;
  extraPrimitiveOverestimationSize?: number;
}

export class PipelineRasterizationConservativeStateCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationConservativeStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationConservativeStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationConservativeStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationConservativeStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationConservativeStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.conservativeRasterizationMode !== undefined) this.conservativeRasterizationMode = data.conservativeRasterizationMode;
      if (data.extraPrimitiveOverestimationSize !== undefined) this.extraPrimitiveOverestimationSize = data.extraPrimitiveOverestimationSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineRasterizationConservativeStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get conservativeRasterizationMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set conservativeRasterizationMode(value: ConservativeRasterizationModeEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extraPrimitiveOverestimationSize() {
    return this.#view.getFloat32(24, LE);
  }
  
  set extraPrimitiveOverestimationSize(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDescriptorIndexingFeatures {
  pNext?: AnyPointer;
  shaderInputAttachmentArrayDynamicIndexing?: Bool32;
  shaderUniformTexelBufferArrayDynamicIndexing?: Bool32;
  shaderStorageTexelBufferArrayDynamicIndexing?: Bool32;
  shaderUniformBufferArrayNonUniformIndexing?: Bool32;
  shaderSampledImageArrayNonUniformIndexing?: Bool32;
  shaderStorageBufferArrayNonUniformIndexing?: Bool32;
  shaderStorageImageArrayNonUniformIndexing?: Bool32;
  shaderInputAttachmentArrayNonUniformIndexing?: Bool32;
  shaderUniformTexelBufferArrayNonUniformIndexing?: Bool32;
  shaderStorageTexelBufferArrayNonUniformIndexing?: Bool32;
  descriptorBindingUniformBufferUpdateAfterBind?: Bool32;
  descriptorBindingSampledImageUpdateAfterBind?: Bool32;
  descriptorBindingStorageImageUpdateAfterBind?: Bool32;
  descriptorBindingStorageBufferUpdateAfterBind?: Bool32;
  descriptorBindingUniformTexelBufferUpdateAfterBind?: Bool32;
  descriptorBindingStorageTexelBufferUpdateAfterBind?: Bool32;
  descriptorBindingUpdateUnusedWhilePending?: Bool32;
  descriptorBindingPartiallyBound?: Bool32;
  descriptorBindingVariableDescriptorCount?: Bool32;
  runtimeDescriptorArray?: Bool32;
}

export class PhysicalDeviceDescriptorIndexingFeatures implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorIndexingFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorIndexingFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorIndexingFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorIndexingFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorIndexingFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderInputAttachmentArrayDynamicIndexing !== undefined) this.shaderInputAttachmentArrayDynamicIndexing = data.shaderInputAttachmentArrayDynamicIndexing;
      if (data.shaderUniformTexelBufferArrayDynamicIndexing !== undefined) this.shaderUniformTexelBufferArrayDynamicIndexing = data.shaderUniformTexelBufferArrayDynamicIndexing;
      if (data.shaderStorageTexelBufferArrayDynamicIndexing !== undefined) this.shaderStorageTexelBufferArrayDynamicIndexing = data.shaderStorageTexelBufferArrayDynamicIndexing;
      if (data.shaderUniformBufferArrayNonUniformIndexing !== undefined) this.shaderUniformBufferArrayNonUniformIndexing = data.shaderUniformBufferArrayNonUniformIndexing;
      if (data.shaderSampledImageArrayNonUniformIndexing !== undefined) this.shaderSampledImageArrayNonUniformIndexing = data.shaderSampledImageArrayNonUniformIndexing;
      if (data.shaderStorageBufferArrayNonUniformIndexing !== undefined) this.shaderStorageBufferArrayNonUniformIndexing = data.shaderStorageBufferArrayNonUniformIndexing;
      if (data.shaderStorageImageArrayNonUniformIndexing !== undefined) this.shaderStorageImageArrayNonUniformIndexing = data.shaderStorageImageArrayNonUniformIndexing;
      if (data.shaderInputAttachmentArrayNonUniformIndexing !== undefined) this.shaderInputAttachmentArrayNonUniformIndexing = data.shaderInputAttachmentArrayNonUniformIndexing;
      if (data.shaderUniformTexelBufferArrayNonUniformIndexing !== undefined) this.shaderUniformTexelBufferArrayNonUniformIndexing = data.shaderUniformTexelBufferArrayNonUniformIndexing;
      if (data.shaderStorageTexelBufferArrayNonUniformIndexing !== undefined) this.shaderStorageTexelBufferArrayNonUniformIndexing = data.shaderStorageTexelBufferArrayNonUniformIndexing;
      if (data.descriptorBindingUniformBufferUpdateAfterBind !== undefined) this.descriptorBindingUniformBufferUpdateAfterBind = data.descriptorBindingUniformBufferUpdateAfterBind;
      if (data.descriptorBindingSampledImageUpdateAfterBind !== undefined) this.descriptorBindingSampledImageUpdateAfterBind = data.descriptorBindingSampledImageUpdateAfterBind;
      if (data.descriptorBindingStorageImageUpdateAfterBind !== undefined) this.descriptorBindingStorageImageUpdateAfterBind = data.descriptorBindingStorageImageUpdateAfterBind;
      if (data.descriptorBindingStorageBufferUpdateAfterBind !== undefined) this.descriptorBindingStorageBufferUpdateAfterBind = data.descriptorBindingStorageBufferUpdateAfterBind;
      if (data.descriptorBindingUniformTexelBufferUpdateAfterBind !== undefined) this.descriptorBindingUniformTexelBufferUpdateAfterBind = data.descriptorBindingUniformTexelBufferUpdateAfterBind;
      if (data.descriptorBindingStorageTexelBufferUpdateAfterBind !== undefined) this.descriptorBindingStorageTexelBufferUpdateAfterBind = data.descriptorBindingStorageTexelBufferUpdateAfterBind;
      if (data.descriptorBindingUpdateUnusedWhilePending !== undefined) this.descriptorBindingUpdateUnusedWhilePending = data.descriptorBindingUpdateUnusedWhilePending;
      if (data.descriptorBindingPartiallyBound !== undefined) this.descriptorBindingPartiallyBound = data.descriptorBindingPartiallyBound;
      if (data.descriptorBindingVariableDescriptorCount !== undefined) this.descriptorBindingVariableDescriptorCount = data.descriptorBindingVariableDescriptorCount;
      if (data.runtimeDescriptorArray !== undefined) this.runtimeDescriptorArray = data.runtimeDescriptorArray;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderInputAttachmentArrayDynamicIndexing() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderInputAttachmentArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderUniformTexelBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderStorageTexelBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexing() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexing() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexing() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderUniformTexelBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderStorageTexelBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get descriptorBindingUniformBufferUpdateAfterBind() {
    return this.#view.getUint32(56, LE);
  }
  
  set descriptorBindingUniformBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get descriptorBindingSampledImageUpdateAfterBind() {
    return this.#view.getUint32(60, LE);
  }
  
  set descriptorBindingSampledImageUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get descriptorBindingStorageImageUpdateAfterBind() {
    return this.#view.getUint32(64, LE);
  }
  
  set descriptorBindingStorageImageUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get descriptorBindingStorageBufferUpdateAfterBind() {
    return this.#view.getUint32(68, LE);
  }
  
  set descriptorBindingStorageBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get descriptorBindingUniformTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(72, LE);
  }
  
  set descriptorBindingUniformTexelBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get descriptorBindingStorageTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(76, LE);
  }
  
  set descriptorBindingStorageTexelBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get descriptorBindingUpdateUnusedWhilePending() {
    return this.#view.getUint32(80, LE);
  }
  
  set descriptorBindingUpdateUnusedWhilePending(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get descriptorBindingPartiallyBound() {
    return this.#view.getUint32(84, LE);
  }
  
  set descriptorBindingPartiallyBound(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get descriptorBindingVariableDescriptorCount() {
    return this.#view.getUint32(88, LE);
  }
  
  set descriptorBindingVariableDescriptorCount(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get runtimeDescriptorArray() {
    return this.#view.getUint32(92, LE);
  }
  
  set runtimeDescriptorArray(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDescriptorIndexingProperties {
  pNext?: AnyPointer;
  maxUpdateAfterBindDescriptorsInAllPools?: number;
  shaderUniformBufferArrayNonUniformIndexingNative?: Bool32;
  shaderSampledImageArrayNonUniformIndexingNative?: Bool32;
  shaderStorageBufferArrayNonUniformIndexingNative?: Bool32;
  shaderStorageImageArrayNonUniformIndexingNative?: Bool32;
  shaderInputAttachmentArrayNonUniformIndexingNative?: Bool32;
  robustBufferAccessUpdateAfterBind?: Bool32;
  quadDivergentImplicitLod?: Bool32;
  maxPerStageDescriptorUpdateAfterBindSamplers?: number;
  maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number;
  maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number;
  maxPerStageDescriptorUpdateAfterBindSampledImages?: number;
  maxPerStageDescriptorUpdateAfterBindStorageImages?: number;
  maxPerStageDescriptorUpdateAfterBindInputAttachments?: number;
  maxPerStageUpdateAfterBindResources?: number;
  maxDescriptorSetUpdateAfterBindSamplers?: number;
  maxDescriptorSetUpdateAfterBindUniformBuffers?: number;
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number;
  maxDescriptorSetUpdateAfterBindStorageBuffers?: number;
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number;
  maxDescriptorSetUpdateAfterBindSampledImages?: number;
  maxDescriptorSetUpdateAfterBindStorageImages?: number;
  maxDescriptorSetUpdateAfterBindInputAttachments?: number;
}

export class PhysicalDeviceDescriptorIndexingProperties implements BaseStruct {
  static size = 112;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorIndexingProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorIndexingProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorIndexingProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorIndexingProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorIndexingProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxUpdateAfterBindDescriptorsInAllPools !== undefined) this.maxUpdateAfterBindDescriptorsInAllPools = data.maxUpdateAfterBindDescriptorsInAllPools;
      if (data.shaderUniformBufferArrayNonUniformIndexingNative !== undefined) this.shaderUniformBufferArrayNonUniformIndexingNative = data.shaderUniformBufferArrayNonUniformIndexingNative;
      if (data.shaderSampledImageArrayNonUniformIndexingNative !== undefined) this.shaderSampledImageArrayNonUniformIndexingNative = data.shaderSampledImageArrayNonUniformIndexingNative;
      if (data.shaderStorageBufferArrayNonUniformIndexingNative !== undefined) this.shaderStorageBufferArrayNonUniformIndexingNative = data.shaderStorageBufferArrayNonUniformIndexingNative;
      if (data.shaderStorageImageArrayNonUniformIndexingNative !== undefined) this.shaderStorageImageArrayNonUniformIndexingNative = data.shaderStorageImageArrayNonUniformIndexingNative;
      if (data.shaderInputAttachmentArrayNonUniformIndexingNative !== undefined) this.shaderInputAttachmentArrayNonUniformIndexingNative = data.shaderInputAttachmentArrayNonUniformIndexingNative;
      if (data.robustBufferAccessUpdateAfterBind !== undefined) this.robustBufferAccessUpdateAfterBind = data.robustBufferAccessUpdateAfterBind;
      if (data.quadDivergentImplicitLod !== undefined) this.quadDivergentImplicitLod = data.quadDivergentImplicitLod;
      if (data.maxPerStageDescriptorUpdateAfterBindSamplers !== undefined) this.maxPerStageDescriptorUpdateAfterBindSamplers = data.maxPerStageDescriptorUpdateAfterBindSamplers;
      if (data.maxPerStageDescriptorUpdateAfterBindUniformBuffers !== undefined) this.maxPerStageDescriptorUpdateAfterBindUniformBuffers = data.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
      if (data.maxPerStageDescriptorUpdateAfterBindStorageBuffers !== undefined) this.maxPerStageDescriptorUpdateAfterBindStorageBuffers = data.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
      if (data.maxPerStageDescriptorUpdateAfterBindSampledImages !== undefined) this.maxPerStageDescriptorUpdateAfterBindSampledImages = data.maxPerStageDescriptorUpdateAfterBindSampledImages;
      if (data.maxPerStageDescriptorUpdateAfterBindStorageImages !== undefined) this.maxPerStageDescriptorUpdateAfterBindStorageImages = data.maxPerStageDescriptorUpdateAfterBindStorageImages;
      if (data.maxPerStageDescriptorUpdateAfterBindInputAttachments !== undefined) this.maxPerStageDescriptorUpdateAfterBindInputAttachments = data.maxPerStageDescriptorUpdateAfterBindInputAttachments;
      if (data.maxPerStageUpdateAfterBindResources !== undefined) this.maxPerStageUpdateAfterBindResources = data.maxPerStageUpdateAfterBindResources;
      if (data.maxDescriptorSetUpdateAfterBindSamplers !== undefined) this.maxDescriptorSetUpdateAfterBindSamplers = data.maxDescriptorSetUpdateAfterBindSamplers;
      if (data.maxDescriptorSetUpdateAfterBindUniformBuffers !== undefined) this.maxDescriptorSetUpdateAfterBindUniformBuffers = data.maxDescriptorSetUpdateAfterBindUniformBuffers;
      if (data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic !== undefined) this.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
      if (data.maxDescriptorSetUpdateAfterBindStorageBuffers !== undefined) this.maxDescriptorSetUpdateAfterBindStorageBuffers = data.maxDescriptorSetUpdateAfterBindStorageBuffers;
      if (data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic !== undefined) this.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
      if (data.maxDescriptorSetUpdateAfterBindSampledImages !== undefined) this.maxDescriptorSetUpdateAfterBindSampledImages = data.maxDescriptorSetUpdateAfterBindSampledImages;
      if (data.maxDescriptorSetUpdateAfterBindStorageImages !== undefined) this.maxDescriptorSetUpdateAfterBindStorageImages = data.maxDescriptorSetUpdateAfterBindStorageImages;
      if (data.maxDescriptorSetUpdateAfterBindInputAttachments !== undefined) this.maxDescriptorSetUpdateAfterBindInputAttachments = data.maxDescriptorSetUpdateAfterBindInputAttachments;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxUpdateAfterBindDescriptorsInAllPools() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxUpdateAfterBindDescriptorsInAllPools(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexingNative() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get robustBufferAccessUpdateAfterBind() {
    return this.#view.getUint32(40, LE);
  }
  
  set robustBufferAccessUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get quadDivergentImplicitLod() {
    return this.#view.getUint32(44, LE);
  }
  
  set quadDivergentImplicitLod(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSamplers() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSampledImages() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageImages() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxPerStageUpdateAfterBindResources() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxPerStageUpdateAfterBindResources(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSamplers() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(80, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffersDynamic(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffersDynamic(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSampledImages() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageImages() {
    return this.#view.getUint32(100, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
}

export interface InitDescriptorSetLayoutBindingFlagsCreateInfo {
  pNext?: AnyPointer;
  bindingCount?: number;
  pBindingFlags?: AnyPointer;
}

export class DescriptorSetLayoutBindingFlagsCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetLayoutBindingFlagsCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetLayoutBindingFlagsCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetLayoutBindingFlagsCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetLayoutBindingFlagsCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetLayoutBindingFlagsCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.bindingCount !== undefined) this.bindingCount = data.bindingCount;
      if (data.pBindingFlags !== undefined) this.pBindingFlags = data.pBindingFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get bindingCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set bindingCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pBindingFlags() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pBindingFlags(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorSetVariableDescriptorCountAllocateInfo {
  pNext?: AnyPointer;
  descriptorSetCount?: number;
  pDescriptorCounts?: AnyPointer;
}

export class DescriptorSetVariableDescriptorCountAllocateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetVariableDescriptorCountAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetVariableDescriptorCountAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetVariableDescriptorCountAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetVariableDescriptorCountAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetVariableDescriptorCountAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorSetCount !== undefined) this.descriptorSetCount = data.descriptorSetCount;
      if (data.pDescriptorCounts !== undefined) this.pDescriptorCounts = data.pDescriptorCounts;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorSetCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorSetCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDescriptorCounts() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDescriptorCounts(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorSetVariableDescriptorCountLayoutSupport {
  pNext?: AnyPointer;
  maxVariableDescriptorCount?: number;
}

export class DescriptorSetVariableDescriptorCountLayoutSupport implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetVariableDescriptorCountLayoutSupport);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetVariableDescriptorCountLayoutSupport) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetVariableDescriptorCountLayoutSupport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetVariableDescriptorCountLayoutSupport.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetVariableDescriptorCountLayoutSupport.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxVariableDescriptorCount !== undefined) this.maxVariableDescriptorCount = data.maxVariableDescriptorCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxVariableDescriptorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxVariableDescriptorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitAttachmentDescription2 {
  pNext?: AnyPointer;
  flags?: AttachmentDescriptionFlags;
  format?: Format;
  samples?: SampleCountFlagBits;
  loadOp?: AttachmentLoadOp;
  storeOp?: AttachmentStoreOp;
  stencilLoadOp?: AttachmentLoadOp;
  stencilStoreOp?: AttachmentStoreOp;
  initialLayout?: ImageLayout;
  finalLayout?: ImageLayout;
}

export class AttachmentDescription2 implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentDescription2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentDescription2) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentDescription2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentDescription2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentDescription2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.format !== undefined) this.format = data.format;
      if (data.samples !== undefined) this.samples = data.samples;
      if (data.loadOp !== undefined) this.loadOp = data.loadOp;
      if (data.storeOp !== undefined) this.storeOp = data.storeOp;
      if (data.stencilLoadOp !== undefined) this.stencilLoadOp = data.stencilLoadOp;
      if (data.stencilStoreOp !== undefined) this.stencilStoreOp = data.stencilStoreOp;
      if (data.initialLayout !== undefined) this.initialLayout = data.initialLayout;
      if (data.finalLayout !== undefined) this.finalLayout = data.finalLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: AttachmentDescriptionFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(20, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get samples() {
    return this.#view.getUint32(24, LE);
  }
  
  set samples(value: SampleCountFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(28, LE);
  }
  
  set loadOp(value: AttachmentLoadOp) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(32, LE);
  }
  
  set storeOp(value: AttachmentStoreOp) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilLoadOp() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilLoadOp(value: AttachmentLoadOp) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get stencilStoreOp() {
    return this.#view.getUint32(40, LE);
  }
  
  set stencilStoreOp(value: AttachmentStoreOp) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get initialLayout() {
    return this.#view.getUint32(44, LE);
  }
  
  set initialLayout(value: ImageLayout) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get finalLayout() {
    return this.#view.getUint32(48, LE);
  }
  
  set finalLayout(value: ImageLayout) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitAttachmentReference2 {
  pNext?: AnyPointer;
  attachment?: number;
  layout?: ImageLayout;
  aspectMask?: ImageAspectFlags;
}

export class AttachmentReference2 implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentReference2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentReference2) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentReference2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentReference2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentReference2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachment !== undefined) this.attachment = data.attachment;
      if (data.layout !== undefined) this.layout = data.layout;
      if (data.aspectMask !== undefined) this.aspectMask = data.aspectMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachment() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachment(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getUint32(20, LE);
  }
  
  set layout(value: ImageLayout) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get aspectMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set aspectMask(value: ImageAspectFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitSubpassDescription2 {
  pNext?: AnyPointer;
  flags?: SubpassDescriptionFlags;
  pipelineBindPoint?: PipelineBindPoint;
  viewMask?: number;
  inputAttachmentCount?: number;
  pInputAttachments?: AnyPointer;
  colorAttachmentCount?: number;
  pColorAttachments?: AnyPointer;
  pResolveAttachments?: AnyPointer;
  pDepthStencilAttachment?: AnyPointer;
  preserveAttachmentCount?: number;
  pPreserveAttachments?: AnyPointer;
}

export class SubpassDescription2 implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassDescription2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassDescription2) {
    if (!data) {
      this.#data = new Uint8Array(SubpassDescription2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassDescription2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassDescription2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pipelineBindPoint !== undefined) this.pipelineBindPoint = data.pipelineBindPoint;
      if (data.viewMask !== undefined) this.viewMask = data.viewMask;
      if (data.inputAttachmentCount !== undefined) this.inputAttachmentCount = data.inputAttachmentCount;
      if (data.pInputAttachments !== undefined) this.pInputAttachments = data.pInputAttachments;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachments !== undefined) this.pColorAttachments = data.pColorAttachments;
      if (data.pResolveAttachments !== undefined) this.pResolveAttachments = data.pResolveAttachments;
      if (data.pDepthStencilAttachment !== undefined) this.pDepthStencilAttachment = data.pDepthStencilAttachment;
      if (data.preserveAttachmentCount !== undefined) this.preserveAttachmentCount = data.preserveAttachmentCount;
      if (data.pPreserveAttachments !== undefined) this.pPreserveAttachments = data.pPreserveAttachments;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SubpassDescriptionFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineBindPoint() {
    return this.#view.getUint32(20, LE);
  }
  
  set pipelineBindPoint(value: PipelineBindPoint) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get inputAttachmentCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set inputAttachmentCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pInputAttachments() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pInputAttachments(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pColorAttachments(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pResolveAttachments() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pResolveAttachments(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pDepthStencilAttachment() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pDepthStencilAttachment(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get preserveAttachmentCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set preserveAttachmentCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get pPreserveAttachments() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pPreserveAttachments(value: AnyPointer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSubpassDependency2 {
  pNext?: AnyPointer;
  srcSubpass?: number;
  dstSubpass?: number;
  srcStageMask?: PipelineStageFlags;
  dstStageMask?: PipelineStageFlags;
  srcAccessMask?: AccessFlags;
  dstAccessMask?: AccessFlags;
  dependencyFlags?: DependencyFlags;
  viewOffset?: number;
}

export class SubpassDependency2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassDependency2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassDependency2) {
    if (!data) {
      this.#data = new Uint8Array(SubpassDependency2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassDependency2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassDependency2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcSubpass !== undefined) this.srcSubpass = data.srcSubpass;
      if (data.dstSubpass !== undefined) this.dstSubpass = data.dstSubpass;
      if (data.srcStageMask !== undefined) this.srcStageMask = data.srcStageMask;
      if (data.dstStageMask !== undefined) this.dstStageMask = data.dstStageMask;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.dependencyFlags !== undefined) this.dependencyFlags = data.dependencyFlags;
      if (data.viewOffset !== undefined) this.viewOffset = data.viewOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcSubpass() {
    return this.#view.getUint32(16, LE);
  }
  
  set srcSubpass(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get dstSubpass() {
    return this.#view.getUint32(20, LE);
  }
  
  set dstSubpass(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get srcStageMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcStageMask(value: PipelineStageFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getUint32(28, LE);
  }
  
  set dstStageMask(value: PipelineStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getUint32(32, LE);
  }
  
  set srcAccessMask(value: AccessFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getUint32(36, LE);
  }
  
  set dstAccessMask(value: AccessFlags) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(40, LE);
  }
  
  set dependencyFlags(value: DependencyFlags) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get viewOffset() {
    return this.#view.getInt32(44, LE);
  }
  
  set viewOffset(value: number) {
    this.#view.setInt32(44, Number(value), LE);
  }
}

export interface InitRenderPassCreateInfo2 {
  pNext?: AnyPointer;
  flags?: RenderPassCreateFlags;
  attachmentCount?: number;
  pAttachments?: AnyPointer;
  subpassCount?: number;
  pSubpasses?: AnyPointer;
  dependencyCount?: number;
  pDependencies?: AnyPointer;
  correlatedViewMaskCount?: number;
  pCorrelatedViewMasks?: AnyPointer;
}

export class RenderPassCreateInfo2 implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassCreateInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassCreateInfo2) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassCreateInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassCreateInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassCreateInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pAttachments !== undefined) this.pAttachments = data.pAttachments;
      if (data.subpassCount !== undefined) this.subpassCount = data.subpassCount;
      if (data.pSubpasses !== undefined) this.pSubpasses = data.pSubpasses;
      if (data.dependencyCount !== undefined) this.dependencyCount = data.dependencyCount;
      if (data.pDependencies !== undefined) this.pDependencies = data.pDependencies;
      if (data.correlatedViewMaskCount !== undefined) this.correlatedViewMaskCount = data.correlatedViewMaskCount;
      if (data.pCorrelatedViewMasks !== undefined) this.pCorrelatedViewMasks = data.pCorrelatedViewMasks;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: RenderPassCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get subpassCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set subpassCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSubpasses() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSubpasses(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get dependencyCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set dependencyCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pDependencies() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pDependencies(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get correlatedViewMaskCount() {
    return this.#view.getUint32(64, LE);
  }
  
  set correlatedViewMaskCount(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get pCorrelatedViewMasks() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pCorrelatedViewMasks(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSubpassBeginInfo {
  pNext?: AnyPointer;
  contents?: SubpassContents;
}

export class SubpassBeginInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(SubpassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.contents !== undefined) this.contents = data.contents;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get contents() {
    return this.#view.getUint32(16, LE);
  }
  
  set contents(value: SubpassContents) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSubpassEndInfo {
  pNext?: AnyPointer;
}

export class SubpassEndInfo implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassEndInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassEndInfo) {
    if (!data) {
      this.#data = new Uint8Array(SubpassEndInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassEndInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassEndInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_END_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceTimelineSemaphoreFeatures {
  pNext?: AnyPointer;
  timelineSemaphore?: Bool32;
}

export class PhysicalDeviceTimelineSemaphoreFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTimelineSemaphoreFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTimelineSemaphoreFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTimelineSemaphoreFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTimelineSemaphoreFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTimelineSemaphoreFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.timelineSemaphore !== undefined) this.timelineSemaphore = data.timelineSemaphore;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get timelineSemaphore() {
    return this.#view.getUint32(16, LE);
  }
  
  set timelineSemaphore(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceTimelineSemaphoreProperties {
  pNext?: AnyPointer;
  maxTimelineSemaphoreValueDifference?: Deno.PointerValue;
}

export class PhysicalDeviceTimelineSemaphoreProperties implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTimelineSemaphoreProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTimelineSemaphoreProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTimelineSemaphoreProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTimelineSemaphoreProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTimelineSemaphoreProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxTimelineSemaphoreValueDifference !== undefined) this.maxTimelineSemaphoreValueDifference = data.maxTimelineSemaphoreValueDifference;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxTimelineSemaphoreValueDifference() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxTimelineSemaphoreValueDifference(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitSemaphoreTypeCreateInfo {
  pNext?: AnyPointer;
  semaphoreType?: SemaphoreType;
  initialValue?: Deno.PointerValue;
}

export class SemaphoreTypeCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreTypeCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreTypeCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreTypeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreTypeCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreTypeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphoreType !== undefined) this.semaphoreType = data.semaphoreType;
      if (data.initialValue !== undefined) this.initialValue = data.initialValue;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphoreType() {
    return this.#view.getUint32(16, LE);
  }
  
  set semaphoreType(value: SemaphoreType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get initialValue() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set initialValue(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitTimelineSemaphoreSubmitInfo {
  pNext?: AnyPointer;
  waitSemaphoreValueCount?: number;
  pWaitSemaphoreValues?: AnyPointer;
  signalSemaphoreValueCount?: number;
  pSignalSemaphoreValues?: AnyPointer;
}

export class TimelineSemaphoreSubmitInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTimelineSemaphoreSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTimelineSemaphoreSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(TimelineSemaphoreSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TimelineSemaphoreSubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TimelineSemaphoreSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.waitSemaphoreValueCount !== undefined) this.waitSemaphoreValueCount = data.waitSemaphoreValueCount;
      if (data.pWaitSemaphoreValues !== undefined) this.pWaitSemaphoreValues = data.pWaitSemaphoreValues;
      if (data.signalSemaphoreValueCount !== undefined) this.signalSemaphoreValueCount = data.signalSemaphoreValueCount;
      if (data.pSignalSemaphoreValues !== undefined) this.pSignalSemaphoreValues = data.pSignalSemaphoreValues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get waitSemaphoreValueCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set waitSemaphoreValueCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pWaitSemaphoreValues() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreValues(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreValueCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set signalSemaphoreValueCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pSignalSemaphoreValues() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pSignalSemaphoreValues(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSemaphoreWaitInfo {
  pNext?: AnyPointer;
  flags?: SemaphoreWaitFlags;
  semaphoreCount?: number;
  pSemaphores?: AnyPointer;
  pValues?: AnyPointer;
}

export class SemaphoreWaitInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreWaitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreWaitInfo) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreWaitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreWaitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreWaitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.semaphoreCount !== undefined) this.semaphoreCount = data.semaphoreCount;
      if (data.pSemaphores !== undefined) this.pSemaphores = data.pSemaphores;
      if (data.pValues !== undefined) this.pValues = data.pValues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SemaphoreWaitFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get semaphoreCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set semaphoreCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pSemaphores() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pSemaphores(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pValues() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pValues(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSemaphoreSignalInfo {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  value?: Deno.PointerValue;
}

export class SemaphoreSignalInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreSignalInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreSignalInfo) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreSignalInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreSignalInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreSignalInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.value !== undefined) this.value = data.value;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get value() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set value(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitVertexInputBindingDivisorDescriptionEXT {
  binding?: number;
  divisor?: number;
}

export class VertexInputBindingDivisorDescriptionEXT implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVertexInputBindingDivisorDescriptionEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVertexInputBindingDivisorDescriptionEXT) {
    if (!data) {
      this.#data = new Uint8Array(VertexInputBindingDivisorDescriptionEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VertexInputBindingDivisorDescriptionEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VertexInputBindingDivisorDescriptionEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.divisor !== undefined) this.divisor = data.divisor;
    }
  }
  
  get binding() {
    return this.#view.getUint32(0, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get divisor() {
    return this.#view.getUint32(4, LE);
  }
  
  set divisor(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitPipelineVertexInputDivisorStateCreateInfoEXT {
  pNext?: AnyPointer;
  vertexBindingDivisorCount?: number;
  pVertexBindingDivisors?: AnyPointer;
}

export class PipelineVertexInputDivisorStateCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineVertexInputDivisorStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineVertexInputDivisorStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineVertexInputDivisorStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineVertexInputDivisorStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineVertexInputDivisorStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexBindingDivisorCount !== undefined) this.vertexBindingDivisorCount = data.vertexBindingDivisorCount;
      if (data.pVertexBindingDivisors !== undefined) this.pVertexBindingDivisors = data.pVertexBindingDivisors;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexBindingDivisorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexBindingDivisorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pVertexBindingDivisors() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVertexBindingDivisors(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  pNext?: AnyPointer;
  maxVertexAttribDivisor?: number;
}

export class PhysicalDeviceVertexAttributeDivisorPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVertexAttributeDivisorPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVertexAttributeDivisorPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVertexAttributeDivisorPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVertexAttributeDivisorPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxVertexAttribDivisor !== undefined) this.maxVertexAttribDivisor = data.maxVertexAttribDivisor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxVertexAttribDivisor() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxVertexAttribDivisor(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePCIBusInfoPropertiesEXT {
  pNext?: AnyPointer;
  pciDomain?: number;
  pciBus?: number;
  pciDevice?: number;
  pciFunction?: number;
}

export class PhysicalDevicePCIBusInfoPropertiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePCIBusInfoPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePCIBusInfoPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePCIBusInfoPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePCIBusInfoPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePCIBusInfoPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pciDomain !== undefined) this.pciDomain = data.pciDomain;
      if (data.pciBus !== undefined) this.pciBus = data.pciBus;
      if (data.pciDevice !== undefined) this.pciDevice = data.pciDevice;
      if (data.pciFunction !== undefined) this.pciFunction = data.pciFunction;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pciDomain() {
    return this.#view.getUint32(16, LE);
  }
  
  set pciDomain(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pciBus() {
    return this.#view.getUint32(20, LE);
  }
  
  set pciBus(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pciDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set pciDevice(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pciFunction() {
    return this.#view.getUint32(28, LE);
  }
  
  set pciFunction(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitImportAndroidHardwareBufferInfoANDROID {
  pNext?: AnyPointer;
  buffer?: AnyPointer;
}

export class ImportAndroidHardwareBufferInfoANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportAndroidHardwareBufferInfoANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportAndroidHardwareBufferInfoANDROID) {
    if (!data) {
      this.#data = new Uint8Array(ImportAndroidHardwareBufferInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportAndroidHardwareBufferInfoANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportAndroidHardwareBufferInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAndroidHardwareBufferUsageANDROID {
  pNext?: AnyPointer;
  androidHardwareBufferUsage?: Deno.PointerValue;
}

export class AndroidHardwareBufferUsageANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAndroidHardwareBufferUsageANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAndroidHardwareBufferUsageANDROID) {
    if (!data) {
      this.#data = new Uint8Array(AndroidHardwareBufferUsageANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AndroidHardwareBufferUsageANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AndroidHardwareBufferUsageANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.androidHardwareBufferUsage !== undefined) this.androidHardwareBufferUsage = data.androidHardwareBufferUsage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get androidHardwareBufferUsage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set androidHardwareBufferUsage(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitAndroidHardwareBufferPropertiesANDROID {
  pNext?: AnyPointer;
  allocationSize?: DeviceSize;
  memoryTypeBits?: number;
}

export class AndroidHardwareBufferPropertiesANDROID implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAndroidHardwareBufferPropertiesANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAndroidHardwareBufferPropertiesANDROID) {
    if (!data) {
      this.#data = new Uint8Array(AndroidHardwareBufferPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AndroidHardwareBufferPropertiesANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AndroidHardwareBufferPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.allocationSize !== undefined) this.allocationSize = data.allocationSize;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get allocationSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set allocationSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(24, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitMemoryGetAndroidHardwareBufferInfoANDROID {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
}

export class MemoryGetAndroidHardwareBufferInfoANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryGetAndroidHardwareBufferInfoANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryGetAndroidHardwareBufferInfoANDROID) {
    if (!data) {
      this.#data = new Uint8Array(MemoryGetAndroidHardwareBufferInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryGetAndroidHardwareBufferInfoANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryGetAndroidHardwareBufferInfoANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAndroidHardwareBufferFormatPropertiesANDROID {
  pNext?: AnyPointer;
  format?: Format;
  externalFormat?: Deno.PointerValue;
  formatFeatures?: FormatFeatureFlags;
  samplerYcbcrConversionComponents?: ComponentMapping;
  suggestedYcbcrModel?: SamplerYcbcrModelConversion;
  suggestedYcbcrRange?: SamplerYcbcrRange;
  suggestedXChromaOffset?: ChromaLocation;
  suggestedYChromaOffset?: ChromaLocation;
}

export class AndroidHardwareBufferFormatPropertiesANDROID implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAndroidHardwareBufferFormatPropertiesANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAndroidHardwareBufferFormatPropertiesANDROID) {
    if (!data) {
      this.#data = new Uint8Array(AndroidHardwareBufferFormatPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AndroidHardwareBufferFormatPropertiesANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AndroidHardwareBufferFormatPropertiesANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.externalFormat !== undefined) this.externalFormat = data.externalFormat;
      if (data.formatFeatures !== undefined) this.formatFeatures = data.formatFeatures;
      if (data.samplerYcbcrConversionComponents !== undefined) this.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
      if (data.suggestedYcbcrModel !== undefined) this.suggestedYcbcrModel = data.suggestedYcbcrModel;
      if (data.suggestedYcbcrRange !== undefined) this.suggestedYcbcrRange = data.suggestedYcbcrRange;
      if (data.suggestedXChromaOffset !== undefined) this.suggestedXChromaOffset = data.suggestedXChromaOffset;
      if (data.suggestedYChromaOffset !== undefined) this.suggestedYChromaOffset = data.suggestedYChromaOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getUint32(32, LE);
  }
  
  set formatFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get samplerYcbcrConversionComponents() {
    return new ComponentMapping(this.#data.subarray(36, 36 + ComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(52, LE);
  }
  
  set suggestedYcbcrModel(value: SamplerYcbcrModelConversion) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(56, LE);
  }
  
  set suggestedYcbcrRange(value: SamplerYcbcrRange) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(60, LE);
  }
  
  set suggestedXChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(64, LE);
  }
  
  set suggestedYChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(64, Number(value), LE);
  }
}

export interface InitCommandBufferInheritanceConditionalRenderingInfoEXT {
  pNext?: AnyPointer;
  conditionalRenderingEnable?: Bool32;
}

export class CommandBufferInheritanceConditionalRenderingInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferInheritanceConditionalRenderingInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferInheritanceConditionalRenderingInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferInheritanceConditionalRenderingInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferInheritanceConditionalRenderingInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferInheritanceConditionalRenderingInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.conditionalRenderingEnable !== undefined) this.conditionalRenderingEnable = data.conditionalRenderingEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get conditionalRenderingEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set conditionalRenderingEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExternalFormatANDROID {
  pNext?: AnyPointer;
  externalFormat?: Deno.PointerValue;
}

export class ExternalFormatANDROID implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExternalFormatANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExternalFormatANDROID) {
    if (!data) {
      this.#data = new Uint8Array(ExternalFormatANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExternalFormatANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExternalFormatANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.externalFormat !== undefined) this.externalFormat = data.externalFormat;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitPhysicalDevice8BitStorageFeatures {
  pNext?: AnyPointer;
  storageBuffer8BitAccess?: Bool32;
  uniformAndStorageBuffer8BitAccess?: Bool32;
  storagePushConstant8?: Bool32;
}

export class PhysicalDevice8BitStorageFeatures implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevice8BitStorageFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevice8BitStorageFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevice8BitStorageFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevice8BitStorageFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevice8BitStorageFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.storageBuffer8BitAccess !== undefined) this.storageBuffer8BitAccess = data.storageBuffer8BitAccess;
      if (data.uniformAndStorageBuffer8BitAccess !== undefined) this.uniformAndStorageBuffer8BitAccess = data.uniformAndStorageBuffer8BitAccess;
      if (data.storagePushConstant8 !== undefined) this.storagePushConstant8 = data.storagePushConstant8;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get storageBuffer8BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer8BitAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer8BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer8BitAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant8() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant8(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceConditionalRenderingFeaturesEXT {
  pNext?: AnyPointer;
  conditionalRendering?: Bool32;
  inheritedConditionalRendering?: Bool32;
}

export class PhysicalDeviceConditionalRenderingFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceConditionalRenderingFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceConditionalRenderingFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceConditionalRenderingFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceConditionalRenderingFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceConditionalRenderingFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.conditionalRendering !== undefined) this.conditionalRendering = data.conditionalRendering;
      if (data.inheritedConditionalRendering !== undefined) this.inheritedConditionalRendering = data.inheritedConditionalRendering;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get conditionalRendering() {
    return this.#view.getUint32(16, LE);
  }
  
  set conditionalRendering(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inheritedConditionalRendering() {
    return this.#view.getUint32(20, LE);
  }
  
  set inheritedConditionalRendering(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkanMemoryModelFeatures {
  pNext?: AnyPointer;
  vulkanMemoryModel?: Bool32;
  vulkanMemoryModelDeviceScope?: Bool32;
  vulkanMemoryModelAvailabilityVisibilityChains?: Bool32;
}

export class PhysicalDeviceVulkanMemoryModelFeatures implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkanMemoryModelFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkanMemoryModelFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkanMemoryModelFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkanMemoryModelFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkanMemoryModelFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vulkanMemoryModel !== undefined) this.vulkanMemoryModel = data.vulkanMemoryModel;
      if (data.vulkanMemoryModelDeviceScope !== undefined) this.vulkanMemoryModelDeviceScope = data.vulkanMemoryModelDeviceScope;
      if (data.vulkanMemoryModelAvailabilityVisibilityChains !== undefined) this.vulkanMemoryModelAvailabilityVisibilityChains = data.vulkanMemoryModelAvailabilityVisibilityChains;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vulkanMemoryModel() {
    return this.#view.getUint32(16, LE);
  }
  
  set vulkanMemoryModel(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vulkanMemoryModelDeviceScope() {
    return this.#view.getUint32(20, LE);
  }
  
  set vulkanMemoryModelDeviceScope(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vulkanMemoryModelAvailabilityVisibilityChains() {
    return this.#view.getUint32(24, LE);
  }
  
  set vulkanMemoryModelAvailabilityVisibilityChains(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderAtomicInt64Features {
  pNext?: AnyPointer;
  shaderBufferInt64Atomics?: Bool32;
  shaderSharedInt64Atomics?: Bool32;
}

export class PhysicalDeviceShaderAtomicInt64Features implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderAtomicInt64Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderAtomicInt64Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicInt64Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderAtomicInt64Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicInt64Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderBufferInt64Atomics !== undefined) this.shaderBufferInt64Atomics = data.shaderBufferInt64Atomics;
      if (data.shaderSharedInt64Atomics !== undefined) this.shaderSharedInt64Atomics = data.shaderSharedInt64Atomics;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderBufferInt64Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferInt64Atomics(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderSharedInt64Atomics() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderSharedInt64Atomics(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderAtomicFloatFeaturesEXT {
  pNext?: AnyPointer;
  shaderBufferFloat32Atomics?: Bool32;
  shaderBufferFloat32AtomicAdd?: Bool32;
  shaderBufferFloat64Atomics?: Bool32;
  shaderBufferFloat64AtomicAdd?: Bool32;
  shaderSharedFloat32Atomics?: Bool32;
  shaderSharedFloat32AtomicAdd?: Bool32;
  shaderSharedFloat64Atomics?: Bool32;
  shaderSharedFloat64AtomicAdd?: Bool32;
  shaderImageFloat32Atomics?: Bool32;
  shaderImageFloat32AtomicAdd?: Bool32;
  sparseImageFloat32Atomics?: Bool32;
  sparseImageFloat32AtomicAdd?: Bool32;
}

export class PhysicalDeviceShaderAtomicFloatFeaturesEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderAtomicFloatFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderAtomicFloatFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicFloatFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderAtomicFloatFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicFloatFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderBufferFloat32Atomics !== undefined) this.shaderBufferFloat32Atomics = data.shaderBufferFloat32Atomics;
      if (data.shaderBufferFloat32AtomicAdd !== undefined) this.shaderBufferFloat32AtomicAdd = data.shaderBufferFloat32AtomicAdd;
      if (data.shaderBufferFloat64Atomics !== undefined) this.shaderBufferFloat64Atomics = data.shaderBufferFloat64Atomics;
      if (data.shaderBufferFloat64AtomicAdd !== undefined) this.shaderBufferFloat64AtomicAdd = data.shaderBufferFloat64AtomicAdd;
      if (data.shaderSharedFloat32Atomics !== undefined) this.shaderSharedFloat32Atomics = data.shaderSharedFloat32Atomics;
      if (data.shaderSharedFloat32AtomicAdd !== undefined) this.shaderSharedFloat32AtomicAdd = data.shaderSharedFloat32AtomicAdd;
      if (data.shaderSharedFloat64Atomics !== undefined) this.shaderSharedFloat64Atomics = data.shaderSharedFloat64Atomics;
      if (data.shaderSharedFloat64AtomicAdd !== undefined) this.shaderSharedFloat64AtomicAdd = data.shaderSharedFloat64AtomicAdd;
      if (data.shaderImageFloat32Atomics !== undefined) this.shaderImageFloat32Atomics = data.shaderImageFloat32Atomics;
      if (data.shaderImageFloat32AtomicAdd !== undefined) this.shaderImageFloat32AtomicAdd = data.shaderImageFloat32AtomicAdd;
      if (data.sparseImageFloat32Atomics !== undefined) this.sparseImageFloat32Atomics = data.sparseImageFloat32Atomics;
      if (data.sparseImageFloat32AtomicAdd !== undefined) this.sparseImageFloat32AtomicAdd = data.sparseImageFloat32AtomicAdd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderBufferFloat32Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferFloat32Atomics(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderBufferFloat32AtomicAdd() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderBufferFloat32AtomicAdd(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderBufferFloat64Atomics() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderBufferFloat64Atomics(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderBufferFloat64AtomicAdd() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderBufferFloat64AtomicAdd(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderSharedFloat32Atomics() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderSharedFloat32Atomics(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderSharedFloat32AtomicAdd() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderSharedFloat32AtomicAdd(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedFloat64Atomics() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedFloat64Atomics(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderSharedFloat64AtomicAdd() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderSharedFloat64AtomicAdd(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderImageFloat32Atomics() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderImageFloat32Atomics(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderImageFloat32AtomicAdd() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderImageFloat32AtomicAdd(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get sparseImageFloat32Atomics() {
    return this.#view.getUint32(56, LE);
  }
  
  set sparseImageFloat32Atomics(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sparseImageFloat32AtomicAdd() {
    return this.#view.getUint32(60, LE);
  }
  
  set sparseImageFloat32AtomicAdd(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
  pNext?: AnyPointer;
  shaderBufferFloat16Atomics?: Bool32;
  shaderBufferFloat16AtomicAdd?: Bool32;
  shaderBufferFloat16AtomicMinMax?: Bool32;
  shaderBufferFloat32AtomicMinMax?: Bool32;
  shaderBufferFloat64AtomicMinMax?: Bool32;
  shaderSharedFloat16Atomics?: Bool32;
  shaderSharedFloat16AtomicAdd?: Bool32;
  shaderSharedFloat16AtomicMinMax?: Bool32;
  shaderSharedFloat32AtomicMinMax?: Bool32;
  shaderSharedFloat64AtomicMinMax?: Bool32;
  shaderImageFloat32AtomicMinMax?: Bool32;
  sparseImageFloat32AtomicMinMax?: Bool32;
}

export class PhysicalDeviceShaderAtomicFloat2FeaturesEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderAtomicFloat2FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicFloat2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderAtomicFloat2FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderAtomicFloat2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderBufferFloat16Atomics !== undefined) this.shaderBufferFloat16Atomics = data.shaderBufferFloat16Atomics;
      if (data.shaderBufferFloat16AtomicAdd !== undefined) this.shaderBufferFloat16AtomicAdd = data.shaderBufferFloat16AtomicAdd;
      if (data.shaderBufferFloat16AtomicMinMax !== undefined) this.shaderBufferFloat16AtomicMinMax = data.shaderBufferFloat16AtomicMinMax;
      if (data.shaderBufferFloat32AtomicMinMax !== undefined) this.shaderBufferFloat32AtomicMinMax = data.shaderBufferFloat32AtomicMinMax;
      if (data.shaderBufferFloat64AtomicMinMax !== undefined) this.shaderBufferFloat64AtomicMinMax = data.shaderBufferFloat64AtomicMinMax;
      if (data.shaderSharedFloat16Atomics !== undefined) this.shaderSharedFloat16Atomics = data.shaderSharedFloat16Atomics;
      if (data.shaderSharedFloat16AtomicAdd !== undefined) this.shaderSharedFloat16AtomicAdd = data.shaderSharedFloat16AtomicAdd;
      if (data.shaderSharedFloat16AtomicMinMax !== undefined) this.shaderSharedFloat16AtomicMinMax = data.shaderSharedFloat16AtomicMinMax;
      if (data.shaderSharedFloat32AtomicMinMax !== undefined) this.shaderSharedFloat32AtomicMinMax = data.shaderSharedFloat32AtomicMinMax;
      if (data.shaderSharedFloat64AtomicMinMax !== undefined) this.shaderSharedFloat64AtomicMinMax = data.shaderSharedFloat64AtomicMinMax;
      if (data.shaderImageFloat32AtomicMinMax !== undefined) this.shaderImageFloat32AtomicMinMax = data.shaderImageFloat32AtomicMinMax;
      if (data.sparseImageFloat32AtomicMinMax !== undefined) this.sparseImageFloat32AtomicMinMax = data.sparseImageFloat32AtomicMinMax;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderBufferFloat16Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderBufferFloat16Atomics(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderBufferFloat16AtomicAdd() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderBufferFloat16AtomicAdd(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get shaderBufferFloat16AtomicMinMax() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderBufferFloat16AtomicMinMax(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderBufferFloat32AtomicMinMax() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderBufferFloat32AtomicMinMax(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderBufferFloat64AtomicMinMax() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderBufferFloat64AtomicMinMax(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderSharedFloat16Atomics() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderSharedFloat16Atomics(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedFloat16AtomicAdd() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedFloat16AtomicAdd(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderSharedFloat16AtomicMinMax() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderSharedFloat16AtomicMinMax(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderSharedFloat32AtomicMinMax() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderSharedFloat32AtomicMinMax(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get shaderSharedFloat64AtomicMinMax() {
    return this.#view.getUint32(52, LE);
  }
  
  set shaderSharedFloat64AtomicMinMax(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderImageFloat32AtomicMinMax() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderImageFloat32AtomicMinMax(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get sparseImageFloat32AtomicMinMax() {
    return this.#view.getUint32(60, LE);
  }
  
  set sparseImageFloat32AtomicMinMax(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  pNext?: AnyPointer;
  vertexAttributeInstanceRateDivisor?: Bool32;
  vertexAttributeInstanceRateZeroDivisor?: Bool32;
}

export class PhysicalDeviceVertexAttributeDivisorFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVertexAttributeDivisorFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVertexAttributeDivisorFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVertexAttributeDivisorFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVertexAttributeDivisorFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexAttributeInstanceRateDivisor !== undefined) this.vertexAttributeInstanceRateDivisor = data.vertexAttributeInstanceRateDivisor;
      if (data.vertexAttributeInstanceRateZeroDivisor !== undefined) this.vertexAttributeInstanceRateZeroDivisor = data.vertexAttributeInstanceRateZeroDivisor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexAttributeInstanceRateDivisor() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexAttributeInstanceRateDivisor(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexAttributeInstanceRateZeroDivisor() {
    return this.#view.getUint32(20, LE);
  }
  
  set vertexAttributeInstanceRateZeroDivisor(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitQueueFamilyCheckpointPropertiesNV {
  pNext?: AnyPointer;
  checkpointExecutionStageMask?: PipelineStageFlags;
}

export class QueueFamilyCheckpointPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyCheckpointPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyCheckpointPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyCheckpointPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyCheckpointPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyCheckpointPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.checkpointExecutionStageMask !== undefined) this.checkpointExecutionStageMask = data.checkpointExecutionStageMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get checkpointExecutionStageMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set checkpointExecutionStageMask(value: PipelineStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCheckpointDataNV {
  pNext?: AnyPointer;
  stage?: PipelineStageFlagBits;
  pCheckpointMarker?: AnyPointer;
}

export class CheckpointDataNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCheckpointDataNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCheckpointDataNV) {
    if (!data) {
      this.#data = new Uint8Array(CheckpointDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CheckpointDataNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CheckpointDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stage !== undefined) this.stage = data.stage;
      if (data.pCheckpointMarker !== undefined) this.pCheckpointMarker = data.pCheckpointMarker;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stage() {
    return this.#view.getUint32(16, LE);
  }
  
  set stage(value: PipelineStageFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pCheckpointMarker() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCheckpointMarker(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDepthStencilResolveProperties {
  pNext?: AnyPointer;
  supportedDepthResolveModes?: ResolveModeFlags;
  supportedStencilResolveModes?: ResolveModeFlags;
  independentResolveNone?: Bool32;
  independentResolve?: Bool32;
}

export class PhysicalDeviceDepthStencilResolveProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDepthStencilResolveProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDepthStencilResolveProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDepthStencilResolveProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDepthStencilResolveProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDepthStencilResolveProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supportedDepthResolveModes !== undefined) this.supportedDepthResolveModes = data.supportedDepthResolveModes;
      if (data.supportedStencilResolveModes !== undefined) this.supportedStencilResolveModes = data.supportedStencilResolveModes;
      if (data.independentResolveNone !== undefined) this.independentResolveNone = data.independentResolveNone;
      if (data.independentResolve !== undefined) this.independentResolve = data.independentResolve;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supportedDepthResolveModes() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedDepthResolveModes(value: ResolveModeFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedStencilResolveModes() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedStencilResolveModes(value: ResolveModeFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get independentResolveNone() {
    return this.#view.getUint32(24, LE);
  }
  
  set independentResolveNone(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get independentResolve() {
    return this.#view.getUint32(28, LE);
  }
  
  set independentResolve(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitSubpassDescriptionDepthStencilResolve {
  pNext?: AnyPointer;
  depthResolveMode?: ResolveModeFlagBits;
  stencilResolveMode?: ResolveModeFlagBits;
  pDepthStencilResolveAttachment?: AnyPointer;
}

export class SubpassDescriptionDepthStencilResolve implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassDescriptionDepthStencilResolve);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassDescriptionDepthStencilResolve) {
    if (!data) {
      this.#data = new Uint8Array(SubpassDescriptionDepthStencilResolve.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassDescriptionDepthStencilResolve.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassDescriptionDepthStencilResolve.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.depthResolveMode !== undefined) this.depthResolveMode = data.depthResolveMode;
      if (data.stencilResolveMode !== undefined) this.stencilResolveMode = data.stencilResolveMode;
      if (data.pDepthStencilResolveAttachment !== undefined) this.pDepthStencilResolveAttachment = data.pDepthStencilResolveAttachment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get depthResolveMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthResolveMode(value: ResolveModeFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilResolveMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilResolveMode(value: ResolveModeFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pDepthStencilResolveAttachment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDepthStencilResolveAttachment(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageViewASTCDecodeModeEXT {
  pNext?: AnyPointer;
  decodeMode?: Format;
}

export class ImageViewASTCDecodeModeEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewASTCDecodeModeEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewASTCDecodeModeEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewASTCDecodeModeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewASTCDecodeModeEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewASTCDecodeModeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.decodeMode !== undefined) this.decodeMode = data.decodeMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get decodeMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set decodeMode(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceASTCDecodeFeaturesEXT {
  pNext?: AnyPointer;
  decodeModeSharedExponent?: Bool32;
}

export class PhysicalDeviceASTCDecodeFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceASTCDecodeFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceASTCDecodeFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceASTCDecodeFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceASTCDecodeFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceASTCDecodeFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.decodeModeSharedExponent !== undefined) this.decodeModeSharedExponent = data.decodeModeSharedExponent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get decodeModeSharedExponent() {
    return this.#view.getUint32(16, LE);
  }
  
  set decodeModeSharedExponent(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceTransformFeedbackFeaturesEXT {
  pNext?: AnyPointer;
  transformFeedback?: Bool32;
  geometryStreams?: Bool32;
}

export class PhysicalDeviceTransformFeedbackFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTransformFeedbackFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTransformFeedbackFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTransformFeedbackFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTransformFeedbackFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTransformFeedbackFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.transformFeedback !== undefined) this.transformFeedback = data.transformFeedback;
      if (data.geometryStreams !== undefined) this.geometryStreams = data.geometryStreams;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get transformFeedback() {
    return this.#view.getUint32(16, LE);
  }
  
  set transformFeedback(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometryStreams() {
    return this.#view.getUint32(20, LE);
  }
  
  set geometryStreams(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceTransformFeedbackPropertiesEXT {
  pNext?: AnyPointer;
  maxTransformFeedbackStreams?: number;
  maxTransformFeedbackBuffers?: number;
  maxTransformFeedbackBufferSize?: DeviceSize;
  maxTransformFeedbackStreamDataSize?: number;
  maxTransformFeedbackBufferDataSize?: number;
  maxTransformFeedbackBufferDataStride?: number;
  transformFeedbackQueries?: Bool32;
  transformFeedbackStreamsLinesTriangles?: Bool32;
  transformFeedbackRasterizationStreamSelect?: Bool32;
  transformFeedbackDraw?: Bool32;
}

export class PhysicalDeviceTransformFeedbackPropertiesEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTransformFeedbackPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTransformFeedbackPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTransformFeedbackPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTransformFeedbackPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTransformFeedbackPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxTransformFeedbackStreams !== undefined) this.maxTransformFeedbackStreams = data.maxTransformFeedbackStreams;
      if (data.maxTransformFeedbackBuffers !== undefined) this.maxTransformFeedbackBuffers = data.maxTransformFeedbackBuffers;
      if (data.maxTransformFeedbackBufferSize !== undefined) this.maxTransformFeedbackBufferSize = data.maxTransformFeedbackBufferSize;
      if (data.maxTransformFeedbackStreamDataSize !== undefined) this.maxTransformFeedbackStreamDataSize = data.maxTransformFeedbackStreamDataSize;
      if (data.maxTransformFeedbackBufferDataSize !== undefined) this.maxTransformFeedbackBufferDataSize = data.maxTransformFeedbackBufferDataSize;
      if (data.maxTransformFeedbackBufferDataStride !== undefined) this.maxTransformFeedbackBufferDataStride = data.maxTransformFeedbackBufferDataStride;
      if (data.transformFeedbackQueries !== undefined) this.transformFeedbackQueries = data.transformFeedbackQueries;
      if (data.transformFeedbackStreamsLinesTriangles !== undefined) this.transformFeedbackStreamsLinesTriangles = data.transformFeedbackStreamsLinesTriangles;
      if (data.transformFeedbackRasterizationStreamSelect !== undefined) this.transformFeedbackRasterizationStreamSelect = data.transformFeedbackRasterizationStreamSelect;
      if (data.transformFeedbackDraw !== undefined) this.transformFeedbackDraw = data.transformFeedbackDraw;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxTransformFeedbackStreams() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxTransformFeedbackStreams(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTransformFeedbackBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTransformFeedbackBuffers(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxTransformFeedbackBufferSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get maxTransformFeedbackStreamDataSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxTransformFeedbackStreamDataSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferDataSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxTransformFeedbackBufferDataSize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxTransformFeedbackBufferDataStride() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxTransformFeedbackBufferDataStride(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get transformFeedbackQueries() {
    return this.#view.getUint32(44, LE);
  }
  
  set transformFeedbackQueries(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get transformFeedbackStreamsLinesTriangles() {
    return this.#view.getUint32(48, LE);
  }
  
  set transformFeedbackStreamsLinesTriangles(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get transformFeedbackRasterizationStreamSelect() {
    return this.#view.getUint32(52, LE);
  }
  
  set transformFeedbackRasterizationStreamSelect(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get transformFeedbackDraw() {
    return this.#view.getUint32(56, LE);
  }
  
  set transformFeedbackDraw(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitPipelineRasterizationStateStreamCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: PipelineRasterizationStateStreamCreateFlagsEXT;
  rasterizationStream?: number;
}

export class PipelineRasterizationStateStreamCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationStateStreamCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationStateStreamCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationStateStreamCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationStateStreamCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationStateStreamCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.rasterizationStream !== undefined) this.rasterizationStream = data.rasterizationStream;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineRasterizationStateStreamCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationStream() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationStream(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  pNext?: AnyPointer;
  representativeFragmentTest?: Bool32;
}

export class PhysicalDeviceRepresentativeFragmentTestFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRepresentativeFragmentTestFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRepresentativeFragmentTestFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRepresentativeFragmentTestFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRepresentativeFragmentTestFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.representativeFragmentTest !== undefined) this.representativeFragmentTest = data.representativeFragmentTest;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get representativeFragmentTest() {
    return this.#view.getUint32(16, LE);
  }
  
  set representativeFragmentTest(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineRepresentativeFragmentTestStateCreateInfoNV {
  pNext?: AnyPointer;
  representativeFragmentTestEnable?: Bool32;
}

export class PipelineRepresentativeFragmentTestStateCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRepresentativeFragmentTestStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRepresentativeFragmentTestStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRepresentativeFragmentTestStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRepresentativeFragmentTestStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRepresentativeFragmentTestStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.representativeFragmentTestEnable !== undefined) this.representativeFragmentTestEnable = data.representativeFragmentTestEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get representativeFragmentTestEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set representativeFragmentTestEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExclusiveScissorFeaturesNV {
  pNext?: AnyPointer;
  exclusiveScissor?: Bool32;
}

export class PhysicalDeviceExclusiveScissorFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExclusiveScissorFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExclusiveScissorFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExclusiveScissorFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExclusiveScissorFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExclusiveScissorFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.exclusiveScissor !== undefined) this.exclusiveScissor = data.exclusiveScissor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get exclusiveScissor() {
    return this.#view.getUint32(16, LE);
  }
  
  set exclusiveScissor(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineViewportExclusiveScissorStateCreateInfoNV {
  pNext?: AnyPointer;
  exclusiveScissorCount?: number;
  pExclusiveScissors?: AnyPointer;
}

export class PipelineViewportExclusiveScissorStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportExclusiveScissorStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportExclusiveScissorStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportExclusiveScissorStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportExclusiveScissorStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportExclusiveScissorStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.exclusiveScissorCount !== undefined) this.exclusiveScissorCount = data.exclusiveScissorCount;
      if (data.pExclusiveScissors !== undefined) this.pExclusiveScissors = data.pExclusiveScissors;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get exclusiveScissorCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set exclusiveScissorCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pExclusiveScissors() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pExclusiveScissors(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceCornerSampledImageFeaturesNV {
  pNext?: AnyPointer;
  cornerSampledImage?: Bool32;
}

export class PhysicalDeviceCornerSampledImageFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCornerSampledImageFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCornerSampledImageFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCornerSampledImageFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCornerSampledImageFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCornerSampledImageFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.cornerSampledImage !== undefined) this.cornerSampledImage = data.cornerSampledImage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get cornerSampledImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set cornerSampledImage(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceComputeShaderDerivativesFeaturesNV {
  pNext?: AnyPointer;
  computeDerivativeGroupQuads?: Bool32;
  computeDerivativeGroupLinear?: Bool32;
}

export class PhysicalDeviceComputeShaderDerivativesFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceComputeShaderDerivativesFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceComputeShaderDerivativesFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceComputeShaderDerivativesFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceComputeShaderDerivativesFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceComputeShaderDerivativesFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.computeDerivativeGroupQuads !== undefined) this.computeDerivativeGroupQuads = data.computeDerivativeGroupQuads;
      if (data.computeDerivativeGroupLinear !== undefined) this.computeDerivativeGroupLinear = data.computeDerivativeGroupLinear;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get computeDerivativeGroupQuads() {
    return this.#view.getUint32(16, LE);
  }
  
  set computeDerivativeGroupQuads(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get computeDerivativeGroupLinear() {
    return this.#view.getUint32(20, LE);
  }
  
  set computeDerivativeGroupLinear(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderImageFootprintFeaturesNV {
  pNext?: AnyPointer;
  imageFootprint?: Bool32;
}

export class PhysicalDeviceShaderImageFootprintFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderImageFootprintFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderImageFootprintFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderImageFootprintFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderImageFootprintFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderImageFootprintFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageFootprint !== undefined) this.imageFootprint = data.imageFootprint;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageFootprint() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageFootprint(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  pNext?: AnyPointer;
  dedicatedAllocationImageAliasing?: Bool32;
}

export class PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dedicatedAllocationImageAliasing !== undefined) this.dedicatedAllocationImageAliasing = data.dedicatedAllocationImageAliasing;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dedicatedAllocationImageAliasing() {
    return this.#view.getUint32(16, LE);
  }
  
  set dedicatedAllocationImageAliasing(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCopyMemoryIndirectFeaturesNV {
  pNext?: AnyPointer;
  indirectCopy?: Bool32;
}

export class PhysicalDeviceCopyMemoryIndirectFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCopyMemoryIndirectFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCopyMemoryIndirectFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCopyMemoryIndirectFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCopyMemoryIndirectFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCopyMemoryIndirectFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.indirectCopy !== undefined) this.indirectCopy = data.indirectCopy;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get indirectCopy() {
    return this.#view.getUint32(16, LE);
  }
  
  set indirectCopy(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCopyMemoryIndirectPropertiesNV {
  pNext?: AnyPointer;
  supportedQueues?: QueueFlags;
}

export class PhysicalDeviceCopyMemoryIndirectPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCopyMemoryIndirectPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCopyMemoryIndirectPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCopyMemoryIndirectPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCopyMemoryIndirectPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCopyMemoryIndirectPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supportedQueues !== undefined) this.supportedQueues = data.supportedQueues;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supportedQueues() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedQueues(value: QueueFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMemoryDecompressionFeaturesNV {
  pNext?: AnyPointer;
  memoryDecompression?: Bool32;
}

export class PhysicalDeviceMemoryDecompressionFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryDecompressionFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryDecompressionFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryDecompressionFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryDecompressionFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryDecompressionFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryDecompression !== undefined) this.memoryDecompression = data.memoryDecompression;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryDecompression() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryDecompression(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMemoryDecompressionPropertiesNV {
  pNext?: AnyPointer;
  decompressionMethods?: MemoryDecompressionMethodFlagsNV;
  maxDecompressionIndirectCount?: Deno.PointerValue;
}

export class PhysicalDeviceMemoryDecompressionPropertiesNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryDecompressionPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryDecompressionPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryDecompressionPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryDecompressionPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryDecompressionPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.decompressionMethods !== undefined) this.decompressionMethods = data.decompressionMethods;
      if (data.maxDecompressionIndirectCount !== undefined) this.maxDecompressionIndirectCount = data.maxDecompressionIndirectCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get decompressionMethods() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set decompressionMethods(value: MemoryDecompressionMethodFlagsNV) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get maxDecompressionIndirectCount() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxDecompressionIndirectCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitShadingRatePaletteNV {
  shadingRatePaletteEntryCount?: number;
  pShadingRatePaletteEntries?: AnyPointer;
}

export class ShadingRatePaletteNV implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShadingRatePaletteNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShadingRatePaletteNV) {
    if (!data) {
      this.#data = new Uint8Array(ShadingRatePaletteNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShadingRatePaletteNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShadingRatePaletteNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.shadingRatePaletteEntryCount !== undefined) this.shadingRatePaletteEntryCount = data.shadingRatePaletteEntryCount;
      if (data.pShadingRatePaletteEntries !== undefined) this.pShadingRatePaletteEntries = data.pShadingRatePaletteEntries;
    }
  }
  
  get shadingRatePaletteEntryCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set shadingRatePaletteEntryCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pShadingRatePaletteEntries() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pShadingRatePaletteEntries(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineViewportShadingRateImageStateCreateInfoNV {
  pNext?: AnyPointer;
  shadingRateImageEnable?: Bool32;
  viewportCount?: number;
  pShadingRatePalettes?: AnyPointer;
}

export class PipelineViewportShadingRateImageStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportShadingRateImageStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportShadingRateImageStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportShadingRateImageStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportShadingRateImageStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportShadingRateImageStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shadingRateImageEnable !== undefined) this.shadingRateImageEnable = data.shadingRateImageEnable;
      if (data.viewportCount !== undefined) this.viewportCount = data.viewportCount;
      if (data.pShadingRatePalettes !== undefined) this.pShadingRatePalettes = data.pShadingRatePalettes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shadingRateImageEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateImageEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pShadingRatePalettes() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pShadingRatePalettes(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceShadingRateImageFeaturesNV {
  pNext?: AnyPointer;
  shadingRateImage?: Bool32;
  shadingRateCoarseSampleOrder?: Bool32;
}

export class PhysicalDeviceShadingRateImageFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShadingRateImageFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShadingRateImageFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShadingRateImageFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShadingRateImageFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShadingRateImageFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shadingRateImage !== undefined) this.shadingRateImage = data.shadingRateImage;
      if (data.shadingRateCoarseSampleOrder !== undefined) this.shadingRateCoarseSampleOrder = data.shadingRateCoarseSampleOrder;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shadingRateImage() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateImage(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shadingRateCoarseSampleOrder() {
    return this.#view.getUint32(20, LE);
  }
  
  set shadingRateCoarseSampleOrder(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShadingRateImagePropertiesNV {
  pNext?: AnyPointer;
  shadingRateTexelSize?: Extent2D;
  shadingRatePaletteSize?: number;
  shadingRateMaxCoarseSamples?: number;
}

export class PhysicalDeviceShadingRateImagePropertiesNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShadingRateImagePropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShadingRateImagePropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShadingRateImagePropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShadingRateImagePropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShadingRateImagePropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shadingRateTexelSize !== undefined) this.shadingRateTexelSize = data.shadingRateTexelSize;
      if (data.shadingRatePaletteSize !== undefined) this.shadingRatePaletteSize = data.shadingRatePaletteSize;
      if (data.shadingRateMaxCoarseSamples !== undefined) this.shadingRateMaxCoarseSamples = data.shadingRateMaxCoarseSamples;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shadingRateTexelSize() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set shadingRateTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get shadingRatePaletteSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set shadingRatePaletteSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shadingRateMaxCoarseSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set shadingRateMaxCoarseSamples(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceInvocationMaskFeaturesHUAWEI {
  pNext?: AnyPointer;
  invocationMask?: Bool32;
}

export class PhysicalDeviceInvocationMaskFeaturesHUAWEI implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceInvocationMaskFeaturesHUAWEI);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceInvocationMaskFeaturesHUAWEI) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceInvocationMaskFeaturesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceInvocationMaskFeaturesHUAWEI.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceInvocationMaskFeaturesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.invocationMask !== undefined) this.invocationMask = data.invocationMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get invocationMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set invocationMask(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCoarseSampleLocationNV {
  pixelX?: number;
  pixelY?: number;
  sample?: number;
}

export class CoarseSampleLocationNV implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCoarseSampleLocationNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCoarseSampleLocationNV) {
    if (!data) {
      this.#data = new Uint8Array(CoarseSampleLocationNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CoarseSampleLocationNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CoarseSampleLocationNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.pixelX !== undefined) this.pixelX = data.pixelX;
      if (data.pixelY !== undefined) this.pixelY = data.pixelY;
      if (data.sample !== undefined) this.sample = data.sample;
    }
  }
  
  get pixelX() {
    return this.#view.getUint32(0, LE);
  }
  
  set pixelX(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pixelY() {
    return this.#view.getUint32(4, LE);
  }
  
  set pixelY(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sample() {
    return this.#view.getUint32(8, LE);
  }
  
  set sample(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitCoarseSampleOrderCustomNV {
  shadingRate?: ShadingRatePaletteEntryNV;
  sampleCount?: number;
  sampleLocationCount?: number;
  pSampleLocations?: AnyPointer;
}

export class CoarseSampleOrderCustomNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCoarseSampleOrderCustomNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCoarseSampleOrderCustomNV) {
    if (!data) {
      this.#data = new Uint8Array(CoarseSampleOrderCustomNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CoarseSampleOrderCustomNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CoarseSampleOrderCustomNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.shadingRate !== undefined) this.shadingRate = data.shadingRate;
      if (data.sampleCount !== undefined) this.sampleCount = data.sampleCount;
      if (data.sampleLocationCount !== undefined) this.sampleLocationCount = data.sampleLocationCount;
      if (data.pSampleLocations !== undefined) this.pSampleLocations = data.pSampleLocations;
    }
  }
  
  get shadingRate() {
    return this.#view.getUint32(0, LE);
  }
  
  set shadingRate(value: ShadingRatePaletteEntryNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get sampleCount() {
    return this.#view.getUint32(4, LE);
  }
  
  set sampleCount(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get sampleLocationCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set sampleLocationCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get pSampleLocations() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pSampleLocations(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  pNext?: AnyPointer;
  sampleOrderType?: CoarseSampleOrderTypeNV;
  customSampleOrderCount?: number;
  pCustomSampleOrders?: AnyPointer;
}

export class PipelineViewportCoarseSampleOrderStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportCoarseSampleOrderStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportCoarseSampleOrderStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportCoarseSampleOrderStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportCoarseSampleOrderStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportCoarseSampleOrderStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampleOrderType !== undefined) this.sampleOrderType = data.sampleOrderType;
      if (data.customSampleOrderCount !== undefined) this.customSampleOrderCount = data.customSampleOrderCount;
      if (data.pCustomSampleOrders !== undefined) this.pCustomSampleOrders = data.pCustomSampleOrders;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampleOrderType() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleOrderType(value: CoarseSampleOrderTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get customSampleOrderCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set customSampleOrderCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pCustomSampleOrders() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCustomSampleOrders(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceMeshShaderFeaturesNV {
  pNext?: AnyPointer;
  taskShader?: Bool32;
  meshShader?: Bool32;
}

export class PhysicalDeviceMeshShaderFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMeshShaderFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMeshShaderFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMeshShaderFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.taskShader !== undefined) this.taskShader = data.taskShader;
      if (data.meshShader !== undefined) this.meshShader = data.meshShader;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get taskShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set taskShader(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get meshShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set meshShader(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMeshShaderPropertiesNV {
  pNext?: AnyPointer;
  maxDrawMeshTasksCount?: number;
  maxTaskWorkGroupInvocations?: number;
  maxTaskWorkGroupSize?: number[];
  maxTaskTotalMemorySize?: number;
  maxTaskOutputCount?: number;
  maxMeshWorkGroupInvocations?: number;
  maxMeshWorkGroupSize?: number[];
  maxMeshTotalMemorySize?: number;
  maxMeshOutputVertices?: number;
  maxMeshOutputPrimitives?: number;
  maxMeshMultiviewViewCount?: number;
  meshOutputPerVertexGranularity?: number;
  meshOutputPerPrimitiveGranularity?: number;
}

export class PhysicalDeviceMeshShaderPropertiesNV implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMeshShaderPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMeshShaderPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMeshShaderPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxDrawMeshTasksCount !== undefined) this.maxDrawMeshTasksCount = data.maxDrawMeshTasksCount;
      if (data.maxTaskWorkGroupInvocations !== undefined) this.maxTaskWorkGroupInvocations = data.maxTaskWorkGroupInvocations;
      if (data.maxTaskWorkGroupSize !== undefined) this.maxTaskWorkGroupSize = data.maxTaskWorkGroupSize;
      if (data.maxTaskTotalMemorySize !== undefined) this.maxTaskTotalMemorySize = data.maxTaskTotalMemorySize;
      if (data.maxTaskOutputCount !== undefined) this.maxTaskOutputCount = data.maxTaskOutputCount;
      if (data.maxMeshWorkGroupInvocations !== undefined) this.maxMeshWorkGroupInvocations = data.maxMeshWorkGroupInvocations;
      if (data.maxMeshWorkGroupSize !== undefined) this.maxMeshWorkGroupSize = data.maxMeshWorkGroupSize;
      if (data.maxMeshTotalMemorySize !== undefined) this.maxMeshTotalMemorySize = data.maxMeshTotalMemorySize;
      if (data.maxMeshOutputVertices !== undefined) this.maxMeshOutputVertices = data.maxMeshOutputVertices;
      if (data.maxMeshOutputPrimitives !== undefined) this.maxMeshOutputPrimitives = data.maxMeshOutputPrimitives;
      if (data.maxMeshMultiviewViewCount !== undefined) this.maxMeshMultiviewViewCount = data.maxMeshMultiviewViewCount;
      if (data.meshOutputPerVertexGranularity !== undefined) this.meshOutputPerVertexGranularity = data.meshOutputPerVertexGranularity;
      if (data.meshOutputPerPrimitiveGranularity !== undefined) this.meshOutputPerPrimitiveGranularity = data.meshOutputPerPrimitiveGranularity;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxDrawMeshTasksCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxDrawMeshTasksCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTaskWorkGroupInvocations() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxTaskWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(24 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxTaskWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(24 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxTaskTotalMemorySize() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxTaskTotalMemorySize(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxTaskOutputCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxTaskOutputCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxMeshWorkGroupInvocations() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxMeshWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(48 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxMeshWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(48 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxMeshTotalMemorySize() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxMeshTotalMemorySize(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxMeshOutputVertices() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxMeshOutputVertices(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxMeshOutputPrimitives() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxMeshOutputPrimitives(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxMeshMultiviewViewCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set maxMeshMultiviewViewCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get meshOutputPerVertexGranularity() {
    return this.#view.getUint32(76, LE);
  }
  
  set meshOutputPerVertexGranularity(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get meshOutputPerPrimitiveGranularity() {
    return this.#view.getUint32(80, LE);
  }
  
  set meshOutputPerPrimitiveGranularity(value: number) {
    this.#view.setUint32(80, Number(value), LE);
  }
}

export interface InitDrawMeshTasksIndirectCommandNV {
  taskCount?: number;
  firstTask?: number;
}

export class DrawMeshTasksIndirectCommandNV implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrawMeshTasksIndirectCommandNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrawMeshTasksIndirectCommandNV) {
    if (!data) {
      this.#data = new Uint8Array(DrawMeshTasksIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrawMeshTasksIndirectCommandNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrawMeshTasksIndirectCommandNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.taskCount !== undefined) this.taskCount = data.taskCount;
      if (data.firstTask !== undefined) this.firstTask = data.firstTask;
    }
  }
  
  get taskCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set taskCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get firstTask() {
    return this.#view.getUint32(4, LE);
  }
  
  set firstTask(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMeshShaderFeaturesEXT {
  pNext?: AnyPointer;
  taskShader?: Bool32;
  meshShader?: Bool32;
  multiviewMeshShader?: Bool32;
  primitiveFragmentShadingRateMeshShader?: Bool32;
  meshShaderQueries?: Bool32;
}

export class PhysicalDeviceMeshShaderFeaturesEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMeshShaderFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMeshShaderFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMeshShaderFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.taskShader !== undefined) this.taskShader = data.taskShader;
      if (data.meshShader !== undefined) this.meshShader = data.meshShader;
      if (data.multiviewMeshShader !== undefined) this.multiviewMeshShader = data.multiviewMeshShader;
      if (data.primitiveFragmentShadingRateMeshShader !== undefined) this.primitiveFragmentShadingRateMeshShader = data.primitiveFragmentShadingRateMeshShader;
      if (data.meshShaderQueries !== undefined) this.meshShaderQueries = data.meshShaderQueries;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get taskShader() {
    return this.#view.getUint32(16, LE);
  }
  
  set taskShader(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get meshShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set meshShader(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get multiviewMeshShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set multiviewMeshShader(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get primitiveFragmentShadingRateMeshShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set primitiveFragmentShadingRateMeshShader(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get meshShaderQueries() {
    return this.#view.getUint32(32, LE);
  }
  
  set meshShaderQueries(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMeshShaderPropertiesEXT {
  pNext?: AnyPointer;
  maxTaskWorkGroupTotalCount?: number;
  maxTaskWorkGroupCount?: number[];
  maxTaskWorkGroupInvocations?: number;
  maxTaskWorkGroupSize?: number[];
  maxTaskPayloadSize?: number;
  maxTaskSharedMemorySize?: number;
  maxTaskPayloadAndSharedMemorySize?: number;
  maxMeshWorkGroupTotalCount?: number;
  maxMeshWorkGroupCount?: number[];
  maxMeshWorkGroupInvocations?: number;
  maxMeshWorkGroupSize?: number[];
  maxMeshSharedMemorySize?: number;
  maxMeshPayloadAndSharedMemorySize?: number;
  maxMeshOutputMemorySize?: number;
  maxMeshPayloadAndOutputMemorySize?: number;
  maxMeshOutputComponents?: number;
  maxMeshOutputVertices?: number;
  maxMeshOutputPrimitives?: number;
  maxMeshOutputLayers?: number;
  maxMeshMultiviewViewCount?: number;
  meshOutputPerVertexGranularity?: number;
  meshOutputPerPrimitiveGranularity?: number;
  maxPreferredTaskWorkGroupInvocations?: number;
  maxPreferredMeshWorkGroupInvocations?: number;
  prefersLocalInvocationVertexOutput?: Bool32;
  prefersLocalInvocationPrimitiveOutput?: Bool32;
  prefersCompactVertexOutput?: Bool32;
  prefersCompactPrimitiveOutput?: Bool32;
}

export class PhysicalDeviceMeshShaderPropertiesEXT implements BaseStruct {
  static size = 160;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMeshShaderPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMeshShaderPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMeshShaderPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMeshShaderPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxTaskWorkGroupTotalCount !== undefined) this.maxTaskWorkGroupTotalCount = data.maxTaskWorkGroupTotalCount;
      if (data.maxTaskWorkGroupCount !== undefined) this.maxTaskWorkGroupCount = data.maxTaskWorkGroupCount;
      if (data.maxTaskWorkGroupInvocations !== undefined) this.maxTaskWorkGroupInvocations = data.maxTaskWorkGroupInvocations;
      if (data.maxTaskWorkGroupSize !== undefined) this.maxTaskWorkGroupSize = data.maxTaskWorkGroupSize;
      if (data.maxTaskPayloadSize !== undefined) this.maxTaskPayloadSize = data.maxTaskPayloadSize;
      if (data.maxTaskSharedMemorySize !== undefined) this.maxTaskSharedMemorySize = data.maxTaskSharedMemorySize;
      if (data.maxTaskPayloadAndSharedMemorySize !== undefined) this.maxTaskPayloadAndSharedMemorySize = data.maxTaskPayloadAndSharedMemorySize;
      if (data.maxMeshWorkGroupTotalCount !== undefined) this.maxMeshWorkGroupTotalCount = data.maxMeshWorkGroupTotalCount;
      if (data.maxMeshWorkGroupCount !== undefined) this.maxMeshWorkGroupCount = data.maxMeshWorkGroupCount;
      if (data.maxMeshWorkGroupInvocations !== undefined) this.maxMeshWorkGroupInvocations = data.maxMeshWorkGroupInvocations;
      if (data.maxMeshWorkGroupSize !== undefined) this.maxMeshWorkGroupSize = data.maxMeshWorkGroupSize;
      if (data.maxMeshSharedMemorySize !== undefined) this.maxMeshSharedMemorySize = data.maxMeshSharedMemorySize;
      if (data.maxMeshPayloadAndSharedMemorySize !== undefined) this.maxMeshPayloadAndSharedMemorySize = data.maxMeshPayloadAndSharedMemorySize;
      if (data.maxMeshOutputMemorySize !== undefined) this.maxMeshOutputMemorySize = data.maxMeshOutputMemorySize;
      if (data.maxMeshPayloadAndOutputMemorySize !== undefined) this.maxMeshPayloadAndOutputMemorySize = data.maxMeshPayloadAndOutputMemorySize;
      if (data.maxMeshOutputComponents !== undefined) this.maxMeshOutputComponents = data.maxMeshOutputComponents;
      if (data.maxMeshOutputVertices !== undefined) this.maxMeshOutputVertices = data.maxMeshOutputVertices;
      if (data.maxMeshOutputPrimitives !== undefined) this.maxMeshOutputPrimitives = data.maxMeshOutputPrimitives;
      if (data.maxMeshOutputLayers !== undefined) this.maxMeshOutputLayers = data.maxMeshOutputLayers;
      if (data.maxMeshMultiviewViewCount !== undefined) this.maxMeshMultiviewViewCount = data.maxMeshMultiviewViewCount;
      if (data.meshOutputPerVertexGranularity !== undefined) this.meshOutputPerVertexGranularity = data.meshOutputPerVertexGranularity;
      if (data.meshOutputPerPrimitiveGranularity !== undefined) this.meshOutputPerPrimitiveGranularity = data.meshOutputPerPrimitiveGranularity;
      if (data.maxPreferredTaskWorkGroupInvocations !== undefined) this.maxPreferredTaskWorkGroupInvocations = data.maxPreferredTaskWorkGroupInvocations;
      if (data.maxPreferredMeshWorkGroupInvocations !== undefined) this.maxPreferredMeshWorkGroupInvocations = data.maxPreferredMeshWorkGroupInvocations;
      if (data.prefersLocalInvocationVertexOutput !== undefined) this.prefersLocalInvocationVertexOutput = data.prefersLocalInvocationVertexOutput;
      if (data.prefersLocalInvocationPrimitiveOutput !== undefined) this.prefersLocalInvocationPrimitiveOutput = data.prefersLocalInvocationPrimitiveOutput;
      if (data.prefersCompactVertexOutput !== undefined) this.prefersCompactVertexOutput = data.prefersCompactVertexOutput;
      if (data.prefersCompactPrimitiveOutput !== undefined) this.prefersCompactPrimitiveOutput = data.prefersCompactPrimitiveOutput;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxTaskWorkGroupTotalCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxTaskWorkGroupTotalCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxTaskWorkGroupCount() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(20 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxTaskWorkGroupCount(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(20 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxTaskWorkGroupInvocations() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxTaskWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(36 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxTaskWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(36 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxTaskPayloadSize() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxTaskPayloadSize(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxTaskSharedMemorySize() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxTaskSharedMemorySize(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxTaskPayloadAndSharedMemorySize() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxTaskPayloadAndSharedMemorySize(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxMeshWorkGroupTotalCount() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxMeshWorkGroupTotalCount(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxMeshWorkGroupCount() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(64 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxMeshWorkGroupCount(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(64 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxMeshWorkGroupInvocations() {
    return this.#view.getUint32(76, LE);
  }
  
  set maxMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get maxMeshWorkGroupSize() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getUint32(80 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set maxMeshWorkGroupSize(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(80 + i * 4, Number(value[i]), LE);
    }
  }
  
  get maxMeshSharedMemorySize() {
    return this.#view.getUint32(92, LE);
  }
  
  set maxMeshSharedMemorySize(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxMeshPayloadAndSharedMemorySize() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxMeshPayloadAndSharedMemorySize(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxMeshOutputMemorySize() {
    return this.#view.getUint32(100, LE);
  }
  
  set maxMeshOutputMemorySize(value: number) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get maxMeshPayloadAndOutputMemorySize() {
    return this.#view.getUint32(104, LE);
  }
  
  set maxMeshPayloadAndOutputMemorySize(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get maxMeshOutputComponents() {
    return this.#view.getUint32(108, LE);
  }
  
  set maxMeshOutputComponents(value: number) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get maxMeshOutputVertices() {
    return this.#view.getUint32(112, LE);
  }
  
  set maxMeshOutputVertices(value: number) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get maxMeshOutputPrimitives() {
    return this.#view.getUint32(116, LE);
  }
  
  set maxMeshOutputPrimitives(value: number) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get maxMeshOutputLayers() {
    return this.#view.getUint32(120, LE);
  }
  
  set maxMeshOutputLayers(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get maxMeshMultiviewViewCount() {
    return this.#view.getUint32(124, LE);
  }
  
  set maxMeshMultiviewViewCount(value: number) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get meshOutputPerVertexGranularity() {
    return this.#view.getUint32(128, LE);
  }
  
  set meshOutputPerVertexGranularity(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get meshOutputPerPrimitiveGranularity() {
    return this.#view.getUint32(132, LE);
  }
  
  set meshOutputPerPrimitiveGranularity(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get maxPreferredTaskWorkGroupInvocations() {
    return this.#view.getUint32(136, LE);
  }
  
  set maxPreferredTaskWorkGroupInvocations(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get maxPreferredMeshWorkGroupInvocations() {
    return this.#view.getUint32(140, LE);
  }
  
  set maxPreferredMeshWorkGroupInvocations(value: number) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get prefersLocalInvocationVertexOutput() {
    return this.#view.getUint32(144, LE);
  }
  
  set prefersLocalInvocationVertexOutput(value: Bool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get prefersLocalInvocationPrimitiveOutput() {
    return this.#view.getUint32(148, LE);
  }
  
  set prefersLocalInvocationPrimitiveOutput(value: Bool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get prefersCompactVertexOutput() {
    return this.#view.getUint32(152, LE);
  }
  
  set prefersCompactVertexOutput(value: Bool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get prefersCompactPrimitiveOutput() {
    return this.#view.getUint32(156, LE);
  }
  
  set prefersCompactPrimitiveOutput(value: Bool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
}

export interface InitDrawMeshTasksIndirectCommandEXT {
  groupCountX?: number;
  groupCountY?: number;
  groupCountZ?: number;
}

export class DrawMeshTasksIndirectCommandEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrawMeshTasksIndirectCommandEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrawMeshTasksIndirectCommandEXT) {
    if (!data) {
      this.#data = new Uint8Array(DrawMeshTasksIndirectCommandEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrawMeshTasksIndirectCommandEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrawMeshTasksIndirectCommandEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.groupCountX !== undefined) this.groupCountX = data.groupCountX;
      if (data.groupCountY !== undefined) this.groupCountY = data.groupCountY;
      if (data.groupCountZ !== undefined) this.groupCountZ = data.groupCountZ;
    }
  }
  
  get groupCountX() {
    return this.#view.getUint32(0, LE);
  }
  
  set groupCountX(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get groupCountY() {
    return this.#view.getUint32(4, LE);
  }
  
  set groupCountY(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get groupCountZ() {
    return this.#view.getUint32(8, LE);
  }
  
  set groupCountZ(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitRayTracingShaderGroupCreateInfoNV {
  pNext?: AnyPointer;
  type?: RayTracingShaderGroupTypeKHR;
  generalShader?: number;
  closestHitShader?: number;
  anyHitShader?: number;
  intersectionShader?: number;
}

export class RayTracingShaderGroupCreateInfoNV implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRayTracingShaderGroupCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRayTracingShaderGroupCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(RayTracingShaderGroupCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RayTracingShaderGroupCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RayTracingShaderGroupCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.generalShader !== undefined) this.generalShader = data.generalShader;
      if (data.closestHitShader !== undefined) this.closestHitShader = data.closestHitShader;
      if (data.anyHitShader !== undefined) this.anyHitShader = data.anyHitShader;
      if (data.intersectionShader !== undefined) this.intersectionShader = data.intersectionShader;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: RayTracingShaderGroupTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get generalShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set generalShader(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get closestHitShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set closestHitShader(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get anyHitShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set anyHitShader(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get intersectionShader() {
    return this.#view.getUint32(32, LE);
  }
  
  set intersectionShader(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitRayTracingShaderGroupCreateInfoKHR {
  pNext?: AnyPointer;
  type?: RayTracingShaderGroupTypeKHR;
  generalShader?: number;
  closestHitShader?: number;
  anyHitShader?: number;
  intersectionShader?: number;
  pShaderGroupCaptureReplayHandle?: AnyPointer;
}

export class RayTracingShaderGroupCreateInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRayTracingShaderGroupCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRayTracingShaderGroupCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(RayTracingShaderGroupCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RayTracingShaderGroupCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RayTracingShaderGroupCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.generalShader !== undefined) this.generalShader = data.generalShader;
      if (data.closestHitShader !== undefined) this.closestHitShader = data.closestHitShader;
      if (data.anyHitShader !== undefined) this.anyHitShader = data.anyHitShader;
      if (data.intersectionShader !== undefined) this.intersectionShader = data.intersectionShader;
      if (data.pShaderGroupCaptureReplayHandle !== undefined) this.pShaderGroupCaptureReplayHandle = data.pShaderGroupCaptureReplayHandle;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: RayTracingShaderGroupTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get generalShader() {
    return this.#view.getUint32(20, LE);
  }
  
  set generalShader(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get closestHitShader() {
    return this.#view.getUint32(24, LE);
  }
  
  set closestHitShader(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get anyHitShader() {
    return this.#view.getUint32(28, LE);
  }
  
  set anyHitShader(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get intersectionShader() {
    return this.#view.getUint32(32, LE);
  }
  
  set intersectionShader(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pShaderGroupCaptureReplayHandle() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pShaderGroupCaptureReplayHandle(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRayTracingPipelineCreateInfoNV {
  pNext?: AnyPointer;
  flags?: PipelineCreateFlags;
  stageCount?: number;
  pStages?: AnyPointer;
  groupCount?: number;
  pGroups?: AnyPointer;
  maxRecursionDepth?: number;
  layout?: PipelineLayout;
  basePipelineHandle?: Pipeline;
  basePipelineIndex?: number;
}

export class RayTracingPipelineCreateInfoNV implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRayTracingPipelineCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRayTracingPipelineCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(RayTracingPipelineCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RayTracingPipelineCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RayTracingPipelineCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.stageCount !== undefined) this.stageCount = data.stageCount;
      if (data.pStages !== undefined) this.pStages = data.pStages;
      if (data.groupCount !== undefined) this.groupCount = data.groupCount;
      if (data.pGroups !== undefined) this.pGroups = data.pGroups;
      if (data.maxRecursionDepth !== undefined) this.maxRecursionDepth = data.maxRecursionDepth;
      if (data.layout !== undefined) this.layout = data.layout;
      if (data.basePipelineHandle !== undefined) this.basePipelineHandle = data.basePipelineHandle;
      if (data.basePipelineIndex !== undefined) this.basePipelineIndex = data.basePipelineIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pGroups(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get maxRecursionDepth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxRecursionDepth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set layout(value: PipelineLayout) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set basePipelineHandle(value: Pipeline) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(72, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(72, Number(value), LE);
  }
}

export interface InitRayTracingPipelineCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: PipelineCreateFlags;
  stageCount?: number;
  pStages?: AnyPointer;
  groupCount?: number;
  pGroups?: AnyPointer;
  maxPipelineRayRecursionDepth?: number;
  pLibraryInfo?: AnyPointer;
  pLibraryInterface?: AnyPointer;
  pDynamicState?: AnyPointer;
  layout?: PipelineLayout;
  basePipelineHandle?: Pipeline;
  basePipelineIndex?: number;
}

export class RayTracingPipelineCreateInfoKHR implements BaseStruct {
  static size = 104;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRayTracingPipelineCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRayTracingPipelineCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(RayTracingPipelineCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RayTracingPipelineCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RayTracingPipelineCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.stageCount !== undefined) this.stageCount = data.stageCount;
      if (data.pStages !== undefined) this.pStages = data.pStages;
      if (data.groupCount !== undefined) this.groupCount = data.groupCount;
      if (data.pGroups !== undefined) this.pGroups = data.pGroups;
      if (data.maxPipelineRayRecursionDepth !== undefined) this.maxPipelineRayRecursionDepth = data.maxPipelineRayRecursionDepth;
      if (data.pLibraryInfo !== undefined) this.pLibraryInfo = data.pLibraryInfo;
      if (data.pLibraryInterface !== undefined) this.pLibraryInterface = data.pLibraryInterface;
      if (data.pDynamicState !== undefined) this.pDynamicState = data.pDynamicState;
      if (data.layout !== undefined) this.layout = data.layout;
      if (data.basePipelineHandle !== undefined) this.basePipelineHandle = data.basePipelineHandle;
      if (data.basePipelineIndex !== undefined) this.basePipelineIndex = data.basePipelineIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stageCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set stageCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pStages() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStages(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get groupCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set groupCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pGroups() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pGroups(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get maxPipelineRayRecursionDepth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxPipelineRayRecursionDepth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pLibraryInfo() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pLibraryInfo(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pLibraryInterface() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pLibraryInterface(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get pDynamicState() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set pDynamicState(value: AnyPointer) {
    this.#view.setBigUint64(72, BigInt(anyPointer(value)), LE);
  }
  
  get layout() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set layout(value: PipelineLayout) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineHandle() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set basePipelineHandle(value: Pipeline) {
    this.#view.setBigUint64(88, BigInt(anyPointer(value)), LE);
  }
  
  get basePipelineIndex() {
    return this.#view.getInt32(96, LE);
  }
  
  set basePipelineIndex(value: number) {
    this.#view.setInt32(96, Number(value), LE);
  }
}

export interface InitGeometryTrianglesNV {
  pNext?: AnyPointer;
  vertexData?: Buffer;
  vertexOffset?: DeviceSize;
  vertexCount?: number;
  vertexStride?: DeviceSize;
  vertexFormat?: Format;
  indexData?: Buffer;
  indexOffset?: DeviceSize;
  indexCount?: number;
  indexType?: IndexType;
  transformData?: Buffer;
  transformOffset?: DeviceSize;
}

export class GeometryTrianglesNV implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeometryTrianglesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeometryTrianglesNV) {
    if (!data) {
      this.#data = new Uint8Array(GeometryTrianglesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeometryTrianglesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeometryTrianglesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexData !== undefined) this.vertexData = data.vertexData;
      if (data.vertexOffset !== undefined) this.vertexOffset = data.vertexOffset;
      if (data.vertexCount !== undefined) this.vertexCount = data.vertexCount;
      if (data.vertexStride !== undefined) this.vertexStride = data.vertexStride;
      if (data.vertexFormat !== undefined) this.vertexFormat = data.vertexFormat;
      if (data.indexData !== undefined) this.indexData = data.indexData;
      if (data.indexOffset !== undefined) this.indexOffset = data.indexOffset;
      if (data.indexCount !== undefined) this.indexCount = data.indexCount;
      if (data.indexType !== undefined) this.indexType = data.indexType;
      if (data.transformData !== undefined) this.transformData = data.transformData;
      if (data.transformOffset !== undefined) this.transformOffset = data.transformOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set vertexData(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get vertexOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set vertexOffset(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get vertexCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set vertexCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get vertexStride() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set vertexStride(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get vertexFormat() {
    return this.#view.getUint32(48, LE);
  }
  
  set vertexFormat(value: Format) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get indexData() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set indexData(value: Buffer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get indexOffset() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set indexOffset(value: DeviceSize) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get indexCount() {
    return this.#view.getUint32(72, LE);
  }
  
  set indexCount(value: number) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(76, LE);
  }
  
  set indexType(value: IndexType) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get transformData() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set transformData(value: Buffer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
  
  get transformOffset() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set transformOffset(value: DeviceSize) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export interface InitGeometryAABBNV {
  pNext?: AnyPointer;
  aabbData?: Buffer;
  numAABBs?: number;
  stride?: number;
  offset?: DeviceSize;
}

export class GeometryAABBNV implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeometryAABBNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeometryAABBNV) {
    if (!data) {
      this.#data = new Uint8Array(GeometryAABBNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeometryAABBNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeometryAABBNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GEOMETRY_AABB_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.aabbData !== undefined) this.aabbData = data.aabbData;
      if (data.numAABBs !== undefined) this.numAABBs = data.numAABBs;
      if (data.stride !== undefined) this.stride = data.stride;
      if (data.offset !== undefined) this.offset = data.offset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get aabbData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set aabbData(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get numAABBs() {
    return this.#view.getUint32(24, LE);
  }
  
  set numAABBs(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(28, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitGeometryDataNV {
  triangles?: GeometryTrianglesNV;
  aabbs?: GeometryAABBNV;
}

export class GeometryDataNV implements BaseStruct {
  static size = 136;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeometryDataNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeometryDataNV) {
    if (!data) {
      this.#data = new Uint8Array(GeometryDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeometryDataNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeometryDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.triangles !== undefined) this.triangles = data.triangles;
      if (data.aabbs !== undefined) this.aabbs = data.aabbs;
    }
  }
  
  get triangles() {
    return new GeometryTrianglesNV(this.#data.subarray(0, 0 + GeometryTrianglesNV.size));
  }
  
  set triangles(value: GeometryTrianglesNV) {
    if (value[BUFFER].byteLength < GeometryTrianglesNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get aabbs() {
    return new GeometryAABBNV(this.#data.subarray(96, 96 + GeometryAABBNV.size));
  }
  
  set aabbs(value: GeometryAABBNV) {
    if (value[BUFFER].byteLength < GeometryAABBNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 96);
  }
}

export interface InitGeometryNV {
  pNext?: AnyPointer;
  geometryType?: GeometryTypeKHR;
  geometry?: GeometryDataNV;
  flags?: GeometryFlagsKHR;
}

export class GeometryNV implements BaseStruct {
  static size = 160;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGeometryNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGeometryNV) {
    if (!data) {
      this.#data = new Uint8Array(GeometryNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GeometryNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GeometryNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GEOMETRY_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.geometryType !== undefined) this.geometryType = data.geometryType;
      if (data.geometry !== undefined) this.geometry = data.geometry;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get geometryType() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryType(value: GeometryTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometry() {
    return new GeometryDataNV(this.#data.subarray(20, 20 + GeometryDataNV.size));
  }
  
  set geometry(value: GeometryDataNV) {
    if (value[BUFFER].byteLength < GeometryDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get flags() {
    return this.#view.getUint32(156, LE);
  }
  
  set flags(value: GeometryFlagsKHR) {
    this.#view.setUint32(156, Number(value), LE);
  }
}

export interface InitAccelerationStructureInfoNV {
  pNext?: AnyPointer;
  type?: AccelerationStructureTypeNV;
  flags?: BuildAccelerationStructureFlagsNV;
  instanceCount?: number;
  geometryCount?: number;
  pGeometries?: AnyPointer;
}

export class AccelerationStructureInfoNV implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.instanceCount !== undefined) this.instanceCount = data.instanceCount;
      if (data.geometryCount !== undefined) this.geometryCount = data.geometryCount;
      if (data.pGeometries !== undefined) this.pGeometries = data.pGeometries;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: AccelerationStructureTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: BuildAccelerationStructureFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get instanceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set instanceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get geometryCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set geometryCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pGeometries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pGeometries(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAccelerationStructureCreateInfoNV {
  pNext?: AnyPointer;
  compactedSize?: DeviceSize;
  info?: AccelerationStructureInfoNV;
}

export class AccelerationStructureCreateInfoNV implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.compactedSize !== undefined) this.compactedSize = data.compactedSize;
      if (data.info !== undefined) this.info = data.info;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get compactedSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set compactedSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get info() {
    return new AccelerationStructureInfoNV(this.#data.subarray(24, 24 + AccelerationStructureInfoNV.size));
  }
  
  set info(value: AccelerationStructureInfoNV) {
    if (value[BUFFER].byteLength < AccelerationStructureInfoNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export interface InitBindAccelerationStructureMemoryInfoNV {
  pNext?: AnyPointer;
  accelerationStructure?: AccelerationStructureNV;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
  deviceIndexCount?: number;
  pDeviceIndices?: AnyPointer;
}

export class BindAccelerationStructureMemoryInfoNV implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindAccelerationStructureMemoryInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindAccelerationStructureMemoryInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(BindAccelerationStructureMemoryInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindAccelerationStructureMemoryInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindAccelerationStructureMemoryInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructure !== undefined) this.accelerationStructure = data.accelerationStructure;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
      if (data.deviceIndexCount !== undefined) this.deviceIndexCount = data.deviceIndexCount;
      if (data.pDeviceIndices !== undefined) this.pDeviceIndices = data.pDeviceIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: AccelerationStructureNV) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get deviceIndexCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set deviceIndexCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pDeviceIndices() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pDeviceIndices(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitWriteDescriptorSetAccelerationStructureKHR {
  pNext?: AnyPointer;
  accelerationStructureCount?: number;
  pAccelerationStructures?: AnyPointer;
}

export class WriteDescriptorSetAccelerationStructureKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWriteDescriptorSetAccelerationStructureKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWriteDescriptorSetAccelerationStructureKHR) {
    if (!data) {
      this.#data = new Uint8Array(WriteDescriptorSetAccelerationStructureKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < WriteDescriptorSetAccelerationStructureKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(WriteDescriptorSetAccelerationStructureKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructureCount !== undefined) this.accelerationStructureCount = data.accelerationStructureCount;
      if (data.pAccelerationStructures !== undefined) this.pAccelerationStructures = data.pAccelerationStructures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAccelerationStructures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAccelerationStructures(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitWriteDescriptorSetAccelerationStructureNV {
  pNext?: AnyPointer;
  accelerationStructureCount?: number;
  pAccelerationStructures?: AnyPointer;
}

export class WriteDescriptorSetAccelerationStructureNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitWriteDescriptorSetAccelerationStructureNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitWriteDescriptorSetAccelerationStructureNV) {
    if (!data) {
      this.#data = new Uint8Array(WriteDescriptorSetAccelerationStructureNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < WriteDescriptorSetAccelerationStructureNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(WriteDescriptorSetAccelerationStructureNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructureCount !== undefined) this.accelerationStructureCount = data.accelerationStructureCount;
      if (data.pAccelerationStructures !== undefined) this.pAccelerationStructures = data.pAccelerationStructures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructureCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructureCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAccelerationStructures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAccelerationStructures(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAccelerationStructureMemoryRequirementsInfoNV {
  pNext?: AnyPointer;
  type?: AccelerationStructureMemoryRequirementsTypeNV;
  accelerationStructure?: AccelerationStructureNV;
}

export class AccelerationStructureMemoryRequirementsInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureMemoryRequirementsInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureMemoryRequirementsInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureMemoryRequirementsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureMemoryRequirementsInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureMemoryRequirementsInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.accelerationStructure !== undefined) this.accelerationStructure = data.accelerationStructure;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: AccelerationStructureMemoryRequirementsTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructure(value: AccelerationStructureNV) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceAccelerationStructureFeaturesKHR {
  pNext?: AnyPointer;
  accelerationStructure?: Bool32;
  accelerationStructureCaptureReplay?: Bool32;
  accelerationStructureIndirectBuild?: Bool32;
  accelerationStructureHostCommands?: Bool32;
  descriptorBindingAccelerationStructureUpdateAfterBind?: Bool32;
}

export class PhysicalDeviceAccelerationStructureFeaturesKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceAccelerationStructureFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceAccelerationStructureFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceAccelerationStructureFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceAccelerationStructureFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceAccelerationStructureFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructure !== undefined) this.accelerationStructure = data.accelerationStructure;
      if (data.accelerationStructureCaptureReplay !== undefined) this.accelerationStructureCaptureReplay = data.accelerationStructureCaptureReplay;
      if (data.accelerationStructureIndirectBuild !== undefined) this.accelerationStructureIndirectBuild = data.accelerationStructureIndirectBuild;
      if (data.accelerationStructureHostCommands !== undefined) this.accelerationStructureHostCommands = data.accelerationStructureHostCommands;
      if (data.descriptorBindingAccelerationStructureUpdateAfterBind !== undefined) this.descriptorBindingAccelerationStructureUpdateAfterBind = data.descriptorBindingAccelerationStructureUpdateAfterBind;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getUint32(16, LE);
  }
  
  set accelerationStructure(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructureCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set accelerationStructureCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get accelerationStructureIndirectBuild() {
    return this.#view.getUint32(24, LE);
  }
  
  set accelerationStructureIndirectBuild(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get accelerationStructureHostCommands() {
    return this.#view.getUint32(28, LE);
  }
  
  set accelerationStructureHostCommands(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get descriptorBindingAccelerationStructureUpdateAfterBind() {
    return this.#view.getUint32(32, LE);
  }
  
  set descriptorBindingAccelerationStructureUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingPipelineFeaturesKHR {
  pNext?: AnyPointer;
  rayTracingPipeline?: Bool32;
  rayTracingPipelineShaderGroupHandleCaptureReplay?: Bool32;
  rayTracingPipelineShaderGroupHandleCaptureReplayMixed?: Bool32;
  rayTracingPipelineTraceRaysIndirect?: Bool32;
  rayTraversalPrimitiveCulling?: Bool32;
}

export class PhysicalDeviceRayTracingPipelineFeaturesKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingPipelineFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingPipelineFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPipelineFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingPipelineFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPipelineFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayTracingPipeline !== undefined) this.rayTracingPipeline = data.rayTracingPipeline;
      if (data.rayTracingPipelineShaderGroupHandleCaptureReplay !== undefined) this.rayTracingPipelineShaderGroupHandleCaptureReplay = data.rayTracingPipelineShaderGroupHandleCaptureReplay;
      if (data.rayTracingPipelineShaderGroupHandleCaptureReplayMixed !== undefined) this.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = data.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
      if (data.rayTracingPipelineTraceRaysIndirect !== undefined) this.rayTracingPipelineTraceRaysIndirect = data.rayTracingPipelineTraceRaysIndirect;
      if (data.rayTraversalPrimitiveCulling !== undefined) this.rayTraversalPrimitiveCulling = data.rayTraversalPrimitiveCulling;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayTracingPipeline() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingPipeline(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingPipelineShaderGroupHandleCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingPipelineShaderGroupHandleCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rayTracingPipelineShaderGroupHandleCaptureReplayMixed() {
    return this.#view.getUint32(24, LE);
  }
  
  set rayTracingPipelineShaderGroupHandleCaptureReplayMixed(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rayTracingPipelineTraceRaysIndirect() {
    return this.#view.getUint32(28, LE);
  }
  
  set rayTracingPipelineTraceRaysIndirect(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get rayTraversalPrimitiveCulling() {
    return this.#view.getUint32(32, LE);
  }
  
  set rayTraversalPrimitiveCulling(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayQueryFeaturesKHR {
  pNext?: AnyPointer;
  rayQuery?: Bool32;
}

export class PhysicalDeviceRayQueryFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayQueryFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayQueryFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayQueryFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayQuery !== undefined) this.rayQuery = data.rayQuery;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayQuery(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceAccelerationStructurePropertiesKHR {
  pNext?: AnyPointer;
  maxGeometryCount?: Deno.PointerValue;
  maxInstanceCount?: Deno.PointerValue;
  maxPrimitiveCount?: Deno.PointerValue;
  maxPerStageDescriptorAccelerationStructures?: number;
  maxPerStageDescriptorUpdateAfterBindAccelerationStructures?: number;
  maxDescriptorSetAccelerationStructures?: number;
  maxDescriptorSetUpdateAfterBindAccelerationStructures?: number;
  minAccelerationStructureScratchOffsetAlignment?: number;
}

export class PhysicalDeviceAccelerationStructurePropertiesKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceAccelerationStructurePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceAccelerationStructurePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceAccelerationStructurePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceAccelerationStructurePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceAccelerationStructurePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxGeometryCount !== undefined) this.maxGeometryCount = data.maxGeometryCount;
      if (data.maxInstanceCount !== undefined) this.maxInstanceCount = data.maxInstanceCount;
      if (data.maxPrimitiveCount !== undefined) this.maxPrimitiveCount = data.maxPrimitiveCount;
      if (data.maxPerStageDescriptorAccelerationStructures !== undefined) this.maxPerStageDescriptorAccelerationStructures = data.maxPerStageDescriptorAccelerationStructures;
      if (data.maxPerStageDescriptorUpdateAfterBindAccelerationStructures !== undefined) this.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = data.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
      if (data.maxDescriptorSetAccelerationStructures !== undefined) this.maxDescriptorSetAccelerationStructures = data.maxDescriptorSetAccelerationStructures;
      if (data.maxDescriptorSetUpdateAfterBindAccelerationStructures !== undefined) this.maxDescriptorSetUpdateAfterBindAccelerationStructures = data.maxDescriptorSetUpdateAfterBindAccelerationStructures;
      if (data.minAccelerationStructureScratchOffsetAlignment !== undefined) this.minAccelerationStructureScratchOffsetAlignment = data.minAccelerationStructureScratchOffsetAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxGeometryCount() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set maxGeometryCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get maxInstanceCount() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set maxInstanceCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get maxPrimitiveCount() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set maxPrimitiveCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxPerStageDescriptorAccelerationStructures() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxPerStageDescriptorAccelerationStructures(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindAccelerationStructures() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindAccelerationStructures(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxDescriptorSetAccelerationStructures() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxDescriptorSetAccelerationStructures(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindAccelerationStructures() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindAccelerationStructures(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get minAccelerationStructureScratchOffsetAlignment() {
    return this.#view.getUint32(56, LE);
  }
  
  set minAccelerationStructureScratchOffsetAlignment(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingPipelinePropertiesKHR {
  pNext?: AnyPointer;
  shaderGroupHandleSize?: number;
  maxRayRecursionDepth?: number;
  maxShaderGroupStride?: number;
  shaderGroupBaseAlignment?: number;
  shaderGroupHandleCaptureReplaySize?: number;
  maxRayDispatchInvocationCount?: number;
  shaderGroupHandleAlignment?: number;
  maxRayHitAttributeSize?: number;
}

export class PhysicalDeviceRayTracingPipelinePropertiesKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingPipelinePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingPipelinePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPipelinePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingPipelinePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPipelinePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderGroupHandleSize !== undefined) this.shaderGroupHandleSize = data.shaderGroupHandleSize;
      if (data.maxRayRecursionDepth !== undefined) this.maxRayRecursionDepth = data.maxRayRecursionDepth;
      if (data.maxShaderGroupStride !== undefined) this.maxShaderGroupStride = data.maxShaderGroupStride;
      if (data.shaderGroupBaseAlignment !== undefined) this.shaderGroupBaseAlignment = data.shaderGroupBaseAlignment;
      if (data.shaderGroupHandleCaptureReplaySize !== undefined) this.shaderGroupHandleCaptureReplaySize = data.shaderGroupHandleCaptureReplaySize;
      if (data.maxRayDispatchInvocationCount !== undefined) this.maxRayDispatchInvocationCount = data.maxRayDispatchInvocationCount;
      if (data.shaderGroupHandleAlignment !== undefined) this.shaderGroupHandleAlignment = data.shaderGroupHandleAlignment;
      if (data.maxRayHitAttributeSize !== undefined) this.maxRayHitAttributeSize = data.maxRayHitAttributeSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderGroupHandleSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderGroupHandleSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxRayRecursionDepth() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxRayRecursionDepth(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxShaderGroupStride() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxShaderGroupStride(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderGroupBaseAlignment() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderGroupBaseAlignment(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get shaderGroupHandleCaptureReplaySize() {
    return this.#view.getUint32(32, LE);
  }
  
  set shaderGroupHandleCaptureReplaySize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxRayDispatchInvocationCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxRayDispatchInvocationCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderGroupHandleAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderGroupHandleAlignment(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxRayHitAttributeSize() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxRayHitAttributeSize(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingPropertiesNV {
  pNext?: AnyPointer;
  shaderGroupHandleSize?: number;
  maxRecursionDepth?: number;
  maxShaderGroupStride?: number;
  shaderGroupBaseAlignment?: number;
  maxGeometryCount?: Deno.PointerValue;
  maxInstanceCount?: Deno.PointerValue;
  maxTriangleCount?: Deno.PointerValue;
  maxDescriptorSetAccelerationStructures?: number;
}

export class PhysicalDeviceRayTracingPropertiesNV implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderGroupHandleSize !== undefined) this.shaderGroupHandleSize = data.shaderGroupHandleSize;
      if (data.maxRecursionDepth !== undefined) this.maxRecursionDepth = data.maxRecursionDepth;
      if (data.maxShaderGroupStride !== undefined) this.maxShaderGroupStride = data.maxShaderGroupStride;
      if (data.shaderGroupBaseAlignment !== undefined) this.shaderGroupBaseAlignment = data.shaderGroupBaseAlignment;
      if (data.maxGeometryCount !== undefined) this.maxGeometryCount = data.maxGeometryCount;
      if (data.maxInstanceCount !== undefined) this.maxInstanceCount = data.maxInstanceCount;
      if (data.maxTriangleCount !== undefined) this.maxTriangleCount = data.maxTriangleCount;
      if (data.maxDescriptorSetAccelerationStructures !== undefined) this.maxDescriptorSetAccelerationStructures = data.maxDescriptorSetAccelerationStructures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderGroupHandleSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderGroupHandleSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxRecursionDepth() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxRecursionDepth(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxShaderGroupStride() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxShaderGroupStride(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderGroupBaseAlignment() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderGroupBaseAlignment(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxGeometryCount() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set maxGeometryCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxInstanceCount() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set maxInstanceCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get maxTriangleCount() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set maxTriangleCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get maxDescriptorSetAccelerationStructures() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxDescriptorSetAccelerationStructures(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitStridedDeviceAddressRegionKHR {
  deviceAddress?: DeviceAddress;
  stride?: DeviceSize;
  size?: DeviceSize;
}

export class StridedDeviceAddressRegionKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitStridedDeviceAddressRegionKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitStridedDeviceAddressRegionKHR) {
    if (!data) {
      this.#data = new Uint8Array(StridedDeviceAddressRegionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < StridedDeviceAddressRegionKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(StridedDeviceAddressRegionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.deviceAddress !== undefined) this.deviceAddress = data.deviceAddress;
      if (data.stride !== undefined) this.stride = data.stride;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set deviceAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get stride() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set stride(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitTraceRaysIndirectCommandKHR {
  width?: number;
  height?: number;
  depth?: number;
}

export class TraceRaysIndirectCommandKHR implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTraceRaysIndirectCommandKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTraceRaysIndirectCommandKHR) {
    if (!data) {
      this.#data = new Uint8Array(TraceRaysIndirectCommandKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TraceRaysIndirectCommandKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TraceRaysIndirectCommandKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.depth !== undefined) this.depth = data.depth;
    }
  }
  
  get width() {
    return this.#view.getUint32(0, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(4, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(8, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitTraceRaysIndirectCommand2KHR {
  raygenShaderRecordAddress?: DeviceAddress;
  raygenShaderRecordSize?: DeviceSize;
  missShaderBindingTableAddress?: DeviceAddress;
  missShaderBindingTableSize?: DeviceSize;
  missShaderBindingTableStride?: DeviceSize;
  hitShaderBindingTableAddress?: DeviceAddress;
  hitShaderBindingTableSize?: DeviceSize;
  hitShaderBindingTableStride?: DeviceSize;
  callableShaderBindingTableAddress?: DeviceAddress;
  callableShaderBindingTableSize?: DeviceSize;
  callableShaderBindingTableStride?: DeviceSize;
  width?: number;
  height?: number;
  depth?: number;
}

export class TraceRaysIndirectCommand2KHR implements BaseStruct {
  static size = 104;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTraceRaysIndirectCommand2KHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTraceRaysIndirectCommand2KHR) {
    if (!data) {
      this.#data = new Uint8Array(TraceRaysIndirectCommand2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TraceRaysIndirectCommand2KHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TraceRaysIndirectCommand2KHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.raygenShaderRecordAddress !== undefined) this.raygenShaderRecordAddress = data.raygenShaderRecordAddress;
      if (data.raygenShaderRecordSize !== undefined) this.raygenShaderRecordSize = data.raygenShaderRecordSize;
      if (data.missShaderBindingTableAddress !== undefined) this.missShaderBindingTableAddress = data.missShaderBindingTableAddress;
      if (data.missShaderBindingTableSize !== undefined) this.missShaderBindingTableSize = data.missShaderBindingTableSize;
      if (data.missShaderBindingTableStride !== undefined) this.missShaderBindingTableStride = data.missShaderBindingTableStride;
      if (data.hitShaderBindingTableAddress !== undefined) this.hitShaderBindingTableAddress = data.hitShaderBindingTableAddress;
      if (data.hitShaderBindingTableSize !== undefined) this.hitShaderBindingTableSize = data.hitShaderBindingTableSize;
      if (data.hitShaderBindingTableStride !== undefined) this.hitShaderBindingTableStride = data.hitShaderBindingTableStride;
      if (data.callableShaderBindingTableAddress !== undefined) this.callableShaderBindingTableAddress = data.callableShaderBindingTableAddress;
      if (data.callableShaderBindingTableSize !== undefined) this.callableShaderBindingTableSize = data.callableShaderBindingTableSize;
      if (data.callableShaderBindingTableStride !== undefined) this.callableShaderBindingTableStride = data.callableShaderBindingTableStride;
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.depth !== undefined) this.depth = data.depth;
    }
  }
  
  get raygenShaderRecordAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set raygenShaderRecordAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get raygenShaderRecordSize() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set raygenShaderRecordSize(value: DeviceSize) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get missShaderBindingTableAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set missShaderBindingTableAddress(value: DeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get missShaderBindingTableSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set missShaderBindingTableSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get missShaderBindingTableStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set missShaderBindingTableStride(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get hitShaderBindingTableAddress() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set hitShaderBindingTableAddress(value: DeviceAddress) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get hitShaderBindingTableSize() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set hitShaderBindingTableSize(value: DeviceSize) {
    this.#view.setBigUint64(48, BigInt(value), LE);
  }
  
  get hitShaderBindingTableStride() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set hitShaderBindingTableStride(value: DeviceSize) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get callableShaderBindingTableAddress() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set callableShaderBindingTableAddress(value: DeviceAddress) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get callableShaderBindingTableSize() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set callableShaderBindingTableSize(value: DeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get callableShaderBindingTableStride() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set callableShaderBindingTableStride(value: DeviceSize) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(88, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(92, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get depth() {
    return this.#view.getUint32(96, LE);
  }
  
  set depth(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
  pNext?: AnyPointer;
  rayTracingMaintenance1?: Bool32;
  rayTracingPipelineTraceRaysIndirect2?: Bool32;
}

export class PhysicalDeviceRayTracingMaintenance1FeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingMaintenance1FeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingMaintenance1FeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingMaintenance1FeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingMaintenance1FeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingMaintenance1FeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayTracingMaintenance1 !== undefined) this.rayTracingMaintenance1 = data.rayTracingMaintenance1;
      if (data.rayTracingPipelineTraceRaysIndirect2 !== undefined) this.rayTracingPipelineTraceRaysIndirect2 = data.rayTracingPipelineTraceRaysIndirect2;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayTracingMaintenance1() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingMaintenance1(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingPipelineTraceRaysIndirect2() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingPipelineTraceRaysIndirect2(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitDrmFormatModifierPropertiesListEXT {
  pNext?: AnyPointer;
  drmFormatModifierCount?: number;
  pDrmFormatModifierProperties?: AnyPointer;
}

export class DrmFormatModifierPropertiesListEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrmFormatModifierPropertiesListEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrmFormatModifierPropertiesListEXT) {
    if (!data) {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesListEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrmFormatModifierPropertiesListEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesListEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifierCount !== undefined) this.drmFormatModifierCount = data.drmFormatModifierCount;
      if (data.pDrmFormatModifierProperties !== undefined) this.pDrmFormatModifierProperties = data.pDrmFormatModifierProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifierProperties() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifierProperties(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDrmFormatModifierPropertiesEXT {
  drmFormatModifier?: Deno.PointerValue;
  drmFormatModifierPlaneCount?: number;
  drmFormatModifierTilingFeatures?: FormatFeatureFlags;
}

export class DrmFormatModifierPropertiesEXT implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrmFormatModifierPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrmFormatModifierPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrmFormatModifierPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.drmFormatModifier !== undefined) this.drmFormatModifier = data.drmFormatModifier;
      if (data.drmFormatModifierPlaneCount !== undefined) this.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
      if (data.drmFormatModifierTilingFeatures !== undefined) this.drmFormatModifierTilingFeatures = data.drmFormatModifierTilingFeatures;
    }
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get drmFormatModifierTilingFeatures() {
    return this.#view.getUint32(12, LE);
  }
  
  set drmFormatModifierTilingFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImageDrmFormatModifierInfoEXT {
  pNext?: AnyPointer;
  drmFormatModifier?: Deno.PointerValue;
  sharingMode?: SharingMode;
  queueFamilyIndexCount?: number;
  pQueueFamilyIndices?: AnyPointer;
}

export class PhysicalDeviceImageDrmFormatModifierInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageDrmFormatModifierInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageDrmFormatModifierInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageDrmFormatModifierInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageDrmFormatModifierInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageDrmFormatModifierInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifier !== undefined) this.drmFormatModifier = data.drmFormatModifier;
      if (data.sharingMode !== undefined) this.sharingMode = data.sharingMode;
      if (data.queueFamilyIndexCount !== undefined) this.queueFamilyIndexCount = data.queueFamilyIndexCount;
      if (data.pQueueFamilyIndices !== undefined) this.pQueueFamilyIndices = data.pQueueFamilyIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get sharingMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set sharingMode(value: SharingMode) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get queueFamilyIndexCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set queueFamilyIndexCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get pQueueFamilyIndices() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pQueueFamilyIndices(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageDrmFormatModifierListCreateInfoEXT {
  pNext?: AnyPointer;
  drmFormatModifierCount?: number;
  pDrmFormatModifiers?: AnyPointer;
}

export class ImageDrmFormatModifierListCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageDrmFormatModifierListCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageDrmFormatModifierListCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageDrmFormatModifierListCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageDrmFormatModifierListCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageDrmFormatModifierListCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifierCount !== undefined) this.drmFormatModifierCount = data.drmFormatModifierCount;
      if (data.pDrmFormatModifiers !== undefined) this.pDrmFormatModifiers = data.pDrmFormatModifiers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifiers() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifiers(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageDrmFormatModifierExplicitCreateInfoEXT {
  pNext?: AnyPointer;
  drmFormatModifier?: Deno.PointerValue;
  drmFormatModifierPlaneCount?: number;
  pPlaneLayouts?: AnyPointer;
}

export class ImageDrmFormatModifierExplicitCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageDrmFormatModifierExplicitCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageDrmFormatModifierExplicitCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageDrmFormatModifierExplicitCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageDrmFormatModifierExplicitCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageDrmFormatModifierExplicitCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifier !== undefined) this.drmFormatModifier = data.drmFormatModifier;
      if (data.drmFormatModifierPlaneCount !== undefined) this.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
      if (data.pPlaneLayouts !== undefined) this.pPlaneLayouts = data.pPlaneLayouts;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPlaneLayouts() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPlaneLayouts(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageDrmFormatModifierPropertiesEXT {
  pNext?: AnyPointer;
  drmFormatModifier?: Deno.PointerValue;
}

export class ImageDrmFormatModifierPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageDrmFormatModifierPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageDrmFormatModifierPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageDrmFormatModifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageDrmFormatModifierPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageDrmFormatModifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifier !== undefined) this.drmFormatModifier = data.drmFormatModifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitImageStencilUsageCreateInfo {
  pNext?: AnyPointer;
  stencilUsage?: ImageUsageFlags;
}

export class ImageStencilUsageCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageStencilUsageCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageStencilUsageCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(ImageStencilUsageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageStencilUsageCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageStencilUsageCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stencilUsage !== undefined) this.stencilUsage = data.stencilUsage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stencilUsage() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilUsage(value: ImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceMemoryOverallocationCreateInfoAMD {
  pNext?: AnyPointer;
  overallocationBehavior?: MemoryOverallocationBehaviorAMD;
}

export class DeviceMemoryOverallocationCreateInfoAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceMemoryOverallocationCreateInfoAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceMemoryOverallocationCreateInfoAMD) {
    if (!data) {
      this.#data = new Uint8Array(DeviceMemoryOverallocationCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceMemoryOverallocationCreateInfoAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceMemoryOverallocationCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.overallocationBehavior !== undefined) this.overallocationBehavior = data.overallocationBehavior;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get overallocationBehavior() {
    return this.#view.getUint32(16, LE);
  }
  
  set overallocationBehavior(value: MemoryOverallocationBehaviorAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMapFeaturesEXT {
  pNext?: AnyPointer;
  fragmentDensityMap?: Bool32;
  fragmentDensityMapDynamic?: Bool32;
  fragmentDensityMapNonSubsampledImages?: Bool32;
}

export class PhysicalDeviceFragmentDensityMapFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMapFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMapFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMapFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityMap !== undefined) this.fragmentDensityMap = data.fragmentDensityMap;
      if (data.fragmentDensityMapDynamic !== undefined) this.fragmentDensityMapDynamic = data.fragmentDensityMapDynamic;
      if (data.fragmentDensityMapNonSubsampledImages !== undefined) this.fragmentDensityMapNonSubsampledImages = data.fragmentDensityMapNonSubsampledImages;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityMap() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMap(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentDensityMapDynamic() {
    return this.#view.getUint32(20, LE);
  }
  
  set fragmentDensityMapDynamic(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get fragmentDensityMapNonSubsampledImages() {
    return this.#view.getUint32(24, LE);
  }
  
  set fragmentDensityMapNonSubsampledImages(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMap2FeaturesEXT {
  pNext?: AnyPointer;
  fragmentDensityMapDeferred?: Bool32;
}

export class PhysicalDeviceFragmentDensityMap2FeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMap2FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMap2FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMap2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMap2FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMap2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityMapDeferred !== undefined) this.fragmentDensityMapDeferred = data.fragmentDensityMapDeferred;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityMapDeferred() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMapDeferred(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
  pNext?: AnyPointer;
  fragmentDensityMapOffset?: Bool32;
}

export class PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityMapOffset !== undefined) this.fragmentDensityMapOffset = data.fragmentDensityMapOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityMapOffset() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityMapOffset(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMapPropertiesEXT {
  pNext?: AnyPointer;
  minFragmentDensityTexelSize?: Extent2D;
  maxFragmentDensityTexelSize?: Extent2D;
  fragmentDensityInvocations?: Bool32;
}

export class PhysicalDeviceFragmentDensityMapPropertiesEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMapPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMapPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMapPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minFragmentDensityTexelSize !== undefined) this.minFragmentDensityTexelSize = data.minFragmentDensityTexelSize;
      if (data.maxFragmentDensityTexelSize !== undefined) this.maxFragmentDensityTexelSize = data.maxFragmentDensityTexelSize;
      if (data.fragmentDensityInvocations !== undefined) this.fragmentDensityInvocations = data.fragmentDensityInvocations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minFragmentDensityTexelSize() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set minFragmentDensityTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxFragmentDensityTexelSize() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set maxFragmentDensityTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get fragmentDensityInvocations() {
    return this.#view.getUint32(32, LE);
  }
  
  set fragmentDensityInvocations(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMap2PropertiesEXT {
  pNext?: AnyPointer;
  subsampledLoads?: Bool32;
  subsampledCoarseReconstructionEarlyAccess?: Bool32;
  maxSubsampledArrayLayers?: number;
  maxDescriptorSetSubsampledSamplers?: number;
}

export class PhysicalDeviceFragmentDensityMap2PropertiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMap2PropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMap2PropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMap2PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMap2PropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMap2PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subsampledLoads !== undefined) this.subsampledLoads = data.subsampledLoads;
      if (data.subsampledCoarseReconstructionEarlyAccess !== undefined) this.subsampledCoarseReconstructionEarlyAccess = data.subsampledCoarseReconstructionEarlyAccess;
      if (data.maxSubsampledArrayLayers !== undefined) this.maxSubsampledArrayLayers = data.maxSubsampledArrayLayers;
      if (data.maxDescriptorSetSubsampledSamplers !== undefined) this.maxDescriptorSetSubsampledSamplers = data.maxDescriptorSetSubsampledSamplers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subsampledLoads() {
    return this.#view.getUint32(16, LE);
  }
  
  set subsampledLoads(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get subsampledCoarseReconstructionEarlyAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set subsampledCoarseReconstructionEarlyAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxSubsampledArrayLayers() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxSubsampledArrayLayers(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxDescriptorSetSubsampledSamplers() {
    return this.#view.getUint32(28, LE);
  }
  
  set maxDescriptorSetSubsampledSamplers(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
  pNext?: AnyPointer;
  fragmentDensityOffsetGranularity?: Extent2D;
}

export class PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityOffsetGranularity !== undefined) this.fragmentDensityOffsetGranularity = data.fragmentDensityOffsetGranularity;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityOffsetGranularity() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set fragmentDensityOffsetGranularity(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitRenderPassFragmentDensityMapCreateInfoEXT {
  pNext?: AnyPointer;
  fragmentDensityMapAttachment?: AttachmentReference;
}

export class RenderPassFragmentDensityMapCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassFragmentDensityMapCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassFragmentDensityMapCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassFragmentDensityMapCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassFragmentDensityMapCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassFragmentDensityMapCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityMapAttachment !== undefined) this.fragmentDensityMapAttachment = data.fragmentDensityMapAttachment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityMapAttachment() {
    return new AttachmentReference(this.#data.subarray(16, 16 + AttachmentReference.size));
  }
  
  set fragmentDensityMapAttachment(value: AttachmentReference) {
    if (value[BUFFER].byteLength < AttachmentReference.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSubpassFragmentDensityMapOffsetEndInfoQCOM {
  pNext?: AnyPointer;
  fragmentDensityOffsetCount?: number;
  pFragmentDensityOffsets?: AnyPointer;
}

export class SubpassFragmentDensityMapOffsetEndInfoQCOM implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassFragmentDensityMapOffsetEndInfoQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassFragmentDensityMapOffsetEndInfoQCOM) {
    if (!data) {
      this.#data = new Uint8Array(SubpassFragmentDensityMapOffsetEndInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassFragmentDensityMapOffsetEndInfoQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassFragmentDensityMapOffsetEndInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentDensityOffsetCount !== undefined) this.fragmentDensityOffsetCount = data.fragmentDensityOffsetCount;
      if (data.pFragmentDensityOffsets !== undefined) this.pFragmentDensityOffsets = data.pFragmentDensityOffsets;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentDensityOffsetCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentDensityOffsetCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pFragmentDensityOffsets() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFragmentDensityOffsets(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceScalarBlockLayoutFeatures {
  pNext?: AnyPointer;
  scalarBlockLayout?: Bool32;
}

export class PhysicalDeviceScalarBlockLayoutFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceScalarBlockLayoutFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceScalarBlockLayoutFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceScalarBlockLayoutFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceScalarBlockLayoutFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceScalarBlockLayoutFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.scalarBlockLayout !== undefined) this.scalarBlockLayout = data.scalarBlockLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get scalarBlockLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set scalarBlockLayout(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSurfaceProtectedCapabilitiesKHR {
  pNext?: AnyPointer;
  supportsProtected?: Bool32;
}

export class SurfaceProtectedCapabilitiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceProtectedCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceProtectedCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceProtectedCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceProtectedCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceProtectedCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supportsProtected !== undefined) this.supportsProtected = data.supportsProtected;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supportsProtected() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportsProtected(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceUniformBufferStandardLayoutFeatures {
  pNext?: AnyPointer;
  uniformBufferStandardLayout?: Bool32;
}

export class PhysicalDeviceUniformBufferStandardLayoutFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceUniformBufferStandardLayoutFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceUniformBufferStandardLayoutFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceUniformBufferStandardLayoutFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceUniformBufferStandardLayoutFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceUniformBufferStandardLayoutFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.uniformBufferStandardLayout !== undefined) this.uniformBufferStandardLayout = data.uniformBufferStandardLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get uniformBufferStandardLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set uniformBufferStandardLayout(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDepthClipEnableFeaturesEXT {
  pNext?: AnyPointer;
  depthClipEnable?: Bool32;
}

export class PhysicalDeviceDepthClipEnableFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDepthClipEnableFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDepthClipEnableFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDepthClipEnableFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDepthClipEnableFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDepthClipEnableFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.depthClipEnable !== undefined) this.depthClipEnable = data.depthClipEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get depthClipEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClipEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineRasterizationDepthClipStateCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: PipelineRasterizationDepthClipStateCreateFlagsEXT;
  depthClipEnable?: Bool32;
}

export class PipelineRasterizationDepthClipStateCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationDepthClipStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationDepthClipStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationDepthClipStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationDepthClipStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationDepthClipStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.depthClipEnable !== undefined) this.depthClipEnable = data.depthClipEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineRasterizationDepthClipStateCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get depthClipEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set depthClipEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMemoryBudgetPropertiesEXT {
  pNext?: AnyPointer;
  heapBudget?: DeviceSize[];
  heapUsage?: DeviceSize[];
}

export class PhysicalDeviceMemoryBudgetPropertiesEXT implements BaseStruct {
  static size = 272;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryBudgetPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryBudgetPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryBudgetPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryBudgetPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryBudgetPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.heapBudget !== undefined) this.heapBudget = data.heapBudget;
      if (data.heapUsage !== undefined) this.heapUsage = data.heapUsage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get heapBudget() {
    const result: DeviceSize[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getBigUint64(16 + i * 8, LE);
      })());
    }
    return result;
  }
  
  set heapBudget(value: DeviceSize[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setBigUint64(16 + i * 8, BigInt(value[i]), LE);
    }
  }
  
  get heapUsage() {
    const result: DeviceSize[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getBigUint64(144 + i * 8, LE);
      })());
    }
    return result;
  }
  
  set heapUsage(value: DeviceSize[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setBigUint64(144 + i * 8, BigInt(value[i]), LE);
    }
  }
}

export interface InitPhysicalDeviceMemoryPriorityFeaturesEXT {
  pNext?: AnyPointer;
  memoryPriority?: Bool32;
}

export class PhysicalDeviceMemoryPriorityFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMemoryPriorityFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMemoryPriorityFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMemoryPriorityFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMemoryPriorityFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMemoryPriorityFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryPriority !== undefined) this.memoryPriority = data.memoryPriority;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryPriority() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryPriority(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryPriorityAllocateInfoEXT {
  pNext?: AnyPointer;
  priority?: number;
}

export class MemoryPriorityAllocateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryPriorityAllocateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryPriorityAllocateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MemoryPriorityAllocateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryPriorityAllocateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryPriorityAllocateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.priority !== undefined) this.priority = data.priority;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get priority() {
    return this.#view.getFloat32(16, LE);
  }
  
  set priority(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
  pNext?: AnyPointer;
  pageableDeviceLocalMemory?: Bool32;
}

export class PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pageableDeviceLocalMemory !== undefined) this.pageableDeviceLocalMemory = data.pageableDeviceLocalMemory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pageableDeviceLocalMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set pageableDeviceLocalMemory(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceBufferDeviceAddressFeatures {
  pNext?: AnyPointer;
  bufferDeviceAddress?: Bool32;
  bufferDeviceAddressCaptureReplay?: Bool32;
  bufferDeviceAddressMultiDevice?: Bool32;
}

export class PhysicalDeviceBufferDeviceAddressFeatures implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceBufferDeviceAddressFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceBufferDeviceAddressFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceBufferDeviceAddressFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceBufferDeviceAddressFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceBufferDeviceAddressFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.bufferDeviceAddress !== undefined) this.bufferDeviceAddress = data.bufferDeviceAddress;
      if (data.bufferDeviceAddressCaptureReplay !== undefined) this.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
      if (data.bufferDeviceAddressMultiDevice !== undefined) this.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(16, LE);
  }
  
  set bufferDeviceAddress(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceBufferDeviceAddressFeaturesEXT {
  pNext?: AnyPointer;
  bufferDeviceAddress?: Bool32;
  bufferDeviceAddressCaptureReplay?: Bool32;
  bufferDeviceAddressMultiDevice?: Bool32;
}

export class PhysicalDeviceBufferDeviceAddressFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceBufferDeviceAddressFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceBufferDeviceAddressFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceBufferDeviceAddressFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceBufferDeviceAddressFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceBufferDeviceAddressFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.bufferDeviceAddress !== undefined) this.bufferDeviceAddress = data.bufferDeviceAddress;
      if (data.bufferDeviceAddressCaptureReplay !== undefined) this.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
      if (data.bufferDeviceAddressMultiDevice !== undefined) this.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(16, LE);
  }
  
  set bufferDeviceAddress(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitBufferDeviceAddressInfo {
  pNext?: AnyPointer;
  buffer?: Buffer;
}

export class BufferDeviceAddressInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferDeviceAddressInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferDeviceAddressInfo) {
    if (!data) {
      this.#data = new Uint8Array(BufferDeviceAddressInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferDeviceAddressInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferDeviceAddressInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBufferOpaqueCaptureAddressCreateInfo {
  pNext?: AnyPointer;
  opaqueCaptureAddress?: Deno.PointerValue;
}

export class BufferOpaqueCaptureAddressCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferOpaqueCaptureAddressCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferOpaqueCaptureAddressCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(BufferOpaqueCaptureAddressCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferOpaqueCaptureAddressCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferOpaqueCaptureAddressCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.opaqueCaptureAddress !== undefined) this.opaqueCaptureAddress = data.opaqueCaptureAddress;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get opaqueCaptureAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureAddress(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitBufferDeviceAddressCreateInfoEXT {
  pNext?: AnyPointer;
  deviceAddress?: DeviceAddress;
}

export class BufferDeviceAddressCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferDeviceAddressCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferDeviceAddressCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(BufferDeviceAddressCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferDeviceAddressCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferDeviceAddressCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceAddress !== undefined) this.deviceAddress = data.deviceAddress;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set deviceAddress(value: DeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceImageViewImageFormatInfoEXT {
  pNext?: AnyPointer;
  imageViewType?: ImageViewType;
}

export class PhysicalDeviceImageViewImageFormatInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageViewImageFormatInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageViewImageFormatInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageViewImageFormatInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageViewImageFormatInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageViewImageFormatInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageViewType !== undefined) this.imageViewType = data.imageViewType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageViewType() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageViewType(value: ImageViewType) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitFilterCubicImageViewImageFormatPropertiesEXT {
  pNext?: AnyPointer;
  filterCubic?: Bool32;
  filterCubicMinmax?: Bool32;
}

export class FilterCubicImageViewImageFormatPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFilterCubicImageViewImageFormatPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFilterCubicImageViewImageFormatPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(FilterCubicImageViewImageFormatPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FilterCubicImageViewImageFormatPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FilterCubicImageViewImageFormatPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.filterCubic !== undefined) this.filterCubic = data.filterCubic;
      if (data.filterCubicMinmax !== undefined) this.filterCubicMinmax = data.filterCubicMinmax;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get filterCubic() {
    return this.#view.getUint32(16, LE);
  }
  
  set filterCubic(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get filterCubicMinmax() {
    return this.#view.getUint32(20, LE);
  }
  
  set filterCubicMinmax(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImagelessFramebufferFeatures {
  pNext?: AnyPointer;
  imagelessFramebuffer?: Bool32;
}

export class PhysicalDeviceImagelessFramebufferFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImagelessFramebufferFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImagelessFramebufferFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImagelessFramebufferFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImagelessFramebufferFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImagelessFramebufferFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imagelessFramebuffer !== undefined) this.imagelessFramebuffer = data.imagelessFramebuffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imagelessFramebuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set imagelessFramebuffer(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitFramebufferAttachmentsCreateInfo {
  pNext?: AnyPointer;
  attachmentImageInfoCount?: number;
  pAttachmentImageInfos?: AnyPointer;
}

export class FramebufferAttachmentsCreateInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFramebufferAttachmentsCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFramebufferAttachmentsCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(FramebufferAttachmentsCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FramebufferAttachmentsCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FramebufferAttachmentsCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachmentImageInfoCount !== undefined) this.attachmentImageInfoCount = data.attachmentImageInfoCount;
      if (data.pAttachmentImageInfos !== undefined) this.pAttachmentImageInfos = data.pAttachmentImageInfos;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentImageInfoCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentImageInfoCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachmentImageInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachmentImageInfos(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitFramebufferAttachmentImageInfo {
  pNext?: AnyPointer;
  flags?: ImageCreateFlags;
  usage?: ImageUsageFlags;
  width?: number;
  height?: number;
  layerCount?: number;
  viewFormatCount?: number;
  pViewFormats?: AnyPointer;
}

export class FramebufferAttachmentImageInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFramebufferAttachmentImageInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFramebufferAttachmentImageInfo) {
    if (!data) {
      this.#data = new Uint8Array(FramebufferAttachmentImageInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FramebufferAttachmentImageInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FramebufferAttachmentImageInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.usage !== undefined) this.usage = data.usage;
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
      if (data.viewFormatCount !== undefined) this.viewFormatCount = data.viewFormatCount;
      if (data.pViewFormats !== undefined) this.pViewFormats = data.pViewFormats;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ImageCreateFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(20, LE);
  }
  
  set usage(value: ImageUsageFlags) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get width() {
    return this.#view.getUint32(24, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(28, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get viewFormatCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set viewFormatCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pViewFormats() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pViewFormats(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRenderPassAttachmentBeginInfo {
  pNext?: AnyPointer;
  attachmentCount?: number;
  pAttachments?: AnyPointer;
}

export class RenderPassAttachmentBeginInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassAttachmentBeginInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassAttachmentBeginInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassAttachmentBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassAttachmentBeginInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassAttachmentBeginInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pAttachments !== undefined) this.pAttachments = data.pAttachments;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pAttachments() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pAttachments(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceTextureCompressionASTCHDRFeatures {
  pNext?: AnyPointer;
  textureCompressionASTC_HDR?: Bool32;
}

export class PhysicalDeviceTextureCompressionASTCHDRFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTextureCompressionASTCHDRFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTextureCompressionASTCHDRFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTextureCompressionASTCHDRFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTextureCompressionASTCHDRFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTextureCompressionASTCHDRFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.textureCompressionASTC_HDR !== undefined) this.textureCompressionASTC_HDR = data.textureCompressionASTC_HDR;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get textureCompressionASTC_HDR() {
    return this.#view.getUint32(16, LE);
  }
  
  set textureCompressionASTC_HDR(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCooperativeMatrixFeaturesNV {
  pNext?: AnyPointer;
  cooperativeMatrix?: Bool32;
  cooperativeMatrixRobustBufferAccess?: Bool32;
}

export class PhysicalDeviceCooperativeMatrixFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCooperativeMatrixFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCooperativeMatrixFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCooperativeMatrixFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCooperativeMatrixFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCooperativeMatrixFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.cooperativeMatrix !== undefined) this.cooperativeMatrix = data.cooperativeMatrix;
      if (data.cooperativeMatrixRobustBufferAccess !== undefined) this.cooperativeMatrixRobustBufferAccess = data.cooperativeMatrixRobustBufferAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get cooperativeMatrix() {
    return this.#view.getUint32(16, LE);
  }
  
  set cooperativeMatrix(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get cooperativeMatrixRobustBufferAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set cooperativeMatrixRobustBufferAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCooperativeMatrixPropertiesNV {
  pNext?: AnyPointer;
  cooperativeMatrixSupportedStages?: ShaderStageFlags;
}

export class PhysicalDeviceCooperativeMatrixPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCooperativeMatrixPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCooperativeMatrixPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCooperativeMatrixPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCooperativeMatrixPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCooperativeMatrixPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.cooperativeMatrixSupportedStages !== undefined) this.cooperativeMatrixSupportedStages = data.cooperativeMatrixSupportedStages;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get cooperativeMatrixSupportedStages() {
    return this.#view.getUint32(16, LE);
  }
  
  set cooperativeMatrixSupportedStages(value: ShaderStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCooperativeMatrixPropertiesNV {
  pNext?: AnyPointer;
  MSize?: number;
  NSize?: number;
  KSize?: number;
  AType?: ComponentTypeNV;
  BType?: ComponentTypeNV;
  CType?: ComponentTypeNV;
  DType?: ComponentTypeNV;
  scope?: ScopeNV;
}

export class CooperativeMatrixPropertiesNV implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCooperativeMatrixPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCooperativeMatrixPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(CooperativeMatrixPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CooperativeMatrixPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CooperativeMatrixPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.MSize !== undefined) this.MSize = data.MSize;
      if (data.NSize !== undefined) this.NSize = data.NSize;
      if (data.KSize !== undefined) this.KSize = data.KSize;
      if (data.AType !== undefined) this.AType = data.AType;
      if (data.BType !== undefined) this.BType = data.BType;
      if (data.CType !== undefined) this.CType = data.CType;
      if (data.DType !== undefined) this.DType = data.DType;
      if (data.scope !== undefined) this.scope = data.scope;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get MSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set MSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get NSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set NSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get KSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set KSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get AType() {
    return this.#view.getUint32(28, LE);
  }
  
  set AType(value: ComponentTypeNV) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get BType() {
    return this.#view.getUint32(32, LE);
  }
  
  set BType(value: ComponentTypeNV) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get CType() {
    return this.#view.getUint32(36, LE);
  }
  
  set CType(value: ComponentTypeNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get DType() {
    return this.#view.getUint32(40, LE);
  }
  
  set DType(value: ComponentTypeNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get scope() {
    return this.#view.getUint32(44, LE);
  }
  
  set scope(value: ScopeNV) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitPhysicalDeviceYcbcrImageArraysFeaturesEXT {
  pNext?: AnyPointer;
  ycbcrImageArrays?: Bool32;
}

export class PhysicalDeviceYcbcrImageArraysFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceYcbcrImageArraysFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceYcbcrImageArraysFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceYcbcrImageArraysFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceYcbcrImageArraysFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceYcbcrImageArraysFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.ycbcrImageArrays !== undefined) this.ycbcrImageArrays = data.ycbcrImageArrays;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get ycbcrImageArrays() {
    return this.#view.getUint32(16, LE);
  }
  
  set ycbcrImageArrays(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImageViewHandleInfoNVX {
  pNext?: AnyPointer;
  imageView?: ImageView;
  descriptorType?: DescriptorType;
  sampler?: Sampler;
}

export class ImageViewHandleInfoNVX implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewHandleInfoNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewHandleInfoNVX) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewHandleInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewHandleInfoNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewHandleInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.descriptorType !== undefined) this.descriptorType = data.descriptorType;
      if (data.sampler !== undefined) this.sampler = data.sampler;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorType() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorType(value: DescriptorType) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sampler() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set sampler(value: Sampler) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageViewAddressPropertiesNVX {
  pNext?: AnyPointer;
  deviceAddress?: DeviceAddress;
  size?: DeviceSize;
}

export class ImageViewAddressPropertiesNVX implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewAddressPropertiesNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewAddressPropertiesNVX) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewAddressPropertiesNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewAddressPropertiesNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewAddressPropertiesNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceAddress !== undefined) this.deviceAddress = data.deviceAddress;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set deviceAddress(value: DeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPresentFrameTokenGGP {
  pNext?: AnyPointer;
  frameToken?: Deno.PointerValue;
}

export class PresentFrameTokenGGP implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPresentFrameTokenGGP);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPresentFrameTokenGGP) {
    if (!data) {
      this.#data = new Uint8Array(PresentFrameTokenGGP.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PresentFrameTokenGGP.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PresentFrameTokenGGP.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.frameToken !== undefined) this.frameToken = data.frameToken;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get frameToken() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set frameToken(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitPipelineCreationFeedback {
  flags?: PipelineCreationFeedbackFlags;
  duration?: Deno.PointerValue;
}

export class PipelineCreationFeedback implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCreationFeedback);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCreationFeedback) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCreationFeedback.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCreationFeedback.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCreationFeedback.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.duration !== undefined) this.duration = data.duration;
    }
  }
  
  get flags() {
    return this.#view.getUint32(0, LE);
  }
  
  set flags(value: PipelineCreationFeedbackFlags) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get duration() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set duration(value: Deno.PointerValue) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
}

export interface InitPipelineCreationFeedbackCreateInfo {
  pNext?: AnyPointer;
  pPipelineCreationFeedback?: AnyPointer;
  pipelineStageCreationFeedbackCount?: number;
  pPipelineStageCreationFeedbacks?: AnyPointer;
}

export class PipelineCreationFeedbackCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCreationFeedbackCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCreationFeedbackCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCreationFeedbackCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCreationFeedbackCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCreationFeedbackCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pPipelineCreationFeedback !== undefined) this.pPipelineCreationFeedback = data.pPipelineCreationFeedback;
      if (data.pipelineStageCreationFeedbackCount !== undefined) this.pipelineStageCreationFeedbackCount = data.pipelineStageCreationFeedbackCount;
      if (data.pPipelineStageCreationFeedbacks !== undefined) this.pPipelineStageCreationFeedbacks = data.pPipelineStageCreationFeedbacks;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pPipelineCreationFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pPipelineCreationFeedback(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineStageCreationFeedbackCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set pipelineStageCreationFeedbackCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pPipelineStageCreationFeedbacks() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pPipelineStageCreationFeedbacks(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSurfaceFullScreenExclusiveInfoEXT {
  pNext?: AnyPointer;
  fullScreenExclusive?: FullScreenExclusiveEXT;
}

export class SurfaceFullScreenExclusiveInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceFullScreenExclusiveInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceFullScreenExclusiveInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceFullScreenExclusiveInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceFullScreenExclusiveInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceFullScreenExclusiveInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fullScreenExclusive !== undefined) this.fullScreenExclusive = data.fullScreenExclusive;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fullScreenExclusive() {
    return this.#view.getUint32(16, LE);
  }
  
  set fullScreenExclusive(value: FullScreenExclusiveEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSurfaceFullScreenExclusiveWin32InfoEXT {
  pNext?: AnyPointer;
  hmonitor?: Deno.PointerValue;
}

export class SurfaceFullScreenExclusiveWin32InfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceFullScreenExclusiveWin32InfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceFullScreenExclusiveWin32InfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceFullScreenExclusiveWin32InfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceFullScreenExclusiveWin32InfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceFullScreenExclusiveWin32InfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.hmonitor !== undefined) this.hmonitor = data.hmonitor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get hmonitor() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set hmonitor(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSurfaceCapabilitiesFullScreenExclusiveEXT {
  pNext?: AnyPointer;
  fullScreenExclusiveSupported?: Bool32;
}

export class SurfaceCapabilitiesFullScreenExclusiveEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceCapabilitiesFullScreenExclusiveEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceCapabilitiesFullScreenExclusiveEXT) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceCapabilitiesFullScreenExclusiveEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceCapabilitiesFullScreenExclusiveEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceCapabilitiesFullScreenExclusiveEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fullScreenExclusiveSupported !== undefined) this.fullScreenExclusiveSupported = data.fullScreenExclusiveSupported;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fullScreenExclusiveSupported() {
    return this.#view.getUint32(16, LE);
  }
  
  set fullScreenExclusiveSupported(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePresentBarrierFeaturesNV {
  pNext?: AnyPointer;
  presentBarrier?: Bool32;
}

export class PhysicalDevicePresentBarrierFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePresentBarrierFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePresentBarrierFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePresentBarrierFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePresentBarrierFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePresentBarrierFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentBarrier !== undefined) this.presentBarrier = data.presentBarrier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentBarrier() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrier(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSurfaceCapabilitiesPresentBarrierNV {
  pNext?: AnyPointer;
  presentBarrierSupported?: Bool32;
}

export class SurfaceCapabilitiesPresentBarrierNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSurfaceCapabilitiesPresentBarrierNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSurfaceCapabilitiesPresentBarrierNV) {
    if (!data) {
      this.#data = new Uint8Array(SurfaceCapabilitiesPresentBarrierNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SurfaceCapabilitiesPresentBarrierNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SurfaceCapabilitiesPresentBarrierNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentBarrierSupported !== undefined) this.presentBarrierSupported = data.presentBarrierSupported;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentBarrierSupported() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrierSupported(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSwapchainPresentBarrierCreateInfoNV {
  pNext?: AnyPointer;
  presentBarrierEnable?: Bool32;
}

export class SwapchainPresentBarrierCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSwapchainPresentBarrierCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSwapchainPresentBarrierCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(SwapchainPresentBarrierCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SwapchainPresentBarrierCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SwapchainPresentBarrierCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.presentBarrierEnable !== undefined) this.presentBarrierEnable = data.presentBarrierEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get presentBarrierEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set presentBarrierEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePerformanceQueryFeaturesKHR {
  pNext?: AnyPointer;
  performanceCounterQueryPools?: Bool32;
  performanceCounterMultipleQueryPools?: Bool32;
}

export class PhysicalDevicePerformanceQueryFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePerformanceQueryFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePerformanceQueryFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePerformanceQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePerformanceQueryFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePerformanceQueryFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.performanceCounterQueryPools !== undefined) this.performanceCounterQueryPools = data.performanceCounterQueryPools;
      if (data.performanceCounterMultipleQueryPools !== undefined) this.performanceCounterMultipleQueryPools = data.performanceCounterMultipleQueryPools;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get performanceCounterQueryPools() {
    return this.#view.getUint32(16, LE);
  }
  
  set performanceCounterQueryPools(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get performanceCounterMultipleQueryPools() {
    return this.#view.getUint32(20, LE);
  }
  
  set performanceCounterMultipleQueryPools(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDevicePerformanceQueryPropertiesKHR {
  pNext?: AnyPointer;
  allowCommandBufferQueryCopies?: Bool32;
}

export class PhysicalDevicePerformanceQueryPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePerformanceQueryPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePerformanceQueryPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePerformanceQueryPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePerformanceQueryPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePerformanceQueryPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.allowCommandBufferQueryCopies !== undefined) this.allowCommandBufferQueryCopies = data.allowCommandBufferQueryCopies;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get allowCommandBufferQueryCopies() {
    return this.#view.getUint32(16, LE);
  }
  
  set allowCommandBufferQueryCopies(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPerformanceCounterKHR {
  pNext?: AnyPointer;
  unit?: PerformanceCounterUnitKHR;
  scope?: PerformanceCounterScopeKHR;
  storage?: PerformanceCounterStorageKHR;
  uuid?: number[];
}

export class PerformanceCounterKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceCounterKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceCounterKHR) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceCounterKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceCounterKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceCounterKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.unit !== undefined) this.unit = data.unit;
      if (data.scope !== undefined) this.scope = data.scope;
      if (data.storage !== undefined) this.storage = data.storage;
      if (data.uuid !== undefined) this.uuid = data.uuid;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get unit() {
    return this.#view.getUint32(16, LE);
  }
  
  set unit(value: PerformanceCounterUnitKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get scope() {
    return this.#view.getUint32(20, LE);
  }
  
  set scope(value: PerformanceCounterScopeKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storage() {
    return this.#view.getUint32(24, LE);
  }
  
  set storage(value: PerformanceCounterStorageKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uuid() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(28 + i * 1);
      })());
    }
    return result;
  }
  
  set uuid(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(28 + i * 1, Number(value[i]));
    }
  }
}

export interface InitPerformanceCounterDescriptionKHR {
  pNext?: AnyPointer;
  flags?: PerformanceCounterDescriptionFlagsKHR;
  name?: number[];
  category?: number[];
  description?: number[];
}

export class PerformanceCounterDescriptionKHR implements BaseStruct {
  static size = 792;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceCounterDescriptionKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceCounterDescriptionKHR) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceCounterDescriptionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceCounterDescriptionKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceCounterDescriptionKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.name !== undefined) this.name = data.name;
      if (data.category !== undefined) this.category = data.category;
      if (data.description !== undefined) this.description = data.description;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PerformanceCounterDescriptionFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get name() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set name(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get category() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(276 + i * 1);
      })());
    }
    return result;
  }
  
  set category(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(276 + i * 1, Number(value[i]));
    }
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(532 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(532 + i * 1, Number(value[i]));
    }
  }
}

export interface InitQueryPoolPerformanceCreateInfoKHR {
  pNext?: AnyPointer;
  queueFamilyIndex?: number;
  counterIndexCount?: number;
  pCounterIndices?: AnyPointer;
}

export class QueryPoolPerformanceCreateInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueryPoolPerformanceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueryPoolPerformanceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(QueryPoolPerformanceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueryPoolPerformanceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueryPoolPerformanceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.queueFamilyIndex !== undefined) this.queueFamilyIndex = data.queueFamilyIndex;
      if (data.counterIndexCount !== undefined) this.counterIndexCount = data.counterIndexCount;
      if (data.pCounterIndices !== undefined) this.pCounterIndices = data.pCounterIndices;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get counterIndexCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set counterIndexCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pCounterIndices() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCounterIndices(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAcquireProfilingLockInfoKHR {
  pNext?: AnyPointer;
  flags?: AcquireProfilingLockFlagsKHR;
  timeout?: Deno.PointerValue;
}

export class AcquireProfilingLockInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAcquireProfilingLockInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAcquireProfilingLockInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AcquireProfilingLockInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AcquireProfilingLockInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AcquireProfilingLockInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.timeout !== undefined) this.timeout = data.timeout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: AcquireProfilingLockFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get timeout() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set timeout(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPerformanceQuerySubmitInfoKHR {
  pNext?: AnyPointer;
  counterPassIndex?: number;
}

export class PerformanceQuerySubmitInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceQuerySubmitInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceQuerySubmitInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceQuerySubmitInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceQuerySubmitInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceQuerySubmitInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.counterPassIndex !== undefined) this.counterPassIndex = data.counterPassIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get counterPassIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set counterPassIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitHeadlessSurfaceCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: HeadlessSurfaceCreateFlagsEXT;
}

export class HeadlessSurfaceCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitHeadlessSurfaceCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitHeadlessSurfaceCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(HeadlessSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < HeadlessSurfaceCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(HeadlessSurfaceCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: HeadlessSurfaceCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCoverageReductionModeFeaturesNV {
  pNext?: AnyPointer;
  coverageReductionMode?: Bool32;
}

export class PhysicalDeviceCoverageReductionModeFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCoverageReductionModeFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCoverageReductionModeFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCoverageReductionModeFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCoverageReductionModeFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCoverageReductionModeFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.coverageReductionMode !== undefined) this.coverageReductionMode = data.coverageReductionMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set coverageReductionMode(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineCoverageReductionStateCreateInfoNV {
  pNext?: AnyPointer;
  flags?: PipelineCoverageReductionStateCreateFlagsNV;
  coverageReductionMode?: CoverageReductionModeNV;
}

export class PipelineCoverageReductionStateCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCoverageReductionStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCoverageReductionStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCoverageReductionStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCoverageReductionStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCoverageReductionStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.coverageReductionMode !== undefined) this.coverageReductionMode = data.coverageReductionMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: PipelineCoverageReductionStateCreateFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set coverageReductionMode(value: CoverageReductionModeNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitFramebufferMixedSamplesCombinationNV {
  pNext?: AnyPointer;
  coverageReductionMode?: CoverageReductionModeNV;
  rasterizationSamples?: SampleCountFlagBits;
  depthStencilSamples?: SampleCountFlags;
  colorSamples?: SampleCountFlags;
}

export class FramebufferMixedSamplesCombinationNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFramebufferMixedSamplesCombinationNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFramebufferMixedSamplesCombinationNV) {
    if (!data) {
      this.#data = new Uint8Array(FramebufferMixedSamplesCombinationNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FramebufferMixedSamplesCombinationNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FramebufferMixedSamplesCombinationNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.coverageReductionMode !== undefined) this.coverageReductionMode = data.coverageReductionMode;
      if (data.rasterizationSamples !== undefined) this.rasterizationSamples = data.rasterizationSamples;
      if (data.depthStencilSamples !== undefined) this.depthStencilSamples = data.depthStencilSamples;
      if (data.colorSamples !== undefined) this.colorSamples = data.colorSamples;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get coverageReductionMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set coverageReductionMode(value: CoverageReductionModeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get depthStencilSamples() {
    return this.#view.getUint32(24, LE);
  }
  
  set depthStencilSamples(value: SampleCountFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get colorSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set colorSamples(value: SampleCountFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
  pNext?: AnyPointer;
  shaderIntegerFunctions2?: Bool32;
}

export class PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderIntegerFunctions2 !== undefined) this.shaderIntegerFunctions2 = data.shaderIntegerFunctions2;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderIntegerFunctions2() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderIntegerFunctions2(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPerformanceValueINTEL {
  type?: PerformanceValueTypeINTEL;
  data?: PerformanceValueDataINTEL;
}

export class PerformanceValueINTEL implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceValueINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceValueINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceValueINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceValueINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceValueINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.type !== undefined) this.type = data.type;
      if (data.data !== undefined) this.data = data.data;
    }
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: PerformanceValueTypeINTEL) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u32","u64","f32","u32","buffer"]}`);
  }
  
  set data(value: PerformanceValueDataINTEL) {
    throw new Error(`Unknown type: {"union":["u32","u64","f32","u32","buffer"]}`);
  }
}

export interface InitInitializePerformanceApiInfoINTEL {
  pNext?: AnyPointer;
  pUserData?: AnyPointer;
}

export class InitializePerformanceApiInfoINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitInitializePerformanceApiInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitInitializePerformanceApiInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(InitializePerformanceApiInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < InitializePerformanceApiInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(InitializePerformanceApiInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pUserData !== undefined) this.pUserData = data.pUserData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pUserData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pUserData(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitQueryPoolPerformanceQueryCreateInfoINTEL {
  pNext?: AnyPointer;
  performanceCountersSampling?: QueryPoolSamplingModeINTEL;
}

export class QueryPoolPerformanceQueryCreateInfoINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueryPoolPerformanceQueryCreateInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueryPoolPerformanceQueryCreateInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(QueryPoolPerformanceQueryCreateInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueryPoolPerformanceQueryCreateInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueryPoolPerformanceQueryCreateInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.performanceCountersSampling !== undefined) this.performanceCountersSampling = data.performanceCountersSampling;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get performanceCountersSampling() {
    return this.#view.getUint32(16, LE);
  }
  
  set performanceCountersSampling(value: QueryPoolSamplingModeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPerformanceMarkerInfoINTEL {
  pNext?: AnyPointer;
  marker?: Deno.PointerValue;
}

export class PerformanceMarkerInfoINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceMarkerInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceMarkerInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceMarkerInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceMarkerInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceMarkerInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.marker !== undefined) this.marker = data.marker;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get marker() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set marker(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitPerformanceStreamMarkerInfoINTEL {
  pNext?: AnyPointer;
  marker?: number;
}

export class PerformanceStreamMarkerInfoINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceStreamMarkerInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceStreamMarkerInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceStreamMarkerInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceStreamMarkerInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceStreamMarkerInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.marker !== undefined) this.marker = data.marker;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get marker() {
    return this.#view.getUint32(16, LE);
  }
  
  set marker(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPerformanceOverrideInfoINTEL {
  pNext?: AnyPointer;
  type?: PerformanceOverrideTypeINTEL;
  enable?: Bool32;
  parameter?: Deno.PointerValue;
}

export class PerformanceOverrideInfoINTEL implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceOverrideInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceOverrideInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceOverrideInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceOverrideInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceOverrideInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.enable !== undefined) this.enable = data.enable;
      if (data.parameter !== undefined) this.parameter = data.parameter;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: PerformanceOverrideTypeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get enable() {
    return this.#view.getUint32(20, LE);
  }
  
  set enable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get parameter() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set parameter(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPerformanceConfigurationAcquireInfoINTEL {
  pNext?: AnyPointer;
  type?: PerformanceConfigurationTypeINTEL;
}

export class PerformanceConfigurationAcquireInfoINTEL implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPerformanceConfigurationAcquireInfoINTEL);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPerformanceConfigurationAcquireInfoINTEL) {
    if (!data) {
      this.#data = new Uint8Array(PerformanceConfigurationAcquireInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PerformanceConfigurationAcquireInfoINTEL.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PerformanceConfigurationAcquireInfoINTEL.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: PerformanceConfigurationTypeINTEL) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderClockFeaturesKHR {
  pNext?: AnyPointer;
  shaderSubgroupClock?: Bool32;
  shaderDeviceClock?: Bool32;
}

export class PhysicalDeviceShaderClockFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderClockFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderClockFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderClockFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderClockFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderClockFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderSubgroupClock !== undefined) this.shaderSubgroupClock = data.shaderSubgroupClock;
      if (data.shaderDeviceClock !== undefined) this.shaderDeviceClock = data.shaderDeviceClock;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderSubgroupClock() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupClock(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderDeviceClock() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderDeviceClock(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceIndexTypeUint8FeaturesEXT {
  pNext?: AnyPointer;
  indexTypeUint8?: Bool32;
}

export class PhysicalDeviceIndexTypeUint8FeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceIndexTypeUint8FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceIndexTypeUint8FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceIndexTypeUint8FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceIndexTypeUint8FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceIndexTypeUint8FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.indexTypeUint8 !== undefined) this.indexTypeUint8 = data.indexTypeUint8;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get indexTypeUint8() {
    return this.#view.getUint32(16, LE);
  }
  
  set indexTypeUint8(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderSMBuiltinsPropertiesNV {
  pNext?: AnyPointer;
  shaderSMCount?: number;
  shaderWarpsPerSM?: number;
}

export class PhysicalDeviceShaderSMBuiltinsPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderSMBuiltinsPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderSMBuiltinsPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderSMBuiltinsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderSMBuiltinsPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderSMBuiltinsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderSMCount !== undefined) this.shaderSMCount = data.shaderSMCount;
      if (data.shaderWarpsPerSM !== undefined) this.shaderWarpsPerSM = data.shaderWarpsPerSM;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderSMCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSMCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shaderWarpsPerSM() {
    return this.#view.getUint32(20, LE);
  }
  
  set shaderWarpsPerSM(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderSMBuiltinsFeaturesNV {
  pNext?: AnyPointer;
  shaderSMBuiltins?: Bool32;
}

export class PhysicalDeviceShaderSMBuiltinsFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderSMBuiltinsFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderSMBuiltinsFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderSMBuiltinsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderSMBuiltinsFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderSMBuiltinsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderSMBuiltins !== undefined) this.shaderSMBuiltins = data.shaderSMBuiltins;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderSMBuiltins() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSMBuiltins(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
  pNext?: AnyPointer;
  fragmentShaderSampleInterlock?: Bool32;
  fragmentShaderPixelInterlock?: Bool32;
  fragmentShaderShadingRateInterlock?: Bool32;
}

export class PhysicalDeviceFragmentShaderInterlockFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShaderInterlockFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderInterlockFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShaderInterlockFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderInterlockFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentShaderSampleInterlock !== undefined) this.fragmentShaderSampleInterlock = data.fragmentShaderSampleInterlock;
      if (data.fragmentShaderPixelInterlock !== undefined) this.fragmentShaderPixelInterlock = data.fragmentShaderPixelInterlock;
      if (data.fragmentShaderShadingRateInterlock !== undefined) this.fragmentShaderShadingRateInterlock = data.fragmentShaderShadingRateInterlock;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentShaderSampleInterlock() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShaderSampleInterlock(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentShaderPixelInterlock() {
    return this.#view.getUint32(20, LE);
  }
  
  set fragmentShaderPixelInterlock(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get fragmentShaderShadingRateInterlock() {
    return this.#view.getUint32(24, LE);
  }
  
  set fragmentShaderShadingRateInterlock(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
  pNext?: AnyPointer;
  separateDepthStencilLayouts?: Bool32;
}

export class PhysicalDeviceSeparateDepthStencilLayoutsFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSeparateDepthStencilLayoutsFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSeparateDepthStencilLayoutsFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSeparateDepthStencilLayoutsFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.separateDepthStencilLayouts !== undefined) this.separateDepthStencilLayouts = data.separateDepthStencilLayouts;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get separateDepthStencilLayouts() {
    return this.#view.getUint32(16, LE);
  }
  
  set separateDepthStencilLayouts(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitAttachmentReferenceStencilLayout {
  pNext?: AnyPointer;
  stencilLayout?: ImageLayout;
}

export class AttachmentReferenceStencilLayout implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentReferenceStencilLayout);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentReferenceStencilLayout) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentReferenceStencilLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentReferenceStencilLayout.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentReferenceStencilLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stencilLayout !== undefined) this.stencilLayout = data.stencilLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stencilLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilLayout(value: ImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
  pNext?: AnyPointer;
  primitiveTopologyListRestart?: Bool32;
  primitiveTopologyPatchListRestart?: Bool32;
}

export class PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.primitiveTopologyListRestart !== undefined) this.primitiveTopologyListRestart = data.primitiveTopologyListRestart;
      if (data.primitiveTopologyPatchListRestart !== undefined) this.primitiveTopologyPatchListRestart = data.primitiveTopologyPatchListRestart;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get primitiveTopologyListRestart() {
    return this.#view.getUint32(16, LE);
  }
  
  set primitiveTopologyListRestart(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitiveTopologyPatchListRestart() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitiveTopologyPatchListRestart(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitAttachmentDescriptionStencilLayout {
  pNext?: AnyPointer;
  stencilInitialLayout?: ImageLayout;
  stencilFinalLayout?: ImageLayout;
}

export class AttachmentDescriptionStencilLayout implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentDescriptionStencilLayout);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentDescriptionStencilLayout) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentDescriptionStencilLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentDescriptionStencilLayout.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentDescriptionStencilLayout.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stencilInitialLayout !== undefined) this.stencilInitialLayout = data.stencilInitialLayout;
      if (data.stencilFinalLayout !== undefined) this.stencilFinalLayout = data.stencilFinalLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stencilInitialLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set stencilInitialLayout(value: ImageLayout) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stencilFinalLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set stencilFinalLayout(value: ImageLayout) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
  pNext?: AnyPointer;
  pipelineExecutableInfo?: Bool32;
}

export class PhysicalDevicePipelineExecutablePropertiesFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelineExecutablePropertiesFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelineExecutablePropertiesFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelineExecutablePropertiesFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineExecutableInfo !== undefined) this.pipelineExecutableInfo = data.pipelineExecutableInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineExecutableInfo() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineExecutableInfo(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineInfoKHR {
  pNext?: AnyPointer;
  pipeline?: Pipeline;
}

export class PipelineInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipeline !== undefined) this.pipeline = data.pipeline;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pipeline(value: Pipeline) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelineExecutablePropertiesKHR {
  pNext?: AnyPointer;
  stages?: ShaderStageFlags;
  name?: number[];
  description?: number[];
  subgroupSize?: number;
}

export class PipelineExecutablePropertiesKHR implements BaseStruct {
  static size = 536;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineExecutablePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineExecutablePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineExecutablePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineExecutablePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineExecutablePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stages !== undefined) this.stages = data.stages;
      if (data.name !== undefined) this.name = data.name;
      if (data.description !== undefined) this.description = data.description;
      if (data.subgroupSize !== undefined) this.subgroupSize = data.subgroupSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stages() {
    return this.#view.getUint32(16, LE);
  }
  
  set stages(value: ShaderStageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get name() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set name(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(276 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(276 + i * 1, Number(value[i]));
    }
  }
  
  get subgroupSize() {
    return this.#view.getUint32(532, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(532, Number(value), LE);
  }
}

export interface InitPipelineExecutableInfoKHR {
  pNext?: AnyPointer;
  pipeline?: Pipeline;
  executableIndex?: number;
}

export class PipelineExecutableInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineExecutableInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineExecutableInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineExecutableInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineExecutableInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineExecutableInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipeline !== undefined) this.pipeline = data.pipeline;
      if (data.executableIndex !== undefined) this.executableIndex = data.executableIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipeline() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pipeline(value: Pipeline) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get executableIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set executableIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPipelineExecutableStatisticKHR {
  pNext?: AnyPointer;
  name?: number[];
  description?: number[];
  format?: PipelineExecutableStatisticFormatKHR;
  value?: PipelineExecutableStatisticValueKHR;
}

export class PipelineExecutableStatisticKHR implements BaseStruct {
  static size = 544;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineExecutableStatisticKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineExecutableStatisticKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineExecutableStatisticKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineExecutableStatisticKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineExecutableStatisticKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.name !== undefined) this.name = data.name;
      if (data.description !== undefined) this.description = data.description;
      if (data.format !== undefined) this.format = data.format;
      if (data.value !== undefined) this.value = data.value;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set name(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(272 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(272 + i * 1, Number(value[i]));
    }
  }
  
  get format() {
    return this.#view.getUint32(528, LE);
  }
  
  set format(value: PipelineExecutableStatisticFormatKHR) {
    this.#view.setUint32(528, Number(value), LE);
  }
  
  get value() {
    throw new Error(`Unknown type: {"union":["u32","i64","u64","f64"]}`);
  }
  
  set value(value: PipelineExecutableStatisticValueKHR) {
    throw new Error(`Unknown type: {"union":["u32","i64","u64","f64"]}`);
  }
}

export interface InitPipelineExecutableInternalRepresentationKHR {
  pNext?: AnyPointer;
  name?: number[];
  description?: number[];
  isText?: Bool32;
  dataSize?: Deno.PointerValue;
  pData?: AnyPointer;
}

export class PipelineExecutableInternalRepresentationKHR implements BaseStruct {
  static size = 552;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineExecutableInternalRepresentationKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineExecutableInternalRepresentationKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineExecutableInternalRepresentationKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineExecutableInternalRepresentationKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineExecutableInternalRepresentationKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.name !== undefined) this.name = data.name;
      if (data.description !== undefined) this.description = data.description;
      if (data.isText !== undefined) this.isText = data.isText;
      if (data.dataSize !== undefined) this.dataSize = data.dataSize;
      if (data.pData !== undefined) this.pData = data.pData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set name(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(272 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(272 + i * 1, Number(value[i]));
    }
  }
  
  get isText() {
    return this.#view.getUint32(528, LE);
  }
  
  set isText(value: Bool32) {
    this.#view.setUint32(528, Number(value), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(536, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(536, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(544, LE);
  }
  
  set pData(value: AnyPointer) {
    this.#view.setBigUint64(544, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
  pNext?: AnyPointer;
  shaderDemoteToHelperInvocation?: Bool32;
}

export class PhysicalDeviceShaderDemoteToHelperInvocationFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderDemoteToHelperInvocationFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderDemoteToHelperInvocationFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderDemoteToHelperInvocationFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderDemoteToHelperInvocationFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderDemoteToHelperInvocationFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderDemoteToHelperInvocation !== undefined) this.shaderDemoteToHelperInvocation = data.shaderDemoteToHelperInvocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderDemoteToHelperInvocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderDemoteToHelperInvocation(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
  pNext?: AnyPointer;
  texelBufferAlignment?: Bool32;
}

export class PhysicalDeviceTexelBufferAlignmentFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTexelBufferAlignmentFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTexelBufferAlignmentFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTexelBufferAlignmentFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTexelBufferAlignmentFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.texelBufferAlignment !== undefined) this.texelBufferAlignment = data.texelBufferAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get texelBufferAlignment() {
    return this.#view.getUint32(16, LE);
  }
  
  set texelBufferAlignment(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceTexelBufferAlignmentProperties {
  pNext?: AnyPointer;
  storageTexelBufferOffsetAlignmentBytes?: DeviceSize;
  storageTexelBufferOffsetSingleTexelAlignment?: Bool32;
  uniformTexelBufferOffsetAlignmentBytes?: DeviceSize;
  uniformTexelBufferOffsetSingleTexelAlignment?: Bool32;
}

export class PhysicalDeviceTexelBufferAlignmentProperties implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTexelBufferAlignmentProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTexelBufferAlignmentProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTexelBufferAlignmentProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTexelBufferAlignmentProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTexelBufferAlignmentProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.storageTexelBufferOffsetAlignmentBytes !== undefined) this.storageTexelBufferOffsetAlignmentBytes = data.storageTexelBufferOffsetAlignmentBytes;
      if (data.storageTexelBufferOffsetSingleTexelAlignment !== undefined) this.storageTexelBufferOffsetSingleTexelAlignment = data.storageTexelBufferOffsetSingleTexelAlignment;
      if (data.uniformTexelBufferOffsetAlignmentBytes !== undefined) this.uniformTexelBufferOffsetAlignmentBytes = data.uniformTexelBufferOffsetAlignmentBytes;
      if (data.uniformTexelBufferOffsetSingleTexelAlignment !== undefined) this.uniformTexelBufferOffsetSingleTexelAlignment = data.uniformTexelBufferOffsetSingleTexelAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get storageTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set storageTexelBufferOffsetAlignmentBytes(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get storageTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(24, LE);
  }
  
  set storageTexelBufferOffsetSingleTexelAlignment(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uniformTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set uniformTexelBufferOffsetAlignmentBytes(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get uniformTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(40, LE);
  }
  
  set uniformTexelBufferOffsetSingleTexelAlignment(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSubgroupSizeControlFeatures {
  pNext?: AnyPointer;
  subgroupSizeControl?: Bool32;
  computeFullSubgroups?: Bool32;
}

export class PhysicalDeviceSubgroupSizeControlFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubgroupSizeControlFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubgroupSizeControlFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupSizeControlFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubgroupSizeControlFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupSizeControlFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subgroupSizeControl !== undefined) this.subgroupSizeControl = data.subgroupSizeControl;
      if (data.computeFullSubgroups !== undefined) this.computeFullSubgroups = data.computeFullSubgroups;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subgroupSizeControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set subgroupSizeControl(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get computeFullSubgroups() {
    return this.#view.getUint32(20, LE);
  }
  
  set computeFullSubgroups(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSubgroupSizeControlProperties {
  pNext?: AnyPointer;
  minSubgroupSize?: number;
  maxSubgroupSize?: number;
  maxComputeWorkgroupSubgroups?: number;
  requiredSubgroupSizeStages?: ShaderStageFlags;
}

export class PhysicalDeviceSubgroupSizeControlProperties implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubgroupSizeControlProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubgroupSizeControlProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupSizeControlProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubgroupSizeControlProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubgroupSizeControlProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minSubgroupSize !== undefined) this.minSubgroupSize = data.minSubgroupSize;
      if (data.maxSubgroupSize !== undefined) this.maxSubgroupSize = data.maxSubgroupSize;
      if (data.maxComputeWorkgroupSubgroups !== undefined) this.maxComputeWorkgroupSubgroups = data.maxComputeWorkgroupSubgroups;
      if (data.requiredSubgroupSizeStages !== undefined) this.requiredSubgroupSizeStages = data.requiredSubgroupSizeStages;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set minSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSubgroupSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSubgroupSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxComputeWorkgroupSubgroups() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxComputeWorkgroupSubgroups(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get requiredSubgroupSizeStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set requiredSubgroupSizeStages(value: ShaderStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPipelineShaderStageRequiredSubgroupSizeCreateInfo {
  pNext?: AnyPointer;
  requiredSubgroupSize?: number;
}

export class PipelineShaderStageRequiredSubgroupSizeCreateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineShaderStageRequiredSubgroupSizeCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineShaderStageRequiredSubgroupSizeCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineShaderStageRequiredSubgroupSizeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineShaderStageRequiredSubgroupSizeCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineShaderStageRequiredSubgroupSizeCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.requiredSubgroupSize !== undefined) this.requiredSubgroupSize = data.requiredSubgroupSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get requiredSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set requiredSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSubpassShadingPipelineCreateInfoHUAWEI {
  pNext?: AnyPointer;
  renderPass?: RenderPass;
  subpass?: number;
}

export class SubpassShadingPipelineCreateInfoHUAWEI implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassShadingPipelineCreateInfoHUAWEI);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassShadingPipelineCreateInfoHUAWEI) {
    if (!data) {
      this.#data = new Uint8Array(SubpassShadingPipelineCreateInfoHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassShadingPipelineCreateInfoHUAWEI.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassShadingPipelineCreateInfoHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.renderPass !== undefined) this.renderPass = data.renderPass;
      if (data.subpass !== undefined) this.subpass = data.subpass;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get renderPass() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set renderPass(value: RenderPass) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get subpass() {
    return this.#view.getUint32(24, LE);
  }
  
  set subpass(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSubpassShadingPropertiesHUAWEI {
  pNext?: AnyPointer;
  maxSubpassShadingWorkgroupSizeAspectRatio?: number;
}

export class PhysicalDeviceSubpassShadingPropertiesHUAWEI implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubpassShadingPropertiesHUAWEI);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubpassShadingPropertiesHUAWEI) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubpassShadingPropertiesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubpassShadingPropertiesHUAWEI.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubpassShadingPropertiesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxSubpassShadingWorkgroupSizeAspectRatio !== undefined) this.maxSubpassShadingWorkgroupSizeAspectRatio = data.maxSubpassShadingWorkgroupSizeAspectRatio;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxSubpassShadingWorkgroupSizeAspectRatio() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxSubpassShadingWorkgroupSizeAspectRatio(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMemoryOpaqueCaptureAddressAllocateInfo {
  pNext?: AnyPointer;
  opaqueCaptureAddress?: Deno.PointerValue;
}

export class MemoryOpaqueCaptureAddressAllocateInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryOpaqueCaptureAddressAllocateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryOpaqueCaptureAddressAllocateInfo) {
    if (!data) {
      this.#data = new Uint8Array(MemoryOpaqueCaptureAddressAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryOpaqueCaptureAddressAllocateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryOpaqueCaptureAddressAllocateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.opaqueCaptureAddress !== undefined) this.opaqueCaptureAddress = data.opaqueCaptureAddress;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get opaqueCaptureAddress() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureAddress(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitDeviceMemoryOpaqueCaptureAddressInfo {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
}

export class DeviceMemoryOpaqueCaptureAddressInfo implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceMemoryOpaqueCaptureAddressInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceMemoryOpaqueCaptureAddressInfo) {
    if (!data) {
      this.#data = new Uint8Array(DeviceMemoryOpaqueCaptureAddressInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceMemoryOpaqueCaptureAddressInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceMemoryOpaqueCaptureAddressInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceLineRasterizationFeaturesEXT {
  pNext?: AnyPointer;
  rectangularLines?: Bool32;
  bresenhamLines?: Bool32;
  smoothLines?: Bool32;
  stippledRectangularLines?: Bool32;
  stippledBresenhamLines?: Bool32;
  stippledSmoothLines?: Bool32;
}

export class PhysicalDeviceLineRasterizationFeaturesEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceLineRasterizationFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceLineRasterizationFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceLineRasterizationFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceLineRasterizationFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceLineRasterizationFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rectangularLines !== undefined) this.rectangularLines = data.rectangularLines;
      if (data.bresenhamLines !== undefined) this.bresenhamLines = data.bresenhamLines;
      if (data.smoothLines !== undefined) this.smoothLines = data.smoothLines;
      if (data.stippledRectangularLines !== undefined) this.stippledRectangularLines = data.stippledRectangularLines;
      if (data.stippledBresenhamLines !== undefined) this.stippledBresenhamLines = data.stippledBresenhamLines;
      if (data.stippledSmoothLines !== undefined) this.stippledSmoothLines = data.stippledSmoothLines;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rectangularLines() {
    return this.#view.getUint32(16, LE);
  }
  
  set rectangularLines(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bresenhamLines() {
    return this.#view.getUint32(20, LE);
  }
  
  set bresenhamLines(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get smoothLines() {
    return this.#view.getUint32(24, LE);
  }
  
  set smoothLines(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get stippledRectangularLines() {
    return this.#view.getUint32(28, LE);
  }
  
  set stippledRectangularLines(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get stippledBresenhamLines() {
    return this.#view.getUint32(32, LE);
  }
  
  set stippledBresenhamLines(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stippledSmoothLines() {
    return this.#view.getUint32(36, LE);
  }
  
  set stippledSmoothLines(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export interface InitPhysicalDeviceLineRasterizationPropertiesEXT {
  pNext?: AnyPointer;
  lineSubPixelPrecisionBits?: number;
}

export class PhysicalDeviceLineRasterizationPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceLineRasterizationPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceLineRasterizationPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceLineRasterizationPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceLineRasterizationPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceLineRasterizationPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.lineSubPixelPrecisionBits !== undefined) this.lineSubPixelPrecisionBits = data.lineSubPixelPrecisionBits;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get lineSubPixelPrecisionBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set lineSubPixelPrecisionBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineRasterizationLineStateCreateInfoEXT {
  pNext?: AnyPointer;
  lineRasterizationMode?: LineRasterizationModeEXT;
  stippledLineEnable?: Bool32;
  lineStippleFactor?: number;
  lineStipplePattern?: number;
}

export class PipelineRasterizationLineStateCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationLineStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationLineStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationLineStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationLineStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationLineStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.lineRasterizationMode !== undefined) this.lineRasterizationMode = data.lineRasterizationMode;
      if (data.stippledLineEnable !== undefined) this.stippledLineEnable = data.stippledLineEnable;
      if (data.lineStippleFactor !== undefined) this.lineStippleFactor = data.lineStippleFactor;
      if (data.lineStipplePattern !== undefined) this.lineStipplePattern = data.lineStipplePattern;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get lineRasterizationMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set lineRasterizationMode(value: LineRasterizationModeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stippledLineEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set stippledLineEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get lineStippleFactor() {
    return this.#view.getUint32(24, LE);
  }
  
  set lineStippleFactor(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get lineStipplePattern() {
    return this.#view.getUint16(28, LE);
  }
  
  set lineStipplePattern(value: number) {
    this.#view.setUint16(28, Number(value), LE);
  }
}

export interface InitPhysicalDevicePipelineCreationCacheControlFeatures {
  pNext?: AnyPointer;
  pipelineCreationCacheControl?: Bool32;
}

export class PhysicalDevicePipelineCreationCacheControlFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelineCreationCacheControlFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelineCreationCacheControlFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelineCreationCacheControlFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelineCreationCacheControlFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelineCreationCacheControlFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineCreationCacheControl !== undefined) this.pipelineCreationCacheControl = data.pipelineCreationCacheControl;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineCreationCacheControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineCreationCacheControl(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan11Features {
  pNext?: AnyPointer;
  storageBuffer16BitAccess?: Bool32;
  uniformAndStorageBuffer16BitAccess?: Bool32;
  storagePushConstant16?: Bool32;
  storageInputOutput16?: Bool32;
  multiview?: Bool32;
  multiviewGeometryShader?: Bool32;
  multiviewTessellationShader?: Bool32;
  variablePointersStorageBuffer?: Bool32;
  variablePointers?: Bool32;
  protectedMemory?: Bool32;
  samplerYcbcrConversion?: Bool32;
  shaderDrawParameters?: Bool32;
}

export class PhysicalDeviceVulkan11Features implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan11Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan11Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan11Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan11Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan11Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.storageBuffer16BitAccess !== undefined) this.storageBuffer16BitAccess = data.storageBuffer16BitAccess;
      if (data.uniformAndStorageBuffer16BitAccess !== undefined) this.uniformAndStorageBuffer16BitAccess = data.uniformAndStorageBuffer16BitAccess;
      if (data.storagePushConstant16 !== undefined) this.storagePushConstant16 = data.storagePushConstant16;
      if (data.storageInputOutput16 !== undefined) this.storageInputOutput16 = data.storageInputOutput16;
      if (data.multiview !== undefined) this.multiview = data.multiview;
      if (data.multiviewGeometryShader !== undefined) this.multiviewGeometryShader = data.multiviewGeometryShader;
      if (data.multiviewTessellationShader !== undefined) this.multiviewTessellationShader = data.multiviewTessellationShader;
      if (data.variablePointersStorageBuffer !== undefined) this.variablePointersStorageBuffer = data.variablePointersStorageBuffer;
      if (data.variablePointers !== undefined) this.variablePointers = data.variablePointers;
      if (data.protectedMemory !== undefined) this.protectedMemory = data.protectedMemory;
      if (data.samplerYcbcrConversion !== undefined) this.samplerYcbcrConversion = data.samplerYcbcrConversion;
      if (data.shaderDrawParameters !== undefined) this.shaderDrawParameters = data.shaderDrawParameters;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get storageBuffer16BitAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffer16BitAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformAndStorageBuffer16BitAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformAndStorageBuffer16BitAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storagePushConstant16() {
    return this.#view.getUint32(24, LE);
  }
  
  set storagePushConstant16(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get storageInputOutput16() {
    return this.#view.getUint32(28, LE);
  }
  
  set storageInputOutput16(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get multiview() {
    return this.#view.getUint32(32, LE);
  }
  
  set multiview(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multiviewGeometryShader() {
    return this.#view.getUint32(36, LE);
  }
  
  set multiviewGeometryShader(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get multiviewTessellationShader() {
    return this.#view.getUint32(40, LE);
  }
  
  set multiviewTessellationShader(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get variablePointersStorageBuffer() {
    return this.#view.getUint32(44, LE);
  }
  
  set variablePointersStorageBuffer(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get variablePointers() {
    return this.#view.getUint32(48, LE);
  }
  
  set variablePointers(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get protectedMemory() {
    return this.#view.getUint32(52, LE);
  }
  
  set protectedMemory(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get samplerYcbcrConversion() {
    return this.#view.getUint32(56, LE);
  }
  
  set samplerYcbcrConversion(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderDrawParameters() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderDrawParameters(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan11Properties {
  pNext?: AnyPointer;
  deviceUUID?: number[];
  driverUUID?: number[];
  deviceLUID?: number[];
  deviceNodeMask?: number;
  deviceLUIDValid?: Bool32;
  subgroupSize?: number;
  subgroupSupportedStages?: ShaderStageFlags;
  subgroupSupportedOperations?: SubgroupFeatureFlags;
  subgroupQuadOperationsInAllStages?: Bool32;
  pointClippingBehavior?: PointClippingBehavior;
  maxMultiviewViewCount?: number;
  maxMultiviewInstanceIndex?: number;
  protectedNoFault?: Bool32;
  maxPerSetDescriptors?: number;
  maxMemoryAllocationSize?: DeviceSize;
}

export class PhysicalDeviceVulkan11Properties implements BaseStruct {
  static size = 112;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan11Properties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan11Properties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan11Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan11Properties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan11Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceUUID !== undefined) this.deviceUUID = data.deviceUUID;
      if (data.driverUUID !== undefined) this.driverUUID = data.driverUUID;
      if (data.deviceLUID !== undefined) this.deviceLUID = data.deviceLUID;
      if (data.deviceNodeMask !== undefined) this.deviceNodeMask = data.deviceNodeMask;
      if (data.deviceLUIDValid !== undefined) this.deviceLUIDValid = data.deviceLUIDValid;
      if (data.subgroupSize !== undefined) this.subgroupSize = data.subgroupSize;
      if (data.subgroupSupportedStages !== undefined) this.subgroupSupportedStages = data.subgroupSupportedStages;
      if (data.subgroupSupportedOperations !== undefined) this.subgroupSupportedOperations = data.subgroupSupportedOperations;
      if (data.subgroupQuadOperationsInAllStages !== undefined) this.subgroupQuadOperationsInAllStages = data.subgroupQuadOperationsInAllStages;
      if (data.pointClippingBehavior !== undefined) this.pointClippingBehavior = data.pointClippingBehavior;
      if (data.maxMultiviewViewCount !== undefined) this.maxMultiviewViewCount = data.maxMultiviewViewCount;
      if (data.maxMultiviewInstanceIndex !== undefined) this.maxMultiviewInstanceIndex = data.maxMultiviewInstanceIndex;
      if (data.protectedNoFault !== undefined) this.protectedNoFault = data.protectedNoFault;
      if (data.maxPerSetDescriptors !== undefined) this.maxPerSetDescriptors = data.maxPerSetDescriptors;
      if (data.maxMemoryAllocationSize !== undefined) this.maxMemoryAllocationSize = data.maxMemoryAllocationSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set deviceUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get driverUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(32 + i * 1);
      })());
    }
    return result;
  }
  
  set driverUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(32 + i * 1, Number(value[i]));
    }
  }
  
  get deviceLUID() {
    const result: number[] = [];
    for (let i = 0; i < 8; i++) {
      result.push((() => {
        return this.#view.getUint8(48 + i * 1);
      })());
    }
    return result;
  }
  
  set deviceLUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(48 + i * 1, Number(value[i]));
    }
  }
  
  get deviceNodeMask() {
    return this.#view.getUint32(56, LE);
  }
  
  set deviceNodeMask(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get deviceLUIDValid() {
    return this.#view.getUint32(60, LE);
  }
  
  set deviceLUIDValid(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get subgroupSize() {
    return this.#view.getUint32(64, LE);
  }
  
  set subgroupSize(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get subgroupSupportedStages() {
    return this.#view.getUint32(68, LE);
  }
  
  set subgroupSupportedStages(value: ShaderStageFlags) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get subgroupSupportedOperations() {
    return this.#view.getUint32(72, LE);
  }
  
  set subgroupSupportedOperations(value: SubgroupFeatureFlags) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get subgroupQuadOperationsInAllStages() {
    return this.#view.getUint32(76, LE);
  }
  
  set subgroupQuadOperationsInAllStages(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get pointClippingBehavior() {
    return this.#view.getUint32(80, LE);
  }
  
  set pointClippingBehavior(value: PointClippingBehavior) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get maxMultiviewViewCount() {
    return this.#view.getUint32(84, LE);
  }
  
  set maxMultiviewViewCount(value: number) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get maxMultiviewInstanceIndex() {
    return this.#view.getUint32(88, LE);
  }
  
  set maxMultiviewInstanceIndex(value: number) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get protectedNoFault() {
    return this.#view.getUint32(92, LE);
  }
  
  set protectedNoFault(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get maxPerSetDescriptors() {
    return this.#view.getUint32(96, LE);
  }
  
  set maxPerSetDescriptors(value: number) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get maxMemoryAllocationSize() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set maxMemoryAllocationSize(value: DeviceSize) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan12Features {
  pNext?: AnyPointer;
  samplerMirrorClampToEdge?: Bool32;
  drawIndirectCount?: Bool32;
  storageBuffer8BitAccess?: Bool32;
  uniformAndStorageBuffer8BitAccess?: Bool32;
  storagePushConstant8?: Bool32;
  shaderBufferInt64Atomics?: Bool32;
  shaderSharedInt64Atomics?: Bool32;
  shaderFloat16?: Bool32;
  shaderInt8?: Bool32;
  descriptorIndexing?: Bool32;
  shaderInputAttachmentArrayDynamicIndexing?: Bool32;
  shaderUniformTexelBufferArrayDynamicIndexing?: Bool32;
  shaderStorageTexelBufferArrayDynamicIndexing?: Bool32;
  shaderUniformBufferArrayNonUniformIndexing?: Bool32;
  shaderSampledImageArrayNonUniformIndexing?: Bool32;
  shaderStorageBufferArrayNonUniformIndexing?: Bool32;
  shaderStorageImageArrayNonUniformIndexing?: Bool32;
  shaderInputAttachmentArrayNonUniformIndexing?: Bool32;
  shaderUniformTexelBufferArrayNonUniformIndexing?: Bool32;
  shaderStorageTexelBufferArrayNonUniformIndexing?: Bool32;
  descriptorBindingUniformBufferUpdateAfterBind?: Bool32;
  descriptorBindingSampledImageUpdateAfterBind?: Bool32;
  descriptorBindingStorageImageUpdateAfterBind?: Bool32;
  descriptorBindingStorageBufferUpdateAfterBind?: Bool32;
  descriptorBindingUniformTexelBufferUpdateAfterBind?: Bool32;
  descriptorBindingStorageTexelBufferUpdateAfterBind?: Bool32;
  descriptorBindingUpdateUnusedWhilePending?: Bool32;
  descriptorBindingPartiallyBound?: Bool32;
  descriptorBindingVariableDescriptorCount?: Bool32;
  runtimeDescriptorArray?: Bool32;
  samplerFilterMinmax?: Bool32;
  scalarBlockLayout?: Bool32;
  imagelessFramebuffer?: Bool32;
  uniformBufferStandardLayout?: Bool32;
  shaderSubgroupExtendedTypes?: Bool32;
  separateDepthStencilLayouts?: Bool32;
  hostQueryReset?: Bool32;
  timelineSemaphore?: Bool32;
  bufferDeviceAddress?: Bool32;
  bufferDeviceAddressCaptureReplay?: Bool32;
  bufferDeviceAddressMultiDevice?: Bool32;
  vulkanMemoryModel?: Bool32;
  vulkanMemoryModelDeviceScope?: Bool32;
  vulkanMemoryModelAvailabilityVisibilityChains?: Bool32;
  shaderOutputViewportIndex?: Bool32;
  shaderOutputLayer?: Bool32;
  subgroupBroadcastDynamicId?: Bool32;
}

export class PhysicalDeviceVulkan12Features implements BaseStruct {
  static size = 208;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan12Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan12Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan12Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan12Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan12Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.samplerMirrorClampToEdge !== undefined) this.samplerMirrorClampToEdge = data.samplerMirrorClampToEdge;
      if (data.drawIndirectCount !== undefined) this.drawIndirectCount = data.drawIndirectCount;
      if (data.storageBuffer8BitAccess !== undefined) this.storageBuffer8BitAccess = data.storageBuffer8BitAccess;
      if (data.uniformAndStorageBuffer8BitAccess !== undefined) this.uniformAndStorageBuffer8BitAccess = data.uniformAndStorageBuffer8BitAccess;
      if (data.storagePushConstant8 !== undefined) this.storagePushConstant8 = data.storagePushConstant8;
      if (data.shaderBufferInt64Atomics !== undefined) this.shaderBufferInt64Atomics = data.shaderBufferInt64Atomics;
      if (data.shaderSharedInt64Atomics !== undefined) this.shaderSharedInt64Atomics = data.shaderSharedInt64Atomics;
      if (data.shaderFloat16 !== undefined) this.shaderFloat16 = data.shaderFloat16;
      if (data.shaderInt8 !== undefined) this.shaderInt8 = data.shaderInt8;
      if (data.descriptorIndexing !== undefined) this.descriptorIndexing = data.descriptorIndexing;
      if (data.shaderInputAttachmentArrayDynamicIndexing !== undefined) this.shaderInputAttachmentArrayDynamicIndexing = data.shaderInputAttachmentArrayDynamicIndexing;
      if (data.shaderUniformTexelBufferArrayDynamicIndexing !== undefined) this.shaderUniformTexelBufferArrayDynamicIndexing = data.shaderUniformTexelBufferArrayDynamicIndexing;
      if (data.shaderStorageTexelBufferArrayDynamicIndexing !== undefined) this.shaderStorageTexelBufferArrayDynamicIndexing = data.shaderStorageTexelBufferArrayDynamicIndexing;
      if (data.shaderUniformBufferArrayNonUniformIndexing !== undefined) this.shaderUniformBufferArrayNonUniformIndexing = data.shaderUniformBufferArrayNonUniformIndexing;
      if (data.shaderSampledImageArrayNonUniformIndexing !== undefined) this.shaderSampledImageArrayNonUniformIndexing = data.shaderSampledImageArrayNonUniformIndexing;
      if (data.shaderStorageBufferArrayNonUniformIndexing !== undefined) this.shaderStorageBufferArrayNonUniformIndexing = data.shaderStorageBufferArrayNonUniformIndexing;
      if (data.shaderStorageImageArrayNonUniformIndexing !== undefined) this.shaderStorageImageArrayNonUniformIndexing = data.shaderStorageImageArrayNonUniformIndexing;
      if (data.shaderInputAttachmentArrayNonUniformIndexing !== undefined) this.shaderInputAttachmentArrayNonUniformIndexing = data.shaderInputAttachmentArrayNonUniformIndexing;
      if (data.shaderUniformTexelBufferArrayNonUniformIndexing !== undefined) this.shaderUniformTexelBufferArrayNonUniformIndexing = data.shaderUniformTexelBufferArrayNonUniformIndexing;
      if (data.shaderStorageTexelBufferArrayNonUniformIndexing !== undefined) this.shaderStorageTexelBufferArrayNonUniformIndexing = data.shaderStorageTexelBufferArrayNonUniformIndexing;
      if (data.descriptorBindingUniformBufferUpdateAfterBind !== undefined) this.descriptorBindingUniformBufferUpdateAfterBind = data.descriptorBindingUniformBufferUpdateAfterBind;
      if (data.descriptorBindingSampledImageUpdateAfterBind !== undefined) this.descriptorBindingSampledImageUpdateAfterBind = data.descriptorBindingSampledImageUpdateAfterBind;
      if (data.descriptorBindingStorageImageUpdateAfterBind !== undefined) this.descriptorBindingStorageImageUpdateAfterBind = data.descriptorBindingStorageImageUpdateAfterBind;
      if (data.descriptorBindingStorageBufferUpdateAfterBind !== undefined) this.descriptorBindingStorageBufferUpdateAfterBind = data.descriptorBindingStorageBufferUpdateAfterBind;
      if (data.descriptorBindingUniformTexelBufferUpdateAfterBind !== undefined) this.descriptorBindingUniformTexelBufferUpdateAfterBind = data.descriptorBindingUniformTexelBufferUpdateAfterBind;
      if (data.descriptorBindingStorageTexelBufferUpdateAfterBind !== undefined) this.descriptorBindingStorageTexelBufferUpdateAfterBind = data.descriptorBindingStorageTexelBufferUpdateAfterBind;
      if (data.descriptorBindingUpdateUnusedWhilePending !== undefined) this.descriptorBindingUpdateUnusedWhilePending = data.descriptorBindingUpdateUnusedWhilePending;
      if (data.descriptorBindingPartiallyBound !== undefined) this.descriptorBindingPartiallyBound = data.descriptorBindingPartiallyBound;
      if (data.descriptorBindingVariableDescriptorCount !== undefined) this.descriptorBindingVariableDescriptorCount = data.descriptorBindingVariableDescriptorCount;
      if (data.runtimeDescriptorArray !== undefined) this.runtimeDescriptorArray = data.runtimeDescriptorArray;
      if (data.samplerFilterMinmax !== undefined) this.samplerFilterMinmax = data.samplerFilterMinmax;
      if (data.scalarBlockLayout !== undefined) this.scalarBlockLayout = data.scalarBlockLayout;
      if (data.imagelessFramebuffer !== undefined) this.imagelessFramebuffer = data.imagelessFramebuffer;
      if (data.uniformBufferStandardLayout !== undefined) this.uniformBufferStandardLayout = data.uniformBufferStandardLayout;
      if (data.shaderSubgroupExtendedTypes !== undefined) this.shaderSubgroupExtendedTypes = data.shaderSubgroupExtendedTypes;
      if (data.separateDepthStencilLayouts !== undefined) this.separateDepthStencilLayouts = data.separateDepthStencilLayouts;
      if (data.hostQueryReset !== undefined) this.hostQueryReset = data.hostQueryReset;
      if (data.timelineSemaphore !== undefined) this.timelineSemaphore = data.timelineSemaphore;
      if (data.bufferDeviceAddress !== undefined) this.bufferDeviceAddress = data.bufferDeviceAddress;
      if (data.bufferDeviceAddressCaptureReplay !== undefined) this.bufferDeviceAddressCaptureReplay = data.bufferDeviceAddressCaptureReplay;
      if (data.bufferDeviceAddressMultiDevice !== undefined) this.bufferDeviceAddressMultiDevice = data.bufferDeviceAddressMultiDevice;
      if (data.vulkanMemoryModel !== undefined) this.vulkanMemoryModel = data.vulkanMemoryModel;
      if (data.vulkanMemoryModelDeviceScope !== undefined) this.vulkanMemoryModelDeviceScope = data.vulkanMemoryModelDeviceScope;
      if (data.vulkanMemoryModelAvailabilityVisibilityChains !== undefined) this.vulkanMemoryModelAvailabilityVisibilityChains = data.vulkanMemoryModelAvailabilityVisibilityChains;
      if (data.shaderOutputViewportIndex !== undefined) this.shaderOutputViewportIndex = data.shaderOutputViewportIndex;
      if (data.shaderOutputLayer !== undefined) this.shaderOutputLayer = data.shaderOutputLayer;
      if (data.subgroupBroadcastDynamicId !== undefined) this.subgroupBroadcastDynamicId = data.subgroupBroadcastDynamicId;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get samplerMirrorClampToEdge() {
    return this.#view.getUint32(16, LE);
  }
  
  set samplerMirrorClampToEdge(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get drawIndirectCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set drawIndirectCount(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get storageBuffer8BitAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set storageBuffer8BitAccess(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get uniformAndStorageBuffer8BitAccess() {
    return this.#view.getUint32(28, LE);
  }
  
  set uniformAndStorageBuffer8BitAccess(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get storagePushConstant8() {
    return this.#view.getUint32(32, LE);
  }
  
  set storagePushConstant8(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderBufferInt64Atomics() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderBufferInt64Atomics(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderSharedInt64Atomics() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderSharedInt64Atomics(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get shaderFloat16() {
    return this.#view.getUint32(44, LE);
  }
  
  set shaderFloat16(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get shaderInt8() {
    return this.#view.getUint32(48, LE);
  }
  
  set shaderInt8(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get descriptorIndexing() {
    return this.#view.getUint32(52, LE);
  }
  
  set descriptorIndexing(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayDynamicIndexing() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderInputAttachmentArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderUniformTexelBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayDynamicIndexing() {
    return this.#view.getUint32(64, LE);
  }
  
  set shaderStorageTexelBufferArrayDynamicIndexing(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexing() {
    return this.#view.getUint32(72, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(76, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexing() {
    return this.#view.getUint32(80, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexing() {
    return this.#view.getUint32(84, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get shaderUniformTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(88, LE);
  }
  
  set shaderUniformTexelBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get shaderStorageTexelBufferArrayNonUniformIndexing() {
    return this.#view.getUint32(92, LE);
  }
  
  set shaderStorageTexelBufferArrayNonUniformIndexing(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get descriptorBindingUniformBufferUpdateAfterBind() {
    return this.#view.getUint32(96, LE);
  }
  
  set descriptorBindingUniformBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get descriptorBindingSampledImageUpdateAfterBind() {
    return this.#view.getUint32(100, LE);
  }
  
  set descriptorBindingSampledImageUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get descriptorBindingStorageImageUpdateAfterBind() {
    return this.#view.getUint32(104, LE);
  }
  
  set descriptorBindingStorageImageUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get descriptorBindingStorageBufferUpdateAfterBind() {
    return this.#view.getUint32(108, LE);
  }
  
  set descriptorBindingStorageBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get descriptorBindingUniformTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(112, LE);
  }
  
  set descriptorBindingUniformTexelBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get descriptorBindingStorageTexelBufferUpdateAfterBind() {
    return this.#view.getUint32(116, LE);
  }
  
  set descriptorBindingStorageTexelBufferUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get descriptorBindingUpdateUnusedWhilePending() {
    return this.#view.getUint32(120, LE);
  }
  
  set descriptorBindingUpdateUnusedWhilePending(value: Bool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get descriptorBindingPartiallyBound() {
    return this.#view.getUint32(124, LE);
  }
  
  set descriptorBindingPartiallyBound(value: Bool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get descriptorBindingVariableDescriptorCount() {
    return this.#view.getUint32(128, LE);
  }
  
  set descriptorBindingVariableDescriptorCount(value: Bool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get runtimeDescriptorArray() {
    return this.#view.getUint32(132, LE);
  }
  
  set runtimeDescriptorArray(value: Bool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get samplerFilterMinmax() {
    return this.#view.getUint32(136, LE);
  }
  
  set samplerFilterMinmax(value: Bool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get scalarBlockLayout() {
    return this.#view.getUint32(140, LE);
  }
  
  set scalarBlockLayout(value: Bool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get imagelessFramebuffer() {
    return this.#view.getUint32(144, LE);
  }
  
  set imagelessFramebuffer(value: Bool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get uniformBufferStandardLayout() {
    return this.#view.getUint32(148, LE);
  }
  
  set uniformBufferStandardLayout(value: Bool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get shaderSubgroupExtendedTypes() {
    return this.#view.getUint32(152, LE);
  }
  
  set shaderSubgroupExtendedTypes(value: Bool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get separateDepthStencilLayouts() {
    return this.#view.getUint32(156, LE);
  }
  
  set separateDepthStencilLayouts(value: Bool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get hostQueryReset() {
    return this.#view.getUint32(160, LE);
  }
  
  set hostQueryReset(value: Bool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get timelineSemaphore() {
    return this.#view.getUint32(164, LE);
  }
  
  set timelineSemaphore(value: Bool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get bufferDeviceAddress() {
    return this.#view.getUint32(168, LE);
  }
  
  set bufferDeviceAddress(value: Bool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get bufferDeviceAddressCaptureReplay() {
    return this.#view.getUint32(172, LE);
  }
  
  set bufferDeviceAddressCaptureReplay(value: Bool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get bufferDeviceAddressMultiDevice() {
    return this.#view.getUint32(176, LE);
  }
  
  set bufferDeviceAddressMultiDevice(value: Bool32) {
    this.#view.setUint32(176, Number(value), LE);
  }
  
  get vulkanMemoryModel() {
    return this.#view.getUint32(180, LE);
  }
  
  set vulkanMemoryModel(value: Bool32) {
    this.#view.setUint32(180, Number(value), LE);
  }
  
  get vulkanMemoryModelDeviceScope() {
    return this.#view.getUint32(184, LE);
  }
  
  set vulkanMemoryModelDeviceScope(value: Bool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get vulkanMemoryModelAvailabilityVisibilityChains() {
    return this.#view.getUint32(188, LE);
  }
  
  set vulkanMemoryModelAvailabilityVisibilityChains(value: Bool32) {
    this.#view.setUint32(188, Number(value), LE);
  }
  
  get shaderOutputViewportIndex() {
    return this.#view.getUint32(192, LE);
  }
  
  set shaderOutputViewportIndex(value: Bool32) {
    this.#view.setUint32(192, Number(value), LE);
  }
  
  get shaderOutputLayer() {
    return this.#view.getUint32(196, LE);
  }
  
  set shaderOutputLayer(value: Bool32) {
    this.#view.setUint32(196, Number(value), LE);
  }
  
  get subgroupBroadcastDynamicId() {
    return this.#view.getUint32(200, LE);
  }
  
  set subgroupBroadcastDynamicId(value: Bool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan12Properties {
  pNext?: AnyPointer;
  driverID?: DriverId;
  driverName?: number[];
  driverInfo?: number[];
  conformanceVersion?: ConformanceVersion;
  denormBehaviorIndependence?: ShaderFloatControlsIndependence;
  roundingModeIndependence?: ShaderFloatControlsIndependence;
  shaderSignedZeroInfNanPreserveFloat16?: Bool32;
  shaderSignedZeroInfNanPreserveFloat32?: Bool32;
  shaderSignedZeroInfNanPreserveFloat64?: Bool32;
  shaderDenormPreserveFloat16?: Bool32;
  shaderDenormPreserveFloat32?: Bool32;
  shaderDenormPreserveFloat64?: Bool32;
  shaderDenormFlushToZeroFloat16?: Bool32;
  shaderDenormFlushToZeroFloat32?: Bool32;
  shaderDenormFlushToZeroFloat64?: Bool32;
  shaderRoundingModeRTEFloat16?: Bool32;
  shaderRoundingModeRTEFloat32?: Bool32;
  shaderRoundingModeRTEFloat64?: Bool32;
  shaderRoundingModeRTZFloat16?: Bool32;
  shaderRoundingModeRTZFloat32?: Bool32;
  shaderRoundingModeRTZFloat64?: Bool32;
  maxUpdateAfterBindDescriptorsInAllPools?: number;
  shaderUniformBufferArrayNonUniformIndexingNative?: Bool32;
  shaderSampledImageArrayNonUniformIndexingNative?: Bool32;
  shaderStorageBufferArrayNonUniformIndexingNative?: Bool32;
  shaderStorageImageArrayNonUniformIndexingNative?: Bool32;
  shaderInputAttachmentArrayNonUniformIndexingNative?: Bool32;
  robustBufferAccessUpdateAfterBind?: Bool32;
  quadDivergentImplicitLod?: Bool32;
  maxPerStageDescriptorUpdateAfterBindSamplers?: number;
  maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number;
  maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number;
  maxPerStageDescriptorUpdateAfterBindSampledImages?: number;
  maxPerStageDescriptorUpdateAfterBindStorageImages?: number;
  maxPerStageDescriptorUpdateAfterBindInputAttachments?: number;
  maxPerStageUpdateAfterBindResources?: number;
  maxDescriptorSetUpdateAfterBindSamplers?: number;
  maxDescriptorSetUpdateAfterBindUniformBuffers?: number;
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number;
  maxDescriptorSetUpdateAfterBindStorageBuffers?: number;
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number;
  maxDescriptorSetUpdateAfterBindSampledImages?: number;
  maxDescriptorSetUpdateAfterBindStorageImages?: number;
  maxDescriptorSetUpdateAfterBindInputAttachments?: number;
  supportedDepthResolveModes?: ResolveModeFlags;
  supportedStencilResolveModes?: ResolveModeFlags;
  independentResolveNone?: Bool32;
  independentResolve?: Bool32;
  filterMinmaxSingleComponentFormats?: Bool32;
  filterMinmaxImageComponentMapping?: Bool32;
  maxTimelineSemaphoreValueDifference?: Deno.PointerValue;
  framebufferIntegerColorSampleCounts?: SampleCountFlags;
}

export class PhysicalDeviceVulkan12Properties implements BaseStruct {
  static size = 736;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan12Properties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan12Properties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan12Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan12Properties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan12Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.driverID !== undefined) this.driverID = data.driverID;
      if (data.driverName !== undefined) this.driverName = data.driverName;
      if (data.driverInfo !== undefined) this.driverInfo = data.driverInfo;
      if (data.conformanceVersion !== undefined) this.conformanceVersion = data.conformanceVersion;
      if (data.denormBehaviorIndependence !== undefined) this.denormBehaviorIndependence = data.denormBehaviorIndependence;
      if (data.roundingModeIndependence !== undefined) this.roundingModeIndependence = data.roundingModeIndependence;
      if (data.shaderSignedZeroInfNanPreserveFloat16 !== undefined) this.shaderSignedZeroInfNanPreserveFloat16 = data.shaderSignedZeroInfNanPreserveFloat16;
      if (data.shaderSignedZeroInfNanPreserveFloat32 !== undefined) this.shaderSignedZeroInfNanPreserveFloat32 = data.shaderSignedZeroInfNanPreserveFloat32;
      if (data.shaderSignedZeroInfNanPreserveFloat64 !== undefined) this.shaderSignedZeroInfNanPreserveFloat64 = data.shaderSignedZeroInfNanPreserveFloat64;
      if (data.shaderDenormPreserveFloat16 !== undefined) this.shaderDenormPreserveFloat16 = data.shaderDenormPreserveFloat16;
      if (data.shaderDenormPreserveFloat32 !== undefined) this.shaderDenormPreserveFloat32 = data.shaderDenormPreserveFloat32;
      if (data.shaderDenormPreserveFloat64 !== undefined) this.shaderDenormPreserveFloat64 = data.shaderDenormPreserveFloat64;
      if (data.shaderDenormFlushToZeroFloat16 !== undefined) this.shaderDenormFlushToZeroFloat16 = data.shaderDenormFlushToZeroFloat16;
      if (data.shaderDenormFlushToZeroFloat32 !== undefined) this.shaderDenormFlushToZeroFloat32 = data.shaderDenormFlushToZeroFloat32;
      if (data.shaderDenormFlushToZeroFloat64 !== undefined) this.shaderDenormFlushToZeroFloat64 = data.shaderDenormFlushToZeroFloat64;
      if (data.shaderRoundingModeRTEFloat16 !== undefined) this.shaderRoundingModeRTEFloat16 = data.shaderRoundingModeRTEFloat16;
      if (data.shaderRoundingModeRTEFloat32 !== undefined) this.shaderRoundingModeRTEFloat32 = data.shaderRoundingModeRTEFloat32;
      if (data.shaderRoundingModeRTEFloat64 !== undefined) this.shaderRoundingModeRTEFloat64 = data.shaderRoundingModeRTEFloat64;
      if (data.shaderRoundingModeRTZFloat16 !== undefined) this.shaderRoundingModeRTZFloat16 = data.shaderRoundingModeRTZFloat16;
      if (data.shaderRoundingModeRTZFloat32 !== undefined) this.shaderRoundingModeRTZFloat32 = data.shaderRoundingModeRTZFloat32;
      if (data.shaderRoundingModeRTZFloat64 !== undefined) this.shaderRoundingModeRTZFloat64 = data.shaderRoundingModeRTZFloat64;
      if (data.maxUpdateAfterBindDescriptorsInAllPools !== undefined) this.maxUpdateAfterBindDescriptorsInAllPools = data.maxUpdateAfterBindDescriptorsInAllPools;
      if (data.shaderUniformBufferArrayNonUniformIndexingNative !== undefined) this.shaderUniformBufferArrayNonUniformIndexingNative = data.shaderUniformBufferArrayNonUniformIndexingNative;
      if (data.shaderSampledImageArrayNonUniformIndexingNative !== undefined) this.shaderSampledImageArrayNonUniformIndexingNative = data.shaderSampledImageArrayNonUniformIndexingNative;
      if (data.shaderStorageBufferArrayNonUniformIndexingNative !== undefined) this.shaderStorageBufferArrayNonUniformIndexingNative = data.shaderStorageBufferArrayNonUniformIndexingNative;
      if (data.shaderStorageImageArrayNonUniformIndexingNative !== undefined) this.shaderStorageImageArrayNonUniformIndexingNative = data.shaderStorageImageArrayNonUniformIndexingNative;
      if (data.shaderInputAttachmentArrayNonUniformIndexingNative !== undefined) this.shaderInputAttachmentArrayNonUniformIndexingNative = data.shaderInputAttachmentArrayNonUniformIndexingNative;
      if (data.robustBufferAccessUpdateAfterBind !== undefined) this.robustBufferAccessUpdateAfterBind = data.robustBufferAccessUpdateAfterBind;
      if (data.quadDivergentImplicitLod !== undefined) this.quadDivergentImplicitLod = data.quadDivergentImplicitLod;
      if (data.maxPerStageDescriptorUpdateAfterBindSamplers !== undefined) this.maxPerStageDescriptorUpdateAfterBindSamplers = data.maxPerStageDescriptorUpdateAfterBindSamplers;
      if (data.maxPerStageDescriptorUpdateAfterBindUniformBuffers !== undefined) this.maxPerStageDescriptorUpdateAfterBindUniformBuffers = data.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
      if (data.maxPerStageDescriptorUpdateAfterBindStorageBuffers !== undefined) this.maxPerStageDescriptorUpdateAfterBindStorageBuffers = data.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
      if (data.maxPerStageDescriptorUpdateAfterBindSampledImages !== undefined) this.maxPerStageDescriptorUpdateAfterBindSampledImages = data.maxPerStageDescriptorUpdateAfterBindSampledImages;
      if (data.maxPerStageDescriptorUpdateAfterBindStorageImages !== undefined) this.maxPerStageDescriptorUpdateAfterBindStorageImages = data.maxPerStageDescriptorUpdateAfterBindStorageImages;
      if (data.maxPerStageDescriptorUpdateAfterBindInputAttachments !== undefined) this.maxPerStageDescriptorUpdateAfterBindInputAttachments = data.maxPerStageDescriptorUpdateAfterBindInputAttachments;
      if (data.maxPerStageUpdateAfterBindResources !== undefined) this.maxPerStageUpdateAfterBindResources = data.maxPerStageUpdateAfterBindResources;
      if (data.maxDescriptorSetUpdateAfterBindSamplers !== undefined) this.maxDescriptorSetUpdateAfterBindSamplers = data.maxDescriptorSetUpdateAfterBindSamplers;
      if (data.maxDescriptorSetUpdateAfterBindUniformBuffers !== undefined) this.maxDescriptorSetUpdateAfterBindUniformBuffers = data.maxDescriptorSetUpdateAfterBindUniformBuffers;
      if (data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic !== undefined) this.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = data.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
      if (data.maxDescriptorSetUpdateAfterBindStorageBuffers !== undefined) this.maxDescriptorSetUpdateAfterBindStorageBuffers = data.maxDescriptorSetUpdateAfterBindStorageBuffers;
      if (data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic !== undefined) this.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = data.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
      if (data.maxDescriptorSetUpdateAfterBindSampledImages !== undefined) this.maxDescriptorSetUpdateAfterBindSampledImages = data.maxDescriptorSetUpdateAfterBindSampledImages;
      if (data.maxDescriptorSetUpdateAfterBindStorageImages !== undefined) this.maxDescriptorSetUpdateAfterBindStorageImages = data.maxDescriptorSetUpdateAfterBindStorageImages;
      if (data.maxDescriptorSetUpdateAfterBindInputAttachments !== undefined) this.maxDescriptorSetUpdateAfterBindInputAttachments = data.maxDescriptorSetUpdateAfterBindInputAttachments;
      if (data.supportedDepthResolveModes !== undefined) this.supportedDepthResolveModes = data.supportedDepthResolveModes;
      if (data.supportedStencilResolveModes !== undefined) this.supportedStencilResolveModes = data.supportedStencilResolveModes;
      if (data.independentResolveNone !== undefined) this.independentResolveNone = data.independentResolveNone;
      if (data.independentResolve !== undefined) this.independentResolve = data.independentResolve;
      if (data.filterMinmaxSingleComponentFormats !== undefined) this.filterMinmaxSingleComponentFormats = data.filterMinmaxSingleComponentFormats;
      if (data.filterMinmaxImageComponentMapping !== undefined) this.filterMinmaxImageComponentMapping = data.filterMinmaxImageComponentMapping;
      if (data.maxTimelineSemaphoreValueDifference !== undefined) this.maxTimelineSemaphoreValueDifference = data.maxTimelineSemaphoreValueDifference;
      if (data.framebufferIntegerColorSampleCounts !== undefined) this.framebufferIntegerColorSampleCounts = data.framebufferIntegerColorSampleCounts;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get driverID() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverID(value: DriverId) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get driverName() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set driverName(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get driverInfo() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(276 + i * 1);
      })());
    }
    return result;
  }
  
  set driverInfo(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(276 + i * 1, Number(value[i]));
    }
  }
  
  get conformanceVersion() {
    return new ConformanceVersion(this.#data.subarray(532, 532 + ConformanceVersion.size));
  }
  
  set conformanceVersion(value: ConformanceVersion) {
    if (value[BUFFER].byteLength < ConformanceVersion.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 532);
  }
  
  get denormBehaviorIndependence() {
    return this.#view.getUint32(536, LE);
  }
  
  set denormBehaviorIndependence(value: ShaderFloatControlsIndependence) {
    this.#view.setUint32(536, Number(value), LE);
  }
  
  get roundingModeIndependence() {
    return this.#view.getUint32(540, LE);
  }
  
  set roundingModeIndependence(value: ShaderFloatControlsIndependence) {
    this.#view.setUint32(540, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat16() {
    return this.#view.getUint32(544, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat16(value: Bool32) {
    this.#view.setUint32(544, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat32() {
    return this.#view.getUint32(548, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat32(value: Bool32) {
    this.#view.setUint32(548, Number(value), LE);
  }
  
  get shaderSignedZeroInfNanPreserveFloat64() {
    return this.#view.getUint32(552, LE);
  }
  
  set shaderSignedZeroInfNanPreserveFloat64(value: Bool32) {
    this.#view.setUint32(552, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat16() {
    return this.#view.getUint32(556, LE);
  }
  
  set shaderDenormPreserveFloat16(value: Bool32) {
    this.#view.setUint32(556, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat32() {
    return this.#view.getUint32(560, LE);
  }
  
  set shaderDenormPreserveFloat32(value: Bool32) {
    this.#view.setUint32(560, Number(value), LE);
  }
  
  get shaderDenormPreserveFloat64() {
    return this.#view.getUint32(564, LE);
  }
  
  set shaderDenormPreserveFloat64(value: Bool32) {
    this.#view.setUint32(564, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat16() {
    return this.#view.getUint32(568, LE);
  }
  
  set shaderDenormFlushToZeroFloat16(value: Bool32) {
    this.#view.setUint32(568, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat32() {
    return this.#view.getUint32(572, LE);
  }
  
  set shaderDenormFlushToZeroFloat32(value: Bool32) {
    this.#view.setUint32(572, Number(value), LE);
  }
  
  get shaderDenormFlushToZeroFloat64() {
    return this.#view.getUint32(576, LE);
  }
  
  set shaderDenormFlushToZeroFloat64(value: Bool32) {
    this.#view.setUint32(576, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat16() {
    return this.#view.getUint32(580, LE);
  }
  
  set shaderRoundingModeRTEFloat16(value: Bool32) {
    this.#view.setUint32(580, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat32() {
    return this.#view.getUint32(584, LE);
  }
  
  set shaderRoundingModeRTEFloat32(value: Bool32) {
    this.#view.setUint32(584, Number(value), LE);
  }
  
  get shaderRoundingModeRTEFloat64() {
    return this.#view.getUint32(588, LE);
  }
  
  set shaderRoundingModeRTEFloat64(value: Bool32) {
    this.#view.setUint32(588, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat16() {
    return this.#view.getUint32(592, LE);
  }
  
  set shaderRoundingModeRTZFloat16(value: Bool32) {
    this.#view.setUint32(592, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat32() {
    return this.#view.getUint32(596, LE);
  }
  
  set shaderRoundingModeRTZFloat32(value: Bool32) {
    this.#view.setUint32(596, Number(value), LE);
  }
  
  get shaderRoundingModeRTZFloat64() {
    return this.#view.getUint32(600, LE);
  }
  
  set shaderRoundingModeRTZFloat64(value: Bool32) {
    this.#view.setUint32(600, Number(value), LE);
  }
  
  get maxUpdateAfterBindDescriptorsInAllPools() {
    return this.#view.getUint32(604, LE);
  }
  
  set maxUpdateAfterBindDescriptorsInAllPools(value: number) {
    this.#view.setUint32(604, Number(value), LE);
  }
  
  get shaderUniformBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(608, LE);
  }
  
  set shaderUniformBufferArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(608, Number(value), LE);
  }
  
  get shaderSampledImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(612, LE);
  }
  
  set shaderSampledImageArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(612, Number(value), LE);
  }
  
  get shaderStorageBufferArrayNonUniformIndexingNative() {
    return this.#view.getUint32(616, LE);
  }
  
  set shaderStorageBufferArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(616, Number(value), LE);
  }
  
  get shaderStorageImageArrayNonUniformIndexingNative() {
    return this.#view.getUint32(620, LE);
  }
  
  set shaderStorageImageArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(620, Number(value), LE);
  }
  
  get shaderInputAttachmentArrayNonUniformIndexingNative() {
    return this.#view.getUint32(624, LE);
  }
  
  set shaderInputAttachmentArrayNonUniformIndexingNative(value: Bool32) {
    this.#view.setUint32(624, Number(value), LE);
  }
  
  get robustBufferAccessUpdateAfterBind() {
    return this.#view.getUint32(628, LE);
  }
  
  set robustBufferAccessUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(628, Number(value), LE);
  }
  
  get quadDivergentImplicitLod() {
    return this.#view.getUint32(632, LE);
  }
  
  set quadDivergentImplicitLod(value: Bool32) {
    this.#view.setUint32(632, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSamplers() {
    return this.#view.getUint32(636, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(636, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(640, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(640, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(644, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(644, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindSampledImages() {
    return this.#view.getUint32(648, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(648, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindStorageImages() {
    return this.#view.getUint32(652, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(652, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(656, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(656, Number(value), LE);
  }
  
  get maxPerStageUpdateAfterBindResources() {
    return this.#view.getUint32(660, LE);
  }
  
  set maxPerStageUpdateAfterBindResources(value: number) {
    this.#view.setUint32(660, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSamplers() {
    return this.#view.getUint32(664, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSamplers(value: number) {
    this.#view.setUint32(664, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffers() {
    return this.#view.getUint32(668, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffers(value: number) {
    this.#view.setUint32(668, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
    return this.#view.getUint32(672, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindUniformBuffersDynamic(value: number) {
    this.#view.setUint32(672, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffers() {
    return this.#view.getUint32(676, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffers(value: number) {
    this.#view.setUint32(676, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
    return this.#view.getUint32(680, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageBuffersDynamic(value: number) {
    this.#view.setUint32(680, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindSampledImages() {
    return this.#view.getUint32(684, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindSampledImages(value: number) {
    this.#view.setUint32(684, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindStorageImages() {
    return this.#view.getUint32(688, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindStorageImages(value: number) {
    this.#view.setUint32(688, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInputAttachments() {
    return this.#view.getUint32(692, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInputAttachments(value: number) {
    this.#view.setUint32(692, Number(value), LE);
  }
  
  get supportedDepthResolveModes() {
    return this.#view.getUint32(696, LE);
  }
  
  set supportedDepthResolveModes(value: ResolveModeFlags) {
    this.#view.setUint32(696, Number(value), LE);
  }
  
  get supportedStencilResolveModes() {
    return this.#view.getUint32(700, LE);
  }
  
  set supportedStencilResolveModes(value: ResolveModeFlags) {
    this.#view.setUint32(700, Number(value), LE);
  }
  
  get independentResolveNone() {
    return this.#view.getUint32(704, LE);
  }
  
  set independentResolveNone(value: Bool32) {
    this.#view.setUint32(704, Number(value), LE);
  }
  
  get independentResolve() {
    return this.#view.getUint32(708, LE);
  }
  
  set independentResolve(value: Bool32) {
    this.#view.setUint32(708, Number(value), LE);
  }
  
  get filterMinmaxSingleComponentFormats() {
    return this.#view.getUint32(712, LE);
  }
  
  set filterMinmaxSingleComponentFormats(value: Bool32) {
    this.#view.setUint32(712, Number(value), LE);
  }
  
  get filterMinmaxImageComponentMapping() {
    return this.#view.getUint32(716, LE);
  }
  
  set filterMinmaxImageComponentMapping(value: Bool32) {
    this.#view.setUint32(716, Number(value), LE);
  }
  
  get maxTimelineSemaphoreValueDifference() {
    return this.#view.getBigUint64(720, LE);
  }
  
  set maxTimelineSemaphoreValueDifference(value: Deno.PointerValue) {
    this.#view.setBigUint64(720, BigInt(value), LE);
  }
  
  get framebufferIntegerColorSampleCounts() {
    return this.#view.getUint32(728, LE);
  }
  
  set framebufferIntegerColorSampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(728, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan13Features {
  pNext?: AnyPointer;
  robustImageAccess?: Bool32;
  inlineUniformBlock?: Bool32;
  descriptorBindingInlineUniformBlockUpdateAfterBind?: Bool32;
  pipelineCreationCacheControl?: Bool32;
  privateData?: Bool32;
  shaderDemoteToHelperInvocation?: Bool32;
  shaderTerminateInvocation?: Bool32;
  subgroupSizeControl?: Bool32;
  computeFullSubgroups?: Bool32;
  synchronization2?: Bool32;
  textureCompressionASTC_HDR?: Bool32;
  shaderZeroInitializeWorkgroupMemory?: Bool32;
  dynamicRendering?: Bool32;
  shaderIntegerDotProduct?: Bool32;
  maintenance4?: Bool32;
}

export class PhysicalDeviceVulkan13Features implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan13Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan13Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan13Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan13Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan13Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.robustImageAccess !== undefined) this.robustImageAccess = data.robustImageAccess;
      if (data.inlineUniformBlock !== undefined) this.inlineUniformBlock = data.inlineUniformBlock;
      if (data.descriptorBindingInlineUniformBlockUpdateAfterBind !== undefined) this.descriptorBindingInlineUniformBlockUpdateAfterBind = data.descriptorBindingInlineUniformBlockUpdateAfterBind;
      if (data.pipelineCreationCacheControl !== undefined) this.pipelineCreationCacheControl = data.pipelineCreationCacheControl;
      if (data.privateData !== undefined) this.privateData = data.privateData;
      if (data.shaderDemoteToHelperInvocation !== undefined) this.shaderDemoteToHelperInvocation = data.shaderDemoteToHelperInvocation;
      if (data.shaderTerminateInvocation !== undefined) this.shaderTerminateInvocation = data.shaderTerminateInvocation;
      if (data.subgroupSizeControl !== undefined) this.subgroupSizeControl = data.subgroupSizeControl;
      if (data.computeFullSubgroups !== undefined) this.computeFullSubgroups = data.computeFullSubgroups;
      if (data.synchronization2 !== undefined) this.synchronization2 = data.synchronization2;
      if (data.textureCompressionASTC_HDR !== undefined) this.textureCompressionASTC_HDR = data.textureCompressionASTC_HDR;
      if (data.shaderZeroInitializeWorkgroupMemory !== undefined) this.shaderZeroInitializeWorkgroupMemory = data.shaderZeroInitializeWorkgroupMemory;
      if (data.dynamicRendering !== undefined) this.dynamicRendering = data.dynamicRendering;
      if (data.shaderIntegerDotProduct !== undefined) this.shaderIntegerDotProduct = data.shaderIntegerDotProduct;
      if (data.maintenance4 !== undefined) this.maintenance4 = data.maintenance4;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get robustImageAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustImageAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inlineUniformBlock() {
    return this.#view.getUint32(20, LE);
  }
  
  set inlineUniformBlock(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get descriptorBindingInlineUniformBlockUpdateAfterBind() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorBindingInlineUniformBlockUpdateAfterBind(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pipelineCreationCacheControl() {
    return this.#view.getUint32(28, LE);
  }
  
  set pipelineCreationCacheControl(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get privateData() {
    return this.#view.getUint32(32, LE);
  }
  
  set privateData(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get shaderDemoteToHelperInvocation() {
    return this.#view.getUint32(36, LE);
  }
  
  set shaderDemoteToHelperInvocation(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get shaderTerminateInvocation() {
    return this.#view.getUint32(40, LE);
  }
  
  set shaderTerminateInvocation(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get subgroupSizeControl() {
    return this.#view.getUint32(44, LE);
  }
  
  set subgroupSizeControl(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get computeFullSubgroups() {
    return this.#view.getUint32(48, LE);
  }
  
  set computeFullSubgroups(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get synchronization2() {
    return this.#view.getUint32(52, LE);
  }
  
  set synchronization2(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get textureCompressionASTC_HDR() {
    return this.#view.getUint32(56, LE);
  }
  
  set textureCompressionASTC_HDR(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get shaderZeroInitializeWorkgroupMemory() {
    return this.#view.getUint32(60, LE);
  }
  
  set shaderZeroInitializeWorkgroupMemory(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get dynamicRendering() {
    return this.#view.getUint32(64, LE);
  }
  
  set dynamicRendering(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get shaderIntegerDotProduct() {
    return this.#view.getUint32(68, LE);
  }
  
  set shaderIntegerDotProduct(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maintenance4() {
    return this.#view.getUint32(72, LE);
  }
  
  set maintenance4(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVulkan13Properties {
  pNext?: AnyPointer;
  minSubgroupSize?: number;
  maxSubgroupSize?: number;
  maxComputeWorkgroupSubgroups?: number;
  requiredSubgroupSizeStages?: ShaderStageFlags;
  maxInlineUniformBlockSize?: number;
  maxPerStageDescriptorInlineUniformBlocks?: number;
  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks?: number;
  maxDescriptorSetInlineUniformBlocks?: number;
  maxDescriptorSetUpdateAfterBindInlineUniformBlocks?: number;
  maxInlineUniformTotalSize?: number;
  integerDotProduct8BitUnsignedAccelerated?: Bool32;
  integerDotProduct8BitSignedAccelerated?: Bool32;
  integerDotProduct8BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct4x8BitPackedUnsignedAccelerated?: Bool32;
  integerDotProduct4x8BitPackedSignedAccelerated?: Bool32;
  integerDotProduct4x8BitPackedMixedSignednessAccelerated?: Bool32;
  integerDotProduct16BitUnsignedAccelerated?: Bool32;
  integerDotProduct16BitSignedAccelerated?: Bool32;
  integerDotProduct16BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct32BitUnsignedAccelerated?: Bool32;
  integerDotProduct32BitSignedAccelerated?: Bool32;
  integerDotProduct32BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct64BitUnsignedAccelerated?: Bool32;
  integerDotProduct64BitSignedAccelerated?: Bool32;
  integerDotProduct64BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated?: Bool32;
  storageTexelBufferOffsetAlignmentBytes?: DeviceSize;
  storageTexelBufferOffsetSingleTexelAlignment?: Bool32;
  uniformTexelBufferOffsetAlignmentBytes?: DeviceSize;
  uniformTexelBufferOffsetSingleTexelAlignment?: Bool32;
  maxBufferSize?: DeviceSize;
}

export class PhysicalDeviceVulkan13Properties implements BaseStruct {
  static size = 216;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVulkan13Properties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVulkan13Properties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVulkan13Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVulkan13Properties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVulkan13Properties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minSubgroupSize !== undefined) this.minSubgroupSize = data.minSubgroupSize;
      if (data.maxSubgroupSize !== undefined) this.maxSubgroupSize = data.maxSubgroupSize;
      if (data.maxComputeWorkgroupSubgroups !== undefined) this.maxComputeWorkgroupSubgroups = data.maxComputeWorkgroupSubgroups;
      if (data.requiredSubgroupSizeStages !== undefined) this.requiredSubgroupSizeStages = data.requiredSubgroupSizeStages;
      if (data.maxInlineUniformBlockSize !== undefined) this.maxInlineUniformBlockSize = data.maxInlineUniformBlockSize;
      if (data.maxPerStageDescriptorInlineUniformBlocks !== undefined) this.maxPerStageDescriptorInlineUniformBlocks = data.maxPerStageDescriptorInlineUniformBlocks;
      if (data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks !== undefined) this.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = data.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
      if (data.maxDescriptorSetInlineUniformBlocks !== undefined) this.maxDescriptorSetInlineUniformBlocks = data.maxDescriptorSetInlineUniformBlocks;
      if (data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks !== undefined) this.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = data.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
      if (data.maxInlineUniformTotalSize !== undefined) this.maxInlineUniformTotalSize = data.maxInlineUniformTotalSize;
      if (data.integerDotProduct8BitUnsignedAccelerated !== undefined) this.integerDotProduct8BitUnsignedAccelerated = data.integerDotProduct8BitUnsignedAccelerated;
      if (data.integerDotProduct8BitSignedAccelerated !== undefined) this.integerDotProduct8BitSignedAccelerated = data.integerDotProduct8BitSignedAccelerated;
      if (data.integerDotProduct8BitMixedSignednessAccelerated !== undefined) this.integerDotProduct8BitMixedSignednessAccelerated = data.integerDotProduct8BitMixedSignednessAccelerated;
      if (data.integerDotProduct4x8BitPackedUnsignedAccelerated !== undefined) this.integerDotProduct4x8BitPackedUnsignedAccelerated = data.integerDotProduct4x8BitPackedUnsignedAccelerated;
      if (data.integerDotProduct4x8BitPackedSignedAccelerated !== undefined) this.integerDotProduct4x8BitPackedSignedAccelerated = data.integerDotProduct4x8BitPackedSignedAccelerated;
      if (data.integerDotProduct4x8BitPackedMixedSignednessAccelerated !== undefined) this.integerDotProduct4x8BitPackedMixedSignednessAccelerated = data.integerDotProduct4x8BitPackedMixedSignednessAccelerated;
      if (data.integerDotProduct16BitUnsignedAccelerated !== undefined) this.integerDotProduct16BitUnsignedAccelerated = data.integerDotProduct16BitUnsignedAccelerated;
      if (data.integerDotProduct16BitSignedAccelerated !== undefined) this.integerDotProduct16BitSignedAccelerated = data.integerDotProduct16BitSignedAccelerated;
      if (data.integerDotProduct16BitMixedSignednessAccelerated !== undefined) this.integerDotProduct16BitMixedSignednessAccelerated = data.integerDotProduct16BitMixedSignednessAccelerated;
      if (data.integerDotProduct32BitUnsignedAccelerated !== undefined) this.integerDotProduct32BitUnsignedAccelerated = data.integerDotProduct32BitUnsignedAccelerated;
      if (data.integerDotProduct32BitSignedAccelerated !== undefined) this.integerDotProduct32BitSignedAccelerated = data.integerDotProduct32BitSignedAccelerated;
      if (data.integerDotProduct32BitMixedSignednessAccelerated !== undefined) this.integerDotProduct32BitMixedSignednessAccelerated = data.integerDotProduct32BitMixedSignednessAccelerated;
      if (data.integerDotProduct64BitUnsignedAccelerated !== undefined) this.integerDotProduct64BitUnsignedAccelerated = data.integerDotProduct64BitUnsignedAccelerated;
      if (data.integerDotProduct64BitSignedAccelerated !== undefined) this.integerDotProduct64BitSignedAccelerated = data.integerDotProduct64BitSignedAccelerated;
      if (data.integerDotProduct64BitMixedSignednessAccelerated !== undefined) this.integerDotProduct64BitMixedSignednessAccelerated = data.integerDotProduct64BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitSignedAccelerated = data.integerDotProductAccumulatingSaturating8BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitSignedAccelerated = data.integerDotProductAccumulatingSaturating16BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitSignedAccelerated = data.integerDotProductAccumulatingSaturating32BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitSignedAccelerated = data.integerDotProductAccumulatingSaturating64BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
      if (data.storageTexelBufferOffsetAlignmentBytes !== undefined) this.storageTexelBufferOffsetAlignmentBytes = data.storageTexelBufferOffsetAlignmentBytes;
      if (data.storageTexelBufferOffsetSingleTexelAlignment !== undefined) this.storageTexelBufferOffsetSingleTexelAlignment = data.storageTexelBufferOffsetSingleTexelAlignment;
      if (data.uniformTexelBufferOffsetAlignmentBytes !== undefined) this.uniformTexelBufferOffsetAlignmentBytes = data.uniformTexelBufferOffsetAlignmentBytes;
      if (data.uniformTexelBufferOffsetSingleTexelAlignment !== undefined) this.uniformTexelBufferOffsetSingleTexelAlignment = data.uniformTexelBufferOffsetSingleTexelAlignment;
      if (data.maxBufferSize !== undefined) this.maxBufferSize = data.maxBufferSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minSubgroupSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set minSubgroupSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxSubgroupSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxSubgroupSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxComputeWorkgroupSubgroups() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxComputeWorkgroupSubgroups(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get requiredSubgroupSizeStages() {
    return this.#view.getUint32(28, LE);
  }
  
  set requiredSubgroupSizeStages(value: ShaderStageFlags) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get maxInlineUniformBlockSize() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxInlineUniformBlockSize(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxPerStageDescriptorInlineUniformBlocks() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxPerStageDescriptorInlineUniformBlocks(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxDescriptorSetInlineUniformBlocks() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxDescriptorSetInlineUniformBlocks(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxDescriptorSetUpdateAfterBindInlineUniformBlocks(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxInlineUniformTotalSize() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxInlineUniformTotalSize(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get integerDotProduct8BitUnsignedAccelerated() {
    return this.#view.getUint32(56, LE);
  }
  
  set integerDotProduct8BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get integerDotProduct8BitSignedAccelerated() {
    return this.#view.getUint32(60, LE);
  }
  
  set integerDotProduct8BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get integerDotProduct8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(64, LE);
  }
  
  set integerDotProduct8BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(68, LE);
  }
  
  set integerDotProduct4x8BitPackedUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(72, LE);
  }
  
  set integerDotProduct4x8BitPackedSignedAccelerated(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(76, LE);
  }
  
  set integerDotProduct4x8BitPackedMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get integerDotProduct16BitUnsignedAccelerated() {
    return this.#view.getUint32(80, LE);
  }
  
  set integerDotProduct16BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get integerDotProduct16BitSignedAccelerated() {
    return this.#view.getUint32(84, LE);
  }
  
  set integerDotProduct16BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get integerDotProduct16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(88, LE);
  }
  
  set integerDotProduct16BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get integerDotProduct32BitUnsignedAccelerated() {
    return this.#view.getUint32(92, LE);
  }
  
  set integerDotProduct32BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get integerDotProduct32BitSignedAccelerated() {
    return this.#view.getUint32(96, LE);
  }
  
  set integerDotProduct32BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get integerDotProduct32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(100, LE);
  }
  
  set integerDotProduct32BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get integerDotProduct64BitUnsignedAccelerated() {
    return this.#view.getUint32(104, LE);
  }
  
  set integerDotProduct64BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get integerDotProduct64BitSignedAccelerated() {
    return this.#view.getUint32(108, LE);
  }
  
  set integerDotProduct64BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get integerDotProduct64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(112, LE);
  }
  
  set integerDotProduct64BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
    return this.#view.getUint32(116, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
    return this.#view.getUint32(120, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(124, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(128, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(132, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated(value: Bool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(136, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
    return this.#view.getUint32(140, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
    return this.#view.getUint32(144, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(144, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(148, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(148, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
    return this.#view.getUint32(152, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(152, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
    return this.#view.getUint32(156, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(156, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(160, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(160, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
    return this.#view.getUint32(164, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(164, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
    return this.#view.getUint32(168, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(168, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(172, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(172, Number(value), LE);
  }
  
  get storageTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set storageTexelBufferOffsetAlignmentBytes(value: DeviceSize) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
  
  get storageTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(184, LE);
  }
  
  set storageTexelBufferOffsetSingleTexelAlignment(value: Bool32) {
    this.#view.setUint32(184, Number(value), LE);
  }
  
  get uniformTexelBufferOffsetAlignmentBytes() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set uniformTexelBufferOffsetAlignmentBytes(value: DeviceSize) {
    this.#view.setBigUint64(192, BigInt(value), LE);
  }
  
  get uniformTexelBufferOffsetSingleTexelAlignment() {
    return this.#view.getUint32(200, LE);
  }
  
  set uniformTexelBufferOffsetSingleTexelAlignment(value: Bool32) {
    this.#view.setUint32(200, Number(value), LE);
  }
  
  get maxBufferSize() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set maxBufferSize(value: DeviceSize) {
    this.#view.setBigUint64(208, BigInt(value), LE);
  }
}

export interface InitPipelineCompilerControlCreateInfoAMD {
  pNext?: AnyPointer;
  compilerControlFlags?: PipelineCompilerControlFlagsAMD;
}

export class PipelineCompilerControlCreateInfoAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineCompilerControlCreateInfoAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineCompilerControlCreateInfoAMD) {
    if (!data) {
      this.#data = new Uint8Array(PipelineCompilerControlCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineCompilerControlCreateInfoAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineCompilerControlCreateInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.compilerControlFlags !== undefined) this.compilerControlFlags = data.compilerControlFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get compilerControlFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set compilerControlFlags(value: PipelineCompilerControlFlagsAMD) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCoherentMemoryFeaturesAMD {
  pNext?: AnyPointer;
  deviceCoherentMemory?: Bool32;
}

export class PhysicalDeviceCoherentMemoryFeaturesAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCoherentMemoryFeaturesAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCoherentMemoryFeaturesAMD) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCoherentMemoryFeaturesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCoherentMemoryFeaturesAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCoherentMemoryFeaturesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceCoherentMemory !== undefined) this.deviceCoherentMemory = data.deviceCoherentMemory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceCoherentMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceCoherentMemory(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceToolProperties {
  pNext?: AnyPointer;
  name?: number[];
  version?: number[];
  purposes?: ToolPurposeFlags;
  description?: number[];
  layer?: number[];
}

export class PhysicalDeviceToolProperties implements BaseStruct {
  static size = 1048;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceToolProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceToolProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceToolProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceToolProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceToolProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.name !== undefined) this.name = data.name;
      if (data.version !== undefined) this.version = data.version;
      if (data.purposes !== undefined) this.purposes = data.purposes;
      if (data.description !== undefined) this.description = data.description;
      if (data.layer !== undefined) this.layer = data.layer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get name() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set name(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get version() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(272 + i * 1);
      })());
    }
    return result;
  }
  
  set version(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(272 + i * 1, Number(value[i]));
    }
  }
  
  get purposes() {
    return this.#view.getUint32(528, LE);
  }
  
  set purposes(value: ToolPurposeFlags) {
    this.#view.setUint32(528, Number(value), LE);
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(532 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(532 + i * 1, Number(value[i]));
    }
  }
  
  get layer() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(788 + i * 1);
      })());
    }
    return result;
  }
  
  set layer(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(788 + i * 1, Number(value[i]));
    }
  }
}

export interface InitSamplerCustomBorderColorCreateInfoEXT {
  pNext?: AnyPointer;
  customBorderColor?: ClearColorValue;
  format?: Format;
}

export class SamplerCustomBorderColorCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerCustomBorderColorCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerCustomBorderColorCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SamplerCustomBorderColorCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerCustomBorderColorCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerCustomBorderColorCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.customBorderColor !== undefined) this.customBorderColor = data.customBorderColor;
      if (data.format !== undefined) this.format = data.format;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get customBorderColor() {
    throw new Error(`Unknown type: {"union":["f32","i32","u32"]}`);
  }
  
  set customBorderColor(value: ClearColorValue) {
    throw new Error(`Unknown type: {"union":["f32","i32","u32"]}`);
  }
  
  get format() {
    return this.#view.getUint32(20, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCustomBorderColorPropertiesEXT {
  pNext?: AnyPointer;
  maxCustomBorderColorSamplers?: number;
}

export class PhysicalDeviceCustomBorderColorPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCustomBorderColorPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCustomBorderColorPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCustomBorderColorPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCustomBorderColorPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCustomBorderColorPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxCustomBorderColorSamplers !== undefined) this.maxCustomBorderColorSamplers = data.maxCustomBorderColorSamplers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxCustomBorderColorSamplers() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxCustomBorderColorSamplers(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceCustomBorderColorFeaturesEXT {
  pNext?: AnyPointer;
  customBorderColors?: Bool32;
  customBorderColorWithoutFormat?: Bool32;
}

export class PhysicalDeviceCustomBorderColorFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceCustomBorderColorFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceCustomBorderColorFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceCustomBorderColorFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceCustomBorderColorFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceCustomBorderColorFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.customBorderColors !== undefined) this.customBorderColors = data.customBorderColors;
      if (data.customBorderColorWithoutFormat !== undefined) this.customBorderColorWithoutFormat = data.customBorderColorWithoutFormat;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get customBorderColors() {
    return this.#view.getUint32(16, LE);
  }
  
  set customBorderColors(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get customBorderColorWithoutFormat() {
    return this.#view.getUint32(20, LE);
  }
  
  set customBorderColorWithoutFormat(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitSamplerBorderColorComponentMappingCreateInfoEXT {
  pNext?: AnyPointer;
  components?: ComponentMapping;
  srgb?: Bool32;
}

export class SamplerBorderColorComponentMappingCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerBorderColorComponentMappingCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerBorderColorComponentMappingCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SamplerBorderColorComponentMappingCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerBorderColorComponentMappingCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerBorderColorComponentMappingCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.components !== undefined) this.components = data.components;
      if (data.srgb !== undefined) this.srgb = data.srgb;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get components() {
    return new ComponentMapping(this.#data.subarray(16, 16 + ComponentMapping.size));
  }
  
  set components(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srgb() {
    return this.#view.getUint32(32, LE);
  }
  
  set srgb(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceBorderColorSwizzleFeaturesEXT {
  pNext?: AnyPointer;
  borderColorSwizzle?: Bool32;
  borderColorSwizzleFromImage?: Bool32;
}

export class PhysicalDeviceBorderColorSwizzleFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceBorderColorSwizzleFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceBorderColorSwizzleFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceBorderColorSwizzleFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceBorderColorSwizzleFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceBorderColorSwizzleFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.borderColorSwizzle !== undefined) this.borderColorSwizzle = data.borderColorSwizzle;
      if (data.borderColorSwizzleFromImage !== undefined) this.borderColorSwizzleFromImage = data.borderColorSwizzleFromImage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get borderColorSwizzle() {
    return this.#view.getUint32(16, LE);
  }
  
  set borderColorSwizzle(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get borderColorSwizzleFromImage() {
    return this.#view.getUint32(20, LE);
  }
  
  set borderColorSwizzleFromImage(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitAccelerationStructureGeometryTrianglesDataKHR {
  pNext?: AnyPointer;
  vertexFormat?: Format;
  vertexData?: DeviceOrHostAddressConstKHR;
  vertexStride?: DeviceSize;
  maxVertex?: number;
  indexType?: IndexType;
  indexData?: DeviceOrHostAddressConstKHR;
  transformData?: DeviceOrHostAddressConstKHR;
}

export class AccelerationStructureGeometryTrianglesDataKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureGeometryTrianglesDataKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureGeometryTrianglesDataKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureGeometryTrianglesDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureGeometryTrianglesDataKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureGeometryTrianglesDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexFormat !== undefined) this.vertexFormat = data.vertexFormat;
      if (data.vertexData !== undefined) this.vertexData = data.vertexData;
      if (data.vertexStride !== undefined) this.vertexStride = data.vertexStride;
      if (data.maxVertex !== undefined) this.maxVertex = data.maxVertex;
      if (data.indexType !== undefined) this.indexType = data.indexType;
      if (data.indexData !== undefined) this.indexData = data.indexData;
      if (data.transformData !== undefined) this.transformData = data.transformData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexFormat() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexFormat(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vertexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set vertexData(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get vertexStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set vertexStride(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxVertex() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxVertex(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(44, LE);
  }
  
  set indexType(value: IndexType) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get indexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set indexData(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get transformData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set transformData(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export interface InitAccelerationStructureGeometryAabbsDataKHR {
  pNext?: AnyPointer;
  data?: DeviceOrHostAddressConstKHR;
  stride?: DeviceSize;
}

export class AccelerationStructureGeometryAabbsDataKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureGeometryAabbsDataKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureGeometryAabbsDataKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureGeometryAabbsDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureGeometryAabbsDataKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureGeometryAabbsDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.data !== undefined) this.data = data.data;
      if (data.stride !== undefined) this.stride = data.stride;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get stride() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set stride(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitAccelerationStructureGeometryInstancesDataKHR {
  pNext?: AnyPointer;
  arrayOfPointers?: Bool32;
  data?: DeviceOrHostAddressConstKHR;
}

export class AccelerationStructureGeometryInstancesDataKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureGeometryInstancesDataKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureGeometryInstancesDataKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureGeometryInstancesDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureGeometryInstancesDataKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureGeometryInstancesDataKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.arrayOfPointers !== undefined) this.arrayOfPointers = data.arrayOfPointers;
      if (data.data !== undefined) this.data = data.data;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get arrayOfPointers() {
    return this.#view.getUint32(16, LE);
  }
  
  set arrayOfPointers(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export interface InitAccelerationStructureGeometryKHR {
  pNext?: AnyPointer;
  geometryType?: GeometryTypeKHR;
  geometry?: AccelerationStructureGeometryDataKHR;
  flags?: GeometryFlagsKHR;
}

export class AccelerationStructureGeometryKHR implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureGeometryKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureGeometryKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureGeometryKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureGeometryKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureGeometryKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.geometryType !== undefined) this.geometryType = data.geometryType;
      if (data.geometry !== undefined) this.geometry = data.geometry;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get geometryType() {
    return this.#view.getUint32(16, LE);
  }
  
  set geometryType(value: GeometryTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get geometry() {
    throw new Error(`Unknown type: {"union":[{"struct":["u32","buffer","u32",{"union":["u64","buffer"]},"u64","u32","u32",{"union":["u64","buffer"]},{"union":["u64","buffer"]}]},{"struct":["u32","buffer",{"union":["u64","buffer"]},"u64"]},{"struct":["u32","buffer","u32",{"union":["u64","buffer"]}]}]}`);
  }
  
  set geometry(value: AccelerationStructureGeometryDataKHR) {
    throw new Error(`Unknown type: {"union":[{"struct":["u32","buffer","u32",{"union":["u64","buffer"]},"u64","u32","u32",{"union":["u64","buffer"]},{"union":["u64","buffer"]}]},{"struct":["u32","buffer",{"union":["u64","buffer"]},"u64"]},{"struct":["u32","buffer","u32",{"union":["u64","buffer"]}]}]}`);
  }
  
  get flags() {
    return this.#view.getUint32(84, LE);
  }
  
  set flags(value: GeometryFlagsKHR) {
    this.#view.setUint32(84, Number(value), LE);
  }
}

export interface InitAccelerationStructureBuildGeometryInfoKHR {
  pNext?: AnyPointer;
  type?: AccelerationStructureTypeKHR;
  flags?: BuildAccelerationStructureFlagsKHR;
  mode?: BuildAccelerationStructureModeKHR;
  srcAccelerationStructure?: AccelerationStructureKHR;
  dstAccelerationStructure?: AccelerationStructureKHR;
  geometryCount?: number;
  pGeometries?: AnyPointer;
  ppGeometries?: AnyPointer;
  scratchData?: DeviceOrHostAddressKHR;
}

export class AccelerationStructureBuildGeometryInfoKHR implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureBuildGeometryInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureBuildGeometryInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureBuildGeometryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureBuildGeometryInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureBuildGeometryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.mode !== undefined) this.mode = data.mode;
      if (data.srcAccelerationStructure !== undefined) this.srcAccelerationStructure = data.srcAccelerationStructure;
      if (data.dstAccelerationStructure !== undefined) this.dstAccelerationStructure = data.dstAccelerationStructure;
      if (data.geometryCount !== undefined) this.geometryCount = data.geometryCount;
      if (data.pGeometries !== undefined) this.pGeometries = data.pGeometries;
      if (data.ppGeometries !== undefined) this.ppGeometries = data.ppGeometries;
      if (data.scratchData !== undefined) this.scratchData = data.scratchData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: AccelerationStructureTypeKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: BuildAccelerationStructureFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(24, LE);
  }
  
  set mode(value: BuildAccelerationStructureModeKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get srcAccelerationStructure() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set srcAccelerationStructure(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get dstAccelerationStructure() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccelerationStructure(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get geometryCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set geometryCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pGeometries() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pGeometries(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get ppGeometries() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set ppGeometries(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get scratchData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set scratchData(value: DeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export interface InitAccelerationStructureBuildRangeInfoKHR {
  primitiveCount?: number;
  primitiveOffset?: number;
  firstVertex?: number;
  transformOffset?: number;
}

export class AccelerationStructureBuildRangeInfoKHR implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureBuildRangeInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureBuildRangeInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureBuildRangeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureBuildRangeInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureBuildRangeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.primitiveCount !== undefined) this.primitiveCount = data.primitiveCount;
      if (data.primitiveOffset !== undefined) this.primitiveOffset = data.primitiveOffset;
      if (data.firstVertex !== undefined) this.firstVertex = data.firstVertex;
      if (data.transformOffset !== undefined) this.transformOffset = data.transformOffset;
    }
  }
  
  get primitiveCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set primitiveCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get primitiveOffset() {
    return this.#view.getUint32(4, LE);
  }
  
  set primitiveOffset(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get firstVertex() {
    return this.#view.getUint32(8, LE);
  }
  
  set firstVertex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get transformOffset() {
    return this.#view.getUint32(12, LE);
  }
  
  set transformOffset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
}

export interface InitAccelerationStructureCreateInfoKHR {
  pNext?: AnyPointer;
  createFlags?: AccelerationStructureCreateFlagsKHR;
  buffer?: Buffer;
  offset?: DeviceSize;
  size?: DeviceSize;
  type?: AccelerationStructureTypeKHR;
  deviceAddress?: DeviceAddress;
}

export class AccelerationStructureCreateInfoKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.createFlags !== undefined) this.createFlags = data.createFlags;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
      if (data.type !== undefined) this.type = data.type;
      if (data.deviceAddress !== undefined) this.deviceAddress = data.deviceAddress;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get createFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set createFlags(value: AccelerationStructureCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(48, LE);
  }
  
  set type(value: AccelerationStructureTypeKHR) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set deviceAddress(value: DeviceAddress) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export interface InitAabbPositionsKHR {
  minX?: number;
  minY?: number;
  minZ?: number;
  maxX?: number;
  maxY?: number;
  maxZ?: number;
}

export class AabbPositionsKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAabbPositionsKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAabbPositionsKHR) {
    if (!data) {
      this.#data = new Uint8Array(AabbPositionsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AabbPositionsKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AabbPositionsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.minX !== undefined) this.minX = data.minX;
      if (data.minY !== undefined) this.minY = data.minY;
      if (data.minZ !== undefined) this.minZ = data.minZ;
      if (data.maxX !== undefined) this.maxX = data.maxX;
      if (data.maxY !== undefined) this.maxY = data.maxY;
      if (data.maxZ !== undefined) this.maxZ = data.maxZ;
    }
  }
  
  get minX() {
    return this.#view.getFloat32(0, LE);
  }
  
  set minX(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get minY() {
    return this.#view.getFloat32(4, LE);
  }
  
  set minY(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get minZ() {
    return this.#view.getFloat32(8, LE);
  }
  
  set minZ(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get maxX() {
    return this.#view.getFloat32(12, LE);
  }
  
  set maxX(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get maxY() {
    return this.#view.getFloat32(16, LE);
  }
  
  set maxY(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get maxZ() {
    return this.#view.getFloat32(20, LE);
  }
  
  set maxZ(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
}

export interface InitTransformMatrixKHR {
  matrix?: number[];
}

export class TransformMatrixKHR implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTransformMatrixKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTransformMatrixKHR) {
    if (!data) {
      this.#data = new Uint8Array(TransformMatrixKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TransformMatrixKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TransformMatrixKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.matrix !== undefined) this.matrix = data.matrix;
    }
  }
  
  get matrix() {
    const result: number[] = [];
    for (let i = 0; i < 3; i++) {
      result.push((() => {
        return this.#view.getFloat32(0 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set matrix(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setFloat32(0 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitAccelerationStructureInstanceKHR {
  transform?: TransformMatrixKHR;
  instanceCustomIndex?: number;
  mask?: number;
  instanceShaderBindingTableRecordOffset?: number;
  flags?: GeometryInstanceFlagsKHR;
  accelerationStructureReference?: Deno.PointerValue;
}

export class AccelerationStructureInstanceKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureInstanceKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureInstanceKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureInstanceKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureInstanceKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureInstanceKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.transform !== undefined) this.transform = data.transform;
      if (data.instanceCustomIndex !== undefined) this.instanceCustomIndex = data.instanceCustomIndex;
      if (data.mask !== undefined) this.mask = data.mask;
      if (data.instanceShaderBindingTableRecordOffset !== undefined) this.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.accelerationStructureReference !== undefined) this.accelerationStructureReference = data.accelerationStructureReference;
    }
  }
  
  get transform() {
    return new TransformMatrixKHR(this.#data.subarray(0, 0 + TransformMatrixKHR.size));
  }
  
  set transform(value: TransformMatrixKHR) {
    if (value[BUFFER].byteLength < TransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(4, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(8, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(12, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: GeometryInstanceFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitAccelerationStructureDeviceAddressInfoKHR {
  pNext?: AnyPointer;
  accelerationStructure?: AccelerationStructureKHR;
}

export class AccelerationStructureDeviceAddressInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureDeviceAddressInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureDeviceAddressInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureDeviceAddressInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureDeviceAddressInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureDeviceAddressInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructure !== undefined) this.accelerationStructure = data.accelerationStructure;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAccelerationStructureVersionInfoKHR {
  pNext?: AnyPointer;
  pVersionData?: AnyPointer;
}

export class AccelerationStructureVersionInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureVersionInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureVersionInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureVersionInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureVersionInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureVersionInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pVersionData !== undefined) this.pVersionData = data.pVersionData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pVersionData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pVersionData(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCopyAccelerationStructureInfoKHR {
  pNext?: AnyPointer;
  src?: AccelerationStructureKHR;
  dst?: AccelerationStructureKHR;
  mode?: CopyAccelerationStructureModeKHR;
}

export class CopyAccelerationStructureInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyAccelerationStructureInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyAccelerationStructureInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(CopyAccelerationStructureInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyAccelerationStructureInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyAccelerationStructureInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitCopyAccelerationStructureToMemoryInfoKHR {
  pNext?: AnyPointer;
  src?: AccelerationStructureKHR;
  dst?: DeviceOrHostAddressKHR;
  mode?: CopyAccelerationStructureModeKHR;
}

export class CopyAccelerationStructureToMemoryInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyAccelerationStructureToMemoryInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyAccelerationStructureToMemoryInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(CopyAccelerationStructureToMemoryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyAccelerationStructureToMemoryInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyAccelerationStructureToMemoryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dst() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set dst(value: DeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitCopyMemoryToAccelerationStructureInfoKHR {
  pNext?: AnyPointer;
  src?: DeviceOrHostAddressConstKHR;
  dst?: AccelerationStructureKHR;
  mode?: CopyAccelerationStructureModeKHR;
}

export class CopyMemoryToAccelerationStructureInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMemoryToAccelerationStructureInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMemoryToAccelerationStructureInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(CopyMemoryToAccelerationStructureInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMemoryToAccelerationStructureInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMemoryToAccelerationStructureInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set src(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyAccelerationStructureModeKHR) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitRayTracingPipelineInterfaceCreateInfoKHR {
  pNext?: AnyPointer;
  maxPipelineRayPayloadSize?: number;
  maxPipelineRayHitAttributeSize?: number;
}

export class RayTracingPipelineInterfaceCreateInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRayTracingPipelineInterfaceCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRayTracingPipelineInterfaceCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(RayTracingPipelineInterfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RayTracingPipelineInterfaceCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RayTracingPipelineInterfaceCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxPipelineRayPayloadSize !== undefined) this.maxPipelineRayPayloadSize = data.maxPipelineRayPayloadSize;
      if (data.maxPipelineRayHitAttributeSize !== undefined) this.maxPipelineRayHitAttributeSize = data.maxPipelineRayHitAttributeSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxPipelineRayPayloadSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxPipelineRayPayloadSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxPipelineRayHitAttributeSize() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxPipelineRayHitAttributeSize(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPipelineLibraryCreateInfoKHR {
  pNext?: AnyPointer;
  libraryCount?: number;
  pLibraries?: AnyPointer;
}

export class PipelineLibraryCreateInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineLibraryCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineLibraryCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineLibraryCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineLibraryCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineLibraryCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.libraryCount !== undefined) this.libraryCount = data.libraryCount;
      if (data.pLibraries !== undefined) this.pLibraries = data.pLibraries;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get libraryCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set libraryCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pLibraries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pLibraries(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceExtendedDynamicStateFeaturesEXT {
  pNext?: AnyPointer;
  extendedDynamicState?: Bool32;
}

export class PhysicalDeviceExtendedDynamicStateFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExtendedDynamicStateFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExtendedDynamicStateFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicStateFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExtendedDynamicStateFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicStateFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.extendedDynamicState !== undefined) this.extendedDynamicState = data.extendedDynamicState;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get extendedDynamicState() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExtendedDynamicState2FeaturesEXT {
  pNext?: AnyPointer;
  extendedDynamicState2?: Bool32;
  extendedDynamicState2LogicOp?: Bool32;
  extendedDynamicState2PatchControlPoints?: Bool32;
}

export class PhysicalDeviceExtendedDynamicState2FeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExtendedDynamicState2FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExtendedDynamicState2FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExtendedDynamicState2FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.extendedDynamicState2 !== undefined) this.extendedDynamicState2 = data.extendedDynamicState2;
      if (data.extendedDynamicState2LogicOp !== undefined) this.extendedDynamicState2LogicOp = data.extendedDynamicState2LogicOp;
      if (data.extendedDynamicState2PatchControlPoints !== undefined) this.extendedDynamicState2PatchControlPoints = data.extendedDynamicState2PatchControlPoints;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get extendedDynamicState2() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState2(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get extendedDynamicState2LogicOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set extendedDynamicState2LogicOp(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extendedDynamicState2PatchControlPoints() {
    return this.#view.getUint32(24, LE);
  }
  
  set extendedDynamicState2PatchControlPoints(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExtendedDynamicState3FeaturesEXT {
  pNext?: AnyPointer;
  extendedDynamicState3TessellationDomainOrigin?: Bool32;
  extendedDynamicState3DepthClampEnable?: Bool32;
  extendedDynamicState3PolygonMode?: Bool32;
  extendedDynamicState3RasterizationSamples?: Bool32;
  extendedDynamicState3SampleMask?: Bool32;
  extendedDynamicState3AlphaToCoverageEnable?: Bool32;
  extendedDynamicState3AlphaToOneEnable?: Bool32;
  extendedDynamicState3LogicOpEnable?: Bool32;
  extendedDynamicState3ColorBlendEnable?: Bool32;
  extendedDynamicState3ColorBlendEquation?: Bool32;
  extendedDynamicState3ColorWriteMask?: Bool32;
  extendedDynamicState3RasterizationStream?: Bool32;
  extendedDynamicState3ConservativeRasterizationMode?: Bool32;
  extendedDynamicState3ExtraPrimitiveOverestimationSize?: Bool32;
  extendedDynamicState3DepthClipEnable?: Bool32;
  extendedDynamicState3SampleLocationsEnable?: Bool32;
  extendedDynamicState3ColorBlendAdvanced?: Bool32;
  extendedDynamicState3ProvokingVertexMode?: Bool32;
  extendedDynamicState3LineRasterizationMode?: Bool32;
  extendedDynamicState3LineStippleEnable?: Bool32;
  extendedDynamicState3DepthClipNegativeOneToOne?: Bool32;
  extendedDynamicState3ViewportWScalingEnable?: Bool32;
  extendedDynamicState3ViewportSwizzle?: Bool32;
  extendedDynamicState3CoverageToColorEnable?: Bool32;
  extendedDynamicState3CoverageToColorLocation?: Bool32;
  extendedDynamicState3CoverageModulationMode?: Bool32;
  extendedDynamicState3CoverageModulationTableEnable?: Bool32;
  extendedDynamicState3CoverageModulationTable?: Bool32;
  extendedDynamicState3CoverageReductionMode?: Bool32;
  extendedDynamicState3RepresentativeFragmentTestEnable?: Bool32;
  extendedDynamicState3ShadingRateImageEnable?: Bool32;
}

export class PhysicalDeviceExtendedDynamicState3FeaturesEXT implements BaseStruct {
  static size = 144;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExtendedDynamicState3FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExtendedDynamicState3FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState3FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExtendedDynamicState3FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState3FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.extendedDynamicState3TessellationDomainOrigin !== undefined) this.extendedDynamicState3TessellationDomainOrigin = data.extendedDynamicState3TessellationDomainOrigin;
      if (data.extendedDynamicState3DepthClampEnable !== undefined) this.extendedDynamicState3DepthClampEnable = data.extendedDynamicState3DepthClampEnable;
      if (data.extendedDynamicState3PolygonMode !== undefined) this.extendedDynamicState3PolygonMode = data.extendedDynamicState3PolygonMode;
      if (data.extendedDynamicState3RasterizationSamples !== undefined) this.extendedDynamicState3RasterizationSamples = data.extendedDynamicState3RasterizationSamples;
      if (data.extendedDynamicState3SampleMask !== undefined) this.extendedDynamicState3SampleMask = data.extendedDynamicState3SampleMask;
      if (data.extendedDynamicState3AlphaToCoverageEnable !== undefined) this.extendedDynamicState3AlphaToCoverageEnable = data.extendedDynamicState3AlphaToCoverageEnable;
      if (data.extendedDynamicState3AlphaToOneEnable !== undefined) this.extendedDynamicState3AlphaToOneEnable = data.extendedDynamicState3AlphaToOneEnable;
      if (data.extendedDynamicState3LogicOpEnable !== undefined) this.extendedDynamicState3LogicOpEnable = data.extendedDynamicState3LogicOpEnable;
      if (data.extendedDynamicState3ColorBlendEnable !== undefined) this.extendedDynamicState3ColorBlendEnable = data.extendedDynamicState3ColorBlendEnable;
      if (data.extendedDynamicState3ColorBlendEquation !== undefined) this.extendedDynamicState3ColorBlendEquation = data.extendedDynamicState3ColorBlendEquation;
      if (data.extendedDynamicState3ColorWriteMask !== undefined) this.extendedDynamicState3ColorWriteMask = data.extendedDynamicState3ColorWriteMask;
      if (data.extendedDynamicState3RasterizationStream !== undefined) this.extendedDynamicState3RasterizationStream = data.extendedDynamicState3RasterizationStream;
      if (data.extendedDynamicState3ConservativeRasterizationMode !== undefined) this.extendedDynamicState3ConservativeRasterizationMode = data.extendedDynamicState3ConservativeRasterizationMode;
      if (data.extendedDynamicState3ExtraPrimitiveOverestimationSize !== undefined) this.extendedDynamicState3ExtraPrimitiveOverestimationSize = data.extendedDynamicState3ExtraPrimitiveOverestimationSize;
      if (data.extendedDynamicState3DepthClipEnable !== undefined) this.extendedDynamicState3DepthClipEnable = data.extendedDynamicState3DepthClipEnable;
      if (data.extendedDynamicState3SampleLocationsEnable !== undefined) this.extendedDynamicState3SampleLocationsEnable = data.extendedDynamicState3SampleLocationsEnable;
      if (data.extendedDynamicState3ColorBlendAdvanced !== undefined) this.extendedDynamicState3ColorBlendAdvanced = data.extendedDynamicState3ColorBlendAdvanced;
      if (data.extendedDynamicState3ProvokingVertexMode !== undefined) this.extendedDynamicState3ProvokingVertexMode = data.extendedDynamicState3ProvokingVertexMode;
      if (data.extendedDynamicState3LineRasterizationMode !== undefined) this.extendedDynamicState3LineRasterizationMode = data.extendedDynamicState3LineRasterizationMode;
      if (data.extendedDynamicState3LineStippleEnable !== undefined) this.extendedDynamicState3LineStippleEnable = data.extendedDynamicState3LineStippleEnable;
      if (data.extendedDynamicState3DepthClipNegativeOneToOne !== undefined) this.extendedDynamicState3DepthClipNegativeOneToOne = data.extendedDynamicState3DepthClipNegativeOneToOne;
      if (data.extendedDynamicState3ViewportWScalingEnable !== undefined) this.extendedDynamicState3ViewportWScalingEnable = data.extendedDynamicState3ViewportWScalingEnable;
      if (data.extendedDynamicState3ViewportSwizzle !== undefined) this.extendedDynamicState3ViewportSwizzle = data.extendedDynamicState3ViewportSwizzle;
      if (data.extendedDynamicState3CoverageToColorEnable !== undefined) this.extendedDynamicState3CoverageToColorEnable = data.extendedDynamicState3CoverageToColorEnable;
      if (data.extendedDynamicState3CoverageToColorLocation !== undefined) this.extendedDynamicState3CoverageToColorLocation = data.extendedDynamicState3CoverageToColorLocation;
      if (data.extendedDynamicState3CoverageModulationMode !== undefined) this.extendedDynamicState3CoverageModulationMode = data.extendedDynamicState3CoverageModulationMode;
      if (data.extendedDynamicState3CoverageModulationTableEnable !== undefined) this.extendedDynamicState3CoverageModulationTableEnable = data.extendedDynamicState3CoverageModulationTableEnable;
      if (data.extendedDynamicState3CoverageModulationTable !== undefined) this.extendedDynamicState3CoverageModulationTable = data.extendedDynamicState3CoverageModulationTable;
      if (data.extendedDynamicState3CoverageReductionMode !== undefined) this.extendedDynamicState3CoverageReductionMode = data.extendedDynamicState3CoverageReductionMode;
      if (data.extendedDynamicState3RepresentativeFragmentTestEnable !== undefined) this.extendedDynamicState3RepresentativeFragmentTestEnable = data.extendedDynamicState3RepresentativeFragmentTestEnable;
      if (data.extendedDynamicState3ShadingRateImageEnable !== undefined) this.extendedDynamicState3ShadingRateImageEnable = data.extendedDynamicState3ShadingRateImageEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get extendedDynamicState3TessellationDomainOrigin() {
    return this.#view.getUint32(16, LE);
  }
  
  set extendedDynamicState3TessellationDomainOrigin(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClampEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set extendedDynamicState3DepthClampEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get extendedDynamicState3PolygonMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set extendedDynamicState3PolygonMode(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get extendedDynamicState3RasterizationSamples() {
    return this.#view.getUint32(28, LE);
  }
  
  set extendedDynamicState3RasterizationSamples(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get extendedDynamicState3SampleMask() {
    return this.#view.getUint32(32, LE);
  }
  
  set extendedDynamicState3SampleMask(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get extendedDynamicState3AlphaToCoverageEnable() {
    return this.#view.getUint32(36, LE);
  }
  
  set extendedDynamicState3AlphaToCoverageEnable(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get extendedDynamicState3AlphaToOneEnable() {
    return this.#view.getUint32(40, LE);
  }
  
  set extendedDynamicState3AlphaToOneEnable(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get extendedDynamicState3LogicOpEnable() {
    return this.#view.getUint32(44, LE);
  }
  
  set extendedDynamicState3LogicOpEnable(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendEnable() {
    return this.#view.getUint32(48, LE);
  }
  
  set extendedDynamicState3ColorBlendEnable(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendEquation() {
    return this.#view.getUint32(52, LE);
  }
  
  set extendedDynamicState3ColorBlendEquation(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get extendedDynamicState3ColorWriteMask() {
    return this.#view.getUint32(56, LE);
  }
  
  set extendedDynamicState3ColorWriteMask(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get extendedDynamicState3RasterizationStream() {
    return this.#view.getUint32(60, LE);
  }
  
  set extendedDynamicState3RasterizationStream(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get extendedDynamicState3ConservativeRasterizationMode() {
    return this.#view.getUint32(64, LE);
  }
  
  set extendedDynamicState3ConservativeRasterizationMode(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get extendedDynamicState3ExtraPrimitiveOverestimationSize() {
    return this.#view.getUint32(68, LE);
  }
  
  set extendedDynamicState3ExtraPrimitiveOverestimationSize(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClipEnable() {
    return this.#view.getUint32(72, LE);
  }
  
  set extendedDynamicState3DepthClipEnable(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get extendedDynamicState3SampleLocationsEnable() {
    return this.#view.getUint32(76, LE);
  }
  
  set extendedDynamicState3SampleLocationsEnable(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get extendedDynamicState3ColorBlendAdvanced() {
    return this.#view.getUint32(80, LE);
  }
  
  set extendedDynamicState3ColorBlendAdvanced(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get extendedDynamicState3ProvokingVertexMode() {
    return this.#view.getUint32(84, LE);
  }
  
  set extendedDynamicState3ProvokingVertexMode(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get extendedDynamicState3LineRasterizationMode() {
    return this.#view.getUint32(88, LE);
  }
  
  set extendedDynamicState3LineRasterizationMode(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get extendedDynamicState3LineStippleEnable() {
    return this.#view.getUint32(92, LE);
  }
  
  set extendedDynamicState3LineStippleEnable(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get extendedDynamicState3DepthClipNegativeOneToOne() {
    return this.#view.getUint32(96, LE);
  }
  
  set extendedDynamicState3DepthClipNegativeOneToOne(value: Bool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get extendedDynamicState3ViewportWScalingEnable() {
    return this.#view.getUint32(100, LE);
  }
  
  set extendedDynamicState3ViewportWScalingEnable(value: Bool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get extendedDynamicState3ViewportSwizzle() {
    return this.#view.getUint32(104, LE);
  }
  
  set extendedDynamicState3ViewportSwizzle(value: Bool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageToColorEnable() {
    return this.#view.getUint32(108, LE);
  }
  
  set extendedDynamicState3CoverageToColorEnable(value: Bool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageToColorLocation() {
    return this.#view.getUint32(112, LE);
  }
  
  set extendedDynamicState3CoverageToColorLocation(value: Bool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationMode() {
    return this.#view.getUint32(116, LE);
  }
  
  set extendedDynamicState3CoverageModulationMode(value: Bool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationTableEnable() {
    return this.#view.getUint32(120, LE);
  }
  
  set extendedDynamicState3CoverageModulationTableEnable(value: Bool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageModulationTable() {
    return this.#view.getUint32(124, LE);
  }
  
  set extendedDynamicState3CoverageModulationTable(value: Bool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get extendedDynamicState3CoverageReductionMode() {
    return this.#view.getUint32(128, LE);
  }
  
  set extendedDynamicState3CoverageReductionMode(value: Bool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get extendedDynamicState3RepresentativeFragmentTestEnable() {
    return this.#view.getUint32(132, LE);
  }
  
  set extendedDynamicState3RepresentativeFragmentTestEnable(value: Bool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get extendedDynamicState3ShadingRateImageEnable() {
    return this.#view.getUint32(136, LE);
  }
  
  set extendedDynamicState3ShadingRateImageEnable(value: Bool32) {
    this.#view.setUint32(136, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExtendedDynamicState3PropertiesEXT {
  pNext?: AnyPointer;
  dynamicPrimitiveTopologyUnrestricted?: Bool32;
}

export class PhysicalDeviceExtendedDynamicState3PropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExtendedDynamicState3PropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExtendedDynamicState3PropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState3PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExtendedDynamicState3PropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExtendedDynamicState3PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dynamicPrimitiveTopologyUnrestricted !== undefined) this.dynamicPrimitiveTopologyUnrestricted = data.dynamicPrimitiveTopologyUnrestricted;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dynamicPrimitiveTopologyUnrestricted() {
    return this.#view.getUint32(16, LE);
  }
  
  set dynamicPrimitiveTopologyUnrestricted(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitColorBlendEquationEXT {
  srcColorBlendFactor?: BlendFactor;
  dstColorBlendFactor?: BlendFactor;
  colorBlendOp?: BlendOp;
  srcAlphaBlendFactor?: BlendFactor;
  dstAlphaBlendFactor?: BlendFactor;
  alphaBlendOp?: BlendOp;
}

export class ColorBlendEquationEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitColorBlendEquationEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitColorBlendEquationEXT) {
    if (!data) {
      this.#data = new Uint8Array(ColorBlendEquationEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ColorBlendEquationEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ColorBlendEquationEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcColorBlendFactor !== undefined) this.srcColorBlendFactor = data.srcColorBlendFactor;
      if (data.dstColorBlendFactor !== undefined) this.dstColorBlendFactor = data.dstColorBlendFactor;
      if (data.colorBlendOp !== undefined) this.colorBlendOp = data.colorBlendOp;
      if (data.srcAlphaBlendFactor !== undefined) this.srcAlphaBlendFactor = data.srcAlphaBlendFactor;
      if (data.dstAlphaBlendFactor !== undefined) this.dstAlphaBlendFactor = data.dstAlphaBlendFactor;
      if (data.alphaBlendOp !== undefined) this.alphaBlendOp = data.alphaBlendOp;
    }
  }
  
  get srcColorBlendFactor() {
    return this.#view.getUint32(0, LE);
  }
  
  set srcColorBlendFactor(value: BlendFactor) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get dstColorBlendFactor() {
    return this.#view.getUint32(4, LE);
  }
  
  set dstColorBlendFactor(value: BlendFactor) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get colorBlendOp() {
    return this.#view.getUint32(8, LE);
  }
  
  set colorBlendOp(value: BlendOp) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get srcAlphaBlendFactor() {
    return this.#view.getUint32(12, LE);
  }
  
  set srcAlphaBlendFactor(value: BlendFactor) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get dstAlphaBlendFactor() {
    return this.#view.getUint32(16, LE);
  }
  
  set dstAlphaBlendFactor(value: BlendFactor) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get alphaBlendOp() {
    return this.#view.getUint32(20, LE);
  }
  
  set alphaBlendOp(value: BlendOp) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitColorBlendAdvancedEXT {
  advancedBlendOp?: BlendOp;
  srcPremultiplied?: Bool32;
  dstPremultiplied?: Bool32;
  blendOverlap?: BlendOverlapEXT;
  clampResults?: Bool32;
}

export class ColorBlendAdvancedEXT implements BaseStruct {
  static size = 20;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitColorBlendAdvancedEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitColorBlendAdvancedEXT) {
    if (!data) {
      this.#data = new Uint8Array(ColorBlendAdvancedEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ColorBlendAdvancedEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ColorBlendAdvancedEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.advancedBlendOp !== undefined) this.advancedBlendOp = data.advancedBlendOp;
      if (data.srcPremultiplied !== undefined) this.srcPremultiplied = data.srcPremultiplied;
      if (data.dstPremultiplied !== undefined) this.dstPremultiplied = data.dstPremultiplied;
      if (data.blendOverlap !== undefined) this.blendOverlap = data.blendOverlap;
      if (data.clampResults !== undefined) this.clampResults = data.clampResults;
    }
  }
  
  get advancedBlendOp() {
    return this.#view.getUint32(0, LE);
  }
  
  set advancedBlendOp(value: BlendOp) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get srcPremultiplied() {
    return this.#view.getUint32(4, LE);
  }
  
  set srcPremultiplied(value: Bool32) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get dstPremultiplied() {
    return this.#view.getUint32(8, LE);
  }
  
  set dstPremultiplied(value: Bool32) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get blendOverlap() {
    return this.#view.getUint32(12, LE);
  }
  
  set blendOverlap(value: BlendOverlapEXT) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get clampResults() {
    return this.#view.getUint32(16, LE);
  }
  
  set clampResults(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitRenderPassTransformBeginInfoQCOM {
  pNext?: AnyPointer;
  transform?: SurfaceTransformFlagBitsKHR;
}

export class RenderPassTransformBeginInfoQCOM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassTransformBeginInfoQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassTransformBeginInfoQCOM) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassTransformBeginInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassTransformBeginInfoQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassTransformBeginInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.transform !== undefined) this.transform = data.transform;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCopyCommandTransformInfoQCOM {
  pNext?: AnyPointer;
  transform?: SurfaceTransformFlagBitsKHR;
}

export class CopyCommandTransformInfoQCOM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyCommandTransformInfoQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyCommandTransformInfoQCOM) {
    if (!data) {
      this.#data = new Uint8Array(CopyCommandTransformInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyCommandTransformInfoQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyCommandTransformInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.transform !== undefined) this.transform = data.transform;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCommandBufferInheritanceRenderPassTransformInfoQCOM {
  pNext?: AnyPointer;
  transform?: SurfaceTransformFlagBitsKHR;
  renderArea?: Rect2D;
}

export class CommandBufferInheritanceRenderPassTransformInfoQCOM implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferInheritanceRenderPassTransformInfoQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferInheritanceRenderPassTransformInfoQCOM) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferInheritanceRenderPassTransformInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferInheritanceRenderPassTransformInfoQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferInheritanceRenderPassTransformInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.transform !== undefined) this.transform = data.transform;
      if (data.renderArea !== undefined) this.renderArea = data.renderArea;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get transform() {
    return this.#view.getUint32(16, LE);
  }
  
  set transform(value: SurfaceTransformFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderArea() {
    return new Rect2D(this.#data.subarray(20, 20 + Rect2D.size));
  }
  
  set renderArea(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
}

export interface InitPhysicalDeviceDiagnosticsConfigFeaturesNV {
  pNext?: AnyPointer;
  diagnosticsConfig?: Bool32;
}

export class PhysicalDeviceDiagnosticsConfigFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDiagnosticsConfigFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDiagnosticsConfigFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDiagnosticsConfigFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDiagnosticsConfigFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDiagnosticsConfigFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.diagnosticsConfig !== undefined) this.diagnosticsConfig = data.diagnosticsConfig;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get diagnosticsConfig() {
    return this.#view.getUint32(16, LE);
  }
  
  set diagnosticsConfig(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceDiagnosticsConfigCreateInfoNV {
  pNext?: AnyPointer;
  flags?: DeviceDiagnosticsConfigFlagsNV;
}

export class DeviceDiagnosticsConfigCreateInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceDiagnosticsConfigCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceDiagnosticsConfigCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(DeviceDiagnosticsConfigCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceDiagnosticsConfigCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceDiagnosticsConfigCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceDiagnosticsConfigFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
  pNext?: AnyPointer;
  shaderZeroInitializeWorkgroupMemory?: Bool32;
}

export class PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderZeroInitializeWorkgroupMemory !== undefined) this.shaderZeroInitializeWorkgroupMemory = data.shaderZeroInitializeWorkgroupMemory;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderZeroInitializeWorkgroupMemory() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderZeroInitializeWorkgroupMemory(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
  pNext?: AnyPointer;
  shaderSubgroupUniformControlFlow?: Bool32;
}

export class PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderSubgroupUniformControlFlow !== undefined) this.shaderSubgroupUniformControlFlow = data.shaderSubgroupUniformControlFlow;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderSubgroupUniformControlFlow() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderSubgroupUniformControlFlow(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRobustness2FeaturesEXT {
  pNext?: AnyPointer;
  robustBufferAccess2?: Bool32;
  robustImageAccess2?: Bool32;
  nullDescriptor?: Bool32;
}

export class PhysicalDeviceRobustness2FeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRobustness2FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRobustness2FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRobustness2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRobustness2FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRobustness2FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.robustBufferAccess2 !== undefined) this.robustBufferAccess2 = data.robustBufferAccess2;
      if (data.robustImageAccess2 !== undefined) this.robustImageAccess2 = data.robustImageAccess2;
      if (data.nullDescriptor !== undefined) this.nullDescriptor = data.nullDescriptor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get robustBufferAccess2() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustBufferAccess2(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get robustImageAccess2() {
    return this.#view.getUint32(20, LE);
  }
  
  set robustImageAccess2(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get nullDescriptor() {
    return this.#view.getUint32(24, LE);
  }
  
  set nullDescriptor(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRobustness2PropertiesEXT {
  pNext?: AnyPointer;
  robustStorageBufferAccessSizeAlignment?: DeviceSize;
  robustUniformBufferAccessSizeAlignment?: DeviceSize;
}

export class PhysicalDeviceRobustness2PropertiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRobustness2PropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRobustness2PropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRobustness2PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRobustness2PropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRobustness2PropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.robustStorageBufferAccessSizeAlignment !== undefined) this.robustStorageBufferAccessSizeAlignment = data.robustStorageBufferAccessSizeAlignment;
      if (data.robustUniformBufferAccessSizeAlignment !== undefined) this.robustUniformBufferAccessSizeAlignment = data.robustUniformBufferAccessSizeAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get robustStorageBufferAccessSizeAlignment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set robustStorageBufferAccessSizeAlignment(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get robustUniformBufferAccessSizeAlignment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set robustUniformBufferAccessSizeAlignment(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceImageRobustnessFeatures {
  pNext?: AnyPointer;
  robustImageAccess?: Bool32;
}

export class PhysicalDeviceImageRobustnessFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageRobustnessFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageRobustnessFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageRobustnessFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageRobustnessFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageRobustnessFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.robustImageAccess !== undefined) this.robustImageAccess = data.robustImageAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get robustImageAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set robustImageAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
  pNext?: AnyPointer;
  workgroupMemoryExplicitLayout?: Bool32;
  workgroupMemoryExplicitLayoutScalarBlockLayout?: Bool32;
  workgroupMemoryExplicitLayout8BitAccess?: Bool32;
  workgroupMemoryExplicitLayout16BitAccess?: Bool32;
}

export class PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.workgroupMemoryExplicitLayout !== undefined) this.workgroupMemoryExplicitLayout = data.workgroupMemoryExplicitLayout;
      if (data.workgroupMemoryExplicitLayoutScalarBlockLayout !== undefined) this.workgroupMemoryExplicitLayoutScalarBlockLayout = data.workgroupMemoryExplicitLayoutScalarBlockLayout;
      if (data.workgroupMemoryExplicitLayout8BitAccess !== undefined) this.workgroupMemoryExplicitLayout8BitAccess = data.workgroupMemoryExplicitLayout8BitAccess;
      if (data.workgroupMemoryExplicitLayout16BitAccess !== undefined) this.workgroupMemoryExplicitLayout16BitAccess = data.workgroupMemoryExplicitLayout16BitAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get workgroupMemoryExplicitLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set workgroupMemoryExplicitLayout(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayoutScalarBlockLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set workgroupMemoryExplicitLayoutScalarBlockLayout(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayout8BitAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set workgroupMemoryExplicitLayout8BitAccess(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get workgroupMemoryExplicitLayout16BitAccess() {
    return this.#view.getUint32(28, LE);
  }
  
  set workgroupMemoryExplicitLayout16BitAccess(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDevicePortabilitySubsetFeaturesKHR {
  pNext?: AnyPointer;
  constantAlphaColorBlendFactors?: Bool32;
  events?: Bool32;
  imageViewFormatReinterpretation?: Bool32;
  imageViewFormatSwizzle?: Bool32;
  imageView2DOn3DImage?: Bool32;
  multisampleArrayImage?: Bool32;
  mutableComparisonSamplers?: Bool32;
  pointPolygons?: Bool32;
  samplerMipLodBias?: Bool32;
  separateStencilMaskRef?: Bool32;
  shaderSampleRateInterpolationFunctions?: Bool32;
  tessellationIsolines?: Bool32;
  tessellationPointMode?: Bool32;
  triangleFans?: Bool32;
  vertexAttributeAccessBeyondStride?: Bool32;
}

export class PhysicalDevicePortabilitySubsetFeaturesKHR implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePortabilitySubsetFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePortabilitySubsetFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePortabilitySubsetFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePortabilitySubsetFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePortabilitySubsetFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.constantAlphaColorBlendFactors !== undefined) this.constantAlphaColorBlendFactors = data.constantAlphaColorBlendFactors;
      if (data.events !== undefined) this.events = data.events;
      if (data.imageViewFormatReinterpretation !== undefined) this.imageViewFormatReinterpretation = data.imageViewFormatReinterpretation;
      if (data.imageViewFormatSwizzle !== undefined) this.imageViewFormatSwizzle = data.imageViewFormatSwizzle;
      if (data.imageView2DOn3DImage !== undefined) this.imageView2DOn3DImage = data.imageView2DOn3DImage;
      if (data.multisampleArrayImage !== undefined) this.multisampleArrayImage = data.multisampleArrayImage;
      if (data.mutableComparisonSamplers !== undefined) this.mutableComparisonSamplers = data.mutableComparisonSamplers;
      if (data.pointPolygons !== undefined) this.pointPolygons = data.pointPolygons;
      if (data.samplerMipLodBias !== undefined) this.samplerMipLodBias = data.samplerMipLodBias;
      if (data.separateStencilMaskRef !== undefined) this.separateStencilMaskRef = data.separateStencilMaskRef;
      if (data.shaderSampleRateInterpolationFunctions !== undefined) this.shaderSampleRateInterpolationFunctions = data.shaderSampleRateInterpolationFunctions;
      if (data.tessellationIsolines !== undefined) this.tessellationIsolines = data.tessellationIsolines;
      if (data.tessellationPointMode !== undefined) this.tessellationPointMode = data.tessellationPointMode;
      if (data.triangleFans !== undefined) this.triangleFans = data.triangleFans;
      if (data.vertexAttributeAccessBeyondStride !== undefined) this.vertexAttributeAccessBeyondStride = data.vertexAttributeAccessBeyondStride;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get constantAlphaColorBlendFactors() {
    return this.#view.getUint32(16, LE);
  }
  
  set constantAlphaColorBlendFactors(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get events() {
    return this.#view.getUint32(20, LE);
  }
  
  set events(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get imageViewFormatReinterpretation() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageViewFormatReinterpretation(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get imageViewFormatSwizzle() {
    return this.#view.getUint32(28, LE);
  }
  
  set imageViewFormatSwizzle(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get imageView2DOn3DImage() {
    return this.#view.getUint32(32, LE);
  }
  
  set imageView2DOn3DImage(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get multisampleArrayImage() {
    return this.#view.getUint32(36, LE);
  }
  
  set multisampleArrayImage(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get mutableComparisonSamplers() {
    return this.#view.getUint32(40, LE);
  }
  
  set mutableComparisonSamplers(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pointPolygons() {
    return this.#view.getUint32(44, LE);
  }
  
  set pointPolygons(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get samplerMipLodBias() {
    return this.#view.getUint32(48, LE);
  }
  
  set samplerMipLodBias(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get separateStencilMaskRef() {
    return this.#view.getUint32(52, LE);
  }
  
  set separateStencilMaskRef(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get shaderSampleRateInterpolationFunctions() {
    return this.#view.getUint32(56, LE);
  }
  
  set shaderSampleRateInterpolationFunctions(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get tessellationIsolines() {
    return this.#view.getUint32(60, LE);
  }
  
  set tessellationIsolines(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get tessellationPointMode() {
    return this.#view.getUint32(64, LE);
  }
  
  set tessellationPointMode(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get triangleFans() {
    return this.#view.getUint32(68, LE);
  }
  
  set triangleFans(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get vertexAttributeAccessBeyondStride() {
    return this.#view.getUint32(72, LE);
  }
  
  set vertexAttributeAccessBeyondStride(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
}

export interface InitPhysicalDevicePortabilitySubsetPropertiesKHR {
  pNext?: AnyPointer;
  minVertexInputBindingStrideAlignment?: number;
}

export class PhysicalDevicePortabilitySubsetPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePortabilitySubsetPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePortabilitySubsetPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePortabilitySubsetPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePortabilitySubsetPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePortabilitySubsetPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minVertexInputBindingStrideAlignment !== undefined) this.minVertexInputBindingStrideAlignment = data.minVertexInputBindingStrideAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minVertexInputBindingStrideAlignment() {
    return this.#view.getUint32(16, LE);
  }
  
  set minVertexInputBindingStrideAlignment(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevice4444FormatsFeaturesEXT {
  pNext?: AnyPointer;
  formatA4R4G4B4?: Bool32;
  formatA4B4G4R4?: Bool32;
}

export class PhysicalDevice4444FormatsFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevice4444FormatsFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevice4444FormatsFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevice4444FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevice4444FormatsFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevice4444FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.formatA4R4G4B4 !== undefined) this.formatA4R4G4B4 = data.formatA4R4G4B4;
      if (data.formatA4B4G4R4 !== undefined) this.formatA4B4G4R4 = data.formatA4B4G4R4;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get formatA4R4G4B4() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatA4R4G4B4(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get formatA4B4G4R4() {
    return this.#view.getUint32(20, LE);
  }
  
  set formatA4B4G4R4(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceSubpassShadingFeaturesHUAWEI {
  pNext?: AnyPointer;
  subpassShading?: Bool32;
}

export class PhysicalDeviceSubpassShadingFeaturesHUAWEI implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubpassShadingFeaturesHUAWEI);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubpassShadingFeaturesHUAWEI) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubpassShadingFeaturesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubpassShadingFeaturesHUAWEI.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubpassShadingFeaturesHUAWEI.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subpassShading !== undefined) this.subpassShading = data.subpassShading;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subpassShading() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassShading(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitBufferCopy2 {
  pNext?: AnyPointer;
  srcOffset?: DeviceSize;
  dstOffset?: DeviceSize;
  size?: DeviceSize;
}

export class BufferCopy2 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCopy2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCopy2) {
    if (!data) {
      this.#data = new Uint8Array(BufferCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCopy2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COPY_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcOffset(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get dstOffset() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstOffset(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitImageCopy2 {
  pNext?: AnyPointer;
  srcSubresource?: ImageSubresourceLayers;
  srcOffset?: Offset3D;
  dstSubresource?: ImageSubresourceLayers;
  dstOffset?: Offset3D;
  extent?: Extent3D;
}

export class ImageCopy2 implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCopy2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCopy2) {
    if (!data) {
      this.#data = new Uint8Array(ImageCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCopy2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_COPY_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.extent !== undefined) this.extent = data.extent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(16, 16 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffset() {
    return new Offset3D(this.#data.subarray(32, 32 + Offset3D.size));
  }
  
  set srcOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(44, 44 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get dstOffset() {
    return new Offset3D(this.#data.subarray(60, 60 + Offset3D.size));
  }
  
  set dstOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(72, 72 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitImageBlit2 {
  pNext?: AnyPointer;
  srcSubresource?: ImageSubresourceLayers;
  srcOffsets?: Offset3D[];
  dstSubresource?: ImageSubresourceLayers;
  dstOffsets?: Offset3D[];
}

export class ImageBlit2 implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageBlit2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageBlit2) {
    if (!data) {
      this.#data = new Uint8Array(ImageBlit2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageBlit2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageBlit2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_BLIT_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffsets !== undefined) this.srcOffsets = data.srcOffsets;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffsets !== undefined) this.dstOffsets = data.dstOffsets;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(16, 16 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffsets() {
    const result: Offset3D[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return new Offset3D(this.#data.subarray(32 + i * 12, 32 + i * 12 + Offset3D.size));
      })());
    }
    return result;
  }
  
  set srcOffsets(value: Offset3D[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < Offset3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 32 + i * 12);
    }
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(56, 56 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get dstOffsets() {
    const result: Offset3D[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return new Offset3D(this.#data.subarray(72 + i * 12, 72 + i * 12 + Offset3D.size));
      })());
    }
    return result;
  }
  
  set dstOffsets(value: Offset3D[]) {
    for (let i = 0; i < value.length; i++) {
      if (value[i][BUFFER].byteLength < Offset3D.size) {
        throw new Error("Data buffer too small");
      }
      this.#data.set(value[i][BUFFER], 72 + i * 12);
    }
  }
}

export interface InitBufferImageCopy2 {
  pNext?: AnyPointer;
  bufferOffset?: DeviceSize;
  bufferRowLength?: number;
  bufferImageHeight?: number;
  imageSubresource?: ImageSubresourceLayers;
  imageOffset?: Offset3D;
  imageExtent?: Extent3D;
}

export class BufferImageCopy2 implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferImageCopy2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferImageCopy2) {
    if (!data) {
      this.#data = new Uint8Array(BufferImageCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferImageCopy2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferImageCopy2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.bufferOffset !== undefined) this.bufferOffset = data.bufferOffset;
      if (data.bufferRowLength !== undefined) this.bufferRowLength = data.bufferRowLength;
      if (data.bufferImageHeight !== undefined) this.bufferImageHeight = data.bufferImageHeight;
      if (data.imageSubresource !== undefined) this.imageSubresource = data.imageSubresource;
      if (data.imageOffset !== undefined) this.imageOffset = data.imageOffset;
      if (data.imageExtent !== undefined) this.imageExtent = data.imageExtent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get bufferOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set bufferOffset(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get bufferRowLength() {
    return this.#view.getUint32(24, LE);
  }
  
  set bufferRowLength(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get bufferImageHeight() {
    return this.#view.getUint32(28, LE);
  }
  
  set bufferImageHeight(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get imageSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(32, 32 + ImageSubresourceLayers.size));
  }
  
  set imageSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get imageOffset() {
    return new Offset3D(this.#data.subarray(48, 48 + Offset3D.size));
  }
  
  set imageOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get imageExtent() {
    return new Extent3D(this.#data.subarray(60, 60 + Extent3D.size));
  }
  
  set imageExtent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
}

export interface InitImageResolve2 {
  pNext?: AnyPointer;
  srcSubresource?: ImageSubresourceLayers;
  srcOffset?: Offset3D;
  dstSubresource?: ImageSubresourceLayers;
  dstOffset?: Offset3D;
  extent?: Extent3D;
}

export class ImageResolve2 implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageResolve2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageResolve2) {
    if (!data) {
      this.#data = new Uint8Array(ImageResolve2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageResolve2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageResolve2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_RESOLVE_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcSubresource !== undefined) this.srcSubresource = data.srcSubresource;
      if (data.srcOffset !== undefined) this.srcOffset = data.srcOffset;
      if (data.dstSubresource !== undefined) this.dstSubresource = data.dstSubresource;
      if (data.dstOffset !== undefined) this.dstOffset = data.dstOffset;
      if (data.extent !== undefined) this.extent = data.extent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(16, 16 + ImageSubresourceLayers.size));
  }
  
  set srcSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get srcOffset() {
    return new Offset3D(this.#data.subarray(32, 32 + Offset3D.size));
  }
  
  set srcOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get dstSubresource() {
    return new ImageSubresourceLayers(this.#data.subarray(44, 44 + ImageSubresourceLayers.size));
  }
  
  set dstSubresource(value: ImageSubresourceLayers) {
    if (value[BUFFER].byteLength < ImageSubresourceLayers.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get dstOffset() {
    return new Offset3D(this.#data.subarray(60, 60 + Offset3D.size));
  }
  
  set dstOffset(value: Offset3D) {
    if (value[BUFFER].byteLength < Offset3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 60);
  }
  
  get extent() {
    return new Extent3D(this.#data.subarray(72, 72 + Extent3D.size));
  }
  
  set extent(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitCopyBufferInfo2 {
  pNext?: AnyPointer;
  srcBuffer?: Buffer;
  dstBuffer?: Buffer;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class CopyBufferInfo2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyBufferInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyBufferInfo2) {
    if (!data) {
      this.#data = new Uint8Array(CopyBufferInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyBufferInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyBufferInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_BUFFER_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcBuffer !== undefined) this.srcBuffer = data.srcBuffer;
      if (data.dstBuffer !== undefined) this.dstBuffer = data.dstBuffer;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcBuffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dstBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstBuffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCopyImageInfo2 {
  pNext?: AnyPointer;
  srcImage?: Image;
  srcImageLayout?: ImageLayout;
  dstImage?: Image;
  dstImageLayout?: ImageLayout;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class CopyImageInfo2 implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyImageInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyImageInfo2) {
    if (!data) {
      this.#data = new Uint8Array(CopyImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyImageInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_IMAGE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcImage !== undefined) this.srcImage = data.srcImage;
      if (data.srcImageLayout !== undefined) this.srcImageLayout = data.srcImageLayout;
      if (data.dstImage !== undefined) this.dstImage = data.dstImage;
      if (data.dstImageLayout !== undefined) this.dstImageLayout = data.dstImageLayout;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: Image) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: ImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBlitImageInfo2 {
  pNext?: AnyPointer;
  srcImage?: Image;
  srcImageLayout?: ImageLayout;
  dstImage?: Image;
  dstImageLayout?: ImageLayout;
  regionCount?: number;
  pRegions?: AnyPointer;
  filter?: Filter;
}

export class BlitImageInfo2 implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBlitImageInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBlitImageInfo2) {
    if (!data) {
      this.#data = new Uint8Array(BlitImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BlitImageInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BlitImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcImage !== undefined) this.srcImage = data.srcImage;
      if (data.srcImageLayout !== undefined) this.srcImageLayout = data.srcImageLayout;
      if (data.dstImage !== undefined) this.dstImage = data.dstImage;
      if (data.dstImageLayout !== undefined) this.dstImageLayout = data.dstImageLayout;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
      if (data.filter !== undefined) this.filter = data.filter;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: Image) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: ImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get filter() {
    return this.#view.getUint32(56, LE);
  }
  
  set filter(value: Filter) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitCopyBufferToImageInfo2 {
  pNext?: AnyPointer;
  srcBuffer?: Buffer;
  dstImage?: Image;
  dstImageLayout?: ImageLayout;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class CopyBufferToImageInfo2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyBufferToImageInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyBufferToImageInfo2) {
    if (!data) {
      this.#data = new Uint8Array(CopyBufferToImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyBufferToImageInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyBufferToImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcBuffer !== undefined) this.srcBuffer = data.srcBuffer;
      if (data.dstImage !== undefined) this.dstImage = data.dstImage;
      if (data.dstImageLayout !== undefined) this.dstImageLayout = data.dstImageLayout;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcBuffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstImage(value: Image) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(32, LE);
  }
  
  set dstImageLayout(value: ImageLayout) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCopyImageToBufferInfo2 {
  pNext?: AnyPointer;
  srcImage?: Image;
  srcImageLayout?: ImageLayout;
  dstBuffer?: Buffer;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class CopyImageToBufferInfo2 implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyImageToBufferInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyImageToBufferInfo2) {
    if (!data) {
      this.#data = new Uint8Array(CopyImageToBufferInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyImageToBufferInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyImageToBufferInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcImage !== undefined) this.srcImage = data.srcImage;
      if (data.srcImageLayout !== undefined) this.srcImageLayout = data.srcImageLayout;
      if (data.dstBuffer !== undefined) this.dstBuffer = data.dstBuffer;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstBuffer() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstBuffer(value: Buffer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitResolveImageInfo2 {
  pNext?: AnyPointer;
  srcImage?: Image;
  srcImageLayout?: ImageLayout;
  dstImage?: Image;
  dstImageLayout?: ImageLayout;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class ResolveImageInfo2 implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitResolveImageInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitResolveImageInfo2) {
    if (!data) {
      this.#data = new Uint8Array(ResolveImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ResolveImageInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ResolveImageInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcImage !== undefined) this.srcImage = data.srcImage;
      if (data.srcImageLayout !== undefined) this.srcImageLayout = data.srcImageLayout;
      if (data.dstImage !== undefined) this.dstImage = data.dstImage;
      if (data.dstImageLayout !== undefined) this.dstImageLayout = data.dstImageLayout;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcImage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcImage(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get srcImageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set srcImageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstImage() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstImage(value: Image) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get dstImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set dstImageLayout(value: ImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
  pNext?: AnyPointer;
  shaderImageInt64Atomics?: Bool32;
  sparseImageInt64Atomics?: Bool32;
}

export class PhysicalDeviceShaderImageAtomicInt64FeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderImageAtomicInt64FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderImageAtomicInt64FeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderImageAtomicInt64FeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderImageInt64Atomics !== undefined) this.shaderImageInt64Atomics = data.shaderImageInt64Atomics;
      if (data.sparseImageInt64Atomics !== undefined) this.sparseImageInt64Atomics = data.sparseImageInt64Atomics;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderImageInt64Atomics() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderImageInt64Atomics(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sparseImageInt64Atomics() {
    return this.#view.getUint32(20, LE);
  }
  
  set sparseImageInt64Atomics(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitFragmentShadingRateAttachmentInfoKHR {
  pNext?: AnyPointer;
  pFragmentShadingRateAttachment?: AnyPointer;
  shadingRateAttachmentTexelSize?: Extent2D;
}

export class FragmentShadingRateAttachmentInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFragmentShadingRateAttachmentInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFragmentShadingRateAttachmentInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(FragmentShadingRateAttachmentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FragmentShadingRateAttachmentInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FragmentShadingRateAttachmentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pFragmentShadingRateAttachment !== undefined) this.pFragmentShadingRateAttachment = data.pFragmentShadingRateAttachment;
      if (data.shadingRateAttachmentTexelSize !== undefined) this.shadingRateAttachmentTexelSize = data.shadingRateAttachmentTexelSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pFragmentShadingRateAttachment() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pFragmentShadingRateAttachment(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get shadingRateAttachmentTexelSize() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set shadingRateAttachmentTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export interface InitPipelineFragmentShadingRateStateCreateInfoKHR {
  pNext?: AnyPointer;
  fragmentSize?: Extent2D;
  combinerOps?: FragmentShadingRateCombinerOpKHR[];
}

export class PipelineFragmentShadingRateStateCreateInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineFragmentShadingRateStateCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineFragmentShadingRateStateCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PipelineFragmentShadingRateStateCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineFragmentShadingRateStateCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineFragmentShadingRateStateCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentSize !== undefined) this.fragmentSize = data.fragmentSize;
      if (data.combinerOps !== undefined) this.combinerOps = data.combinerOps;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentSize() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set fragmentSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get combinerOps() {
    const result: FragmentShadingRateCombinerOpKHR[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getUint32(24 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set combinerOps(value: FragmentShadingRateCombinerOpKHR[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(24 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitPhysicalDeviceFragmentShadingRateFeaturesKHR {
  pNext?: AnyPointer;
  pipelineFragmentShadingRate?: Bool32;
  primitiveFragmentShadingRate?: Bool32;
  attachmentFragmentShadingRate?: Bool32;
}

export class PhysicalDeviceFragmentShadingRateFeaturesKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShadingRateFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShadingRateFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShadingRateFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineFragmentShadingRate !== undefined) this.pipelineFragmentShadingRate = data.pipelineFragmentShadingRate;
      if (data.primitiveFragmentShadingRate !== undefined) this.primitiveFragmentShadingRate = data.primitiveFragmentShadingRate;
      if (data.attachmentFragmentShadingRate !== undefined) this.attachmentFragmentShadingRate = data.attachmentFragmentShadingRate;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineFragmentShadingRate() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineFragmentShadingRate(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitiveFragmentShadingRate() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitiveFragmentShadingRate(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get attachmentFragmentShadingRate() {
    return this.#view.getUint32(24, LE);
  }
  
  set attachmentFragmentShadingRate(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShadingRatePropertiesKHR {
  pNext?: AnyPointer;
  minFragmentShadingRateAttachmentTexelSize?: Extent2D;
  maxFragmentShadingRateAttachmentTexelSize?: Extent2D;
  maxFragmentShadingRateAttachmentTexelSizeAspectRatio?: number;
  primitiveFragmentShadingRateWithMultipleViewports?: Bool32;
  layeredShadingRateAttachments?: Bool32;
  fragmentShadingRateNonTrivialCombinerOps?: Bool32;
  maxFragmentSize?: Extent2D;
  maxFragmentSizeAspectRatio?: number;
  maxFragmentShadingRateCoverageSamples?: number;
  maxFragmentShadingRateRasterizationSamples?: SampleCountFlagBits;
  fragmentShadingRateWithShaderDepthStencilWrites?: Bool32;
  fragmentShadingRateWithSampleMask?: Bool32;
  fragmentShadingRateWithShaderSampleMask?: Bool32;
  fragmentShadingRateWithConservativeRasterization?: Bool32;
  fragmentShadingRateWithFragmentShaderInterlock?: Bool32;
  fragmentShadingRateWithCustomSampleLocations?: Bool32;
  fragmentShadingRateStrictMultiplyCombiner?: Bool32;
}

export class PhysicalDeviceFragmentShadingRatePropertiesKHR implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShadingRatePropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShadingRatePropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRatePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShadingRatePropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRatePropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minFragmentShadingRateAttachmentTexelSize !== undefined) this.minFragmentShadingRateAttachmentTexelSize = data.minFragmentShadingRateAttachmentTexelSize;
      if (data.maxFragmentShadingRateAttachmentTexelSize !== undefined) this.maxFragmentShadingRateAttachmentTexelSize = data.maxFragmentShadingRateAttachmentTexelSize;
      if (data.maxFragmentShadingRateAttachmentTexelSizeAspectRatio !== undefined) this.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = data.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
      if (data.primitiveFragmentShadingRateWithMultipleViewports !== undefined) this.primitiveFragmentShadingRateWithMultipleViewports = data.primitiveFragmentShadingRateWithMultipleViewports;
      if (data.layeredShadingRateAttachments !== undefined) this.layeredShadingRateAttachments = data.layeredShadingRateAttachments;
      if (data.fragmentShadingRateNonTrivialCombinerOps !== undefined) this.fragmentShadingRateNonTrivialCombinerOps = data.fragmentShadingRateNonTrivialCombinerOps;
      if (data.maxFragmentSize !== undefined) this.maxFragmentSize = data.maxFragmentSize;
      if (data.maxFragmentSizeAspectRatio !== undefined) this.maxFragmentSizeAspectRatio = data.maxFragmentSizeAspectRatio;
      if (data.maxFragmentShadingRateCoverageSamples !== undefined) this.maxFragmentShadingRateCoverageSamples = data.maxFragmentShadingRateCoverageSamples;
      if (data.maxFragmentShadingRateRasterizationSamples !== undefined) this.maxFragmentShadingRateRasterizationSamples = data.maxFragmentShadingRateRasterizationSamples;
      if (data.fragmentShadingRateWithShaderDepthStencilWrites !== undefined) this.fragmentShadingRateWithShaderDepthStencilWrites = data.fragmentShadingRateWithShaderDepthStencilWrites;
      if (data.fragmentShadingRateWithSampleMask !== undefined) this.fragmentShadingRateWithSampleMask = data.fragmentShadingRateWithSampleMask;
      if (data.fragmentShadingRateWithShaderSampleMask !== undefined) this.fragmentShadingRateWithShaderSampleMask = data.fragmentShadingRateWithShaderSampleMask;
      if (data.fragmentShadingRateWithConservativeRasterization !== undefined) this.fragmentShadingRateWithConservativeRasterization = data.fragmentShadingRateWithConservativeRasterization;
      if (data.fragmentShadingRateWithFragmentShaderInterlock !== undefined) this.fragmentShadingRateWithFragmentShaderInterlock = data.fragmentShadingRateWithFragmentShaderInterlock;
      if (data.fragmentShadingRateWithCustomSampleLocations !== undefined) this.fragmentShadingRateWithCustomSampleLocations = data.fragmentShadingRateWithCustomSampleLocations;
      if (data.fragmentShadingRateStrictMultiplyCombiner !== undefined) this.fragmentShadingRateStrictMultiplyCombiner = data.fragmentShadingRateStrictMultiplyCombiner;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minFragmentShadingRateAttachmentTexelSize() {
    return new Extent2D(this.#data.subarray(16, 16 + Extent2D.size));
  }
  
  set minFragmentShadingRateAttachmentTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get maxFragmentShadingRateAttachmentTexelSize() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set maxFragmentShadingRateAttachmentTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get maxFragmentShadingRateAttachmentTexelSizeAspectRatio() {
    return this.#view.getUint32(32, LE);
  }
  
  set maxFragmentShadingRateAttachmentTexelSizeAspectRatio(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get primitiveFragmentShadingRateWithMultipleViewports() {
    return this.#view.getUint32(36, LE);
  }
  
  set primitiveFragmentShadingRateWithMultipleViewports(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get layeredShadingRateAttachments() {
    return this.#view.getUint32(40, LE);
  }
  
  set layeredShadingRateAttachments(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get fragmentShadingRateNonTrivialCombinerOps() {
    return this.#view.getUint32(44, LE);
  }
  
  set fragmentShadingRateNonTrivialCombinerOps(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxFragmentSize() {
    return new Extent2D(this.#data.subarray(48, 48 + Extent2D.size));
  }
  
  set maxFragmentSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get maxFragmentSizeAspectRatio() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxFragmentSizeAspectRatio(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get maxFragmentShadingRateCoverageSamples() {
    return this.#view.getUint32(60, LE);
  }
  
  set maxFragmentShadingRateCoverageSamples(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get maxFragmentShadingRateRasterizationSamples() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxFragmentShadingRateRasterizationSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get fragmentShadingRateWithShaderDepthStencilWrites() {
    return this.#view.getUint32(68, LE);
  }
  
  set fragmentShadingRateWithShaderDepthStencilWrites(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get fragmentShadingRateWithSampleMask() {
    return this.#view.getUint32(72, LE);
  }
  
  set fragmentShadingRateWithSampleMask(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get fragmentShadingRateWithShaderSampleMask() {
    return this.#view.getUint32(76, LE);
  }
  
  set fragmentShadingRateWithShaderSampleMask(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get fragmentShadingRateWithConservativeRasterization() {
    return this.#view.getUint32(80, LE);
  }
  
  set fragmentShadingRateWithConservativeRasterization(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get fragmentShadingRateWithFragmentShaderInterlock() {
    return this.#view.getUint32(84, LE);
  }
  
  set fragmentShadingRateWithFragmentShaderInterlock(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get fragmentShadingRateWithCustomSampleLocations() {
    return this.#view.getUint32(88, LE);
  }
  
  set fragmentShadingRateWithCustomSampleLocations(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get fragmentShadingRateStrictMultiplyCombiner() {
    return this.#view.getUint32(92, LE);
  }
  
  set fragmentShadingRateStrictMultiplyCombiner(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShadingRateKHR {
  pNext?: AnyPointer;
  sampleCounts?: SampleCountFlags;
  fragmentSize?: Extent2D;
}

export class PhysicalDeviceFragmentShadingRateKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShadingRateKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShadingRateKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShadingRateKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampleCounts !== undefined) this.sampleCounts = data.sampleCounts;
      if (data.fragmentSize !== undefined) this.fragmentSize = data.fragmentSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampleCounts() {
    return this.#view.getUint32(16, LE);
  }
  
  set sampleCounts(value: SampleCountFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fragmentSize() {
    return new Extent2D(this.#data.subarray(20, 20 + Extent2D.size));
  }
  
  set fragmentSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
}

export interface InitPhysicalDeviceShaderTerminateInvocationFeatures {
  pNext?: AnyPointer;
  shaderTerminateInvocation?: Bool32;
}

export class PhysicalDeviceShaderTerminateInvocationFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderTerminateInvocationFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderTerminateInvocationFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderTerminateInvocationFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderTerminateInvocationFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderTerminateInvocationFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderTerminateInvocation !== undefined) this.shaderTerminateInvocation = data.shaderTerminateInvocation;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderTerminateInvocation() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderTerminateInvocation(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
  pNext?: AnyPointer;
  fragmentShadingRateEnums?: Bool32;
  supersampleFragmentShadingRates?: Bool32;
  noInvocationFragmentShadingRates?: Bool32;
}

export class PhysicalDeviceFragmentShadingRateEnumsFeaturesNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShadingRateEnumsFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentShadingRateEnums !== undefined) this.fragmentShadingRateEnums = data.fragmentShadingRateEnums;
      if (data.supersampleFragmentShadingRates !== undefined) this.supersampleFragmentShadingRates = data.supersampleFragmentShadingRates;
      if (data.noInvocationFragmentShadingRates !== undefined) this.noInvocationFragmentShadingRates = data.noInvocationFragmentShadingRates;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentShadingRateEnums() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShadingRateEnums(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supersampleFragmentShadingRates() {
    return this.#view.getUint32(20, LE);
  }
  
  set supersampleFragmentShadingRates(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get noInvocationFragmentShadingRates() {
    return this.#view.getUint32(24, LE);
  }
  
  set noInvocationFragmentShadingRates(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
  pNext?: AnyPointer;
  maxFragmentShadingRateInvocationCount?: SampleCountFlagBits;
}

export class PhysicalDeviceFragmentShadingRateEnumsPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateEnumsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShadingRateEnumsPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShadingRateEnumsPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxFragmentShadingRateInvocationCount !== undefined) this.maxFragmentShadingRateInvocationCount = data.maxFragmentShadingRateInvocationCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxFragmentShadingRateInvocationCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxFragmentShadingRateInvocationCount(value: SampleCountFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineFragmentShadingRateEnumStateCreateInfoNV {
  pNext?: AnyPointer;
  shadingRateType?: FragmentShadingRateTypeNV;
  shadingRate?: FragmentShadingRateNV;
  combinerOps?: FragmentShadingRateCombinerOpKHR[];
}

export class PipelineFragmentShadingRateEnumStateCreateInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineFragmentShadingRateEnumStateCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineFragmentShadingRateEnumStateCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(PipelineFragmentShadingRateEnumStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineFragmentShadingRateEnumStateCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineFragmentShadingRateEnumStateCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shadingRateType !== undefined) this.shadingRateType = data.shadingRateType;
      if (data.shadingRate !== undefined) this.shadingRate = data.shadingRate;
      if (data.combinerOps !== undefined) this.combinerOps = data.combinerOps;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shadingRateType() {
    return this.#view.getUint32(16, LE);
  }
  
  set shadingRateType(value: FragmentShadingRateTypeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get shadingRate() {
    return this.#view.getUint32(20, LE);
  }
  
  set shadingRate(value: FragmentShadingRateNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get combinerOps() {
    const result: FragmentShadingRateCombinerOpKHR[] = [];
    for (let i = 0; i < 2; i++) {
      result.push((() => {
        return this.#view.getUint32(24 + i * 4, LE);
      })());
    }
    return result;
  }
  
  set combinerOps(value: FragmentShadingRateCombinerOpKHR[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint32(24 + i * 4, Number(value[i]), LE);
    }
  }
}

export interface InitAccelerationStructureBuildSizesInfoKHR {
  pNext?: AnyPointer;
  accelerationStructureSize?: DeviceSize;
  updateScratchSize?: DeviceSize;
  buildScratchSize?: DeviceSize;
}

export class AccelerationStructureBuildSizesInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureBuildSizesInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureBuildSizesInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureBuildSizesInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureBuildSizesInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureBuildSizesInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructureSize !== undefined) this.accelerationStructureSize = data.accelerationStructureSize;
      if (data.updateScratchSize !== undefined) this.updateScratchSize = data.updateScratchSize;
      if (data.buildScratchSize !== undefined) this.buildScratchSize = data.buildScratchSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructureSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructureSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get updateScratchSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set updateScratchSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get buildScratchSize() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set buildScratchSize(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceImage2DViewOf3DFeaturesEXT {
  pNext?: AnyPointer;
  image2DViewOf3D?: Bool32;
  sampler2DViewOf3D?: Bool32;
}

export class PhysicalDeviceImage2DViewOf3DFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImage2DViewOf3DFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImage2DViewOf3DFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImage2DViewOf3DFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImage2DViewOf3DFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImage2DViewOf3DFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image2DViewOf3D !== undefined) this.image2DViewOf3D = data.image2DViewOf3D;
      if (data.sampler2DViewOf3D !== undefined) this.sampler2DViewOf3D = data.sampler2DViewOf3D;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image2DViewOf3D() {
    return this.#view.getUint32(16, LE);
  }
  
  set image2DViewOf3D(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get sampler2DViewOf3D() {
    return this.#view.getUint32(20, LE);
  }
  
  set sampler2DViewOf3D(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
  pNext?: AnyPointer;
  mutableDescriptorType?: Bool32;
}

export class PhysicalDeviceMutableDescriptorTypeFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMutableDescriptorTypeFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMutableDescriptorTypeFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMutableDescriptorTypeFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMutableDescriptorTypeFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMutableDescriptorTypeFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mutableDescriptorType !== undefined) this.mutableDescriptorType = data.mutableDescriptorType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mutableDescriptorType() {
    return this.#view.getUint32(16, LE);
  }
  
  set mutableDescriptorType(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMutableDescriptorTypeListEXT {
  descriptorTypeCount?: number;
  pDescriptorTypes?: AnyPointer;
}

export class MutableDescriptorTypeListEXT implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMutableDescriptorTypeListEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMutableDescriptorTypeListEXT) {
    if (!data) {
      this.#data = new Uint8Array(MutableDescriptorTypeListEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MutableDescriptorTypeListEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MutableDescriptorTypeListEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.descriptorTypeCount !== undefined) this.descriptorTypeCount = data.descriptorTypeCount;
      if (data.pDescriptorTypes !== undefined) this.pDescriptorTypes = data.pDescriptorTypes;
    }
  }
  
  get descriptorTypeCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set descriptorTypeCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pDescriptorTypes() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pDescriptorTypes(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMutableDescriptorTypeCreateInfoEXT {
  pNext?: AnyPointer;
  mutableDescriptorTypeListCount?: number;
  pMutableDescriptorTypeLists?: AnyPointer;
}

export class MutableDescriptorTypeCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMutableDescriptorTypeCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMutableDescriptorTypeCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MutableDescriptorTypeCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MutableDescriptorTypeCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MutableDescriptorTypeCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mutableDescriptorTypeListCount !== undefined) this.mutableDescriptorTypeListCount = data.mutableDescriptorTypeListCount;
      if (data.pMutableDescriptorTypeLists !== undefined) this.pMutableDescriptorTypeLists = data.pMutableDescriptorTypeLists;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mutableDescriptorTypeListCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set mutableDescriptorTypeListCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pMutableDescriptorTypeLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMutableDescriptorTypeLists(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDepthClipControlFeaturesEXT {
  pNext?: AnyPointer;
  depthClipControl?: Bool32;
}

export class PhysicalDeviceDepthClipControlFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDepthClipControlFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDepthClipControlFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDepthClipControlFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDepthClipControlFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDepthClipControlFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.depthClipControl !== undefined) this.depthClipControl = data.depthClipControl;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get depthClipControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClipControl(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineViewportDepthClipControlCreateInfoEXT {
  pNext?: AnyPointer;
  negativeOneToOne?: Bool32;
}

export class PipelineViewportDepthClipControlCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineViewportDepthClipControlCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineViewportDepthClipControlCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineViewportDepthClipControlCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineViewportDepthClipControlCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineViewportDepthClipControlCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.negativeOneToOne !== undefined) this.negativeOneToOne = data.negativeOneToOne;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get negativeOneToOne() {
    return this.#view.getUint32(16, LE);
  }
  
  set negativeOneToOne(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
  pNext?: AnyPointer;
  vertexInputDynamicState?: Bool32;
}

export class PhysicalDeviceVertexInputDynamicStateFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVertexInputDynamicStateFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVertexInputDynamicStateFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVertexInputDynamicStateFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVertexInputDynamicStateFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexInputDynamicState !== undefined) this.vertexInputDynamicState = data.vertexInputDynamicState;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexInputDynamicState() {
    return this.#view.getUint32(16, LE);
  }
  
  set vertexInputDynamicState(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceExternalMemoryRDMAFeaturesNV {
  pNext?: AnyPointer;
  externalMemoryRDMA?: Bool32;
}

export class PhysicalDeviceExternalMemoryRDMAFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceExternalMemoryRDMAFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceExternalMemoryRDMAFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceExternalMemoryRDMAFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceExternalMemoryRDMAFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceExternalMemoryRDMAFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.externalMemoryRDMA !== undefined) this.externalMemoryRDMA = data.externalMemoryRDMA;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get externalMemoryRDMA() {
    return this.#view.getUint32(16, LE);
  }
  
  set externalMemoryRDMA(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVertexInputBindingDescription2EXT {
  pNext?: AnyPointer;
  binding?: number;
  stride?: number;
  inputRate?: VertexInputRate;
  divisor?: number;
}

export class VertexInputBindingDescription2EXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVertexInputBindingDescription2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVertexInputBindingDescription2EXT) {
    if (!data) {
      this.#data = new Uint8Array(VertexInputBindingDescription2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VertexInputBindingDescription2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VertexInputBindingDescription2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.stride !== undefined) this.stride = data.stride;
      if (data.inputRate !== undefined) this.inputRate = data.inputRate;
      if (data.divisor !== undefined) this.divisor = data.divisor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get binding() {
    return this.#view.getUint32(16, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get stride() {
    return this.#view.getUint32(20, LE);
  }
  
  set stride(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get inputRate() {
    return this.#view.getUint32(24, LE);
  }
  
  set inputRate(value: VertexInputRate) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get divisor() {
    return this.#view.getUint32(28, LE);
  }
  
  set divisor(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitVertexInputAttributeDescription2EXT {
  pNext?: AnyPointer;
  location?: number;
  binding?: number;
  format?: Format;
  offset?: number;
}

export class VertexInputAttributeDescription2EXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVertexInputAttributeDescription2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVertexInputAttributeDescription2EXT) {
    if (!data) {
      this.#data = new Uint8Array(VertexInputAttributeDescription2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VertexInputAttributeDescription2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VertexInputAttributeDescription2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.location !== undefined) this.location = data.location;
      if (data.binding !== undefined) this.binding = data.binding;
      if (data.format !== undefined) this.format = data.format;
      if (data.offset !== undefined) this.offset = data.offset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get location() {
    return this.#view.getUint32(16, LE);
  }
  
  set location(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get binding() {
    return this.#view.getUint32(20, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(24, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get offset() {
    return this.#view.getUint32(28, LE);
  }
  
  set offset(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceColorWriteEnableFeaturesEXT {
  pNext?: AnyPointer;
  colorWriteEnable?: Bool32;
}

export class PhysicalDeviceColorWriteEnableFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceColorWriteEnableFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceColorWriteEnableFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceColorWriteEnableFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceColorWriteEnableFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceColorWriteEnableFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.colorWriteEnable !== undefined) this.colorWriteEnable = data.colorWriteEnable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get colorWriteEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorWriteEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineColorWriteCreateInfoEXT {
  pNext?: AnyPointer;
  attachmentCount?: number;
  pColorWriteEnables?: AnyPointer;
}

export class PipelineColorWriteCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineColorWriteCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineColorWriteCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineColorWriteCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineColorWriteCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineColorWriteCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachmentCount !== undefined) this.attachmentCount = data.attachmentCount;
      if (data.pColorWriteEnables !== undefined) this.pColorWriteEnables = data.pColorWriteEnables;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pColorWriteEnables() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorWriteEnables(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitMemoryBarrier2 {
  pNext?: AnyPointer;
  srcStageMask?: PipelineStageFlags2;
  srcAccessMask?: AccessFlags2;
  dstStageMask?: PipelineStageFlags2;
  dstAccessMask?: AccessFlags2;
}

export class MemoryBarrier2 implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryBarrier2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryBarrier2) {
    if (!data) {
      this.#data = new Uint8Array(MemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryBarrier2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_BARRIER_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcStageMask !== undefined) this.srcStageMask = data.srcStageMask;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstStageMask !== undefined) this.dstStageMask = data.dstStageMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export interface InitImageMemoryBarrier2 {
  pNext?: AnyPointer;
  srcStageMask?: PipelineStageFlags2;
  srcAccessMask?: AccessFlags2;
  dstStageMask?: PipelineStageFlags2;
  dstAccessMask?: AccessFlags2;
  oldLayout?: ImageLayout;
  newLayout?: ImageLayout;
  srcQueueFamilyIndex?: number;
  dstQueueFamilyIndex?: number;
  image?: Image;
  subresourceRange?: ImageSubresourceRange;
}

export class ImageMemoryBarrier2 implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageMemoryBarrier2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageMemoryBarrier2) {
    if (!data) {
      this.#data = new Uint8Array(ImageMemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageMemoryBarrier2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageMemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcStageMask !== undefined) this.srcStageMask = data.srcStageMask;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstStageMask !== undefined) this.dstStageMask = data.dstStageMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.oldLayout !== undefined) this.oldLayout = data.oldLayout;
      if (data.newLayout !== undefined) this.newLayout = data.newLayout;
      if (data.srcQueueFamilyIndex !== undefined) this.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
      if (data.dstQueueFamilyIndex !== undefined) this.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
      if (data.image !== undefined) this.image = data.image;
      if (data.subresourceRange !== undefined) this.subresourceRange = data.subresourceRange;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get oldLayout() {
    return this.#view.getUint32(48, LE);
  }
  
  set oldLayout(value: ImageLayout) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get newLayout() {
    return this.#view.getUint32(52, LE);
  }
  
  set newLayout(value: ImageLayout) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(56, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(60, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get subresourceRange() {
    return new ImageSubresourceRange(this.#data.subarray(72, 72 + ImageSubresourceRange.size));
  }
  
  set subresourceRange(value: ImageSubresourceRange) {
    if (value[BUFFER].byteLength < ImageSubresourceRange.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitBufferMemoryBarrier2 {
  pNext?: AnyPointer;
  srcStageMask?: PipelineStageFlags2;
  srcAccessMask?: AccessFlags2;
  dstStageMask?: PipelineStageFlags2;
  dstAccessMask?: AccessFlags2;
  srcQueueFamilyIndex?: number;
  dstQueueFamilyIndex?: number;
  buffer?: Buffer;
  offset?: DeviceSize;
  size?: DeviceSize;
}

export class BufferMemoryBarrier2 implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferMemoryBarrier2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferMemoryBarrier2) {
    if (!data) {
      this.#data = new Uint8Array(BufferMemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferMemoryBarrier2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferMemoryBarrier2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.srcStageMask !== undefined) this.srcStageMask = data.srcStageMask;
      if (data.srcAccessMask !== undefined) this.srcAccessMask = data.srcAccessMask;
      if (data.dstStageMask !== undefined) this.dstStageMask = data.dstStageMask;
      if (data.dstAccessMask !== undefined) this.dstAccessMask = data.dstAccessMask;
      if (data.srcQueueFamilyIndex !== undefined) this.srcQueueFamilyIndex = data.srcQueueFamilyIndex;
      if (data.dstQueueFamilyIndex !== undefined) this.dstQueueFamilyIndex = data.dstQueueFamilyIndex;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get srcStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set srcStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get srcAccessMask() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get dstStageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstAccessMask() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstAccessMask(value: AccessFlags2) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get srcQueueFamilyIndex() {
    return this.#view.getUint32(48, LE);
  }
  
  set srcQueueFamilyIndex(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get dstQueueFamilyIndex() {
    return this.#view.getUint32(52, LE);
  }
  
  set dstQueueFamilyIndex(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
}

export interface InitDependencyInfo {
  pNext?: AnyPointer;
  dependencyFlags?: DependencyFlags;
  memoryBarrierCount?: number;
  pMemoryBarriers?: AnyPointer;
  bufferMemoryBarrierCount?: number;
  pBufferMemoryBarriers?: AnyPointer;
  imageMemoryBarrierCount?: number;
  pImageMemoryBarriers?: AnyPointer;
}

export class DependencyInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDependencyInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDependencyInfo) {
    if (!data) {
      this.#data = new Uint8Array(DependencyInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DependencyInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DependencyInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEPENDENCY_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dependencyFlags !== undefined) this.dependencyFlags = data.dependencyFlags;
      if (data.memoryBarrierCount !== undefined) this.memoryBarrierCount = data.memoryBarrierCount;
      if (data.pMemoryBarriers !== undefined) this.pMemoryBarriers = data.pMemoryBarriers;
      if (data.bufferMemoryBarrierCount !== undefined) this.bufferMemoryBarrierCount = data.bufferMemoryBarrierCount;
      if (data.pBufferMemoryBarriers !== undefined) this.pBufferMemoryBarriers = data.pBufferMemoryBarriers;
      if (data.imageMemoryBarrierCount !== undefined) this.imageMemoryBarrierCount = data.imageMemoryBarrierCount;
      if (data.pImageMemoryBarriers !== undefined) this.pImageMemoryBarriers = data.pImageMemoryBarriers;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dependencyFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set dependencyFlags(value: DependencyFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryBarrierCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set memoryBarrierCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pMemoryBarriers() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pMemoryBarriers(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get bufferMemoryBarrierCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set bufferMemoryBarrierCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pBufferMemoryBarriers() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pBufferMemoryBarriers(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get imageMemoryBarrierCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageMemoryBarrierCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pImageMemoryBarriers() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pImageMemoryBarriers(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSemaphoreSubmitInfo {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  value?: Deno.PointerValue;
  stageMask?: PipelineStageFlags2;
  deviceIndex?: number;
}

export class SemaphoreSubmitInfo implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSemaphoreSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSemaphoreSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(SemaphoreSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SemaphoreSubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SemaphoreSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.value !== undefined) this.value = data.value;
      if (data.stageMask !== undefined) this.stageMask = data.stageMask;
      if (data.deviceIndex !== undefined) this.deviceIndex = data.deviceIndex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get value() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set value(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get stageMask() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set stageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get deviceIndex() {
    return this.#view.getUint32(40, LE);
  }
  
  set deviceIndex(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitCommandBufferSubmitInfo {
  pNext?: AnyPointer;
  commandBuffer?: CommandBuffer;
  deviceMask?: number;
}

export class CommandBufferSubmitInfo implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferSubmitInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferSubmitInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferSubmitInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferSubmitInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.commandBuffer !== undefined) this.commandBuffer = data.commandBuffer;
      if (data.deviceMask !== undefined) this.deviceMask = data.deviceMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get commandBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set commandBuffer(value: CommandBuffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get deviceMask() {
    return this.#view.getUint32(24, LE);
  }
  
  set deviceMask(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitSubmitInfo2 {
  pNext?: AnyPointer;
  flags?: SubmitFlags;
  waitSemaphoreInfoCount?: number;
  pWaitSemaphoreInfos?: AnyPointer;
  commandBufferInfoCount?: number;
  pCommandBufferInfos?: AnyPointer;
  signalSemaphoreInfoCount?: number;
  pSignalSemaphoreInfos?: AnyPointer;
}

export class SubmitInfo2 implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubmitInfo2);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubmitInfo2) {
    if (!data) {
      this.#data = new Uint8Array(SubmitInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubmitInfo2.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubmitInfo2.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBMIT_INFO_2;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.waitSemaphoreInfoCount !== undefined) this.waitSemaphoreInfoCount = data.waitSemaphoreInfoCount;
      if (data.pWaitSemaphoreInfos !== undefined) this.pWaitSemaphoreInfos = data.pWaitSemaphoreInfos;
      if (data.commandBufferInfoCount !== undefined) this.commandBufferInfoCount = data.commandBufferInfoCount;
      if (data.pCommandBufferInfos !== undefined) this.pCommandBufferInfos = data.pCommandBufferInfos;
      if (data.signalSemaphoreInfoCount !== undefined) this.signalSemaphoreInfoCount = data.signalSemaphoreInfoCount;
      if (data.pSignalSemaphoreInfos !== undefined) this.pSignalSemaphoreInfos = data.pSignalSemaphoreInfos;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: SubmitFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get waitSemaphoreInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set waitSemaphoreInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pWaitSemaphoreInfos() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pWaitSemaphoreInfos(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get commandBufferInfoCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set commandBufferInfoCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pCommandBufferInfos() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCommandBufferInfos(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get signalSemaphoreInfoCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set signalSemaphoreInfoCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pSignalSemaphoreInfos() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pSignalSemaphoreInfos(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitQueueFamilyCheckpointProperties2NV {
  pNext?: AnyPointer;
  checkpointExecutionStageMask?: PipelineStageFlags2;
}

export class QueueFamilyCheckpointProperties2NV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyCheckpointProperties2NV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyCheckpointProperties2NV) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyCheckpointProperties2NV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyCheckpointProperties2NV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyCheckpointProperties2NV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.checkpointExecutionStageMask !== undefined) this.checkpointExecutionStageMask = data.checkpointExecutionStageMask;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get checkpointExecutionStageMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set checkpointExecutionStageMask(value: PipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitCheckpointData2NV {
  pNext?: AnyPointer;
  stage?: PipelineStageFlags2;
  pCheckpointMarker?: AnyPointer;
}

export class CheckpointData2NV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCheckpointData2NV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCheckpointData2NV) {
    if (!data) {
      this.#data = new Uint8Array(CheckpointData2NV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CheckpointData2NV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CheckpointData2NV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stage !== undefined) this.stage = data.stage;
      if (data.pCheckpointMarker !== undefined) this.pCheckpointMarker = data.pCheckpointMarker;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stage() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set stage(value: PipelineStageFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pCheckpointMarker() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pCheckpointMarker(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceSynchronization2Features {
  pNext?: AnyPointer;
  synchronization2?: Bool32;
}

export class PhysicalDeviceSynchronization2Features implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSynchronization2Features);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSynchronization2Features) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSynchronization2Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSynchronization2Features.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSynchronization2Features.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.synchronization2 !== undefined) this.synchronization2 = data.synchronization2;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get synchronization2() {
    return this.#view.getUint32(16, LE);
  }
  
  set synchronization2(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
  pNext?: AnyPointer;
  primitivesGeneratedQuery?: Bool32;
  primitivesGeneratedQueryWithRasterizerDiscard?: Bool32;
  primitivesGeneratedQueryWithNonZeroStreams?: Bool32;
}

export class PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.primitivesGeneratedQuery !== undefined) this.primitivesGeneratedQuery = data.primitivesGeneratedQuery;
      if (data.primitivesGeneratedQueryWithRasterizerDiscard !== undefined) this.primitivesGeneratedQueryWithRasterizerDiscard = data.primitivesGeneratedQueryWithRasterizerDiscard;
      if (data.primitivesGeneratedQueryWithNonZeroStreams !== undefined) this.primitivesGeneratedQueryWithNonZeroStreams = data.primitivesGeneratedQueryWithNonZeroStreams;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get primitivesGeneratedQuery() {
    return this.#view.getUint32(16, LE);
  }
  
  set primitivesGeneratedQuery(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get primitivesGeneratedQueryWithRasterizerDiscard() {
    return this.#view.getUint32(20, LE);
  }
  
  set primitivesGeneratedQueryWithRasterizerDiscard(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primitivesGeneratedQueryWithNonZeroStreams() {
    return this.#view.getUint32(24, LE);
  }
  
  set primitivesGeneratedQueryWithNonZeroStreams(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceLegacyDitheringFeaturesEXT {
  pNext?: AnyPointer;
  legacyDithering?: Bool32;
}

export class PhysicalDeviceLegacyDitheringFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceLegacyDitheringFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceLegacyDitheringFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceLegacyDitheringFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceLegacyDitheringFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceLegacyDitheringFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.legacyDithering !== undefined) this.legacyDithering = data.legacyDithering;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get legacyDithering() {
    return this.#view.getUint32(16, LE);
  }
  
  set legacyDithering(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
  pNext?: AnyPointer;
  multisampledRenderToSingleSampled?: Bool32;
}

export class PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.multisampledRenderToSingleSampled !== undefined) this.multisampledRenderToSingleSampled = data.multisampledRenderToSingleSampled;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get multisampledRenderToSingleSampled() {
    return this.#view.getUint32(16, LE);
  }
  
  set multisampledRenderToSingleSampled(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitSubpassResolvePerformanceQueryEXT {
  pNext?: AnyPointer;
  optimal?: Bool32;
}

export class SubpassResolvePerformanceQueryEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubpassResolvePerformanceQueryEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubpassResolvePerformanceQueryEXT) {
    if (!data) {
      this.#data = new Uint8Array(SubpassResolvePerformanceQueryEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubpassResolvePerformanceQueryEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubpassResolvePerformanceQueryEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.optimal !== undefined) this.optimal = data.optimal;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get optimal() {
    return this.#view.getUint32(16, LE);
  }
  
  set optimal(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMultisampledRenderToSingleSampledInfoEXT {
  pNext?: AnyPointer;
  multisampledRenderToSingleSampledEnable?: Bool32;
  rasterizationSamples?: SampleCountFlagBits;
}

export class MultisampledRenderToSingleSampledInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMultisampledRenderToSingleSampledInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMultisampledRenderToSingleSampledInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MultisampledRenderToSingleSampledInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MultisampledRenderToSingleSampledInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MultisampledRenderToSingleSampledInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.multisampledRenderToSingleSampledEnable !== undefined) this.multisampledRenderToSingleSampledEnable = data.multisampledRenderToSingleSampledEnable;
      if (data.rasterizationSamples !== undefined) this.rasterizationSamples = data.rasterizationSamples;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get multisampledRenderToSingleSampledEnable() {
    return this.#view.getUint32(16, LE);
  }
  
  set multisampledRenderToSingleSampledEnable(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDevicePipelineProtectedAccessFeaturesEXT {
  pNext?: AnyPointer;
  pipelineProtectedAccess?: Bool32;
}

export class PhysicalDevicePipelineProtectedAccessFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelineProtectedAccessFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelineProtectedAccessFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelineProtectedAccessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelineProtectedAccessFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelineProtectedAccessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineProtectedAccess !== undefined) this.pipelineProtectedAccess = data.pipelineProtectedAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineProtectedAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineProtectedAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitQueueFamilyVideoPropertiesKHR {
  pNext?: AnyPointer;
  videoCodecOperations?: VideoCodecOperationFlagsKHR;
}

export class QueueFamilyVideoPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyVideoPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyVideoPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyVideoPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyVideoPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyVideoPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.videoCodecOperations !== undefined) this.videoCodecOperations = data.videoCodecOperations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get videoCodecOperations() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoCodecOperations(value: VideoCodecOperationFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitQueueFamilyQueryResultStatusPropertiesKHR {
  pNext?: AnyPointer;
  queryResultStatusSupport?: Bool32;
}

export class QueueFamilyQueryResultStatusPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitQueueFamilyQueryResultStatusPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitQueueFamilyQueryResultStatusPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(QueueFamilyQueryResultStatusPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < QueueFamilyQueryResultStatusPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(QueueFamilyQueryResultStatusPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.queryResultStatusSupport !== undefined) this.queryResultStatusSupport = data.queryResultStatusSupport;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get queryResultStatusSupport() {
    return this.#view.getUint32(16, LE);
  }
  
  set queryResultStatusSupport(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoProfileListInfoKHR {
  pNext?: AnyPointer;
  profileCount?: number;
  pProfiles?: AnyPointer;
}

export class VideoProfileListInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoProfileListInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoProfileListInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoProfileListInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoProfileListInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoProfileListInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.profileCount !== undefined) this.profileCount = data.profileCount;
      if (data.pProfiles !== undefined) this.pProfiles = data.pProfiles;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get profileCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set profileCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pProfiles() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pProfiles(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceVideoFormatInfoKHR {
  pNext?: AnyPointer;
  imageUsage?: ImageUsageFlags;
}

export class PhysicalDeviceVideoFormatInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceVideoFormatInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceVideoFormatInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceVideoFormatInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceVideoFormatInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceVideoFormatInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageUsage !== undefined) this.imageUsage = data.imageUsage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageUsage() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageUsage(value: ImageUsageFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoFormatPropertiesKHR {
  pNext?: AnyPointer;
  format?: Format;
  componentMapping?: ComponentMapping;
  imageCreateFlags?: ImageCreateFlags;
  imageType?: ImageType;
  imageTiling?: ImageTiling;
  imageUsageFlags?: ImageUsageFlags;
}

export class VideoFormatPropertiesKHR implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoFormatPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoFormatPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoFormatPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoFormatPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoFormatPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.componentMapping !== undefined) this.componentMapping = data.componentMapping;
      if (data.imageCreateFlags !== undefined) this.imageCreateFlags = data.imageCreateFlags;
      if (data.imageType !== undefined) this.imageType = data.imageType;
      if (data.imageTiling !== undefined) this.imageTiling = data.imageTiling;
      if (data.imageUsageFlags !== undefined) this.imageUsageFlags = data.imageUsageFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get componentMapping() {
    return new ComponentMapping(this.#data.subarray(20, 20 + ComponentMapping.size));
  }
  
  set componentMapping(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get imageCreateFlags() {
    return this.#view.getUint32(36, LE);
  }
  
  set imageCreateFlags(value: ImageCreateFlags) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get imageType() {
    return this.#view.getUint32(40, LE);
  }
  
  set imageType(value: ImageType) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get imageTiling() {
    return this.#view.getUint32(44, LE);
  }
  
  set imageTiling(value: ImageTiling) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get imageUsageFlags() {
    return this.#view.getUint32(48, LE);
  }
  
  set imageUsageFlags(value: ImageUsageFlags) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitVideoProfileInfoKHR {
  pNext?: AnyPointer;
  videoCodecOperation?: VideoCodecOperationFlagBitsKHR;
  chromaSubsampling?: VideoChromaSubsamplingFlagsKHR;
  lumaBitDepth?: VideoComponentBitDepthFlagsKHR;
  chromaBitDepth?: VideoComponentBitDepthFlagsKHR;
}

export class VideoProfileInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoProfileInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoProfileInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoProfileInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoProfileInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoProfileInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.videoCodecOperation !== undefined) this.videoCodecOperation = data.videoCodecOperation;
      if (data.chromaSubsampling !== undefined) this.chromaSubsampling = data.chromaSubsampling;
      if (data.lumaBitDepth !== undefined) this.lumaBitDepth = data.lumaBitDepth;
      if (data.chromaBitDepth !== undefined) this.chromaBitDepth = data.chromaBitDepth;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get videoCodecOperation() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoCodecOperation(value: VideoCodecOperationFlagBitsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get chromaSubsampling() {
    return this.#view.getUint32(20, LE);
  }
  
  set chromaSubsampling(value: VideoChromaSubsamplingFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get lumaBitDepth() {
    return this.#view.getUint32(24, LE);
  }
  
  set lumaBitDepth(value: VideoComponentBitDepthFlagsKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get chromaBitDepth() {
    return this.#view.getUint32(28, LE);
  }
  
  set chromaBitDepth(value: VideoComponentBitDepthFlagsKHR) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitVideoCapabilitiesKHR {
  pNext?: AnyPointer;
  flags?: VideoCapabilityFlagsKHR;
  minBitstreamBufferOffsetAlignment?: DeviceSize;
  minBitstreamBufferSizeAlignment?: DeviceSize;
  pictureAccessGranularity?: Extent2D;
  minCodedExtent?: Extent2D;
  maxCodedExtent?: Extent2D;
  maxDpbSlots?: number;
  maxActiveReferencePictures?: number;
  stdHeaderVersion?: ExtensionProperties;
}

export class VideoCapabilitiesKHR implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.minBitstreamBufferOffsetAlignment !== undefined) this.minBitstreamBufferOffsetAlignment = data.minBitstreamBufferOffsetAlignment;
      if (data.minBitstreamBufferSizeAlignment !== undefined) this.minBitstreamBufferSizeAlignment = data.minBitstreamBufferSizeAlignment;
      if (data.pictureAccessGranularity !== undefined) this.pictureAccessGranularity = data.pictureAccessGranularity;
      if (data.minCodedExtent !== undefined) this.minCodedExtent = data.minCodedExtent;
      if (data.maxCodedExtent !== undefined) this.maxCodedExtent = data.maxCodedExtent;
      if (data.maxDpbSlots !== undefined) this.maxDpbSlots = data.maxDpbSlots;
      if (data.maxActiveReferencePictures !== undefined) this.maxActiveReferencePictures = data.maxActiveReferencePictures;
      if (data.stdHeaderVersion !== undefined) this.stdHeaderVersion = data.stdHeaderVersion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get minBitstreamBufferOffsetAlignment() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set minBitstreamBufferOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get minBitstreamBufferSizeAlignment() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set minBitstreamBufferSizeAlignment(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get pictureAccessGranularity() {
    return new Extent2D(this.#data.subarray(40, 40 + Extent2D.size));
  }
  
  set pictureAccessGranularity(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get minCodedExtent() {
    return new Extent2D(this.#data.subarray(48, 48 + Extent2D.size));
  }
  
  set minCodedExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get maxCodedExtent() {
    return new Extent2D(this.#data.subarray(56, 56 + Extent2D.size));
  }
  
  set maxCodedExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get maxDpbSlots() {
    return this.#view.getUint32(64, LE);
  }
  
  set maxDpbSlots(value: number) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get maxActiveReferencePictures() {
    return this.#view.getUint32(68, LE);
  }
  
  set maxActiveReferencePictures(value: number) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get stdHeaderVersion() {
    return new ExtensionProperties(this.#data.subarray(72, 72 + ExtensionProperties.size));
  }
  
  set stdHeaderVersion(value: ExtensionProperties) {
    if (value[BUFFER].byteLength < ExtensionProperties.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitVideoSessionMemoryRequirementsKHR {
  pNext?: AnyPointer;
  memoryBindIndex?: number;
  memoryRequirements?: MemoryRequirements;
}

export class VideoSessionMemoryRequirementsKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoSessionMemoryRequirementsKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoSessionMemoryRequirementsKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoSessionMemoryRequirementsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoSessionMemoryRequirementsKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoSessionMemoryRequirementsKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryBindIndex !== undefined) this.memoryBindIndex = data.memoryBindIndex;
      if (data.memoryRequirements !== undefined) this.memoryRequirements = data.memoryRequirements;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryBindIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryBindIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memoryRequirements() {
    return new MemoryRequirements(this.#data.subarray(24, 24 + MemoryRequirements.size));
  }
  
  set memoryRequirements(value: MemoryRequirements) {
    if (value[BUFFER].byteLength < MemoryRequirements.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
}

export interface InitBindVideoSessionMemoryInfoKHR {
  pNext?: AnyPointer;
  memoryBindIndex?: number;
  memory?: DeviceMemory;
  memoryOffset?: DeviceSize;
  memorySize?: DeviceSize;
}

export class BindVideoSessionMemoryInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBindVideoSessionMemoryInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBindVideoSessionMemoryInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(BindVideoSessionMemoryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BindVideoSessionMemoryInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BindVideoSessionMemoryInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryBindIndex !== undefined) this.memoryBindIndex = data.memoryBindIndex;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.memoryOffset !== undefined) this.memoryOffset = data.memoryOffset;
      if (data.memorySize !== undefined) this.memorySize = data.memorySize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryBindIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryBindIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get memoryOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set memoryOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get memorySize() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set memorySize(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
}

export interface InitVideoPictureResourceInfoKHR {
  pNext?: AnyPointer;
  codedOffset?: Offset2D;
  codedExtent?: Extent2D;
  baseArrayLayer?: number;
  imageViewBinding?: ImageView;
}

export class VideoPictureResourceInfoKHR implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoPictureResourceInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoPictureResourceInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoPictureResourceInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoPictureResourceInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoPictureResourceInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.codedOffset !== undefined) this.codedOffset = data.codedOffset;
      if (data.codedExtent !== undefined) this.codedExtent = data.codedExtent;
      if (data.baseArrayLayer !== undefined) this.baseArrayLayer = data.baseArrayLayer;
      if (data.imageViewBinding !== undefined) this.imageViewBinding = data.imageViewBinding;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get codedOffset() {
    return new Offset2D(this.#data.subarray(16, 16 + Offset2D.size));
  }
  
  set codedOffset(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get codedExtent() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set codedExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get baseArrayLayer() {
    return this.#view.getUint32(32, LE);
  }
  
  set baseArrayLayer(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get imageViewBinding() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set imageViewBinding(value: ImageView) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoReferenceSlotInfoKHR {
  pNext?: AnyPointer;
  slotIndex?: number;
  pPictureResource?: AnyPointer;
}

export class VideoReferenceSlotInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoReferenceSlotInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoReferenceSlotInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoReferenceSlotInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoReferenceSlotInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoReferenceSlotInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.slotIndex !== undefined) this.slotIndex = data.slotIndex;
      if (data.pPictureResource !== undefined) this.pPictureResource = data.pPictureResource;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt32(16, LE);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt32(16, Number(value), LE);
  }
  
  get pPictureResource() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPictureResource(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeCapabilitiesKHR {
  pNext?: AnyPointer;
  flags?: VideoDecodeCapabilityFlagsKHR;
}

export class VideoDecodeCapabilitiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoDecodeCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoDecodeUsageInfoKHR {
  pNext?: AnyPointer;
  videoUsageHints?: VideoDecodeUsageFlagsKHR;
}

export class VideoDecodeUsageInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeUsageInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeUsageInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeUsageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeUsageInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeUsageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.videoUsageHints !== undefined) this.videoUsageHints = data.videoUsageHints;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get videoUsageHints() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoUsageHints(value: VideoDecodeUsageFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoDecodeInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoDecodeFlagsKHR;
  srcBuffer?: Buffer;
  srcBufferOffset?: DeviceSize;
  srcBufferRange?: DeviceSize;
  dstPictureResource?: VideoPictureResourceInfoKHR;
  pSetupReferenceSlot?: AnyPointer;
  referenceSlotCount?: number;
  pReferenceSlots?: AnyPointer;
}

export class VideoDecodeInfoKHR implements BaseStruct {
  static size = 120;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.srcBuffer !== undefined) this.srcBuffer = data.srcBuffer;
      if (data.srcBufferOffset !== undefined) this.srcBufferOffset = data.srcBufferOffset;
      if (data.srcBufferRange !== undefined) this.srcBufferRange = data.srcBufferRange;
      if (data.dstPictureResource !== undefined) this.dstPictureResource = data.dstPictureResource;
      if (data.pSetupReferenceSlot !== undefined) this.pSetupReferenceSlot = data.pSetupReferenceSlot;
      if (data.referenceSlotCount !== undefined) this.referenceSlotCount = data.referenceSlotCount;
      if (data.pReferenceSlots !== undefined) this.pReferenceSlots = data.pReferenceSlots;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoDecodeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get srcBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set srcBuffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get srcBufferOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set srcBufferOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get srcBufferRange() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set srcBufferRange(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get dstPictureResource() {
    return new VideoPictureResourceInfoKHR(this.#data.subarray(48, 48 + VideoPictureResourceInfoKHR.size));
  }
  
  set dstPictureResource(value: VideoPictureResourceInfoKHR) {
    if (value[BUFFER].byteLength < VideoPictureResourceInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get pSetupReferenceSlot() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pSetupReferenceSlot(value: AnyPointer) {
    this.#view.setBigUint64(96, BigInt(anyPointer(value)), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(104, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set pReferenceSlots(value: AnyPointer) {
    this.#view.setBigUint64(112, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH264ProfileInfoEXT {
  pNext?: AnyPointer;
  stdProfileIdc?: StdVideoH264ProfileIdc;
  pictureLayout?: VideoDecodeH264PictureLayoutFlagBitsEXT;
}

export class VideoDecodeH264ProfileInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264ProfileInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264ProfileInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264ProfileInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdProfileIdc !== undefined) this.stdProfileIdc = data.stdProfileIdc;
      if (data.pictureLayout !== undefined) this.pictureLayout = data.pictureLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pictureLayout() {
    return this.#view.getUint32(20, LE);
  }
  
  set pictureLayout(value: VideoDecodeH264PictureLayoutFlagBitsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitVideoDecodeH264CapabilitiesEXT {
  pNext?: AnyPointer;
  maxLevelIdc?: StdVideoH264LevelIdc;
  fieldOffsetGranularity?: Offset2D;
}

export class VideoDecodeH264CapabilitiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264CapabilitiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264CapabilitiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264CapabilitiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxLevelIdc !== undefined) this.maxLevelIdc = data.maxLevelIdc;
      if (data.fieldOffsetGranularity !== undefined) this.fieldOffsetGranularity = data.fieldOffsetGranularity;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxLevelIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxLevelIdc(value: StdVideoH264LevelIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get fieldOffsetGranularity() {
    return new Offset2D(this.#data.subarray(20, 20 + Offset2D.size));
  }
  
  set fieldOffsetGranularity(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
}

export interface InitVideoDecodeH264SessionParametersAddInfoEXT {
  pNext?: AnyPointer;
  stdSPSCount?: number;
  pStdSPSs?: AnyPointer;
  stdPPSCount?: number;
  pStdPPSs?: AnyPointer;
}

export class VideoDecodeH264SessionParametersAddInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264SessionParametersAddInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264SessionParametersAddInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264SessionParametersAddInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdSPSCount !== undefined) this.stdSPSCount = data.stdSPSCount;
      if (data.pStdSPSs !== undefined) this.pStdSPSs = data.pStdSPSs;
      if (data.stdPPSCount !== undefined) this.stdPPSCount = data.stdPPSCount;
      if (data.pStdPPSs !== undefined) this.pStdPPSs = data.pStdPPSs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdSPSs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdPPSs(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH264SessionParametersCreateInfoEXT {
  pNext?: AnyPointer;
  maxStdSPSCount?: number;
  maxStdPPSCount?: number;
  pParametersAddInfo?: AnyPointer;
}

export class VideoDecodeH264SessionParametersCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264SessionParametersCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264SessionParametersCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264SessionParametersCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxStdSPSCount !== undefined) this.maxStdSPSCount = data.maxStdSPSCount;
      if (data.maxStdPPSCount !== undefined) this.maxStdPPSCount = data.maxStdPPSCount;
      if (data.pParametersAddInfo !== undefined) this.pParametersAddInfo = data.pParametersAddInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pParametersAddInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH264PictureInfoEXT {
  pNext?: AnyPointer;
  pStdPictureInfo?: AnyPointer;
  sliceCount?: number;
  pSliceOffsets?: AnyPointer;
}

export class VideoDecodeH264PictureInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264PictureInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264PictureInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264PictureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264PictureInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264PictureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pStdPictureInfo !== undefined) this.pStdPictureInfo = data.pStdPictureInfo;
      if (data.sliceCount !== undefined) this.sliceCount = data.sliceCount;
      if (data.pSliceOffsets !== undefined) this.pSliceOffsets = data.pSliceOffsets;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pStdPictureInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdPictureInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get sliceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set sliceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSliceOffsets() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceOffsets(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH264DpbSlotInfoEXT {
  pNext?: AnyPointer;
  pStdReferenceInfo?: AnyPointer;
}

export class VideoDecodeH264DpbSlotInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH264DpbSlotInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH264DpbSlotInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH264DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH264DpbSlotInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH264DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pStdReferenceInfo !== undefined) this.pStdReferenceInfo = data.pStdReferenceInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdReferenceInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH265ProfileInfoEXT {
  pNext?: AnyPointer;
  stdProfileIdc?: StdVideoH265ProfileIdc;
}

export class VideoDecodeH265ProfileInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265ProfileInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265ProfileInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265ProfileInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdProfileIdc !== undefined) this.stdProfileIdc = data.stdProfileIdc;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoDecodeH265CapabilitiesEXT {
  pNext?: AnyPointer;
  maxLevelIdc?: StdVideoH265LevelIdc;
}

export class VideoDecodeH265CapabilitiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265CapabilitiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265CapabilitiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265CapabilitiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxLevelIdc !== undefined) this.maxLevelIdc = data.maxLevelIdc;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxLevelIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxLevelIdc(value: StdVideoH265LevelIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoDecodeH265SessionParametersAddInfoEXT {
  pNext?: AnyPointer;
  stdVPSCount?: number;
  pStdVPSs?: AnyPointer;
  stdSPSCount?: number;
  pStdSPSs?: AnyPointer;
  stdPPSCount?: number;
  pStdPPSs?: AnyPointer;
}

export class VideoDecodeH265SessionParametersAddInfoEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265SessionParametersAddInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265SessionParametersAddInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265SessionParametersAddInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdVPSCount !== undefined) this.stdVPSCount = data.stdVPSCount;
      if (data.pStdVPSs !== undefined) this.pStdVPSs = data.pStdVPSs;
      if (data.stdSPSCount !== undefined) this.stdSPSCount = data.stdSPSCount;
      if (data.pStdSPSs !== undefined) this.pStdSPSs = data.pStdSPSs;
      if (data.stdPPSCount !== undefined) this.stdPPSCount = data.stdPPSCount;
      if (data.pStdPPSs !== undefined) this.pStdPPSs = data.pStdPPSs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdVPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdVPSs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdSPSs(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pStdPPSs(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH265SessionParametersCreateInfoEXT {
  pNext?: AnyPointer;
  maxStdVPSCount?: number;
  maxStdSPSCount?: number;
  maxStdPPSCount?: number;
  pParametersAddInfo?: AnyPointer;
}

export class VideoDecodeH265SessionParametersCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265SessionParametersCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265SessionParametersCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265SessionParametersCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxStdVPSCount !== undefined) this.maxStdVPSCount = data.maxStdVPSCount;
      if (data.maxStdSPSCount !== undefined) this.maxStdSPSCount = data.maxStdSPSCount;
      if (data.maxStdPPSCount !== undefined) this.maxStdPPSCount = data.maxStdPPSCount;
      if (data.pParametersAddInfo !== undefined) this.pParametersAddInfo = data.pParametersAddInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxStdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pParametersAddInfo(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH265PictureInfoEXT {
  pNext?: AnyPointer;
  pStdPictureInfo?: AnyPointer;
  sliceCount?: number;
  pSliceOffsets?: AnyPointer;
}

export class VideoDecodeH265PictureInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265PictureInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265PictureInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265PictureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265PictureInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265PictureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pStdPictureInfo !== undefined) this.pStdPictureInfo = data.pStdPictureInfo;
      if (data.sliceCount !== undefined) this.sliceCount = data.sliceCount;
      if (data.pSliceOffsets !== undefined) this.pSliceOffsets = data.pSliceOffsets;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pStdPictureInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdPictureInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get sliceCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set sliceCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pSliceOffsets() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceOffsets(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoDecodeH265DpbSlotInfoEXT {
  pNext?: AnyPointer;
  pStdReferenceInfo?: AnyPointer;
}

export class VideoDecodeH265DpbSlotInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoDecodeH265DpbSlotInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoDecodeH265DpbSlotInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoDecodeH265DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoDecodeH265DpbSlotInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoDecodeH265DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pStdReferenceInfo !== undefined) this.pStdReferenceInfo = data.pStdReferenceInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pStdReferenceInfo(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoSessionCreateInfoKHR {
  pNext?: AnyPointer;
  queueFamilyIndex?: number;
  flags?: VideoSessionCreateFlagsKHR;
  pVideoProfile?: AnyPointer;
  pictureFormat?: Format;
  maxCodedExtent?: Extent2D;
  referencePictureFormat?: Format;
  maxDpbSlots?: number;
  maxActiveReferencePictures?: number;
  pStdHeaderVersion?: AnyPointer;
}

export class VideoSessionCreateInfoKHR implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoSessionCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoSessionCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoSessionCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoSessionCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoSessionCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.queueFamilyIndex !== undefined) this.queueFamilyIndex = data.queueFamilyIndex;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.pVideoProfile !== undefined) this.pVideoProfile = data.pVideoProfile;
      if (data.pictureFormat !== undefined) this.pictureFormat = data.pictureFormat;
      if (data.maxCodedExtent !== undefined) this.maxCodedExtent = data.maxCodedExtent;
      if (data.referencePictureFormat !== undefined) this.referencePictureFormat = data.referencePictureFormat;
      if (data.maxDpbSlots !== undefined) this.maxDpbSlots = data.maxDpbSlots;
      if (data.maxActiveReferencePictures !== undefined) this.maxActiveReferencePictures = data.maxActiveReferencePictures;
      if (data.pStdHeaderVersion !== undefined) this.pStdHeaderVersion = data.pStdHeaderVersion;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get queueFamilyIndex() {
    return this.#view.getUint32(16, LE);
  }
  
  set queueFamilyIndex(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: VideoSessionCreateFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pVideoProfile() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pVideoProfile(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pictureFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set pictureFormat(value: Format) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxCodedExtent() {
    return new Extent2D(this.#data.subarray(36, 36 + Extent2D.size));
  }
  
  set maxCodedExtent(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
  
  get referencePictureFormat() {
    return this.#view.getUint32(44, LE);
  }
  
  set referencePictureFormat(value: Format) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxDpbSlots() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxDpbSlots(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxActiveReferencePictures() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxActiveReferencePictures(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get pStdHeaderVersion() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pStdHeaderVersion(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoSessionParametersCreateInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoSessionParametersCreateFlagsKHR;
  videoSessionParametersTemplate?: VideoSessionParametersKHR;
  videoSession?: VideoSessionKHR;
}

export class VideoSessionParametersCreateInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoSessionParametersCreateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoSessionParametersCreateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoSessionParametersCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoSessionParametersCreateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoSessionParametersCreateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.videoSessionParametersTemplate !== undefined) this.videoSessionParametersTemplate = data.videoSessionParametersTemplate;
      if (data.videoSession !== undefined) this.videoSession = data.videoSession;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoSessionParametersCreateFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoSessionParametersTemplate() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set videoSessionParametersTemplate(value: VideoSessionParametersKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get videoSession() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set videoSession(value: VideoSessionKHR) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoSessionParametersUpdateInfoKHR {
  pNext?: AnyPointer;
  updateSequenceCount?: number;
}

export class VideoSessionParametersUpdateInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoSessionParametersUpdateInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoSessionParametersUpdateInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoSessionParametersUpdateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoSessionParametersUpdateInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoSessionParametersUpdateInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.updateSequenceCount !== undefined) this.updateSequenceCount = data.updateSequenceCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get updateSequenceCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set updateSequenceCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoBeginCodingInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoBeginCodingFlagsKHR;
  videoSession?: VideoSessionKHR;
  videoSessionParameters?: VideoSessionParametersKHR;
  referenceSlotCount?: number;
  pReferenceSlots?: AnyPointer;
}

export class VideoBeginCodingInfoKHR implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoBeginCodingInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoBeginCodingInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoBeginCodingInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoBeginCodingInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoBeginCodingInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.videoSession !== undefined) this.videoSession = data.videoSession;
      if (data.videoSessionParameters !== undefined) this.videoSessionParameters = data.videoSessionParameters;
      if (data.referenceSlotCount !== undefined) this.referenceSlotCount = data.referenceSlotCount;
      if (data.pReferenceSlots !== undefined) this.pReferenceSlots = data.pReferenceSlots;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoBeginCodingFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoSession() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set videoSession(value: VideoSessionKHR) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get videoSessionParameters() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set videoSessionParameters(value: VideoSessionParametersKHR) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pReferenceSlots(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEndCodingInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoEndCodingFlagsKHR;
}

export class VideoEndCodingInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEndCodingInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEndCodingInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEndCodingInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEndCodingInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEndCodingInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEndCodingFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoCodingControlInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoCodingControlFlagsKHR;
}

export class VideoCodingControlInfoKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoCodingControlInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoCodingControlInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoCodingControlInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoCodingControlInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoCodingControlInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoCodingControlFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoEncodeUsageInfoKHR {
  pNext?: AnyPointer;
  videoUsageHints?: VideoEncodeUsageFlagsKHR;
  videoContentHints?: VideoEncodeContentFlagsKHR;
  tuningMode?: VideoEncodeTuningModeKHR;
}

export class VideoEncodeUsageInfoKHR implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeUsageInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeUsageInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeUsageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeUsageInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeUsageInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.videoUsageHints !== undefined) this.videoUsageHints = data.videoUsageHints;
      if (data.videoContentHints !== undefined) this.videoContentHints = data.videoContentHints;
      if (data.tuningMode !== undefined) this.tuningMode = data.tuningMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get videoUsageHints() {
    return this.#view.getUint32(16, LE);
  }
  
  set videoUsageHints(value: VideoEncodeUsageFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get videoContentHints() {
    return this.#view.getUint32(20, LE);
  }
  
  set videoContentHints(value: VideoEncodeContentFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get tuningMode() {
    return this.#view.getUint32(24, LE);
  }
  
  set tuningMode(value: VideoEncodeTuningModeKHR) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitVideoEncodeInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoEncodeFlagsKHR;
  qualityLevel?: number;
  dstBitstreamBuffer?: Buffer;
  dstBitstreamBufferOffset?: DeviceSize;
  dstBitstreamBufferMaxRange?: DeviceSize;
  srcPictureResource?: VideoPictureResourceInfoKHR;
  pSetupReferenceSlot?: AnyPointer;
  referenceSlotCount?: number;
  pReferenceSlots?: AnyPointer;
  precedingExternallyEncodedBytes?: number;
}

export class VideoEncodeInfoKHR implements BaseStruct {
  static size = 128;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.qualityLevel !== undefined) this.qualityLevel = data.qualityLevel;
      if (data.dstBitstreamBuffer !== undefined) this.dstBitstreamBuffer = data.dstBitstreamBuffer;
      if (data.dstBitstreamBufferOffset !== undefined) this.dstBitstreamBufferOffset = data.dstBitstreamBufferOffset;
      if (data.dstBitstreamBufferMaxRange !== undefined) this.dstBitstreamBufferMaxRange = data.dstBitstreamBufferMaxRange;
      if (data.srcPictureResource !== undefined) this.srcPictureResource = data.srcPictureResource;
      if (data.pSetupReferenceSlot !== undefined) this.pSetupReferenceSlot = data.pSetupReferenceSlot;
      if (data.referenceSlotCount !== undefined) this.referenceSlotCount = data.referenceSlotCount;
      if (data.pReferenceSlots !== undefined) this.pReferenceSlots = data.pReferenceSlots;
      if (data.precedingExternallyEncodedBytes !== undefined) this.precedingExternallyEncodedBytes = data.precedingExternallyEncodedBytes;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEncodeFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get qualityLevel() {
    return this.#view.getUint32(20, LE);
  }
  
  set qualityLevel(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get dstBitstreamBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dstBitstreamBuffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get dstBitstreamBufferOffset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstBitstreamBufferOffset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get dstBitstreamBufferMaxRange() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set dstBitstreamBufferMaxRange(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get srcPictureResource() {
    return new VideoPictureResourceInfoKHR(this.#data.subarray(48, 48 + VideoPictureResourceInfoKHR.size));
  }
  
  set srcPictureResource(value: VideoPictureResourceInfoKHR) {
    if (value[BUFFER].byteLength < VideoPictureResourceInfoKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 48);
  }
  
  get pSetupReferenceSlot() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set pSetupReferenceSlot(value: AnyPointer) {
    this.#view.setBigUint64(96, BigInt(anyPointer(value)), LE);
  }
  
  get referenceSlotCount() {
    return this.#view.getUint32(104, LE);
  }
  
  set referenceSlotCount(value: number) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get pReferenceSlots() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set pReferenceSlots(value: AnyPointer) {
    this.#view.setBigUint64(112, BigInt(anyPointer(value)), LE);
  }
  
  get precedingExternallyEncodedBytes() {
    return this.#view.getUint32(120, LE);
  }
  
  set precedingExternallyEncodedBytes(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
}

export interface InitVideoEncodeRateControlInfoKHR {
  pNext?: AnyPointer;
  flags?: VideoEncodeRateControlFlagsKHR;
  rateControlMode?: VideoEncodeRateControlModeFlagBitsKHR;
  layerCount?: number;
  pLayerConfigs?: AnyPointer;
}

export class VideoEncodeRateControlInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeRateControlInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeRateControlInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeRateControlInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeRateControlInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeRateControlInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.rateControlMode !== undefined) this.rateControlMode = data.rateControlMode;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
      if (data.pLayerConfigs !== undefined) this.pLayerConfigs = data.pLayerConfigs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEncodeRateControlFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rateControlMode() {
    return this.#view.getUint32(20, LE);
  }
  
  set rateControlMode(value: VideoEncodeRateControlModeFlagBitsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get layerCount() {
    return this.#view.getUint8(24);
  }
  
  set layerCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get pLayerConfigs() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pLayerConfigs(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeRateControlLayerInfoKHR {
  pNext?: AnyPointer;
  averageBitrate?: number;
  maxBitrate?: number;
  frameRateNumerator?: number;
  frameRateDenominator?: number;
  virtualBufferSizeInMs?: number;
  initialVirtualBufferSizeInMs?: number;
}

export class VideoEncodeRateControlLayerInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeRateControlLayerInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeRateControlLayerInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeRateControlLayerInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeRateControlLayerInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeRateControlLayerInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.averageBitrate !== undefined) this.averageBitrate = data.averageBitrate;
      if (data.maxBitrate !== undefined) this.maxBitrate = data.maxBitrate;
      if (data.frameRateNumerator !== undefined) this.frameRateNumerator = data.frameRateNumerator;
      if (data.frameRateDenominator !== undefined) this.frameRateDenominator = data.frameRateDenominator;
      if (data.virtualBufferSizeInMs !== undefined) this.virtualBufferSizeInMs = data.virtualBufferSizeInMs;
      if (data.initialVirtualBufferSizeInMs !== undefined) this.initialVirtualBufferSizeInMs = data.initialVirtualBufferSizeInMs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get averageBitrate() {
    return this.#view.getUint32(16, LE);
  }
  
  set averageBitrate(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxBitrate() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxBitrate(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get frameRateNumerator() {
    return this.#view.getUint32(24, LE);
  }
  
  set frameRateNumerator(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get frameRateDenominator() {
    return this.#view.getUint32(28, LE);
  }
  
  set frameRateDenominator(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get virtualBufferSizeInMs() {
    return this.#view.getUint32(32, LE);
  }
  
  set virtualBufferSizeInMs(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get initialVirtualBufferSizeInMs() {
    return this.#view.getUint32(36, LE);
  }
  
  set initialVirtualBufferSizeInMs(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export interface InitVideoEncodeCapabilitiesKHR {
  pNext?: AnyPointer;
  flags?: VideoEncodeCapabilityFlagsKHR;
  rateControlModes?: VideoEncodeRateControlModeFlagsKHR;
  rateControlLayerCount?: number;
  qualityLevelCount?: number;
  inputImageDataFillAlignment?: Extent2D;
}

export class VideoEncodeCapabilitiesKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeCapabilitiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeCapabilitiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeCapabilitiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeCapabilitiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.rateControlModes !== undefined) this.rateControlModes = data.rateControlModes;
      if (data.rateControlLayerCount !== undefined) this.rateControlLayerCount = data.rateControlLayerCount;
      if (data.qualityLevelCount !== undefined) this.qualityLevelCount = data.qualityLevelCount;
      if (data.inputImageDataFillAlignment !== undefined) this.inputImageDataFillAlignment = data.inputImageDataFillAlignment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEncodeCapabilityFlagsKHR) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rateControlModes() {
    return this.#view.getUint32(20, LE);
  }
  
  set rateControlModes(value: VideoEncodeRateControlModeFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rateControlLayerCount() {
    return this.#view.getUint8(24);
  }
  
  set rateControlLayerCount(value: number) {
    this.#view.setUint8(24, Number(value));
  }
  
  get qualityLevelCount() {
    return this.#view.getUint8(25);
  }
  
  set qualityLevelCount(value: number) {
    this.#view.setUint8(25, Number(value));
  }
  
  get inputImageDataFillAlignment() {
    return new Extent2D(this.#data.subarray(28, 28 + Extent2D.size));
  }
  
  set inputImageDataFillAlignment(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
}

export interface InitVideoEncodeH264CapabilitiesEXT {
  pNext?: AnyPointer;
  flags?: VideoEncodeH264CapabilityFlagsEXT;
  inputModeFlags?: VideoEncodeH264InputModeFlagsEXT;
  outputModeFlags?: VideoEncodeH264OutputModeFlagsEXT;
  maxPPictureL0ReferenceCount?: number;
  maxBPictureL0ReferenceCount?: number;
  maxL1ReferenceCount?: number;
  motionVectorsOverPicBoundariesFlag?: Bool32;
  maxBytesPerPicDenom?: number;
  maxBitsPerMbDenom?: number;
  log2MaxMvLengthHorizontal?: number;
  log2MaxMvLengthVertical?: number;
}

export class VideoEncodeH264CapabilitiesEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264CapabilitiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264CapabilitiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264CapabilitiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.inputModeFlags !== undefined) this.inputModeFlags = data.inputModeFlags;
      if (data.outputModeFlags !== undefined) this.outputModeFlags = data.outputModeFlags;
      if (data.maxPPictureL0ReferenceCount !== undefined) this.maxPPictureL0ReferenceCount = data.maxPPictureL0ReferenceCount;
      if (data.maxBPictureL0ReferenceCount !== undefined) this.maxBPictureL0ReferenceCount = data.maxBPictureL0ReferenceCount;
      if (data.maxL1ReferenceCount !== undefined) this.maxL1ReferenceCount = data.maxL1ReferenceCount;
      if (data.motionVectorsOverPicBoundariesFlag !== undefined) this.motionVectorsOverPicBoundariesFlag = data.motionVectorsOverPicBoundariesFlag;
      if (data.maxBytesPerPicDenom !== undefined) this.maxBytesPerPicDenom = data.maxBytesPerPicDenom;
      if (data.maxBitsPerMbDenom !== undefined) this.maxBitsPerMbDenom = data.maxBitsPerMbDenom;
      if (data.log2MaxMvLengthHorizontal !== undefined) this.log2MaxMvLengthHorizontal = data.log2MaxMvLengthHorizontal;
      if (data.log2MaxMvLengthVertical !== undefined) this.log2MaxMvLengthVertical = data.log2MaxMvLengthVertical;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEncodeH264CapabilityFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inputModeFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set inputModeFlags(value: VideoEncodeH264InputModeFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get outputModeFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set outputModeFlags(value: VideoEncodeH264OutputModeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get maxPPictureL0ReferenceCount() {
    return this.#view.getUint8(28);
  }
  
  set maxPPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(28, Number(value));
  }
  
  get maxBPictureL0ReferenceCount() {
    return this.#view.getUint8(29);
  }
  
  set maxBPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(29, Number(value));
  }
  
  get maxL1ReferenceCount() {
    return this.#view.getUint8(30);
  }
  
  set maxL1ReferenceCount(value: number) {
    this.#view.setUint8(30, Number(value));
  }
  
  get motionVectorsOverPicBoundariesFlag() {
    return this.#view.getUint32(32, LE);
  }
  
  set motionVectorsOverPicBoundariesFlag(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxBytesPerPicDenom() {
    return this.#view.getUint32(36, LE);
  }
  
  set maxBytesPerPicDenom(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get maxBitsPerMbDenom() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxBitsPerMbDenom(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get log2MaxMvLengthHorizontal() {
    return this.#view.getUint32(44, LE);
  }
  
  set log2MaxMvLengthHorizontal(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get log2MaxMvLengthVertical() {
    return this.#view.getUint32(48, LE);
  }
  
  set log2MaxMvLengthVertical(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitVideoEncodeH264SessionParametersAddInfoEXT {
  pNext?: AnyPointer;
  stdSPSCount?: number;
  pStdSPSs?: AnyPointer;
  stdPPSCount?: number;
  pStdPPSs?: AnyPointer;
}

export class VideoEncodeH264SessionParametersAddInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264SessionParametersAddInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264SessionParametersAddInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264SessionParametersAddInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdSPSCount !== undefined) this.stdSPSCount = data.stdSPSCount;
      if (data.pStdSPSs !== undefined) this.pStdSPSs = data.pStdSPSs;
      if (data.stdPPSCount !== undefined) this.stdPPSCount = data.stdPPSCount;
      if (data.pStdPPSs !== undefined) this.pStdPPSs = data.pStdPPSs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdSPSs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdPPSs(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264SessionParametersCreateInfoEXT {
  pNext?: AnyPointer;
  maxStdSPSCount?: number;
  maxStdPPSCount?: number;
  pParametersAddInfo?: AnyPointer;
}

export class VideoEncodeH264SessionParametersCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264SessionParametersCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264SessionParametersCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264SessionParametersCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxStdSPSCount !== undefined) this.maxStdSPSCount = data.maxStdSPSCount;
      if (data.maxStdPPSCount !== undefined) this.maxStdPPSCount = data.maxStdPPSCount;
      if (data.pParametersAddInfo !== undefined) this.pParametersAddInfo = data.pParametersAddInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pParametersAddInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264DpbSlotInfoEXT {
  pNext?: AnyPointer;
  slotIndex?: number;
  pStdReferenceInfo?: AnyPointer;
}

export class VideoEncodeH264DpbSlotInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264DpbSlotInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264DpbSlotInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264DpbSlotInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.slotIndex !== undefined) this.slotIndex = data.slotIndex;
      if (data.pStdReferenceInfo !== undefined) this.pStdReferenceInfo = data.pStdReferenceInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt8(16);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt8(16, Number(value));
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdReferenceInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264VclFrameInfoEXT {
  pNext?: AnyPointer;
  pReferenceFinalLists?: AnyPointer;
  naluSliceEntryCount?: number;
  pNaluSliceEntries?: AnyPointer;
  pCurrentPictureInfo?: AnyPointer;
}

export class VideoEncodeH264VclFrameInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264VclFrameInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264VclFrameInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264VclFrameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264VclFrameInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264VclFrameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pReferenceFinalLists !== undefined) this.pReferenceFinalLists = data.pReferenceFinalLists;
      if (data.naluSliceEntryCount !== undefined) this.naluSliceEntryCount = data.naluSliceEntryCount;
      if (data.pNaluSliceEntries !== undefined) this.pNaluSliceEntries = data.pNaluSliceEntries;
      if (data.pCurrentPictureInfo !== undefined) this.pCurrentPictureInfo = data.pCurrentPictureInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceFinalLists(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get naluSliceEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set naluSliceEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pNaluSliceEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pNaluSliceEntries(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pCurrentPictureInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCurrentPictureInfo(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264ReferenceListsInfoEXT {
  pNext?: AnyPointer;
  referenceList0EntryCount?: number;
  pReferenceList0Entries?: AnyPointer;
  referenceList1EntryCount?: number;
  pReferenceList1Entries?: AnyPointer;
  pMemMgmtCtrlOperations?: AnyPointer;
}

export class VideoEncodeH264ReferenceListsInfoEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264ReferenceListsInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264ReferenceListsInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264ReferenceListsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264ReferenceListsInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264ReferenceListsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.referenceList0EntryCount !== undefined) this.referenceList0EntryCount = data.referenceList0EntryCount;
      if (data.pReferenceList0Entries !== undefined) this.pReferenceList0Entries = data.pReferenceList0Entries;
      if (data.referenceList1EntryCount !== undefined) this.referenceList1EntryCount = data.referenceList1EntryCount;
      if (data.pReferenceList1Entries !== undefined) this.pReferenceList1Entries = data.pReferenceList1Entries;
      if (data.pMemMgmtCtrlOperations !== undefined) this.pMemMgmtCtrlOperations = data.pMemMgmtCtrlOperations;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get referenceList0EntryCount() {
    return this.#view.getUint8(16);
  }
  
  set referenceList0EntryCount(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pReferenceList0Entries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceList0Entries(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get referenceList1EntryCount() {
    return this.#view.getUint8(32);
  }
  
  set referenceList1EntryCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pReferenceList1Entries() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pReferenceList1Entries(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pMemMgmtCtrlOperations() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pMemMgmtCtrlOperations(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264EmitPictureParametersInfoEXT {
  pNext?: AnyPointer;
  spsId?: number;
  emitSpsEnable?: Bool32;
  ppsIdEntryCount?: number;
  ppsIdEntries?: AnyPointer;
}

export class VideoEncodeH264EmitPictureParametersInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264EmitPictureParametersInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264EmitPictureParametersInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264EmitPictureParametersInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264EmitPictureParametersInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264EmitPictureParametersInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.spsId !== undefined) this.spsId = data.spsId;
      if (data.emitSpsEnable !== undefined) this.emitSpsEnable = data.emitSpsEnable;
      if (data.ppsIdEntryCount !== undefined) this.ppsIdEntryCount = data.ppsIdEntryCount;
      if (data.ppsIdEntries !== undefined) this.ppsIdEntries = data.ppsIdEntries;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get spsId() {
    return this.#view.getUint8(16);
  }
  
  set spsId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get emitSpsEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set emitSpsEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get ppsIdEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set ppsIdEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ppsIdEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set ppsIdEntries(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264ProfileInfoEXT {
  pNext?: AnyPointer;
  stdProfileIdc?: StdVideoH264ProfileIdc;
}

export class VideoEncodeH264ProfileInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264ProfileInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264ProfileInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264ProfileInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdProfileIdc !== undefined) this.stdProfileIdc = data.stdProfileIdc;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH264ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoEncodeH264NaluSliceInfoEXT {
  pNext?: AnyPointer;
  mbCount?: number;
  pReferenceFinalLists?: AnyPointer;
  pSliceHeaderStd?: AnyPointer;
}

export class VideoEncodeH264NaluSliceInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264NaluSliceInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264NaluSliceInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264NaluSliceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264NaluSliceInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264NaluSliceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mbCount !== undefined) this.mbCount = data.mbCount;
      if (data.pReferenceFinalLists !== undefined) this.pReferenceFinalLists = data.pReferenceFinalLists;
      if (data.pSliceHeaderStd !== undefined) this.pSliceHeaderStd = data.pSliceHeaderStd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mbCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set mbCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceFinalLists(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pSliceHeaderStd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceHeaderStd(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH264RateControlInfoEXT {
  pNext?: AnyPointer;
  gopFrameCount?: number;
  idrPeriod?: number;
  consecutiveBFrameCount?: number;
  rateControlStructure?: VideoEncodeH264RateControlStructureEXT;
  temporalLayerCount?: number;
}

export class VideoEncodeH264RateControlInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264RateControlInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264RateControlInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264RateControlInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264RateControlInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264RateControlInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.gopFrameCount !== undefined) this.gopFrameCount = data.gopFrameCount;
      if (data.idrPeriod !== undefined) this.idrPeriod = data.idrPeriod;
      if (data.consecutiveBFrameCount !== undefined) this.consecutiveBFrameCount = data.consecutiveBFrameCount;
      if (data.rateControlStructure !== undefined) this.rateControlStructure = data.rateControlStructure;
      if (data.temporalLayerCount !== undefined) this.temporalLayerCount = data.temporalLayerCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get gopFrameCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set gopFrameCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get idrPeriod() {
    return this.#view.getUint32(20, LE);
  }
  
  set idrPeriod(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get consecutiveBFrameCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set consecutiveBFrameCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rateControlStructure() {
    return this.#view.getUint32(28, LE);
  }
  
  set rateControlStructure(value: VideoEncodeH264RateControlStructureEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get temporalLayerCount() {
    return this.#view.getUint8(32);
  }
  
  set temporalLayerCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export interface InitVideoEncodeH264QpEXT {
  qpI?: number;
  qpP?: number;
  qpB?: number;
}

export class VideoEncodeH264QpEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264QpEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264QpEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264QpEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264QpEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264QpEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.qpI !== undefined) this.qpI = data.qpI;
      if (data.qpP !== undefined) this.qpP = data.qpP;
      if (data.qpB !== undefined) this.qpB = data.qpB;
    }
  }
  
  get qpI() {
    return this.#view.getInt32(0, LE);
  }
  
  set qpI(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get qpP() {
    return this.#view.getInt32(4, LE);
  }
  
  set qpP(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get qpB() {
    return this.#view.getInt32(8, LE);
  }
  
  set qpB(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export interface InitVideoEncodeH264FrameSizeEXT {
  frameISize?: number;
  framePSize?: number;
  frameBSize?: number;
}

export class VideoEncodeH264FrameSizeEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264FrameSizeEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264FrameSizeEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264FrameSizeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264FrameSizeEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264FrameSizeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.frameISize !== undefined) this.frameISize = data.frameISize;
      if (data.framePSize !== undefined) this.framePSize = data.framePSize;
      if (data.frameBSize !== undefined) this.frameBSize = data.frameBSize;
    }
  }
  
  get frameISize() {
    return this.#view.getUint32(0, LE);
  }
  
  set frameISize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get framePSize() {
    return this.#view.getUint32(4, LE);
  }
  
  set framePSize(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get frameBSize() {
    return this.#view.getUint32(8, LE);
  }
  
  set frameBSize(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitVideoEncodeH264RateControlLayerInfoEXT {
  pNext?: AnyPointer;
  temporalLayerId?: number;
  useInitialRcQp?: Bool32;
  initialRcQp?: VideoEncodeH264QpEXT;
  useMinQp?: Bool32;
  minQp?: VideoEncodeH264QpEXT;
  useMaxQp?: Bool32;
  maxQp?: VideoEncodeH264QpEXT;
  useMaxFrameSize?: Bool32;
  maxFrameSize?: VideoEncodeH264FrameSizeEXT;
}

export class VideoEncodeH264RateControlLayerInfoEXT implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH264RateControlLayerInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH264RateControlLayerInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH264RateControlLayerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH264RateControlLayerInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH264RateControlLayerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.temporalLayerId !== undefined) this.temporalLayerId = data.temporalLayerId;
      if (data.useInitialRcQp !== undefined) this.useInitialRcQp = data.useInitialRcQp;
      if (data.initialRcQp !== undefined) this.initialRcQp = data.initialRcQp;
      if (data.useMinQp !== undefined) this.useMinQp = data.useMinQp;
      if (data.minQp !== undefined) this.minQp = data.minQp;
      if (data.useMaxQp !== undefined) this.useMaxQp = data.useMaxQp;
      if (data.maxQp !== undefined) this.maxQp = data.maxQp;
      if (data.useMaxFrameSize !== undefined) this.useMaxFrameSize = data.useMaxFrameSize;
      if (data.maxFrameSize !== undefined) this.maxFrameSize = data.maxFrameSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get temporalLayerId() {
    return this.#view.getUint8(16);
  }
  
  set temporalLayerId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get useInitialRcQp() {
    return this.#view.getUint32(20, LE);
  }
  
  set useInitialRcQp(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get initialRcQp() {
    return new VideoEncodeH264QpEXT(this.#data.subarray(24, 24 + VideoEncodeH264QpEXT.size));
  }
  
  set initialRcQp(value: VideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get useMinQp() {
    return this.#view.getUint32(36, LE);
  }
  
  set useMinQp(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minQp() {
    return new VideoEncodeH264QpEXT(this.#data.subarray(40, 40 + VideoEncodeH264QpEXT.size));
  }
  
  set minQp(value: VideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get useMaxQp() {
    return this.#view.getUint32(52, LE);
  }
  
  set useMaxQp(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxQp() {
    return new VideoEncodeH264QpEXT(this.#data.subarray(56, 56 + VideoEncodeH264QpEXT.size));
  }
  
  set maxQp(value: VideoEncodeH264QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH264QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get useMaxFrameSize() {
    return this.#view.getUint32(68, LE);
  }
  
  set useMaxFrameSize(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxFrameSize() {
    return new VideoEncodeH264FrameSizeEXT(this.#data.subarray(72, 72 + VideoEncodeH264FrameSizeEXT.size));
  }
  
  set maxFrameSize(value: VideoEncodeH264FrameSizeEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH264FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitVideoEncodeH265CapabilitiesEXT {
  pNext?: AnyPointer;
  flags?: VideoEncodeH265CapabilityFlagsEXT;
  inputModeFlags?: VideoEncodeH265InputModeFlagsEXT;
  outputModeFlags?: VideoEncodeH265OutputModeFlagsEXT;
  ctbSizes?: VideoEncodeH265CtbSizeFlagsEXT;
  transformBlockSizes?: VideoEncodeH265TransformBlockSizeFlagsEXT;
  maxPPictureL0ReferenceCount?: number;
  maxBPictureL0ReferenceCount?: number;
  maxL1ReferenceCount?: number;
  maxSubLayersCount?: number;
  minLog2MinLumaCodingBlockSizeMinus3?: number;
  maxLog2MinLumaCodingBlockSizeMinus3?: number;
  minLog2MinLumaTransformBlockSizeMinus2?: number;
  maxLog2MinLumaTransformBlockSizeMinus2?: number;
  minMaxTransformHierarchyDepthInter?: number;
  maxMaxTransformHierarchyDepthInter?: number;
  minMaxTransformHierarchyDepthIntra?: number;
  maxMaxTransformHierarchyDepthIntra?: number;
  maxDiffCuQpDeltaDepth?: number;
  minMaxNumMergeCand?: number;
  maxMaxNumMergeCand?: number;
}

export class VideoEncodeH265CapabilitiesEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265CapabilitiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265CapabilitiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265CapabilitiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265CapabilitiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.inputModeFlags !== undefined) this.inputModeFlags = data.inputModeFlags;
      if (data.outputModeFlags !== undefined) this.outputModeFlags = data.outputModeFlags;
      if (data.ctbSizes !== undefined) this.ctbSizes = data.ctbSizes;
      if (data.transformBlockSizes !== undefined) this.transformBlockSizes = data.transformBlockSizes;
      if (data.maxPPictureL0ReferenceCount !== undefined) this.maxPPictureL0ReferenceCount = data.maxPPictureL0ReferenceCount;
      if (data.maxBPictureL0ReferenceCount !== undefined) this.maxBPictureL0ReferenceCount = data.maxBPictureL0ReferenceCount;
      if (data.maxL1ReferenceCount !== undefined) this.maxL1ReferenceCount = data.maxL1ReferenceCount;
      if (data.maxSubLayersCount !== undefined) this.maxSubLayersCount = data.maxSubLayersCount;
      if (data.minLog2MinLumaCodingBlockSizeMinus3 !== undefined) this.minLog2MinLumaCodingBlockSizeMinus3 = data.minLog2MinLumaCodingBlockSizeMinus3;
      if (data.maxLog2MinLumaCodingBlockSizeMinus3 !== undefined) this.maxLog2MinLumaCodingBlockSizeMinus3 = data.maxLog2MinLumaCodingBlockSizeMinus3;
      if (data.minLog2MinLumaTransformBlockSizeMinus2 !== undefined) this.minLog2MinLumaTransformBlockSizeMinus2 = data.minLog2MinLumaTransformBlockSizeMinus2;
      if (data.maxLog2MinLumaTransformBlockSizeMinus2 !== undefined) this.maxLog2MinLumaTransformBlockSizeMinus2 = data.maxLog2MinLumaTransformBlockSizeMinus2;
      if (data.minMaxTransformHierarchyDepthInter !== undefined) this.minMaxTransformHierarchyDepthInter = data.minMaxTransformHierarchyDepthInter;
      if (data.maxMaxTransformHierarchyDepthInter !== undefined) this.maxMaxTransformHierarchyDepthInter = data.maxMaxTransformHierarchyDepthInter;
      if (data.minMaxTransformHierarchyDepthIntra !== undefined) this.minMaxTransformHierarchyDepthIntra = data.minMaxTransformHierarchyDepthIntra;
      if (data.maxMaxTransformHierarchyDepthIntra !== undefined) this.maxMaxTransformHierarchyDepthIntra = data.maxMaxTransformHierarchyDepthIntra;
      if (data.maxDiffCuQpDeltaDepth !== undefined) this.maxDiffCuQpDeltaDepth = data.maxDiffCuQpDeltaDepth;
      if (data.minMaxNumMergeCand !== undefined) this.minMaxNumMergeCand = data.minMaxNumMergeCand;
      if (data.maxMaxNumMergeCand !== undefined) this.maxMaxNumMergeCand = data.maxMaxNumMergeCand;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: VideoEncodeH265CapabilityFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get inputModeFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set inputModeFlags(value: VideoEncodeH265InputModeFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get outputModeFlags() {
    return this.#view.getUint32(24, LE);
  }
  
  set outputModeFlags(value: VideoEncodeH265OutputModeFlagsEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ctbSizes() {
    return this.#view.getUint32(28, LE);
  }
  
  set ctbSizes(value: VideoEncodeH265CtbSizeFlagsEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get transformBlockSizes() {
    return this.#view.getUint32(32, LE);
  }
  
  set transformBlockSizes(value: VideoEncodeH265TransformBlockSizeFlagsEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get maxPPictureL0ReferenceCount() {
    return this.#view.getUint8(36);
  }
  
  set maxPPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(36, Number(value));
  }
  
  get maxBPictureL0ReferenceCount() {
    return this.#view.getUint8(37);
  }
  
  set maxBPictureL0ReferenceCount(value: number) {
    this.#view.setUint8(37, Number(value));
  }
  
  get maxL1ReferenceCount() {
    return this.#view.getUint8(38);
  }
  
  set maxL1ReferenceCount(value: number) {
    this.#view.setUint8(38, Number(value));
  }
  
  get maxSubLayersCount() {
    return this.#view.getUint8(39);
  }
  
  set maxSubLayersCount(value: number) {
    this.#view.setUint8(39, Number(value));
  }
  
  get minLog2MinLumaCodingBlockSizeMinus3() {
    return this.#view.getUint8(40);
  }
  
  set minLog2MinLumaCodingBlockSizeMinus3(value: number) {
    this.#view.setUint8(40, Number(value));
  }
  
  get maxLog2MinLumaCodingBlockSizeMinus3() {
    return this.#view.getUint8(41);
  }
  
  set maxLog2MinLumaCodingBlockSizeMinus3(value: number) {
    this.#view.setUint8(41, Number(value));
  }
  
  get minLog2MinLumaTransformBlockSizeMinus2() {
    return this.#view.getUint8(42);
  }
  
  set minLog2MinLumaTransformBlockSizeMinus2(value: number) {
    this.#view.setUint8(42, Number(value));
  }
  
  get maxLog2MinLumaTransformBlockSizeMinus2() {
    return this.#view.getUint8(43);
  }
  
  set maxLog2MinLumaTransformBlockSizeMinus2(value: number) {
    this.#view.setUint8(43, Number(value));
  }
  
  get minMaxTransformHierarchyDepthInter() {
    return this.#view.getUint8(44);
  }
  
  set minMaxTransformHierarchyDepthInter(value: number) {
    this.#view.setUint8(44, Number(value));
  }
  
  get maxMaxTransformHierarchyDepthInter() {
    return this.#view.getUint8(45);
  }
  
  set maxMaxTransformHierarchyDepthInter(value: number) {
    this.#view.setUint8(45, Number(value));
  }
  
  get minMaxTransformHierarchyDepthIntra() {
    return this.#view.getUint8(46);
  }
  
  set minMaxTransformHierarchyDepthIntra(value: number) {
    this.#view.setUint8(46, Number(value));
  }
  
  get maxMaxTransformHierarchyDepthIntra() {
    return this.#view.getUint8(47);
  }
  
  set maxMaxTransformHierarchyDepthIntra(value: number) {
    this.#view.setUint8(47, Number(value));
  }
  
  get maxDiffCuQpDeltaDepth() {
    return this.#view.getUint8(48);
  }
  
  set maxDiffCuQpDeltaDepth(value: number) {
    this.#view.setUint8(48, Number(value));
  }
  
  get minMaxNumMergeCand() {
    return this.#view.getUint8(49);
  }
  
  set minMaxNumMergeCand(value: number) {
    this.#view.setUint8(49, Number(value));
  }
  
  get maxMaxNumMergeCand() {
    return this.#view.getUint8(50);
  }
  
  set maxMaxNumMergeCand(value: number) {
    this.#view.setUint8(50, Number(value));
  }
}

export interface InitVideoEncodeH265SessionParametersAddInfoEXT {
  pNext?: AnyPointer;
  stdVPSCount?: number;
  pStdVPSs?: AnyPointer;
  stdSPSCount?: number;
  pStdSPSs?: AnyPointer;
  stdPPSCount?: number;
  pStdPPSs?: AnyPointer;
}

export class VideoEncodeH265SessionParametersAddInfoEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265SessionParametersAddInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265SessionParametersAddInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265SessionParametersAddInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265SessionParametersAddInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdVPSCount !== undefined) this.stdVPSCount = data.stdVPSCount;
      if (data.pStdVPSs !== undefined) this.pStdVPSs = data.pStdVPSs;
      if (data.stdSPSCount !== undefined) this.stdSPSCount = data.stdSPSCount;
      if (data.pStdSPSs !== undefined) this.pStdSPSs = data.pStdSPSs;
      if (data.stdPPSCount !== undefined) this.stdPPSCount = data.stdPPSCount;
      if (data.pStdPPSs !== undefined) this.pStdPPSs = data.pStdPPSs;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pStdVPSs() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdVPSs(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get stdSPSCount() {
    return this.#view.getUint32(32, LE);
  }
  
  set stdSPSCount(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get pStdSPSs() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pStdSPSs(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get stdPPSCount() {
    return this.#view.getUint32(48, LE);
  }
  
  set stdPPSCount(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get pStdPPSs() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pStdPPSs(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265SessionParametersCreateInfoEXT {
  pNext?: AnyPointer;
  maxStdVPSCount?: number;
  maxStdSPSCount?: number;
  maxStdPPSCount?: number;
  pParametersAddInfo?: AnyPointer;
}

export class VideoEncodeH265SessionParametersCreateInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265SessionParametersCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265SessionParametersCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265SessionParametersCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265SessionParametersCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxStdVPSCount !== undefined) this.maxStdVPSCount = data.maxStdVPSCount;
      if (data.maxStdSPSCount !== undefined) this.maxStdSPSCount = data.maxStdSPSCount;
      if (data.maxStdPPSCount !== undefined) this.maxStdPPSCount = data.maxStdPPSCount;
      if (data.pParametersAddInfo !== undefined) this.pParametersAddInfo = data.pParametersAddInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxStdVPSCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxStdVPSCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxStdSPSCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxStdSPSCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get maxStdPPSCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set maxStdPPSCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pParametersAddInfo() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pParametersAddInfo(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265VclFrameInfoEXT {
  pNext?: AnyPointer;
  pReferenceFinalLists?: AnyPointer;
  naluSliceSegmentEntryCount?: number;
  pNaluSliceSegmentEntries?: AnyPointer;
  pCurrentPictureInfo?: AnyPointer;
}

export class VideoEncodeH265VclFrameInfoEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265VclFrameInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265VclFrameInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265VclFrameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265VclFrameInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265VclFrameInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pReferenceFinalLists !== undefined) this.pReferenceFinalLists = data.pReferenceFinalLists;
      if (data.naluSliceSegmentEntryCount !== undefined) this.naluSliceSegmentEntryCount = data.naluSliceSegmentEntryCount;
      if (data.pNaluSliceSegmentEntries !== undefined) this.pNaluSliceSegmentEntries = data.pNaluSliceSegmentEntries;
      if (data.pCurrentPictureInfo !== undefined) this.pCurrentPictureInfo = data.pCurrentPictureInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pReferenceFinalLists(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get naluSliceSegmentEntryCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set naluSliceSegmentEntryCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pNaluSliceSegmentEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pNaluSliceSegmentEntries(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get pCurrentPictureInfo() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pCurrentPictureInfo(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265EmitPictureParametersInfoEXT {
  pNext?: AnyPointer;
  vpsId?: number;
  spsId?: number;
  emitVpsEnable?: Bool32;
  emitSpsEnable?: Bool32;
  ppsIdEntryCount?: number;
  ppsIdEntries?: AnyPointer;
}

export class VideoEncodeH265EmitPictureParametersInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265EmitPictureParametersInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265EmitPictureParametersInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265EmitPictureParametersInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265EmitPictureParametersInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265EmitPictureParametersInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vpsId !== undefined) this.vpsId = data.vpsId;
      if (data.spsId !== undefined) this.spsId = data.spsId;
      if (data.emitVpsEnable !== undefined) this.emitVpsEnable = data.emitVpsEnable;
      if (data.emitSpsEnable !== undefined) this.emitSpsEnable = data.emitSpsEnable;
      if (data.ppsIdEntryCount !== undefined) this.ppsIdEntryCount = data.ppsIdEntryCount;
      if (data.ppsIdEntries !== undefined) this.ppsIdEntries = data.ppsIdEntries;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vpsId() {
    return this.#view.getUint8(16);
  }
  
  set vpsId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get spsId() {
    return this.#view.getUint8(17);
  }
  
  set spsId(value: number) {
    this.#view.setUint8(17, Number(value));
  }
  
  get emitVpsEnable() {
    return this.#view.getUint32(20, LE);
  }
  
  set emitVpsEnable(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get emitSpsEnable() {
    return this.#view.getUint32(24, LE);
  }
  
  set emitSpsEnable(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get ppsIdEntryCount() {
    return this.#view.getUint32(28, LE);
  }
  
  set ppsIdEntryCount(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get ppsIdEntries() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set ppsIdEntries(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265NaluSliceSegmentInfoEXT {
  pNext?: AnyPointer;
  ctbCount?: number;
  pReferenceFinalLists?: AnyPointer;
  pSliceSegmentHeaderStd?: AnyPointer;
}

export class VideoEncodeH265NaluSliceSegmentInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265NaluSliceSegmentInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265NaluSliceSegmentInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265NaluSliceSegmentInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265NaluSliceSegmentInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265NaluSliceSegmentInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.ctbCount !== undefined) this.ctbCount = data.ctbCount;
      if (data.pReferenceFinalLists !== undefined) this.pReferenceFinalLists = data.pReferenceFinalLists;
      if (data.pSliceSegmentHeaderStd !== undefined) this.pSliceSegmentHeaderStd = data.pSliceSegmentHeaderStd;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get ctbCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set ctbCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pReferenceFinalLists() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceFinalLists(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get pSliceSegmentHeaderStd() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pSliceSegmentHeaderStd(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265RateControlInfoEXT {
  pNext?: AnyPointer;
  gopFrameCount?: number;
  idrPeriod?: number;
  consecutiveBFrameCount?: number;
  rateControlStructure?: VideoEncodeH265RateControlStructureEXT;
  subLayerCount?: number;
}

export class VideoEncodeH265RateControlInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265RateControlInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265RateControlInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265RateControlInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265RateControlInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265RateControlInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.gopFrameCount !== undefined) this.gopFrameCount = data.gopFrameCount;
      if (data.idrPeriod !== undefined) this.idrPeriod = data.idrPeriod;
      if (data.consecutiveBFrameCount !== undefined) this.consecutiveBFrameCount = data.consecutiveBFrameCount;
      if (data.rateControlStructure !== undefined) this.rateControlStructure = data.rateControlStructure;
      if (data.subLayerCount !== undefined) this.subLayerCount = data.subLayerCount;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get gopFrameCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set gopFrameCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get idrPeriod() {
    return this.#view.getUint32(20, LE);
  }
  
  set idrPeriod(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get consecutiveBFrameCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set consecutiveBFrameCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get rateControlStructure() {
    return this.#view.getUint32(28, LE);
  }
  
  set rateControlStructure(value: VideoEncodeH265RateControlStructureEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get subLayerCount() {
    return this.#view.getUint8(32);
  }
  
  set subLayerCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
}

export interface InitVideoEncodeH265QpEXT {
  qpI?: number;
  qpP?: number;
  qpB?: number;
}

export class VideoEncodeH265QpEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265QpEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265QpEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265QpEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265QpEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265QpEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.qpI !== undefined) this.qpI = data.qpI;
      if (data.qpP !== undefined) this.qpP = data.qpP;
      if (data.qpB !== undefined) this.qpB = data.qpB;
    }
  }
  
  get qpI() {
    return this.#view.getInt32(0, LE);
  }
  
  set qpI(value: number) {
    this.#view.setInt32(0, Number(value), LE);
  }
  
  get qpP() {
    return this.#view.getInt32(4, LE);
  }
  
  set qpP(value: number) {
    this.#view.setInt32(4, Number(value), LE);
  }
  
  get qpB() {
    return this.#view.getInt32(8, LE);
  }
  
  set qpB(value: number) {
    this.#view.setInt32(8, Number(value), LE);
  }
}

export interface InitVideoEncodeH265FrameSizeEXT {
  frameISize?: number;
  framePSize?: number;
  frameBSize?: number;
}

export class VideoEncodeH265FrameSizeEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265FrameSizeEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265FrameSizeEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265FrameSizeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265FrameSizeEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265FrameSizeEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.frameISize !== undefined) this.frameISize = data.frameISize;
      if (data.framePSize !== undefined) this.framePSize = data.framePSize;
      if (data.frameBSize !== undefined) this.frameBSize = data.frameBSize;
    }
  }
  
  get frameISize() {
    return this.#view.getUint32(0, LE);
  }
  
  set frameISize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get framePSize() {
    return this.#view.getUint32(4, LE);
  }
  
  set framePSize(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get frameBSize() {
    return this.#view.getUint32(8, LE);
  }
  
  set frameBSize(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitVideoEncodeH265RateControlLayerInfoEXT {
  pNext?: AnyPointer;
  temporalId?: number;
  useInitialRcQp?: Bool32;
  initialRcQp?: VideoEncodeH265QpEXT;
  useMinQp?: Bool32;
  minQp?: VideoEncodeH265QpEXT;
  useMaxQp?: Bool32;
  maxQp?: VideoEncodeH265QpEXT;
  useMaxFrameSize?: Bool32;
  maxFrameSize?: VideoEncodeH265FrameSizeEXT;
}

export class VideoEncodeH265RateControlLayerInfoEXT implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265RateControlLayerInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265RateControlLayerInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265RateControlLayerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265RateControlLayerInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265RateControlLayerInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.temporalId !== undefined) this.temporalId = data.temporalId;
      if (data.useInitialRcQp !== undefined) this.useInitialRcQp = data.useInitialRcQp;
      if (data.initialRcQp !== undefined) this.initialRcQp = data.initialRcQp;
      if (data.useMinQp !== undefined) this.useMinQp = data.useMinQp;
      if (data.minQp !== undefined) this.minQp = data.minQp;
      if (data.useMaxQp !== undefined) this.useMaxQp = data.useMaxQp;
      if (data.maxQp !== undefined) this.maxQp = data.maxQp;
      if (data.useMaxFrameSize !== undefined) this.useMaxFrameSize = data.useMaxFrameSize;
      if (data.maxFrameSize !== undefined) this.maxFrameSize = data.maxFrameSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get temporalId() {
    return this.#view.getUint8(16);
  }
  
  set temporalId(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get useInitialRcQp() {
    return this.#view.getUint32(20, LE);
  }
  
  set useInitialRcQp(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get initialRcQp() {
    return new VideoEncodeH265QpEXT(this.#data.subarray(24, 24 + VideoEncodeH265QpEXT.size));
  }
  
  set initialRcQp(value: VideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get useMinQp() {
    return this.#view.getUint32(36, LE);
  }
  
  set useMinQp(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minQp() {
    return new VideoEncodeH265QpEXT(this.#data.subarray(40, 40 + VideoEncodeH265QpEXT.size));
  }
  
  set minQp(value: VideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get useMaxQp() {
    return this.#view.getUint32(52, LE);
  }
  
  set useMaxQp(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxQp() {
    return new VideoEncodeH265QpEXT(this.#data.subarray(56, 56 + VideoEncodeH265QpEXT.size));
  }
  
  set maxQp(value: VideoEncodeH265QpEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH265QpEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 56);
  }
  
  get useMaxFrameSize() {
    return this.#view.getUint32(68, LE);
  }
  
  set useMaxFrameSize(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get maxFrameSize() {
    return new VideoEncodeH265FrameSizeEXT(this.#data.subarray(72, 72 + VideoEncodeH265FrameSizeEXT.size));
  }
  
  set maxFrameSize(value: VideoEncodeH265FrameSizeEXT) {
    if (value[BUFFER].byteLength < VideoEncodeH265FrameSizeEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 72);
  }
}

export interface InitVideoEncodeH265ProfileInfoEXT {
  pNext?: AnyPointer;
  stdProfileIdc?: StdVideoH265ProfileIdc;
}

export class VideoEncodeH265ProfileInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265ProfileInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265ProfileInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265ProfileInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265ProfileInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.stdProfileIdc !== undefined) this.stdProfileIdc = data.stdProfileIdc;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get stdProfileIdc() {
    return this.#view.getUint32(16, LE);
  }
  
  set stdProfileIdc(value: StdVideoH265ProfileIdc) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitVideoEncodeH265DpbSlotInfoEXT {
  pNext?: AnyPointer;
  slotIndex?: number;
  pStdReferenceInfo?: AnyPointer;
}

export class VideoEncodeH265DpbSlotInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265DpbSlotInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265DpbSlotInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265DpbSlotInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265DpbSlotInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.slotIndex !== undefined) this.slotIndex = data.slotIndex;
      if (data.pStdReferenceInfo !== undefined) this.pStdReferenceInfo = data.pStdReferenceInfo;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get slotIndex() {
    return this.#view.getInt8(16);
  }
  
  set slotIndex(value: number) {
    this.#view.setInt8(16, Number(value));
  }
  
  get pStdReferenceInfo() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pStdReferenceInfo(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitVideoEncodeH265ReferenceListsInfoEXT {
  pNext?: AnyPointer;
  referenceList0EntryCount?: number;
  pReferenceList0Entries?: AnyPointer;
  referenceList1EntryCount?: number;
  pReferenceList1Entries?: AnyPointer;
  pReferenceModifications?: AnyPointer;
}

export class VideoEncodeH265ReferenceListsInfoEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitVideoEncodeH265ReferenceListsInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitVideoEncodeH265ReferenceListsInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(VideoEncodeH265ReferenceListsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < VideoEncodeH265ReferenceListsInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(VideoEncodeH265ReferenceListsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.referenceList0EntryCount !== undefined) this.referenceList0EntryCount = data.referenceList0EntryCount;
      if (data.pReferenceList0Entries !== undefined) this.pReferenceList0Entries = data.pReferenceList0Entries;
      if (data.referenceList1EntryCount !== undefined) this.referenceList1EntryCount = data.referenceList1EntryCount;
      if (data.pReferenceList1Entries !== undefined) this.pReferenceList1Entries = data.pReferenceList1Entries;
      if (data.pReferenceModifications !== undefined) this.pReferenceModifications = data.pReferenceModifications;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get referenceList0EntryCount() {
    return this.#view.getUint8(16);
  }
  
  set referenceList0EntryCount(value: number) {
    this.#view.setUint8(16, Number(value));
  }
  
  get pReferenceList0Entries() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pReferenceList0Entries(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get referenceList1EntryCount() {
    return this.#view.getUint8(32);
  }
  
  set referenceList1EntryCount(value: number) {
    this.#view.setUint8(32, Number(value));
  }
  
  get pReferenceList1Entries() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set pReferenceList1Entries(value: AnyPointer) {
    this.#view.setBigUint64(40, BigInt(anyPointer(value)), LE);
  }
  
  get pReferenceModifications() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pReferenceModifications(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceInheritedViewportScissorFeaturesNV {
  pNext?: AnyPointer;
  inheritedViewportScissor2D?: Bool32;
}

export class PhysicalDeviceInheritedViewportScissorFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceInheritedViewportScissorFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceInheritedViewportScissorFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceInheritedViewportScissorFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceInheritedViewportScissorFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceInheritedViewportScissorFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.inheritedViewportScissor2D !== undefined) this.inheritedViewportScissor2D = data.inheritedViewportScissor2D;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get inheritedViewportScissor2D() {
    return this.#view.getUint32(16, LE);
  }
  
  set inheritedViewportScissor2D(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCommandBufferInheritanceViewportScissorInfoNV {
  pNext?: AnyPointer;
  viewportScissor2D?: Bool32;
  viewportDepthCount?: number;
  pViewportDepths?: AnyPointer;
}

export class CommandBufferInheritanceViewportScissorInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferInheritanceViewportScissorInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferInheritanceViewportScissorInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferInheritanceViewportScissorInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferInheritanceViewportScissorInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferInheritanceViewportScissorInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.viewportScissor2D !== undefined) this.viewportScissor2D = data.viewportScissor2D;
      if (data.viewportDepthCount !== undefined) this.viewportDepthCount = data.viewportDepthCount;
      if (data.pViewportDepths !== undefined) this.pViewportDepths = data.pViewportDepths;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get viewportScissor2D() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewportScissor2D(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewportDepthCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewportDepthCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pViewportDepths() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pViewportDepths(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
  pNext?: AnyPointer;
  ycbcr2plane444Formats?: Bool32;
}

export class PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.ycbcr2plane444Formats !== undefined) this.ycbcr2plane444Formats = data.ycbcr2plane444Formats;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get ycbcr2plane444Formats() {
    return this.#view.getUint32(16, LE);
  }
  
  set ycbcr2plane444Formats(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceProvokingVertexFeaturesEXT {
  pNext?: AnyPointer;
  provokingVertexLast?: Bool32;
  transformFeedbackPreservesProvokingVertex?: Bool32;
}

export class PhysicalDeviceProvokingVertexFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProvokingVertexFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProvokingVertexFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProvokingVertexFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProvokingVertexFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProvokingVertexFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.provokingVertexLast !== undefined) this.provokingVertexLast = data.provokingVertexLast;
      if (data.transformFeedbackPreservesProvokingVertex !== undefined) this.transformFeedbackPreservesProvokingVertex = data.transformFeedbackPreservesProvokingVertex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get provokingVertexLast() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexLast(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transformFeedbackPreservesProvokingVertex() {
    return this.#view.getUint32(20, LE);
  }
  
  set transformFeedbackPreservesProvokingVertex(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceProvokingVertexPropertiesEXT {
  pNext?: AnyPointer;
  provokingVertexModePerPipeline?: Bool32;
  transformFeedbackPreservesTriangleFanProvokingVertex?: Bool32;
}

export class PhysicalDeviceProvokingVertexPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceProvokingVertexPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceProvokingVertexPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceProvokingVertexPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceProvokingVertexPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceProvokingVertexPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.provokingVertexModePerPipeline !== undefined) this.provokingVertexModePerPipeline = data.provokingVertexModePerPipeline;
      if (data.transformFeedbackPreservesTriangleFanProvokingVertex !== undefined) this.transformFeedbackPreservesTriangleFanProvokingVertex = data.transformFeedbackPreservesTriangleFanProvokingVertex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get provokingVertexModePerPipeline() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexModePerPipeline(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get transformFeedbackPreservesTriangleFanProvokingVertex() {
    return this.#view.getUint32(20, LE);
  }
  
  set transformFeedbackPreservesTriangleFanProvokingVertex(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPipelineRasterizationProvokingVertexStateCreateInfoEXT {
  pNext?: AnyPointer;
  provokingVertexMode?: ProvokingVertexModeEXT;
}

export class PipelineRasterizationProvokingVertexStateCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRasterizationProvokingVertexStateCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRasterizationProvokingVertexStateCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRasterizationProvokingVertexStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRasterizationProvokingVertexStateCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRasterizationProvokingVertexStateCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.provokingVertexMode !== undefined) this.provokingVertexMode = data.provokingVertexMode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get provokingVertexMode() {
    return this.#view.getUint32(16, LE);
  }
  
  set provokingVertexMode(value: ProvokingVertexModeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCuModuleCreateInfoNVX {
  pNext?: AnyPointer;
  dataSize?: Deno.PointerValue;
  pData?: AnyPointer;
}

export class CuModuleCreateInfoNVX implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCuModuleCreateInfoNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCuModuleCreateInfoNVX) {
    if (!data) {
      this.#data = new Uint8Array(CuModuleCreateInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CuModuleCreateInfoNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CuModuleCreateInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dataSize !== undefined) this.dataSize = data.dataSize;
      if (data.pData !== undefined) this.pData = data.pData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dataSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set dataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get pData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pData(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCuFunctionCreateInfoNVX {
  pNext?: AnyPointer;
  module?: CuModuleNVX;
  pName?: AnyPointer;
}

export class CuFunctionCreateInfoNVX implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCuFunctionCreateInfoNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCuFunctionCreateInfoNVX) {
    if (!data) {
      this.#data = new Uint8Array(CuFunctionCreateInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CuFunctionCreateInfoNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CuFunctionCreateInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.module !== undefined) this.module = data.module;
      if (data.pName !== undefined) this.pName = data.pName;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get module() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set module(value: CuModuleNVX) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get pName() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pName(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCuLaunchInfoNVX {
  pNext?: AnyPointer;
  vk_function?: CuFunctionNVX;
  gridDimX?: number;
  gridDimY?: number;
  gridDimZ?: number;
  blockDimX?: number;
  blockDimY?: number;
  blockDimZ?: number;
  sharedMemBytes?: number;
  paramCount?: Deno.PointerValue;
  pParams?: AnyPointer;
  extraCount?: Deno.PointerValue;
  pExtras?: AnyPointer;
}

export class CuLaunchInfoNVX implements BaseStruct {
  static size = 88;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCuLaunchInfoNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCuLaunchInfoNVX) {
    if (!data) {
      this.#data = new Uint8Array(CuLaunchInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CuLaunchInfoNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CuLaunchInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vk_function !== undefined) this.vk_function = data.vk_function;
      if (data.gridDimX !== undefined) this.gridDimX = data.gridDimX;
      if (data.gridDimY !== undefined) this.gridDimY = data.gridDimY;
      if (data.gridDimZ !== undefined) this.gridDimZ = data.gridDimZ;
      if (data.blockDimX !== undefined) this.blockDimX = data.blockDimX;
      if (data.blockDimY !== undefined) this.blockDimY = data.blockDimY;
      if (data.blockDimZ !== undefined) this.blockDimZ = data.blockDimZ;
      if (data.sharedMemBytes !== undefined) this.sharedMemBytes = data.sharedMemBytes;
      if (data.paramCount !== undefined) this.paramCount = data.paramCount;
      if (data.pParams !== undefined) this.pParams = data.pParams;
      if (data.extraCount !== undefined) this.extraCount = data.extraCount;
      if (data.pExtras !== undefined) this.pExtras = data.pExtras;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vk_function() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set vk_function(value: CuFunctionNVX) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get gridDimX() {
    return this.#view.getUint32(24, LE);
  }
  
  set gridDimX(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get gridDimY() {
    return this.#view.getUint32(28, LE);
  }
  
  set gridDimY(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get gridDimZ() {
    return this.#view.getUint32(32, LE);
  }
  
  set gridDimZ(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get blockDimX() {
    return this.#view.getUint32(36, LE);
  }
  
  set blockDimX(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get blockDimY() {
    return this.#view.getUint32(40, LE);
  }
  
  set blockDimY(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get blockDimZ() {
    return this.#view.getUint32(44, LE);
  }
  
  set blockDimZ(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get sharedMemBytes() {
    return this.#view.getUint32(48, LE);
  }
  
  set sharedMemBytes(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get paramCount() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set paramCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
  
  get pParams() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pParams(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
  
  get extraCount() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set extraCount(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get pExtras() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set pExtras(value: AnyPointer) {
    this.#view.setBigUint64(80, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceDescriptorBufferFeaturesEXT {
  pNext?: AnyPointer;
  descriptorBuffer?: Bool32;
  descriptorBufferCaptureReplay?: Bool32;
  descriptorBufferImageLayoutIgnored?: Bool32;
  descriptorBufferPushDescriptors?: Bool32;
}

export class PhysicalDeviceDescriptorBufferFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorBufferFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorBufferFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorBufferFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorBuffer !== undefined) this.descriptorBuffer = data.descriptorBuffer;
      if (data.descriptorBufferCaptureReplay !== undefined) this.descriptorBufferCaptureReplay = data.descriptorBufferCaptureReplay;
      if (data.descriptorBufferImageLayoutIgnored !== undefined) this.descriptorBufferImageLayoutIgnored = data.descriptorBufferImageLayoutIgnored;
      if (data.descriptorBufferPushDescriptors !== undefined) this.descriptorBufferPushDescriptors = data.descriptorBufferPushDescriptors;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorBuffer() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorBuffer(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get descriptorBufferCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set descriptorBufferCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get descriptorBufferImageLayoutIgnored() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorBufferImageLayoutIgnored(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get descriptorBufferPushDescriptors() {
    return this.#view.getUint32(28, LE);
  }
  
  set descriptorBufferPushDescriptors(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDescriptorBufferPropertiesEXT {
  pNext?: AnyPointer;
  combinedImageSamplerDescriptorSingleArray?: Bool32;
  bufferlessPushDescriptors?: Bool32;
  allowSamplerImageViewPostSubmitCreation?: Bool32;
  descriptorBufferOffsetAlignment?: DeviceSize;
  maxDescriptorBufferBindings?: number;
  maxResourceDescriptorBufferBindings?: number;
  maxSamplerDescriptorBufferBindings?: number;
  maxEmbeddedImmutableSamplerBindings?: number;
  maxEmbeddedImmutableSamplers?: number;
  bufferCaptureReplayDescriptorDataSize?: Deno.PointerValue;
  imageCaptureReplayDescriptorDataSize?: Deno.PointerValue;
  imageViewCaptureReplayDescriptorDataSize?: Deno.PointerValue;
  samplerCaptureReplayDescriptorDataSize?: Deno.PointerValue;
  accelerationStructureCaptureReplayDescriptorDataSize?: Deno.PointerValue;
  samplerDescriptorSize?: Deno.PointerValue;
  combinedImageSamplerDescriptorSize?: Deno.PointerValue;
  sampledImageDescriptorSize?: Deno.PointerValue;
  storageImageDescriptorSize?: Deno.PointerValue;
  uniformTexelBufferDescriptorSize?: Deno.PointerValue;
  robustUniformTexelBufferDescriptorSize?: Deno.PointerValue;
  storageTexelBufferDescriptorSize?: Deno.PointerValue;
  robustStorageTexelBufferDescriptorSize?: Deno.PointerValue;
  uniformBufferDescriptorSize?: Deno.PointerValue;
  robustUniformBufferDescriptorSize?: Deno.PointerValue;
  storageBufferDescriptorSize?: Deno.PointerValue;
  robustStorageBufferDescriptorSize?: Deno.PointerValue;
  inputAttachmentDescriptorSize?: Deno.PointerValue;
  accelerationStructureDescriptorSize?: Deno.PointerValue;
  maxSamplerDescriptorBufferRange?: DeviceSize;
  maxResourceDescriptorBufferRange?: DeviceSize;
  samplerDescriptorBufferAddressSpaceSize?: DeviceSize;
  resourceDescriptorBufferAddressSpaceSize?: DeviceSize;
  descriptorBufferAddressSpaceSize?: DeviceSize;
}

export class PhysicalDeviceDescriptorBufferPropertiesEXT implements BaseStruct {
  static size = 256;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorBufferPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorBufferPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorBufferPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.combinedImageSamplerDescriptorSingleArray !== undefined) this.combinedImageSamplerDescriptorSingleArray = data.combinedImageSamplerDescriptorSingleArray;
      if (data.bufferlessPushDescriptors !== undefined) this.bufferlessPushDescriptors = data.bufferlessPushDescriptors;
      if (data.allowSamplerImageViewPostSubmitCreation !== undefined) this.allowSamplerImageViewPostSubmitCreation = data.allowSamplerImageViewPostSubmitCreation;
      if (data.descriptorBufferOffsetAlignment !== undefined) this.descriptorBufferOffsetAlignment = data.descriptorBufferOffsetAlignment;
      if (data.maxDescriptorBufferBindings !== undefined) this.maxDescriptorBufferBindings = data.maxDescriptorBufferBindings;
      if (data.maxResourceDescriptorBufferBindings !== undefined) this.maxResourceDescriptorBufferBindings = data.maxResourceDescriptorBufferBindings;
      if (data.maxSamplerDescriptorBufferBindings !== undefined) this.maxSamplerDescriptorBufferBindings = data.maxSamplerDescriptorBufferBindings;
      if (data.maxEmbeddedImmutableSamplerBindings !== undefined) this.maxEmbeddedImmutableSamplerBindings = data.maxEmbeddedImmutableSamplerBindings;
      if (data.maxEmbeddedImmutableSamplers !== undefined) this.maxEmbeddedImmutableSamplers = data.maxEmbeddedImmutableSamplers;
      if (data.bufferCaptureReplayDescriptorDataSize !== undefined) this.bufferCaptureReplayDescriptorDataSize = data.bufferCaptureReplayDescriptorDataSize;
      if (data.imageCaptureReplayDescriptorDataSize !== undefined) this.imageCaptureReplayDescriptorDataSize = data.imageCaptureReplayDescriptorDataSize;
      if (data.imageViewCaptureReplayDescriptorDataSize !== undefined) this.imageViewCaptureReplayDescriptorDataSize = data.imageViewCaptureReplayDescriptorDataSize;
      if (data.samplerCaptureReplayDescriptorDataSize !== undefined) this.samplerCaptureReplayDescriptorDataSize = data.samplerCaptureReplayDescriptorDataSize;
      if (data.accelerationStructureCaptureReplayDescriptorDataSize !== undefined) this.accelerationStructureCaptureReplayDescriptorDataSize = data.accelerationStructureCaptureReplayDescriptorDataSize;
      if (data.samplerDescriptorSize !== undefined) this.samplerDescriptorSize = data.samplerDescriptorSize;
      if (data.combinedImageSamplerDescriptorSize !== undefined) this.combinedImageSamplerDescriptorSize = data.combinedImageSamplerDescriptorSize;
      if (data.sampledImageDescriptorSize !== undefined) this.sampledImageDescriptorSize = data.sampledImageDescriptorSize;
      if (data.storageImageDescriptorSize !== undefined) this.storageImageDescriptorSize = data.storageImageDescriptorSize;
      if (data.uniformTexelBufferDescriptorSize !== undefined) this.uniformTexelBufferDescriptorSize = data.uniformTexelBufferDescriptorSize;
      if (data.robustUniformTexelBufferDescriptorSize !== undefined) this.robustUniformTexelBufferDescriptorSize = data.robustUniformTexelBufferDescriptorSize;
      if (data.storageTexelBufferDescriptorSize !== undefined) this.storageTexelBufferDescriptorSize = data.storageTexelBufferDescriptorSize;
      if (data.robustStorageTexelBufferDescriptorSize !== undefined) this.robustStorageTexelBufferDescriptorSize = data.robustStorageTexelBufferDescriptorSize;
      if (data.uniformBufferDescriptorSize !== undefined) this.uniformBufferDescriptorSize = data.uniformBufferDescriptorSize;
      if (data.robustUniformBufferDescriptorSize !== undefined) this.robustUniformBufferDescriptorSize = data.robustUniformBufferDescriptorSize;
      if (data.storageBufferDescriptorSize !== undefined) this.storageBufferDescriptorSize = data.storageBufferDescriptorSize;
      if (data.robustStorageBufferDescriptorSize !== undefined) this.robustStorageBufferDescriptorSize = data.robustStorageBufferDescriptorSize;
      if (data.inputAttachmentDescriptorSize !== undefined) this.inputAttachmentDescriptorSize = data.inputAttachmentDescriptorSize;
      if (data.accelerationStructureDescriptorSize !== undefined) this.accelerationStructureDescriptorSize = data.accelerationStructureDescriptorSize;
      if (data.maxSamplerDescriptorBufferRange !== undefined) this.maxSamplerDescriptorBufferRange = data.maxSamplerDescriptorBufferRange;
      if (data.maxResourceDescriptorBufferRange !== undefined) this.maxResourceDescriptorBufferRange = data.maxResourceDescriptorBufferRange;
      if (data.samplerDescriptorBufferAddressSpaceSize !== undefined) this.samplerDescriptorBufferAddressSpaceSize = data.samplerDescriptorBufferAddressSpaceSize;
      if (data.resourceDescriptorBufferAddressSpaceSize !== undefined) this.resourceDescriptorBufferAddressSpaceSize = data.resourceDescriptorBufferAddressSpaceSize;
      if (data.descriptorBufferAddressSpaceSize !== undefined) this.descriptorBufferAddressSpaceSize = data.descriptorBufferAddressSpaceSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get combinedImageSamplerDescriptorSingleArray() {
    return this.#view.getUint32(16, LE);
  }
  
  set combinedImageSamplerDescriptorSingleArray(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferlessPushDescriptors() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferlessPushDescriptors(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get allowSamplerImageViewPostSubmitCreation() {
    return this.#view.getUint32(24, LE);
  }
  
  set allowSamplerImageViewPostSubmitCreation(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get descriptorBufferOffsetAlignment() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set descriptorBufferOffsetAlignment(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get maxDescriptorBufferBindings() {
    return this.#view.getUint32(40, LE);
  }
  
  set maxDescriptorBufferBindings(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get maxResourceDescriptorBufferBindings() {
    return this.#view.getUint32(44, LE);
  }
  
  set maxResourceDescriptorBufferBindings(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxSamplerDescriptorBufferBindings() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxSamplerDescriptorBufferBindings(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxEmbeddedImmutableSamplerBindings() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxEmbeddedImmutableSamplerBindings(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxEmbeddedImmutableSamplers() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxEmbeddedImmutableSamplers(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get bufferCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set bufferCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(64, BigInt(value), LE);
  }
  
  get imageCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(72, LE);
  }
  
  set imageCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(72, BigInt(value), LE);
  }
  
  get imageViewCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(80, LE);
  }
  
  set imageViewCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(80, BigInt(value), LE);
  }
  
  get samplerCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set samplerCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
  
  get accelerationStructureCaptureReplayDescriptorDataSize() {
    return this.#view.getBigUint64(96, LE);
  }
  
  set accelerationStructureCaptureReplayDescriptorDataSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(96, BigInt(value), LE);
  }
  
  get samplerDescriptorSize() {
    return this.#view.getBigUint64(104, LE);
  }
  
  set samplerDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(104, BigInt(value), LE);
  }
  
  get combinedImageSamplerDescriptorSize() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set combinedImageSamplerDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
  
  get sampledImageDescriptorSize() {
    return this.#view.getBigUint64(120, LE);
  }
  
  set sampledImageDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(120, BigInt(value), LE);
  }
  
  get storageImageDescriptorSize() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set storageImageDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(128, BigInt(value), LE);
  }
  
  get uniformTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(136, LE);
  }
  
  set uniformTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(136, BigInt(value), LE);
  }
  
  get robustUniformTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set robustUniformTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(144, BigInt(value), LE);
  }
  
  get storageTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(152, LE);
  }
  
  set storageTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(152, BigInt(value), LE);
  }
  
  get robustStorageTexelBufferDescriptorSize() {
    return this.#view.getBigUint64(160, LE);
  }
  
  set robustStorageTexelBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(160, BigInt(value), LE);
  }
  
  get uniformBufferDescriptorSize() {
    return this.#view.getBigUint64(168, LE);
  }
  
  set uniformBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(168, BigInt(value), LE);
  }
  
  get robustUniformBufferDescriptorSize() {
    return this.#view.getBigUint64(176, LE);
  }
  
  set robustUniformBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(176, BigInt(value), LE);
  }
  
  get storageBufferDescriptorSize() {
    return this.#view.getBigUint64(184, LE);
  }
  
  set storageBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(184, BigInt(value), LE);
  }
  
  get robustStorageBufferDescriptorSize() {
    return this.#view.getBigUint64(192, LE);
  }
  
  set robustStorageBufferDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(192, BigInt(value), LE);
  }
  
  get inputAttachmentDescriptorSize() {
    return this.#view.getBigUint64(200, LE);
  }
  
  set inputAttachmentDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(200, BigInt(value), LE);
  }
  
  get accelerationStructureDescriptorSize() {
    return this.#view.getBigUint64(208, LE);
  }
  
  set accelerationStructureDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(208, BigInt(value), LE);
  }
  
  get maxSamplerDescriptorBufferRange() {
    return this.#view.getBigUint64(216, LE);
  }
  
  set maxSamplerDescriptorBufferRange(value: DeviceSize) {
    this.#view.setBigUint64(216, BigInt(value), LE);
  }
  
  get maxResourceDescriptorBufferRange() {
    return this.#view.getBigUint64(224, LE);
  }
  
  set maxResourceDescriptorBufferRange(value: DeviceSize) {
    this.#view.setBigUint64(224, BigInt(value), LE);
  }
  
  get samplerDescriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(232, LE);
  }
  
  set samplerDescriptorBufferAddressSpaceSize(value: DeviceSize) {
    this.#view.setBigUint64(232, BigInt(value), LE);
  }
  
  get resourceDescriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(240, LE);
  }
  
  set resourceDescriptorBufferAddressSpaceSize(value: DeviceSize) {
    this.#view.setBigUint64(240, BigInt(value), LE);
  }
  
  get descriptorBufferAddressSpaceSize() {
    return this.#view.getBigUint64(248, LE);
  }
  
  set descriptorBufferAddressSpaceSize(value: DeviceSize) {
    this.#view.setBigUint64(248, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
  pNext?: AnyPointer;
  combinedImageSamplerDensityMapDescriptorSize?: Deno.PointerValue;
}

export class PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.combinedImageSamplerDensityMapDescriptorSize !== undefined) this.combinedImageSamplerDensityMapDescriptorSize = data.combinedImageSamplerDensityMapDescriptorSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get combinedImageSamplerDensityMapDescriptorSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set combinedImageSamplerDensityMapDescriptorSize(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitDescriptorAddressInfoEXT {
  pNext?: AnyPointer;
  address?: DeviceAddress;
  range?: DeviceSize;
  format?: Format;
}

export class DescriptorAddressInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorAddressInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorAddressInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorAddressInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorAddressInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorAddressInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.address !== undefined) this.address = data.address;
      if (data.range !== undefined) this.range = data.range;
      if (data.format !== undefined) this.format = data.format;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get address() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set address(value: DeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get range() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set range(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(32, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitDescriptorBufferBindingInfoEXT {
  pNext?: AnyPointer;
  address?: DeviceAddress;
  usage?: BufferUsageFlags;
}

export class DescriptorBufferBindingInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorBufferBindingInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorBufferBindingInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorBufferBindingInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorBufferBindingInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorBufferBindingInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.address !== undefined) this.address = data.address;
      if (data.usage !== undefined) this.usage = data.usage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get address() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set address(value: DeviceAddress) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get usage() {
    return this.#view.getUint32(24, LE);
  }
  
  set usage(value: BufferUsageFlags) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitDescriptorBufferBindingPushDescriptorBufferHandleEXT {
  pNext?: AnyPointer;
  buffer?: Buffer;
}

export class DescriptorBufferBindingPushDescriptorBufferHandleEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorBufferBindingPushDescriptorBufferHandleEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorBufferBindingPushDescriptorBufferHandleEXT) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorBufferBindingPushDescriptorBufferHandleEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorBufferBindingPushDescriptorBufferHandleEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorBufferBindingPushDescriptorBufferHandleEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDescriptorGetInfoEXT {
  pNext?: AnyPointer;
  type?: DescriptorType;
  data?: DescriptorDataEXT;
}

export class DescriptorGetInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorGetInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorGetInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorGetInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorGetInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorGetInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.data !== undefined) this.data = data.data;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: DescriptorType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","u64"]}`);
  }
  
  set data(value: DescriptorDataEXT) {
    throw new Error(`Unknown type: {"union":["buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","buffer","u64"]}`);
  }
}

export interface InitBufferCaptureDescriptorDataInfoEXT {
  pNext?: AnyPointer;
  buffer?: Buffer;
}

export class BufferCaptureDescriptorDataInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCaptureDescriptorDataInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCaptureDescriptorDataInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(BufferCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCaptureDescriptorDataInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.buffer !== undefined) this.buffer = data.buffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageCaptureDescriptorDataInfoEXT {
  pNext?: AnyPointer;
  image?: Image;
}

export class ImageCaptureDescriptorDataInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCaptureDescriptorDataInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCaptureDescriptorDataInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCaptureDescriptorDataInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageViewCaptureDescriptorDataInfoEXT {
  pNext?: AnyPointer;
  imageView?: ImageView;
}

export class ImageViewCaptureDescriptorDataInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewCaptureDescriptorDataInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewCaptureDescriptorDataInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewCaptureDescriptorDataInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageView !== undefined) this.imageView = data.imageView;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitSamplerCaptureDescriptorDataInfoEXT {
  pNext?: AnyPointer;
  sampler?: Sampler;
}

export class SamplerCaptureDescriptorDataInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSamplerCaptureDescriptorDataInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSamplerCaptureDescriptorDataInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(SamplerCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SamplerCaptureDescriptorDataInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SamplerCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.sampler !== undefined) this.sampler = data.sampler;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get sampler() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set sampler(value: Sampler) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitAccelerationStructureCaptureDescriptorDataInfoEXT {
  pNext?: AnyPointer;
  accelerationStructure?: AccelerationStructureKHR;
  accelerationStructureNV?: AccelerationStructureNV;
}

export class AccelerationStructureCaptureDescriptorDataInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureCaptureDescriptorDataInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureCaptureDescriptorDataInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureCaptureDescriptorDataInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureCaptureDescriptorDataInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.accelerationStructure !== undefined) this.accelerationStructure = data.accelerationStructure;
      if (data.accelerationStructureNV !== undefined) this.accelerationStructureNV = data.accelerationStructureNV;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructure() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set accelerationStructure(value: AccelerationStructureKHR) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get accelerationStructureNV() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureNV(value: AccelerationStructureNV) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitOpaqueCaptureDescriptorDataCreateInfoEXT {
  pNext?: AnyPointer;
  opaqueCaptureDescriptorData?: AnyPointer;
}

export class OpaqueCaptureDescriptorDataCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpaqueCaptureDescriptorDataCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpaqueCaptureDescriptorDataCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(OpaqueCaptureDescriptorDataCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpaqueCaptureDescriptorDataCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpaqueCaptureDescriptorDataCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.opaqueCaptureDescriptorData !== undefined) this.opaqueCaptureDescriptorData = data.opaqueCaptureDescriptorData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get opaqueCaptureDescriptorData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set opaqueCaptureDescriptorData(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceShaderIntegerDotProductFeatures {
  pNext?: AnyPointer;
  shaderIntegerDotProduct?: Bool32;
}

export class PhysicalDeviceShaderIntegerDotProductFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderIntegerDotProductFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderIntegerDotProductFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerDotProductFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderIntegerDotProductFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerDotProductFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderIntegerDotProduct !== undefined) this.shaderIntegerDotProduct = data.shaderIntegerDotProduct;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderIntegerDotProduct() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderIntegerDotProduct(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderIntegerDotProductProperties {
  pNext?: AnyPointer;
  integerDotProduct8BitUnsignedAccelerated?: Bool32;
  integerDotProduct8BitSignedAccelerated?: Bool32;
  integerDotProduct8BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct4x8BitPackedUnsignedAccelerated?: Bool32;
  integerDotProduct4x8BitPackedSignedAccelerated?: Bool32;
  integerDotProduct4x8BitPackedMixedSignednessAccelerated?: Bool32;
  integerDotProduct16BitUnsignedAccelerated?: Bool32;
  integerDotProduct16BitSignedAccelerated?: Bool32;
  integerDotProduct16BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct32BitUnsignedAccelerated?: Bool32;
  integerDotProduct32BitSignedAccelerated?: Bool32;
  integerDotProduct32BitMixedSignednessAccelerated?: Bool32;
  integerDotProduct64BitUnsignedAccelerated?: Bool32;
  integerDotProduct64BitSignedAccelerated?: Bool32;
  integerDotProduct64BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitUnsignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitSignedAccelerated?: Bool32;
  integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated?: Bool32;
}

export class PhysicalDeviceShaderIntegerDotProductProperties implements BaseStruct {
  static size = 136;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderIntegerDotProductProperties);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderIntegerDotProductProperties) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerDotProductProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderIntegerDotProductProperties.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderIntegerDotProductProperties.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.integerDotProduct8BitUnsignedAccelerated !== undefined) this.integerDotProduct8BitUnsignedAccelerated = data.integerDotProduct8BitUnsignedAccelerated;
      if (data.integerDotProduct8BitSignedAccelerated !== undefined) this.integerDotProduct8BitSignedAccelerated = data.integerDotProduct8BitSignedAccelerated;
      if (data.integerDotProduct8BitMixedSignednessAccelerated !== undefined) this.integerDotProduct8BitMixedSignednessAccelerated = data.integerDotProduct8BitMixedSignednessAccelerated;
      if (data.integerDotProduct4x8BitPackedUnsignedAccelerated !== undefined) this.integerDotProduct4x8BitPackedUnsignedAccelerated = data.integerDotProduct4x8BitPackedUnsignedAccelerated;
      if (data.integerDotProduct4x8BitPackedSignedAccelerated !== undefined) this.integerDotProduct4x8BitPackedSignedAccelerated = data.integerDotProduct4x8BitPackedSignedAccelerated;
      if (data.integerDotProduct4x8BitPackedMixedSignednessAccelerated !== undefined) this.integerDotProduct4x8BitPackedMixedSignednessAccelerated = data.integerDotProduct4x8BitPackedMixedSignednessAccelerated;
      if (data.integerDotProduct16BitUnsignedAccelerated !== undefined) this.integerDotProduct16BitUnsignedAccelerated = data.integerDotProduct16BitUnsignedAccelerated;
      if (data.integerDotProduct16BitSignedAccelerated !== undefined) this.integerDotProduct16BitSignedAccelerated = data.integerDotProduct16BitSignedAccelerated;
      if (data.integerDotProduct16BitMixedSignednessAccelerated !== undefined) this.integerDotProduct16BitMixedSignednessAccelerated = data.integerDotProduct16BitMixedSignednessAccelerated;
      if (data.integerDotProduct32BitUnsignedAccelerated !== undefined) this.integerDotProduct32BitUnsignedAccelerated = data.integerDotProduct32BitUnsignedAccelerated;
      if (data.integerDotProduct32BitSignedAccelerated !== undefined) this.integerDotProduct32BitSignedAccelerated = data.integerDotProduct32BitSignedAccelerated;
      if (data.integerDotProduct32BitMixedSignednessAccelerated !== undefined) this.integerDotProduct32BitMixedSignednessAccelerated = data.integerDotProduct32BitMixedSignednessAccelerated;
      if (data.integerDotProduct64BitUnsignedAccelerated !== undefined) this.integerDotProduct64BitUnsignedAccelerated = data.integerDotProduct64BitUnsignedAccelerated;
      if (data.integerDotProduct64BitSignedAccelerated !== undefined) this.integerDotProduct64BitSignedAccelerated = data.integerDotProduct64BitSignedAccelerated;
      if (data.integerDotProduct64BitMixedSignednessAccelerated !== undefined) this.integerDotProduct64BitMixedSignednessAccelerated = data.integerDotProduct64BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitSignedAccelerated = data.integerDotProductAccumulatingSaturating8BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitSignedAccelerated = data.integerDotProductAccumulatingSaturating16BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitSignedAccelerated = data.integerDotProductAccumulatingSaturating32BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = data.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitSignedAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitSignedAccelerated = data.integerDotProductAccumulatingSaturating64BitSignedAccelerated;
      if (data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated !== undefined) this.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = data.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get integerDotProduct8BitUnsignedAccelerated() {
    return this.#view.getUint32(16, LE);
  }
  
  set integerDotProduct8BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get integerDotProduct8BitSignedAccelerated() {
    return this.#view.getUint32(20, LE);
  }
  
  set integerDotProduct8BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get integerDotProduct8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(24, LE);
  }
  
  set integerDotProduct8BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(28, LE);
  }
  
  set integerDotProduct4x8BitPackedUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(32, LE);
  }
  
  set integerDotProduct4x8BitPackedSignedAccelerated(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(36, LE);
  }
  
  set integerDotProduct4x8BitPackedMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get integerDotProduct16BitUnsignedAccelerated() {
    return this.#view.getUint32(40, LE);
  }
  
  set integerDotProduct16BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get integerDotProduct16BitSignedAccelerated() {
    return this.#view.getUint32(44, LE);
  }
  
  set integerDotProduct16BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get integerDotProduct16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(48, LE);
  }
  
  set integerDotProduct16BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get integerDotProduct32BitUnsignedAccelerated() {
    return this.#view.getUint32(52, LE);
  }
  
  set integerDotProduct32BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get integerDotProduct32BitSignedAccelerated() {
    return this.#view.getUint32(56, LE);
  }
  
  set integerDotProduct32BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get integerDotProduct32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(60, LE);
  }
  
  set integerDotProduct32BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get integerDotProduct64BitUnsignedAccelerated() {
    return this.#view.getUint32(64, LE);
  }
  
  set integerDotProduct64BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get integerDotProduct64BitSignedAccelerated() {
    return this.#view.getUint32(68, LE);
  }
  
  set integerDotProduct64BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(68, Number(value), LE);
  }
  
  get integerDotProduct64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(72, LE);
  }
  
  set integerDotProduct64BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
    return this.#view.getUint32(76, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(76, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
    return this.#view.getUint32(80, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(80, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
    return this.#view.getUint32(84, LE);
  }
  
  set integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
    return this.#view.getUint32(88, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
    return this.#view.getUint32(92, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated(value: Bool32) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
    return this.#view.getUint32(96, LE);
  }
  
  set integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(96, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
    return this.#view.getUint32(100, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(100, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
    return this.#view.getUint32(104, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
    return this.#view.getUint32(108, LE);
  }
  
  set integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
    return this.#view.getUint32(112, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(112, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
    return this.#view.getUint32(116, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(116, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
    return this.#view.getUint32(120, LE);
  }
  
  set integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
    return this.#view.getUint32(124, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitUnsignedAccelerated(value: Bool32) {
    this.#view.setUint32(124, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
    return this.#view.getUint32(128, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitSignedAccelerated(value: Bool32) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
    return this.#view.getUint32(132, LE);
  }
  
  set integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated(value: Bool32) {
    this.#view.setUint32(132, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDrmPropertiesEXT {
  pNext?: AnyPointer;
  hasPrimary?: Bool32;
  hasRender?: Bool32;
  primaryMajor?: Deno.PointerValue;
  primaryMinor?: Deno.PointerValue;
  renderMajor?: Deno.PointerValue;
  renderMinor?: Deno.PointerValue;
}

export class PhysicalDeviceDrmPropertiesEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDrmPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDrmPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDrmPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDrmPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDrmPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.hasPrimary !== undefined) this.hasPrimary = data.hasPrimary;
      if (data.hasRender !== undefined) this.hasRender = data.hasRender;
      if (data.primaryMajor !== undefined) this.primaryMajor = data.primaryMajor;
      if (data.primaryMinor !== undefined) this.primaryMinor = data.primaryMinor;
      if (data.renderMajor !== undefined) this.renderMajor = data.renderMajor;
      if (data.renderMinor !== undefined) this.renderMinor = data.renderMinor;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get hasPrimary() {
    return this.#view.getUint32(16, LE);
  }
  
  set hasPrimary(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get hasRender() {
    return this.#view.getUint32(20, LE);
  }
  
  set hasRender(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get primaryMajor() {
    return this.#view.getBigInt64(24, LE);
  }
  
  set primaryMajor(value: Deno.PointerValue) {
    this.#view.setBigInt64(24, BigInt(value), LE);
  }
  
  get primaryMinor() {
    return this.#view.getBigInt64(32, LE);
  }
  
  set primaryMinor(value: Deno.PointerValue) {
    this.#view.setBigInt64(32, BigInt(value), LE);
  }
  
  get renderMajor() {
    return this.#view.getBigInt64(40, LE);
  }
  
  set renderMajor(value: Deno.PointerValue) {
    this.#view.setBigInt64(40, BigInt(value), LE);
  }
  
  get renderMinor() {
    return this.#view.getBigInt64(48, LE);
  }
  
  set renderMinor(value: Deno.PointerValue) {
    this.#view.setBigInt64(48, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
  pNext?: AnyPointer;
  fragmentShaderBarycentric?: Bool32;
}

export class PhysicalDeviceFragmentShaderBarycentricFeaturesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShaderBarycentricFeaturesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderBarycentricFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShaderBarycentricFeaturesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderBarycentricFeaturesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.fragmentShaderBarycentric !== undefined) this.fragmentShaderBarycentric = data.fragmentShaderBarycentric;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get fragmentShaderBarycentric() {
    return this.#view.getUint32(16, LE);
  }
  
  set fragmentShaderBarycentric(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
  pNext?: AnyPointer;
  triStripVertexOrderIndependentOfProvokingVertex?: Bool32;
}

export class PhysicalDeviceFragmentShaderBarycentricPropertiesKHR implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFragmentShaderBarycentricPropertiesKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderBarycentricPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFragmentShaderBarycentricPropertiesKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFragmentShaderBarycentricPropertiesKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.triStripVertexOrderIndependentOfProvokingVertex !== undefined) this.triStripVertexOrderIndependentOfProvokingVertex = data.triStripVertexOrderIndependentOfProvokingVertex;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get triStripVertexOrderIndependentOfProvokingVertex() {
    return this.#view.getUint32(16, LE);
  }
  
  set triStripVertexOrderIndependentOfProvokingVertex(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingMotionBlurFeaturesNV {
  pNext?: AnyPointer;
  rayTracingMotionBlur?: Bool32;
  rayTracingMotionBlurPipelineTraceRaysIndirect?: Bool32;
}

export class PhysicalDeviceRayTracingMotionBlurFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingMotionBlurFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingMotionBlurFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingMotionBlurFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingMotionBlurFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingMotionBlurFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayTracingMotionBlur !== undefined) this.rayTracingMotionBlur = data.rayTracingMotionBlur;
      if (data.rayTracingMotionBlurPipelineTraceRaysIndirect !== undefined) this.rayTracingMotionBlurPipelineTraceRaysIndirect = data.rayTracingMotionBlurPipelineTraceRaysIndirect;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayTracingMotionBlur() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingMotionBlur(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rayTracingMotionBlurPipelineTraceRaysIndirect() {
    return this.#view.getUint32(20, LE);
  }
  
  set rayTracingMotionBlurPipelineTraceRaysIndirect(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitAccelerationStructureGeometryMotionTrianglesDataNV {
  pNext?: AnyPointer;
  vertexData?: DeviceOrHostAddressConstKHR;
}

export class AccelerationStructureGeometryMotionTrianglesDataNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureGeometryMotionTrianglesDataNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureGeometryMotionTrianglesDataNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureGeometryMotionTrianglesDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureGeometryMotionTrianglesDataNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureGeometryMotionTrianglesDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.vertexData !== undefined) this.vertexData = data.vertexData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get vertexData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set vertexData(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
}

export interface InitAccelerationStructureMotionInfoNV {
  pNext?: AnyPointer;
  maxInstances?: number;
  flags?: AccelerationStructureMotionInfoFlagsNV;
}

export class AccelerationStructureMotionInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureMotionInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureMotionInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureMotionInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureMotionInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureMotionInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxInstances !== undefined) this.maxInstances = data.maxInstances;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxInstances() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxInstances(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: AccelerationStructureMotionInfoFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitSRTDataNV {
  sx?: number;
  a?: number;
  b?: number;
  pvx?: number;
  sy?: number;
  c?: number;
  pvy?: number;
  sz?: number;
  pvz?: number;
  qx?: number;
  qy?: number;
  qz?: number;
  qw?: number;
  tx?: number;
  ty?: number;
  tz?: number;
}

export class SRTDataNV implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSRTDataNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSRTDataNV) {
    if (!data) {
      this.#data = new Uint8Array(SRTDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SRTDataNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SRTDataNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.sx !== undefined) this.sx = data.sx;
      if (data.a !== undefined) this.a = data.a;
      if (data.b !== undefined) this.b = data.b;
      if (data.pvx !== undefined) this.pvx = data.pvx;
      if (data.sy !== undefined) this.sy = data.sy;
      if (data.c !== undefined) this.c = data.c;
      if (data.pvy !== undefined) this.pvy = data.pvy;
      if (data.sz !== undefined) this.sz = data.sz;
      if (data.pvz !== undefined) this.pvz = data.pvz;
      if (data.qx !== undefined) this.qx = data.qx;
      if (data.qy !== undefined) this.qy = data.qy;
      if (data.qz !== undefined) this.qz = data.qz;
      if (data.qw !== undefined) this.qw = data.qw;
      if (data.tx !== undefined) this.tx = data.tx;
      if (data.ty !== undefined) this.ty = data.ty;
      if (data.tz !== undefined) this.tz = data.tz;
    }
  }
  
  get sx() {
    return this.#view.getFloat32(0, LE);
  }
  
  set sx(value: number) {
    this.#view.setFloat32(0, Number(value), LE);
  }
  
  get a() {
    return this.#view.getFloat32(4, LE);
  }
  
  set a(value: number) {
    this.#view.setFloat32(4, Number(value), LE);
  }
  
  get b() {
    return this.#view.getFloat32(8, LE);
  }
  
  set b(value: number) {
    this.#view.setFloat32(8, Number(value), LE);
  }
  
  get pvx() {
    return this.#view.getFloat32(12, LE);
  }
  
  set pvx(value: number) {
    this.#view.setFloat32(12, Number(value), LE);
  }
  
  get sy() {
    return this.#view.getFloat32(16, LE);
  }
  
  set sy(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
  
  get c() {
    return this.#view.getFloat32(20, LE);
  }
  
  set c(value: number) {
    this.#view.setFloat32(20, Number(value), LE);
  }
  
  get pvy() {
    return this.#view.getFloat32(24, LE);
  }
  
  set pvy(value: number) {
    this.#view.setFloat32(24, Number(value), LE);
  }
  
  get sz() {
    return this.#view.getFloat32(28, LE);
  }
  
  set sz(value: number) {
    this.#view.setFloat32(28, Number(value), LE);
  }
  
  get pvz() {
    return this.#view.getFloat32(32, LE);
  }
  
  set pvz(value: number) {
    this.#view.setFloat32(32, Number(value), LE);
  }
  
  get qx() {
    return this.#view.getFloat32(36, LE);
  }
  
  set qx(value: number) {
    this.#view.setFloat32(36, Number(value), LE);
  }
  
  get qy() {
    return this.#view.getFloat32(40, LE);
  }
  
  set qy(value: number) {
    this.#view.setFloat32(40, Number(value), LE);
  }
  
  get qz() {
    return this.#view.getFloat32(44, LE);
  }
  
  set qz(value: number) {
    this.#view.setFloat32(44, Number(value), LE);
  }
  
  get qw() {
    return this.#view.getFloat32(48, LE);
  }
  
  set qw(value: number) {
    this.#view.setFloat32(48, Number(value), LE);
  }
  
  get tx() {
    return this.#view.getFloat32(52, LE);
  }
  
  set tx(value: number) {
    this.#view.setFloat32(52, Number(value), LE);
  }
  
  get ty() {
    return this.#view.getFloat32(56, LE);
  }
  
  set ty(value: number) {
    this.#view.setFloat32(56, Number(value), LE);
  }
  
  get tz() {
    return this.#view.getFloat32(60, LE);
  }
  
  set tz(value: number) {
    this.#view.setFloat32(60, Number(value), LE);
  }
}

export interface InitAccelerationStructureSRTMotionInstanceNV {
  transformT0?: SRTDataNV;
  transformT1?: SRTDataNV;
  instanceCustomIndex?: number;
  mask?: number;
  instanceShaderBindingTableRecordOffset?: number;
  flags?: GeometryInstanceFlagsKHR;
  accelerationStructureReference?: Deno.PointerValue;
}

export class AccelerationStructureSRTMotionInstanceNV implements BaseStruct {
  static size = 152;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureSRTMotionInstanceNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureSRTMotionInstanceNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureSRTMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureSRTMotionInstanceNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureSRTMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.transformT0 !== undefined) this.transformT0 = data.transformT0;
      if (data.transformT1 !== undefined) this.transformT1 = data.transformT1;
      if (data.instanceCustomIndex !== undefined) this.instanceCustomIndex = data.instanceCustomIndex;
      if (data.mask !== undefined) this.mask = data.mask;
      if (data.instanceShaderBindingTableRecordOffset !== undefined) this.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.accelerationStructureReference !== undefined) this.accelerationStructureReference = data.accelerationStructureReference;
    }
  }
  
  get transformT0() {
    return new SRTDataNV(this.#data.subarray(0, 0 + SRTDataNV.size));
  }
  
  set transformT0(value: SRTDataNV) {
    if (value[BUFFER].byteLength < SRTDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get transformT1() {
    return new SRTDataNV(this.#data.subarray(64, 64 + SRTDataNV.size));
  }
  
  set transformT1(value: SRTDataNV) {
    if (value[BUFFER].byteLength < SRTDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 64);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(128, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(128, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(132, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(132, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(136, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(136, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(140, LE);
  }
  
  set flags(value: GeometryInstanceFlagsKHR) {
    this.#view.setUint32(140, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(144, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(144, BigInt(value), LE);
  }
}

export interface InitAccelerationStructureMatrixMotionInstanceNV {
  transformT0?: TransformMatrixKHR;
  transformT1?: TransformMatrixKHR;
  instanceCustomIndex?: number;
  mask?: number;
  instanceShaderBindingTableRecordOffset?: number;
  flags?: GeometryInstanceFlagsKHR;
  accelerationStructureReference?: Deno.PointerValue;
}

export class AccelerationStructureMatrixMotionInstanceNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureMatrixMotionInstanceNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureMatrixMotionInstanceNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureMatrixMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureMatrixMotionInstanceNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureMatrixMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.transformT0 !== undefined) this.transformT0 = data.transformT0;
      if (data.transformT1 !== undefined) this.transformT1 = data.transformT1;
      if (data.instanceCustomIndex !== undefined) this.instanceCustomIndex = data.instanceCustomIndex;
      if (data.mask !== undefined) this.mask = data.mask;
      if (data.instanceShaderBindingTableRecordOffset !== undefined) this.instanceShaderBindingTableRecordOffset = data.instanceShaderBindingTableRecordOffset;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.accelerationStructureReference !== undefined) this.accelerationStructureReference = data.accelerationStructureReference;
    }
  }
  
  get transformT0() {
    return new TransformMatrixKHR(this.#data.subarray(0, 0 + TransformMatrixKHR.size));
  }
  
  set transformT0(value: TransformMatrixKHR) {
    if (value[BUFFER].byteLength < TransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 0);
  }
  
  get transformT1() {
    return new TransformMatrixKHR(this.#data.subarray(4, 4 + TransformMatrixKHR.size));
  }
  
  set transformT1(value: TransformMatrixKHR) {
    if (value[BUFFER].byteLength < TransformMatrixKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 4);
  }
  
  get instanceCustomIndex() {
    return this.#view.getUint32(8, LE);
  }
  
  set instanceCustomIndex(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get mask() {
    return this.#view.getUint32(12, LE);
  }
  
  set mask(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get instanceShaderBindingTableRecordOffset() {
    return this.#view.getUint32(16, LE);
  }
  
  set instanceShaderBindingTableRecordOffset(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: GeometryInstanceFlagsKHR) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get accelerationStructureReference() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set accelerationStructureReference(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitAccelerationStructureMotionInstanceNV {
  type?: AccelerationStructureMotionInstanceTypeNV;
  flags?: AccelerationStructureMotionInstanceFlagsNV;
  data?: AccelerationStructureMotionInstanceDataNV;
}

export class AccelerationStructureMotionInstanceNV implements BaseStruct {
  static size = 160;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureMotionInstanceNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureMotionInstanceNV) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureMotionInstanceNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureMotionInstanceNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.type !== undefined) this.type = data.type;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.data !== undefined) this.data = data.data;
    }
  }
  
  get type() {
    return this.#view.getUint32(0, LE);
  }
  
  set type(value: AccelerationStructureMotionInstanceTypeNV) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(4, LE);
  }
  
  set flags(value: AccelerationStructureMotionInstanceFlagsNV) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":[{"struct":[{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32"]},{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},"u32","u32","u32","u32","u64"]}]}`);
  }
  
  set data(value: AccelerationStructureMotionInstanceDataNV) {
    throw new Error(`Unknown type: {"union":[{"struct":[{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32"]},{"struct":["f32"]},"u32","u32","u32","u32","u64"]},{"struct":[{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},{"struct":["f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32","f32"]},"u32","u32","u32","u32","u64"]}]}`);
  }
}

export interface InitMemoryGetRemoteAddressInfoNV {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  handleType?: ExternalMemoryHandleTypeFlagBits;
}

export class MemoryGetRemoteAddressInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMemoryGetRemoteAddressInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMemoryGetRemoteAddressInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(MemoryGetRemoteAddressInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MemoryGetRemoteAddressInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MemoryGetRemoteAddressInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.handleType !== undefined) this.handleType = data.handleType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get handleType() {
    return this.#view.getUint32(24, LE);
  }
  
  set handleType(value: ExternalMemoryHandleTypeFlagBits) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitImportMemoryBufferCollectionFUCHSIA {
  pNext?: AnyPointer;
  collection?: BufferCollectionFUCHSIA;
  index?: number;
}

export class ImportMemoryBufferCollectionFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMemoryBufferCollectionFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMemoryBufferCollectionFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImportMemoryBufferCollectionFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMemoryBufferCollectionFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMemoryBufferCollectionFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.collection !== undefined) this.collection = data.collection;
      if (data.index !== undefined) this.index = data.index;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: BufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitBufferCollectionImageCreateInfoFUCHSIA {
  pNext?: AnyPointer;
  collection?: BufferCollectionFUCHSIA;
  index?: number;
}

export class BufferCollectionImageCreateInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCollectionImageCreateInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCollectionImageCreateInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferCollectionImageCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCollectionImageCreateInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCollectionImageCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.collection !== undefined) this.collection = data.collection;
      if (data.index !== undefined) this.index = data.index;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: BufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitBufferCollectionBufferCreateInfoFUCHSIA {
  pNext?: AnyPointer;
  collection?: BufferCollectionFUCHSIA;
  index?: number;
}

export class BufferCollectionBufferCreateInfoFUCHSIA implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCollectionBufferCreateInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCollectionBufferCreateInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferCollectionBufferCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCollectionBufferCreateInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCollectionBufferCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.collection !== undefined) this.collection = data.collection;
      if (data.index !== undefined) this.index = data.index;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get collection() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collection(value: BufferCollectionFUCHSIA) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get index() {
    return this.#view.getUint32(24, LE);
  }
  
  set index(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitBufferCollectionCreateInfoFUCHSIA {
  pNext?: AnyPointer;
  collectionToken?: Deno.PointerValue;
}

export class BufferCollectionCreateInfoFUCHSIA implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCollectionCreateInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCollectionCreateInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferCollectionCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCollectionCreateInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCollectionCreateInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.collectionToken !== undefined) this.collectionToken = data.collectionToken;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get collectionToken() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set collectionToken(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitBufferCollectionPropertiesFUCHSIA {
  pNext?: AnyPointer;
  memoryTypeBits?: number;
  bufferCount?: number;
  createInfoIndex?: number;
  sysmemPixelFormat?: Deno.PointerValue;
  formatFeatures?: FormatFeatureFlags;
  sysmemColorSpaceIndex?: SysmemColorSpaceFUCHSIA;
  samplerYcbcrConversionComponents?: ComponentMapping;
  suggestedYcbcrModel?: SamplerYcbcrModelConversion;
  suggestedYcbcrRange?: SamplerYcbcrRange;
  suggestedXChromaOffset?: ChromaLocation;
  suggestedYChromaOffset?: ChromaLocation;
}

export class BufferCollectionPropertiesFUCHSIA implements BaseStruct {
  static size = 104;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCollectionPropertiesFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCollectionPropertiesFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferCollectionPropertiesFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCollectionPropertiesFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCollectionPropertiesFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memoryTypeBits !== undefined) this.memoryTypeBits = data.memoryTypeBits;
      if (data.bufferCount !== undefined) this.bufferCount = data.bufferCount;
      if (data.createInfoIndex !== undefined) this.createInfoIndex = data.createInfoIndex;
      if (data.sysmemPixelFormat !== undefined) this.sysmemPixelFormat = data.sysmemPixelFormat;
      if (data.formatFeatures !== undefined) this.formatFeatures = data.formatFeatures;
      if (data.sysmemColorSpaceIndex !== undefined) this.sysmemColorSpaceIndex = data.sysmemColorSpaceIndex;
      if (data.samplerYcbcrConversionComponents !== undefined) this.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
      if (data.suggestedYcbcrModel !== undefined) this.suggestedYcbcrModel = data.suggestedYcbcrModel;
      if (data.suggestedYcbcrRange !== undefined) this.suggestedYcbcrRange = data.suggestedYcbcrRange;
      if (data.suggestedXChromaOffset !== undefined) this.suggestedXChromaOffset = data.suggestedXChromaOffset;
      if (data.suggestedYChromaOffset !== undefined) this.suggestedYChromaOffset = data.suggestedYChromaOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memoryTypeBits() {
    return this.#view.getUint32(16, LE);
  }
  
  set memoryTypeBits(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get bufferCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set bufferCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get createInfoIndex() {
    return this.#view.getUint32(24, LE);
  }
  
  set createInfoIndex(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get sysmemPixelFormat() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set sysmemPixelFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getUint32(40, LE);
  }
  
  set formatFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get sysmemColorSpaceIndex() {
    return new SysmemColorSpaceFUCHSIA(this.#data.subarray(44, 44 + SysmemColorSpaceFUCHSIA.size));
  }
  
  set sysmemColorSpaceIndex(value: SysmemColorSpaceFUCHSIA) {
    if (value[BUFFER].byteLength < SysmemColorSpaceFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 44);
  }
  
  get samplerYcbcrConversionComponents() {
    return new ComponentMapping(this.#data.subarray(68, 68 + ComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 68);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(84, LE);
  }
  
  set suggestedYcbcrModel(value: SamplerYcbcrModelConversion) {
    this.#view.setUint32(84, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(88, LE);
  }
  
  set suggestedYcbcrRange(value: SamplerYcbcrRange) {
    this.#view.setUint32(88, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(92, LE);
  }
  
  set suggestedXChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(92, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(96, LE);
  }
  
  set suggestedYChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(96, Number(value), LE);
  }
}

export interface InitBufferConstraintsInfoFUCHSIA {
  pNext?: AnyPointer;
  createInfo?: BufferCreateInfo;
  requiredFormatFeatures?: FormatFeatureFlags;
  bufferCollectionConstraints?: BufferCollectionConstraintsInfoFUCHSIA;
}

export class BufferConstraintsInfoFUCHSIA implements BaseStruct {
  static size = 120;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferConstraintsInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferConstraintsInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferConstraintsInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.createInfo !== undefined) this.createInfo = data.createInfo;
      if (data.requiredFormatFeatures !== undefined) this.requiredFormatFeatures = data.requiredFormatFeatures;
      if (data.bufferCollectionConstraints !== undefined) this.bufferCollectionConstraints = data.bufferCollectionConstraints;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get createInfo() {
    return new BufferCreateInfo(this.#data.subarray(16, 16 + BufferCreateInfo.size));
  }
  
  set createInfo(value: BufferCreateInfo) {
    if (value[BUFFER].byteLength < BufferCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get requiredFormatFeatures() {
    return this.#view.getUint32(72, LE);
  }
  
  set requiredFormatFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(72, Number(value), LE);
  }
  
  get bufferCollectionConstraints() {
    return new BufferCollectionConstraintsInfoFUCHSIA(this.#data.subarray(76, 76 + BufferCollectionConstraintsInfoFUCHSIA.size));
  }
  
  set bufferCollectionConstraints(value: BufferCollectionConstraintsInfoFUCHSIA) {
    if (value[BUFFER].byteLength < BufferCollectionConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 76);
  }
}

export interface InitSysmemColorSpaceFUCHSIA {
  pNext?: AnyPointer;
  colorSpace?: number;
}

export class SysmemColorSpaceFUCHSIA implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSysmemColorSpaceFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSysmemColorSpaceFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(SysmemColorSpaceFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SysmemColorSpaceFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SysmemColorSpaceFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.colorSpace !== undefined) this.colorSpace = data.colorSpace;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get colorSpace() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorSpace(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImageFormatConstraintsInfoFUCHSIA {
  pNext?: AnyPointer;
  imageCreateInfo?: ImageCreateInfo;
  requiredFormatFeatures?: FormatFeatureFlags;
  flags?: ImageFormatConstraintsFlagsFUCHSIA;
  sysmemPixelFormat?: Deno.PointerValue;
  colorSpaceCount?: number;
  pColorSpaces?: AnyPointer;
}

export class ImageFormatConstraintsInfoFUCHSIA implements BaseStruct {
  static size = 136;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageFormatConstraintsInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageFormatConstraintsInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImageFormatConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageFormatConstraintsInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageFormatConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageCreateInfo !== undefined) this.imageCreateInfo = data.imageCreateInfo;
      if (data.requiredFormatFeatures !== undefined) this.requiredFormatFeatures = data.requiredFormatFeatures;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.sysmemPixelFormat !== undefined) this.sysmemPixelFormat = data.sysmemPixelFormat;
      if (data.colorSpaceCount !== undefined) this.colorSpaceCount = data.colorSpaceCount;
      if (data.pColorSpaces !== undefined) this.pColorSpaces = data.pColorSpaces;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageCreateInfo() {
    return new ImageCreateInfo(this.#data.subarray(16, 16 + ImageCreateInfo.size));
  }
  
  set imageCreateInfo(value: ImageCreateInfo) {
    if (value[BUFFER].byteLength < ImageCreateInfo.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get requiredFormatFeatures() {
    return this.#view.getUint32(104, LE);
  }
  
  set requiredFormatFeatures(value: FormatFeatureFlags) {
    this.#view.setUint32(104, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(108, LE);
  }
  
  set flags(value: ImageFormatConstraintsFlagsFUCHSIA) {
    this.#view.setUint32(108, Number(value), LE);
  }
  
  get sysmemPixelFormat() {
    return this.#view.getBigUint64(112, LE);
  }
  
  set sysmemPixelFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(112, BigInt(value), LE);
  }
  
  get colorSpaceCount() {
    return this.#view.getUint32(120, LE);
  }
  
  set colorSpaceCount(value: number) {
    this.#view.setUint32(120, Number(value), LE);
  }
  
  get pColorSpaces() {
    return this.#view.getBigUint64(128, LE);
  }
  
  set pColorSpaces(value: AnyPointer) {
    this.#view.setBigUint64(128, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImageConstraintsInfoFUCHSIA {
  pNext?: AnyPointer;
  formatConstraintsCount?: number;
  pFormatConstraints?: AnyPointer;
  bufferCollectionConstraints?: BufferCollectionConstraintsInfoFUCHSIA;
  flags?: ImageConstraintsInfoFlagsFUCHSIA;
}

export class ImageConstraintsInfoFUCHSIA implements BaseStruct {
  static size = 80;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageConstraintsInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageConstraintsInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(ImageConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageConstraintsInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.formatConstraintsCount !== undefined) this.formatConstraintsCount = data.formatConstraintsCount;
      if (data.pFormatConstraints !== undefined) this.pFormatConstraints = data.pFormatConstraints;
      if (data.bufferCollectionConstraints !== undefined) this.bufferCollectionConstraints = data.bufferCollectionConstraints;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get formatConstraintsCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatConstraintsCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pFormatConstraints() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFormatConstraints(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get bufferCollectionConstraints() {
    return new BufferCollectionConstraintsInfoFUCHSIA(this.#data.subarray(32, 32 + BufferCollectionConstraintsInfoFUCHSIA.size));
  }
  
  set bufferCollectionConstraints(value: BufferCollectionConstraintsInfoFUCHSIA) {
    if (value[BUFFER].byteLength < BufferCollectionConstraintsInfoFUCHSIA.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 32);
  }
  
  get flags() {
    return this.#view.getUint32(72, LE);
  }
  
  set flags(value: ImageConstraintsInfoFlagsFUCHSIA) {
    this.#view.setUint32(72, Number(value), LE);
  }
}

export interface InitBufferCollectionConstraintsInfoFUCHSIA {
  pNext?: AnyPointer;
  minBufferCount?: number;
  maxBufferCount?: number;
  minBufferCountForCamping?: number;
  minBufferCountForDedicatedSlack?: number;
  minBufferCountForSharedSlack?: number;
}

export class BufferCollectionConstraintsInfoFUCHSIA implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitBufferCollectionConstraintsInfoFUCHSIA);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitBufferCollectionConstraintsInfoFUCHSIA) {
    if (!data) {
      this.#data = new Uint8Array(BufferCollectionConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < BufferCollectionConstraintsInfoFUCHSIA.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(BufferCollectionConstraintsInfoFUCHSIA.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minBufferCount !== undefined) this.minBufferCount = data.minBufferCount;
      if (data.maxBufferCount !== undefined) this.maxBufferCount = data.maxBufferCount;
      if (data.minBufferCountForCamping !== undefined) this.minBufferCountForCamping = data.minBufferCountForCamping;
      if (data.minBufferCountForDedicatedSlack !== undefined) this.minBufferCountForDedicatedSlack = data.minBufferCountForDedicatedSlack;
      if (data.minBufferCountForSharedSlack !== undefined) this.minBufferCountForSharedSlack = data.minBufferCountForSharedSlack;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minBufferCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set minBufferCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxBufferCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxBufferCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get minBufferCountForCamping() {
    return this.#view.getUint32(24, LE);
  }
  
  set minBufferCountForCamping(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get minBufferCountForDedicatedSlack() {
    return this.#view.getUint32(28, LE);
  }
  
  set minBufferCountForDedicatedSlack(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get minBufferCountForSharedSlack() {
    return this.#view.getUint32(32, LE);
  }
  
  set minBufferCountForSharedSlack(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
  pNext?: AnyPointer;
  formatRgba10x6WithoutYCbCrSampler?: Bool32;
}

export class PhysicalDeviceRGBA10X6FormatsFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRGBA10X6FormatsFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRGBA10X6FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRGBA10X6FormatsFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRGBA10X6FormatsFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.formatRgba10x6WithoutYCbCrSampler !== undefined) this.formatRgba10x6WithoutYCbCrSampler = data.formatRgba10x6WithoutYCbCrSampler;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get formatRgba10x6WithoutYCbCrSampler() {
    return this.#view.getUint32(16, LE);
  }
  
  set formatRgba10x6WithoutYCbCrSampler(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitFormatProperties3 {
  pNext?: AnyPointer;
  linearTilingFeatures?: FormatFeatureFlags2;
  optimalTilingFeatures?: FormatFeatureFlags2;
  bufferFeatures?: FormatFeatureFlags2;
}

export class FormatProperties3 implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitFormatProperties3);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitFormatProperties3) {
    if (!data) {
      this.#data = new Uint8Array(FormatProperties3.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < FormatProperties3.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(FormatProperties3.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.linearTilingFeatures !== undefined) this.linearTilingFeatures = data.linearTilingFeatures;
      if (data.optimalTilingFeatures !== undefined) this.optimalTilingFeatures = data.optimalTilingFeatures;
      if (data.bufferFeatures !== undefined) this.bufferFeatures = data.bufferFeatures;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get linearTilingFeatures() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set linearTilingFeatures(value: FormatFeatureFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get optimalTilingFeatures() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set optimalTilingFeatures(value: FormatFeatureFlags2) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get bufferFeatures() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set bufferFeatures(value: FormatFeatureFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitDrmFormatModifierPropertiesList2EXT {
  pNext?: AnyPointer;
  drmFormatModifierCount?: number;
  pDrmFormatModifierProperties?: AnyPointer;
}

export class DrmFormatModifierPropertiesList2EXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrmFormatModifierPropertiesList2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrmFormatModifierPropertiesList2EXT) {
    if (!data) {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesList2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrmFormatModifierPropertiesList2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrmFormatModifierPropertiesList2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.drmFormatModifierCount !== undefined) this.drmFormatModifierCount = data.drmFormatModifierCount;
      if (data.pDrmFormatModifierProperties !== undefined) this.pDrmFormatModifierProperties = data.pDrmFormatModifierProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get drmFormatModifierCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set drmFormatModifierCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pDrmFormatModifierProperties() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pDrmFormatModifierProperties(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDrmFormatModifierProperties2EXT {
  drmFormatModifier?: Deno.PointerValue;
  drmFormatModifierPlaneCount?: number;
  drmFormatModifierTilingFeatures?: FormatFeatureFlags2;
}

export class DrmFormatModifierProperties2EXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDrmFormatModifierProperties2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDrmFormatModifierProperties2EXT) {
    if (!data) {
      this.#data = new Uint8Array(DrmFormatModifierProperties2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DrmFormatModifierProperties2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DrmFormatModifierProperties2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.drmFormatModifier !== undefined) this.drmFormatModifier = data.drmFormatModifier;
      if (data.drmFormatModifierPlaneCount !== undefined) this.drmFormatModifierPlaneCount = data.drmFormatModifierPlaneCount;
      if (data.drmFormatModifierTilingFeatures !== undefined) this.drmFormatModifierTilingFeatures = data.drmFormatModifierTilingFeatures;
    }
  }
  
  get drmFormatModifier() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set drmFormatModifier(value: Deno.PointerValue) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get drmFormatModifierPlaneCount() {
    return this.#view.getUint32(8, LE);
  }
  
  set drmFormatModifierPlaneCount(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get drmFormatModifierTilingFeatures() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set drmFormatModifierTilingFeatures(value: FormatFeatureFlags2) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitAndroidHardwareBufferFormatProperties2ANDROID {
  pNext?: AnyPointer;
  format?: Format;
  externalFormat?: Deno.PointerValue;
  formatFeatures?: FormatFeatureFlags2;
  samplerYcbcrConversionComponents?: ComponentMapping;
  suggestedYcbcrModel?: SamplerYcbcrModelConversion;
  suggestedYcbcrRange?: SamplerYcbcrRange;
  suggestedXChromaOffset?: ChromaLocation;
  suggestedYChromaOffset?: ChromaLocation;
}

export class AndroidHardwareBufferFormatProperties2ANDROID implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAndroidHardwareBufferFormatProperties2ANDROID);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAndroidHardwareBufferFormatProperties2ANDROID) {
    if (!data) {
      this.#data = new Uint8Array(AndroidHardwareBufferFormatProperties2ANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AndroidHardwareBufferFormatProperties2ANDROID.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AndroidHardwareBufferFormatProperties2ANDROID.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
      if (data.externalFormat !== undefined) this.externalFormat = data.externalFormat;
      if (data.formatFeatures !== undefined) this.formatFeatures = data.formatFeatures;
      if (data.samplerYcbcrConversionComponents !== undefined) this.samplerYcbcrConversionComponents = data.samplerYcbcrConversionComponents;
      if (data.suggestedYcbcrModel !== undefined) this.suggestedYcbcrModel = data.suggestedYcbcrModel;
      if (data.suggestedYcbcrRange !== undefined) this.suggestedYcbcrRange = data.suggestedYcbcrRange;
      if (data.suggestedXChromaOffset !== undefined) this.suggestedXChromaOffset = data.suggestedXChromaOffset;
      if (data.suggestedYChromaOffset !== undefined) this.suggestedYChromaOffset = data.suggestedYChromaOffset;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get externalFormat() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set externalFormat(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get formatFeatures() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set formatFeatures(value: FormatFeatureFlags2) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get samplerYcbcrConversionComponents() {
    return new ComponentMapping(this.#data.subarray(40, 40 + ComponentMapping.size));
  }
  
  set samplerYcbcrConversionComponents(value: ComponentMapping) {
    if (value[BUFFER].byteLength < ComponentMapping.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 40);
  }
  
  get suggestedYcbcrModel() {
    return this.#view.getUint32(56, LE);
  }
  
  set suggestedYcbcrModel(value: SamplerYcbcrModelConversion) {
    this.#view.setUint32(56, Number(value), LE);
  }
  
  get suggestedYcbcrRange() {
    return this.#view.getUint32(60, LE);
  }
  
  set suggestedYcbcrRange(value: SamplerYcbcrRange) {
    this.#view.setUint32(60, Number(value), LE);
  }
  
  get suggestedXChromaOffset() {
    return this.#view.getUint32(64, LE);
  }
  
  set suggestedXChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(64, Number(value), LE);
  }
  
  get suggestedYChromaOffset() {
    return this.#view.getUint32(68, LE);
  }
  
  set suggestedYChromaOffset(value: ChromaLocation) {
    this.#view.setUint32(68, Number(value), LE);
  }
}

export interface InitPipelineRenderingCreateInfo {
  pNext?: AnyPointer;
  viewMask?: number;
  colorAttachmentCount?: number;
  pColorAttachmentFormats?: AnyPointer;
  depthAttachmentFormat?: Format;
  stencilAttachmentFormat?: Format;
}

export class PipelineRenderingCreateInfo implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRenderingCreateInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRenderingCreateInfo) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRenderingCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRenderingCreateInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRenderingCreateInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.viewMask !== undefined) this.viewMask = data.viewMask;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachmentFormats !== undefined) this.pColorAttachmentFormats = data.pColorAttachmentFormats;
      if (data.depthAttachmentFormat !== undefined) this.depthAttachmentFormat = data.depthAttachmentFormat;
      if (data.stencilAttachmentFormat !== undefined) this.stencilAttachmentFormat = data.stencilAttachmentFormat;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(16, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pColorAttachmentFormats() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorAttachmentFormats(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get depthAttachmentFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthAttachmentFormat(value: Format) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get stencilAttachmentFormat() {
    return this.#view.getUint32(36, LE);
  }
  
  set stencilAttachmentFormat(value: Format) {
    this.#view.setUint32(36, Number(value), LE);
  }
}

export interface InitRenderingInfo {
  pNext?: AnyPointer;
  flags?: RenderingFlags;
  renderArea?: Rect2D;
  layerCount?: number;
  viewMask?: number;
  colorAttachmentCount?: number;
  pColorAttachments?: AnyPointer;
  pDepthAttachment?: AnyPointer;
  pStencilAttachment?: AnyPointer;
}

export class RenderingInfo implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderingInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderingInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderingInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderingInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderingInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDERING_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.renderArea !== undefined) this.renderArea = data.renderArea;
      if (data.layerCount !== undefined) this.layerCount = data.layerCount;
      if (data.viewMask !== undefined) this.viewMask = data.viewMask;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachments !== undefined) this.pColorAttachments = data.pColorAttachments;
      if (data.pDepthAttachment !== undefined) this.pDepthAttachment = data.pDepthAttachment;
      if (data.pStencilAttachment !== undefined) this.pStencilAttachment = data.pStencilAttachment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: RenderingFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get renderArea() {
    return new Rect2D(this.#data.subarray(20, 20 + Rect2D.size));
  }
  
  set renderArea(value: Rect2D) {
    if (value[BUFFER].byteLength < Rect2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get layerCount() {
    return this.#view.getUint32(36, LE);
  }
  
  set layerCount(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(40, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pColorAttachments() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pColorAttachments(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get pDepthAttachment() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set pDepthAttachment(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get pStencilAttachment() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set pStencilAttachment(value: AnyPointer) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRenderingAttachmentInfo {
  pNext?: AnyPointer;
  imageView?: ImageView;
  imageLayout?: ImageLayout;
  resolveMode?: ResolveModeFlagBits;
  resolveImageView?: ImageView;
  resolveImageLayout?: ImageLayout;
  loadOp?: AttachmentLoadOp;
  storeOp?: AttachmentStoreOp;
  clearValue?: ClearValue;
}

export class RenderingAttachmentInfo implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderingAttachmentInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderingAttachmentInfo) {
    if (!data) {
      this.#data = new Uint8Array(RenderingAttachmentInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderingAttachmentInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderingAttachmentInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.imageLayout !== undefined) this.imageLayout = data.imageLayout;
      if (data.resolveMode !== undefined) this.resolveMode = data.resolveMode;
      if (data.resolveImageView !== undefined) this.resolveImageView = data.resolveImageView;
      if (data.resolveImageLayout !== undefined) this.resolveImageLayout = data.resolveImageLayout;
      if (data.loadOp !== undefined) this.loadOp = data.loadOp;
      if (data.storeOp !== undefined) this.storeOp = data.storeOp;
      if (data.clearValue !== undefined) this.clearValue = data.clearValue;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get resolveMode() {
    return this.#view.getUint32(28, LE);
  }
  
  set resolveMode(value: ResolveModeFlagBits) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get resolveImageView() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set resolveImageView(value: ImageView) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get resolveImageLayout() {
    return this.#view.getUint32(40, LE);
  }
  
  set resolveImageLayout(value: ImageLayout) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get loadOp() {
    return this.#view.getUint32(44, LE);
  }
  
  set loadOp(value: AttachmentLoadOp) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get storeOp() {
    return this.#view.getUint32(48, LE);
  }
  
  set storeOp(value: AttachmentStoreOp) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get clearValue() {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
  
  set clearValue(value: ClearValue) {
    throw new Error(`Unknown type: {"union":[{"union":["f32","i32","u32"]},{"struct":["f32","u32"]}]}`);
  }
}

export interface InitRenderingFragmentShadingRateAttachmentInfoKHR {
  pNext?: AnyPointer;
  imageView?: ImageView;
  imageLayout?: ImageLayout;
  shadingRateAttachmentTexelSize?: Extent2D;
}

export class RenderingFragmentShadingRateAttachmentInfoKHR implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderingFragmentShadingRateAttachmentInfoKHR);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderingFragmentShadingRateAttachmentInfoKHR) {
    if (!data) {
      this.#data = new Uint8Array(RenderingFragmentShadingRateAttachmentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderingFragmentShadingRateAttachmentInfoKHR.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderingFragmentShadingRateAttachmentInfoKHR.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.imageLayout !== undefined) this.imageLayout = data.imageLayout;
      if (data.shadingRateAttachmentTexelSize !== undefined) this.shadingRateAttachmentTexelSize = data.shadingRateAttachmentTexelSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shadingRateAttachmentTexelSize() {
    return new Extent2D(this.#data.subarray(28, 28 + Extent2D.size));
  }
  
  set shadingRateAttachmentTexelSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
}

export interface InitRenderingFragmentDensityMapAttachmentInfoEXT {
  pNext?: AnyPointer;
  imageView?: ImageView;
  imageLayout?: ImageLayout;
}

export class RenderingFragmentDensityMapAttachmentInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderingFragmentDensityMapAttachmentInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderingFragmentDensityMapAttachmentInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderingFragmentDensityMapAttachmentInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderingFragmentDensityMapAttachmentInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderingFragmentDensityMapAttachmentInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.imageLayout !== undefined) this.imageLayout = data.imageLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get imageLayout() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageLayout(value: ImageLayout) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDynamicRenderingFeatures {
  pNext?: AnyPointer;
  dynamicRendering?: Bool32;
}

export class PhysicalDeviceDynamicRenderingFeatures implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDynamicRenderingFeatures);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDynamicRenderingFeatures) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDynamicRenderingFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDynamicRenderingFeatures.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDynamicRenderingFeatures.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.dynamicRendering !== undefined) this.dynamicRendering = data.dynamicRendering;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get dynamicRendering() {
    return this.#view.getUint32(16, LE);
  }
  
  set dynamicRendering(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitCommandBufferInheritanceRenderingInfo {
  pNext?: AnyPointer;
  flags?: RenderingFlags;
  viewMask?: number;
  colorAttachmentCount?: number;
  pColorAttachmentFormats?: AnyPointer;
  depthAttachmentFormat?: Format;
  stencilAttachmentFormat?: Format;
  rasterizationSamples?: SampleCountFlagBits;
}

export class CommandBufferInheritanceRenderingInfo implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCommandBufferInheritanceRenderingInfo);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCommandBufferInheritanceRenderingInfo) {
    if (!data) {
      this.#data = new Uint8Array(CommandBufferInheritanceRenderingInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CommandBufferInheritanceRenderingInfo.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CommandBufferInheritanceRenderingInfo.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.viewMask !== undefined) this.viewMask = data.viewMask;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachmentFormats !== undefined) this.pColorAttachmentFormats = data.pColorAttachmentFormats;
      if (data.depthAttachmentFormat !== undefined) this.depthAttachmentFormat = data.depthAttachmentFormat;
      if (data.stencilAttachmentFormat !== undefined) this.stencilAttachmentFormat = data.stencilAttachmentFormat;
      if (data.rasterizationSamples !== undefined) this.rasterizationSamples = data.rasterizationSamples;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: RenderingFlags) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get viewMask() {
    return this.#view.getUint32(20, LE);
  }
  
  set viewMask(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get pColorAttachmentFormats() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set pColorAttachmentFormats(value: AnyPointer) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get depthAttachmentFormat() {
    return this.#view.getUint32(40, LE);
  }
  
  set depthAttachmentFormat(value: Format) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get stencilAttachmentFormat() {
    return this.#view.getUint32(44, LE);
  }
  
  set stencilAttachmentFormat(value: Format) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get rasterizationSamples() {
    return this.#view.getUint32(48, LE);
  }
  
  set rasterizationSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitAttachmentSampleCountInfoAMD {
  pNext?: AnyPointer;
  colorAttachmentCount?: number;
  pColorAttachmentSamples?: AnyPointer;
  depthStencilAttachmentSamples?: SampleCountFlagBits;
}

export class AttachmentSampleCountInfoAMD implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAttachmentSampleCountInfoAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAttachmentSampleCountInfoAMD) {
    if (!data) {
      this.#data = new Uint8Array(AttachmentSampleCountInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AttachmentSampleCountInfoAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AttachmentSampleCountInfoAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.colorAttachmentCount !== undefined) this.colorAttachmentCount = data.colorAttachmentCount;
      if (data.pColorAttachmentSamples !== undefined) this.pColorAttachmentSamples = data.pColorAttachmentSamples;
      if (data.depthStencilAttachmentSamples !== undefined) this.depthStencilAttachmentSamples = data.depthStencilAttachmentSamples;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get colorAttachmentCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set colorAttachmentCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pColorAttachmentSamples() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pColorAttachmentSamples(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get depthStencilAttachmentSamples() {
    return this.#view.getUint32(32, LE);
  }
  
  set depthStencilAttachmentSamples(value: SampleCountFlagBits) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitMultiviewPerViewAttributesInfoNVX {
  pNext?: AnyPointer;
  perViewAttributes?: Bool32;
  perViewAttributesPositionXOnly?: Bool32;
}

export class MultiviewPerViewAttributesInfoNVX implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMultiviewPerViewAttributesInfoNVX);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMultiviewPerViewAttributesInfoNVX) {
    if (!data) {
      this.#data = new Uint8Array(MultiviewPerViewAttributesInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MultiviewPerViewAttributesInfoNVX.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MultiviewPerViewAttributesInfoNVX.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.perViewAttributes !== undefined) this.perViewAttributes = data.perViewAttributes;
      if (data.perViewAttributesPositionXOnly !== undefined) this.perViewAttributesPositionXOnly = data.perViewAttributesPositionXOnly;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get perViewAttributes() {
    return this.#view.getUint32(16, LE);
  }
  
  set perViewAttributes(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get perViewAttributesPositionXOnly() {
    return this.#view.getUint32(20, LE);
  }
  
  set perViewAttributesPositionXOnly(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImageViewMinLodFeaturesEXT {
  pNext?: AnyPointer;
  minLod?: Bool32;
}

export class PhysicalDeviceImageViewMinLodFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageViewMinLodFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageViewMinLodFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageViewMinLodFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageViewMinLodFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageViewMinLodFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minLod !== undefined) this.minLod = data.minLod;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minLod() {
    return this.#view.getUint32(16, LE);
  }
  
  set minLod(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImageViewMinLodCreateInfoEXT {
  pNext?: AnyPointer;
  minLod?: number;
}

export class ImageViewMinLodCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewMinLodCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewMinLodCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewMinLodCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewMinLodCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewMinLodCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.minLod !== undefined) this.minLod = data.minLod;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get minLod() {
    return this.#view.getFloat32(16, LE);
  }
  
  set minLod(value: number) {
    this.#view.setFloat32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
  pNext?: AnyPointer;
  rasterizationOrderColorAttachmentAccess?: Bool32;
  rasterizationOrderDepthAttachmentAccess?: Bool32;
  rasterizationOrderStencilAttachmentAccess?: Bool32;
}

export class PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rasterizationOrderColorAttachmentAccess !== undefined) this.rasterizationOrderColorAttachmentAccess = data.rasterizationOrderColorAttachmentAccess;
      if (data.rasterizationOrderDepthAttachmentAccess !== undefined) this.rasterizationOrderDepthAttachmentAccess = data.rasterizationOrderDepthAttachmentAccess;
      if (data.rasterizationOrderStencilAttachmentAccess !== undefined) this.rasterizationOrderStencilAttachmentAccess = data.rasterizationOrderStencilAttachmentAccess;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rasterizationOrderColorAttachmentAccess() {
    return this.#view.getUint32(16, LE);
  }
  
  set rasterizationOrderColorAttachmentAccess(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get rasterizationOrderDepthAttachmentAccess() {
    return this.#view.getUint32(20, LE);
  }
  
  set rasterizationOrderDepthAttachmentAccess(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get rasterizationOrderStencilAttachmentAccess() {
    return this.#view.getUint32(24, LE);
  }
  
  set rasterizationOrderStencilAttachmentAccess(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceLinearColorAttachmentFeaturesNV {
  pNext?: AnyPointer;
  linearColorAttachment?: Bool32;
}

export class PhysicalDeviceLinearColorAttachmentFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceLinearColorAttachmentFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceLinearColorAttachmentFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceLinearColorAttachmentFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceLinearColorAttachmentFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceLinearColorAttachmentFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.linearColorAttachment !== undefined) this.linearColorAttachment = data.linearColorAttachment;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get linearColorAttachment() {
    return this.#view.getUint32(16, LE);
  }
  
  set linearColorAttachment(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
  pNext?: AnyPointer;
  graphicsPipelineLibrary?: Bool32;
}

export class PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.graphicsPipelineLibrary !== undefined) this.graphicsPipelineLibrary = data.graphicsPipelineLibrary;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get graphicsPipelineLibrary() {
    return this.#view.getUint32(16, LE);
  }
  
  set graphicsPipelineLibrary(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
  pNext?: AnyPointer;
  graphicsPipelineLibraryFastLinking?: Bool32;
  graphicsPipelineLibraryIndependentInterpolationDecoration?: Bool32;
}

export class PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.graphicsPipelineLibraryFastLinking !== undefined) this.graphicsPipelineLibraryFastLinking = data.graphicsPipelineLibraryFastLinking;
      if (data.graphicsPipelineLibraryIndependentInterpolationDecoration !== undefined) this.graphicsPipelineLibraryIndependentInterpolationDecoration = data.graphicsPipelineLibraryIndependentInterpolationDecoration;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get graphicsPipelineLibraryFastLinking() {
    return this.#view.getUint32(16, LE);
  }
  
  set graphicsPipelineLibraryFastLinking(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get graphicsPipelineLibraryIndependentInterpolationDecoration() {
    return this.#view.getUint32(20, LE);
  }
  
  set graphicsPipelineLibraryIndependentInterpolationDecoration(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitGraphicsPipelineLibraryCreateInfoEXT {
  pNext?: AnyPointer;
  flags?: GraphicsPipelineLibraryFlagsEXT;
}

export class GraphicsPipelineLibraryCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitGraphicsPipelineLibraryCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitGraphicsPipelineLibraryCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(GraphicsPipelineLibraryCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < GraphicsPipelineLibraryCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(GraphicsPipelineLibraryCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: GraphicsPipelineLibraryFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
  pNext?: AnyPointer;
  descriptorSetHostMapping?: Bool32;
}

export class PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorSetHostMapping !== undefined) this.descriptorSetHostMapping = data.descriptorSetHostMapping;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorSetHostMapping() {
    return this.#view.getUint32(16, LE);
  }
  
  set descriptorSetHostMapping(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDescriptorSetBindingReferenceVALVE {
  pNext?: AnyPointer;
  descriptorSetLayout?: DescriptorSetLayout;
  binding?: number;
}

export class DescriptorSetBindingReferenceVALVE implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetBindingReferenceVALVE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetBindingReferenceVALVE) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetBindingReferenceVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetBindingReferenceVALVE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetBindingReferenceVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorSetLayout !== undefined) this.descriptorSetLayout = data.descriptorSetLayout;
      if (data.binding !== undefined) this.binding = data.binding;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorSetLayout() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorSetLayout(value: DescriptorSetLayout) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get binding() {
    return this.#view.getUint32(24, LE);
  }
  
  set binding(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitDescriptorSetLayoutHostMappingInfoVALVE {
  pNext?: AnyPointer;
  descriptorOffset?: Deno.PointerValue;
  descriptorSize?: number;
}

export class DescriptorSetLayoutHostMappingInfoVALVE implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDescriptorSetLayoutHostMappingInfoVALVE);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDescriptorSetLayoutHostMappingInfoVALVE) {
    if (!data) {
      this.#data = new Uint8Array(DescriptorSetLayoutHostMappingInfoVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DescriptorSetLayoutHostMappingInfoVALVE.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DescriptorSetLayoutHostMappingInfoVALVE.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.descriptorOffset !== undefined) this.descriptorOffset = data.descriptorOffset;
      if (data.descriptorSize !== undefined) this.descriptorSize = data.descriptorSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get descriptorOffset() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set descriptorOffset(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get descriptorSize() {
    return this.#view.getUint32(24, LE);
  }
  
  set descriptorSize(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
  pNext?: AnyPointer;
  shaderModuleIdentifier?: Bool32;
}

export class PhysicalDeviceShaderModuleIdentifierFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderModuleIdentifierFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderModuleIdentifierFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderModuleIdentifierFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderModuleIdentifierFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderModuleIdentifierFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderModuleIdentifier !== undefined) this.shaderModuleIdentifier = data.shaderModuleIdentifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderModuleIdentifier() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderModuleIdentifier(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
  pNext?: AnyPointer;
  shaderModuleIdentifierAlgorithmUUID?: number[];
}

export class PhysicalDeviceShaderModuleIdentifierPropertiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderModuleIdentifierPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderModuleIdentifierPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderModuleIdentifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderModuleIdentifierPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderModuleIdentifierPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderModuleIdentifierAlgorithmUUID !== undefined) this.shaderModuleIdentifierAlgorithmUUID = data.shaderModuleIdentifierAlgorithmUUID;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderModuleIdentifierAlgorithmUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set shaderModuleIdentifierAlgorithmUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
}

export interface InitPipelineShaderStageModuleIdentifierCreateInfoEXT {
  pNext?: AnyPointer;
  identifierSize?: number;
  pIdentifier?: AnyPointer;
}

export class PipelineShaderStageModuleIdentifierCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineShaderStageModuleIdentifierCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineShaderStageModuleIdentifierCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineShaderStageModuleIdentifierCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineShaderStageModuleIdentifierCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineShaderStageModuleIdentifierCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.identifierSize !== undefined) this.identifierSize = data.identifierSize;
      if (data.pIdentifier !== undefined) this.pIdentifier = data.pIdentifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get identifierSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set identifierSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pIdentifier() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pIdentifier(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitShaderModuleIdentifierEXT {
  pNext?: AnyPointer;
  identifierSize?: number;
  identifier?: number[];
}

export class ShaderModuleIdentifierEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitShaderModuleIdentifierEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitShaderModuleIdentifierEXT) {
    if (!data) {
      this.#data = new Uint8Array(ShaderModuleIdentifierEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ShaderModuleIdentifierEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ShaderModuleIdentifierEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.identifierSize !== undefined) this.identifierSize = data.identifierSize;
      if (data.identifier !== undefined) this.identifier = data.identifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get identifierSize() {
    return this.#view.getUint32(16, LE);
  }
  
  set identifierSize(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get identifier() {
    const result: number[] = [];
    for (let i = 0; i < 32; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set identifier(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
}

export interface InitImageCompressionControlEXT {
  pNext?: AnyPointer;
  flags?: ImageCompressionFlagsEXT;
  compressionControlPlaneCount?: number;
  pFixedRateFlags?: AnyPointer;
}

export class ImageCompressionControlEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCompressionControlEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCompressionControlEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageCompressionControlEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCompressionControlEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCompressionControlEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.compressionControlPlaneCount !== undefined) this.compressionControlPlaneCount = data.compressionControlPlaneCount;
      if (data.pFixedRateFlags !== undefined) this.pFixedRateFlags = data.pFixedRateFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: ImageCompressionFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get compressionControlPlaneCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set compressionControlPlaneCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pFixedRateFlags() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pFixedRateFlags(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceImageCompressionControlFeaturesEXT {
  pNext?: AnyPointer;
  imageCompressionControl?: Bool32;
}

export class PhysicalDeviceImageCompressionControlFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageCompressionControlFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageCompressionControlFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageCompressionControlFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageCompressionControlFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageCompressionControlFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageCompressionControl !== undefined) this.imageCompressionControl = data.imageCompressionControl;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageCompressionControl() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionControl(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImageCompressionPropertiesEXT {
  pNext?: AnyPointer;
  imageCompressionFlags?: ImageCompressionFlagsEXT;
  imageCompressionFixedRateFlags?: ImageCompressionFixedRateFlagsEXT;
}

export class ImageCompressionPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageCompressionPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageCompressionPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageCompressionPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageCompressionPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageCompressionPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageCompressionFlags !== undefined) this.imageCompressionFlags = data.imageCompressionFlags;
      if (data.imageCompressionFixedRateFlags !== undefined) this.imageCompressionFixedRateFlags = data.imageCompressionFixedRateFlags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageCompressionFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionFlags(value: ImageCompressionFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get imageCompressionFixedRateFlags() {
    return this.#view.getUint32(20, LE);
  }
  
  set imageCompressionFixedRateFlags(value: ImageCompressionFixedRateFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
  pNext?: AnyPointer;
  imageCompressionControlSwapchain?: Bool32;
}

export class PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageCompressionControlSwapchain !== undefined) this.imageCompressionControlSwapchain = data.imageCompressionControlSwapchain;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageCompressionControlSwapchain() {
    return this.#view.getUint32(16, LE);
  }
  
  set imageCompressionControlSwapchain(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitImageSubresource2EXT {
  pNext?: AnyPointer;
  imageSubresource?: ImageSubresource;
}

export class ImageSubresource2EXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageSubresource2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageSubresource2EXT) {
    if (!data) {
      this.#data = new Uint8Array(ImageSubresource2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageSubresource2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageSubresource2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.imageSubresource !== undefined) this.imageSubresource = data.imageSubresource;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get imageSubresource() {
    return new ImageSubresource(this.#data.subarray(16, 16 + ImageSubresource.size));
  }
  
  set imageSubresource(value: ImageSubresource) {
    if (value[BUFFER].byteLength < ImageSubresource.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitSubresourceLayout2EXT {
  pNext?: AnyPointer;
  subresourceLayout?: SubresourceLayout;
}

export class SubresourceLayout2EXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitSubresourceLayout2EXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitSubresourceLayout2EXT) {
    if (!data) {
      this.#data = new Uint8Array(SubresourceLayout2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < SubresourceLayout2EXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(SubresourceLayout2EXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subresourceLayout !== undefined) this.subresourceLayout = data.subresourceLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subresourceLayout() {
    return new SubresourceLayout(this.#data.subarray(16, 16 + SubresourceLayout.size));
  }
  
  set subresourceLayout(value: SubresourceLayout) {
    if (value[BUFFER].byteLength < SubresourceLayout.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
}

export interface InitRenderPassCreationControlEXT {
  pNext?: AnyPointer;
  disallowMerging?: Bool32;
}

export class RenderPassCreationControlEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassCreationControlEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassCreationControlEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassCreationControlEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassCreationControlEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassCreationControlEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.disallowMerging !== undefined) this.disallowMerging = data.disallowMerging;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get disallowMerging() {
    return this.#view.getUint32(16, LE);
  }
  
  set disallowMerging(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitRenderPassCreationFeedbackInfoEXT {
  postMergeSubpassCount?: number;
}

export class RenderPassCreationFeedbackInfoEXT implements BaseStruct {
  static size = 4;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassCreationFeedbackInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassCreationFeedbackInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassCreationFeedbackInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassCreationFeedbackInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassCreationFeedbackInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.postMergeSubpassCount !== undefined) this.postMergeSubpassCount = data.postMergeSubpassCount;
    }
  }
  
  get postMergeSubpassCount() {
    return this.#view.getUint32(0, LE);
  }
  
  set postMergeSubpassCount(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
}

export interface InitRenderPassCreationFeedbackCreateInfoEXT {
  pNext?: AnyPointer;
  pRenderPassFeedback?: AnyPointer;
}

export class RenderPassCreationFeedbackCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassCreationFeedbackCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassCreationFeedbackCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassCreationFeedbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassCreationFeedbackCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassCreationFeedbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pRenderPassFeedback !== undefined) this.pRenderPassFeedback = data.pRenderPassFeedback;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pRenderPassFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pRenderPassFeedback(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitRenderPassSubpassFeedbackInfoEXT {
  subpassMergeStatus?: SubpassMergeStatusEXT;
  description?: number[];
  postMergeIndex?: number;
}

export class RenderPassSubpassFeedbackInfoEXT implements BaseStruct {
  static size = 264;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassSubpassFeedbackInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassSubpassFeedbackInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassSubpassFeedbackInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassSubpassFeedbackInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassSubpassFeedbackInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.subpassMergeStatus !== undefined) this.subpassMergeStatus = data.subpassMergeStatus;
      if (data.description !== undefined) this.description = data.description;
      if (data.postMergeIndex !== undefined) this.postMergeIndex = data.postMergeIndex;
    }
  }
  
  get subpassMergeStatus() {
    return this.#view.getUint32(0, LE);
  }
  
  set subpassMergeStatus(value: SubpassMergeStatusEXT) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(4 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(4 + i * 1, Number(value[i]));
    }
  }
  
  get postMergeIndex() {
    return this.#view.getUint32(260, LE);
  }
  
  set postMergeIndex(value: number) {
    this.#view.setUint32(260, Number(value), LE);
  }
}

export interface InitRenderPassSubpassFeedbackCreateInfoEXT {
  pNext?: AnyPointer;
  pSubpassFeedback?: AnyPointer;
}

export class RenderPassSubpassFeedbackCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitRenderPassSubpassFeedbackCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitRenderPassSubpassFeedbackCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(RenderPassSubpassFeedbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < RenderPassSubpassFeedbackCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(RenderPassSubpassFeedbackCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pSubpassFeedback !== undefined) this.pSubpassFeedback = data.pSubpassFeedback;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pSubpassFeedback() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pSubpassFeedback(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
  pNext?: AnyPointer;
  subpassMergeFeedback?: Bool32;
}

export class PhysicalDeviceSubpassMergeFeedbackFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceSubpassMergeFeedbackFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceSubpassMergeFeedbackFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceSubpassMergeFeedbackFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceSubpassMergeFeedbackFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.subpassMergeFeedback !== undefined) this.subpassMergeFeedback = data.subpassMergeFeedback;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get subpassMergeFeedback() {
    return this.#view.getUint32(16, LE);
  }
  
  set subpassMergeFeedback(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitMicromapBuildInfoEXT {
  pNext?: AnyPointer;
  type?: MicromapTypeEXT;
  flags?: BuildMicromapFlagsEXT;
  mode?: BuildMicromapModeEXT;
  dstMicromap?: MicromapEXT;
  usageCountsCount?: number;
  pUsageCounts?: AnyPointer;
  ppUsageCounts?: AnyPointer;
  data?: DeviceOrHostAddressConstKHR;
  scratchData?: DeviceOrHostAddressKHR;
  triangleArray?: DeviceOrHostAddressConstKHR;
  triangleArrayStride?: DeviceSize;
}

export class MicromapBuildInfoEXT implements BaseStruct {
  static size = 96;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapBuildInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapBuildInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapBuildInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapBuildInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapBuildInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.type !== undefined) this.type = data.type;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.mode !== undefined) this.mode = data.mode;
      if (data.dstMicromap !== undefined) this.dstMicromap = data.dstMicromap;
      if (data.usageCountsCount !== undefined) this.usageCountsCount = data.usageCountsCount;
      if (data.pUsageCounts !== undefined) this.pUsageCounts = data.pUsageCounts;
      if (data.ppUsageCounts !== undefined) this.ppUsageCounts = data.ppUsageCounts;
      if (data.data !== undefined) this.data = data.data;
      if (data.scratchData !== undefined) this.scratchData = data.scratchData;
      if (data.triangleArray !== undefined) this.triangleArray = data.triangleArray;
      if (data.triangleArrayStride !== undefined) this.triangleArrayStride = data.triangleArrayStride;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get type() {
    return this.#view.getUint32(16, LE);
  }
  
  set type(value: MicromapTypeEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(20, LE);
  }
  
  set flags(value: BuildMicromapFlagsEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get mode() {
    return this.#view.getUint32(24, LE);
  }
  
  set mode(value: BuildMicromapModeEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get dstMicromap() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set dstMicromap(value: MicromapEXT) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get usageCountsCount() {
    return this.#view.getUint32(40, LE);
  }
  
  set usageCountsCount(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get pUsageCounts() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pUsageCounts(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get ppUsageCounts() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppUsageCounts(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get data() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set data(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get scratchData() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set scratchData(value: DeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get triangleArray() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set triangleArray(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get triangleArrayStride() {
    return this.#view.getBigUint64(88, LE);
  }
  
  set triangleArrayStride(value: DeviceSize) {
    this.#view.setBigUint64(88, BigInt(value), LE);
  }
}

export interface InitMicromapCreateInfoEXT {
  pNext?: AnyPointer;
  createFlags?: MicromapCreateFlagsEXT;
  buffer?: Buffer;
  offset?: DeviceSize;
  size?: DeviceSize;
  type?: MicromapTypeEXT;
  deviceAddress?: DeviceAddress;
}

export class MicromapCreateInfoEXT implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.createFlags !== undefined) this.createFlags = data.createFlags;
      if (data.buffer !== undefined) this.buffer = data.buffer;
      if (data.offset !== undefined) this.offset = data.offset;
      if (data.size !== undefined) this.size = data.size;
      if (data.type !== undefined) this.type = data.type;
      if (data.deviceAddress !== undefined) this.deviceAddress = data.deviceAddress;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get createFlags() {
    return this.#view.getUint32(16, LE);
  }
  
  set createFlags(value: MicromapCreateFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get buffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buffer(value: Buffer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get offset() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set offset(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(40, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(40, BigInt(value), LE);
  }
  
  get type() {
    return this.#view.getUint32(48, LE);
  }
  
  set type(value: MicromapTypeEXT) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get deviceAddress() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set deviceAddress(value: DeviceAddress) {
    this.#view.setBigUint64(56, BigInt(value), LE);
  }
}

export interface InitMicromapVersionInfoEXT {
  pNext?: AnyPointer;
  pVersionData?: AnyPointer;
}

export class MicromapVersionInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapVersionInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapVersionInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapVersionInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapVersionInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapVersionInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pVersionData !== undefined) this.pVersionData = data.pVersionData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pVersionData() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set pVersionData(value: AnyPointer) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitCopyMicromapInfoEXT {
  pNext?: AnyPointer;
  src?: MicromapEXT;
  dst?: MicromapEXT;
  mode?: CopyMicromapModeEXT;
}

export class CopyMicromapInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMicromapInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMicromapInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(CopyMicromapInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMicromapInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMicromapInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: MicromapEXT) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: MicromapEXT) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitCopyMicromapToMemoryInfoEXT {
  pNext?: AnyPointer;
  src?: MicromapEXT;
  dst?: DeviceOrHostAddressKHR;
  mode?: CopyMicromapModeEXT;
}

export class CopyMicromapToMemoryInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMicromapToMemoryInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMicromapToMemoryInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(CopyMicromapToMemoryInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMicromapToMemoryInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMicromapToMemoryInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set src(value: MicromapEXT) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get dst() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set dst(value: DeviceOrHostAddressKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitCopyMemoryToMicromapInfoEXT {
  pNext?: AnyPointer;
  src?: DeviceOrHostAddressConstKHR;
  dst?: MicromapEXT;
  mode?: CopyMicromapModeEXT;
}

export class CopyMemoryToMicromapInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitCopyMemoryToMicromapInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitCopyMemoryToMicromapInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(CopyMemoryToMicromapInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < CopyMemoryToMicromapInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(CopyMemoryToMicromapInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.src !== undefined) this.src = data.src;
      if (data.dst !== undefined) this.dst = data.dst;
      if (data.mode !== undefined) this.mode = data.mode;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get src() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set src(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get dst() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set dst(value: MicromapEXT) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mode() {
    return this.#view.getUint32(32, LE);
  }
  
  set mode(value: CopyMicromapModeEXT) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitMicromapBuildSizesInfoEXT {
  pNext?: AnyPointer;
  micromapSize?: DeviceSize;
  buildScratchSize?: DeviceSize;
  discardable?: Bool32;
}

export class MicromapBuildSizesInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapBuildSizesInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapBuildSizesInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapBuildSizesInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapBuildSizesInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapBuildSizesInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.micromapSize !== undefined) this.micromapSize = data.micromapSize;
      if (data.buildScratchSize !== undefined) this.buildScratchSize = data.buildScratchSize;
      if (data.discardable !== undefined) this.discardable = data.discardable;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get micromapSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set micromapSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get buildScratchSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set buildScratchSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get discardable() {
    return this.#view.getUint32(32, LE);
  }
  
  set discardable(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitMicromapUsageEXT {
  count?: number;
  subdivisionLevel?: number;
  format?: number;
}

export class MicromapUsageEXT implements BaseStruct {
  static size = 12;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapUsageEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapUsageEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapUsageEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapUsageEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapUsageEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.count !== undefined) this.count = data.count;
      if (data.subdivisionLevel !== undefined) this.subdivisionLevel = data.subdivisionLevel;
      if (data.format !== undefined) this.format = data.format;
    }
  }
  
  get count() {
    return this.#view.getUint32(0, LE);
  }
  
  set count(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get subdivisionLevel() {
    return this.#view.getUint32(4, LE);
  }
  
  set subdivisionLevel(value: number) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint32(8, LE);
  }
  
  set format(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
}

export interface InitMicromapTriangleEXT {
  dataOffset?: number;
  subdivisionLevel?: number;
  format?: number;
}

export class MicromapTriangleEXT implements BaseStruct {
  static size = 8;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitMicromapTriangleEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitMicromapTriangleEXT) {
    if (!data) {
      this.#data = new Uint8Array(MicromapTriangleEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < MicromapTriangleEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(MicromapTriangleEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.dataOffset !== undefined) this.dataOffset = data.dataOffset;
      if (data.subdivisionLevel !== undefined) this.subdivisionLevel = data.subdivisionLevel;
      if (data.format !== undefined) this.format = data.format;
    }
  }
  
  get dataOffset() {
    return this.#view.getUint32(0, LE);
  }
  
  set dataOffset(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get subdivisionLevel() {
    return this.#view.getUint16(4, LE);
  }
  
  set subdivisionLevel(value: number) {
    this.#view.setUint16(4, Number(value), LE);
  }
  
  get format() {
    return this.#view.getUint16(6, LE);
  }
  
  set format(value: number) {
    this.#view.setUint16(6, Number(value), LE);
  }
}

export interface InitPhysicalDeviceOpacityMicromapFeaturesEXT {
  pNext?: AnyPointer;
  micromap?: Bool32;
  micromapCaptureReplay?: Bool32;
  micromapHostCommands?: Bool32;
}

export class PhysicalDeviceOpacityMicromapFeaturesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceOpacityMicromapFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceOpacityMicromapFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceOpacityMicromapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceOpacityMicromapFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceOpacityMicromapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.micromap !== undefined) this.micromap = data.micromap;
      if (data.micromapCaptureReplay !== undefined) this.micromapCaptureReplay = data.micromapCaptureReplay;
      if (data.micromapHostCommands !== undefined) this.micromapHostCommands = data.micromapHostCommands;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get micromap() {
    return this.#view.getUint32(16, LE);
  }
  
  set micromap(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get micromapCaptureReplay() {
    return this.#view.getUint32(20, LE);
  }
  
  set micromapCaptureReplay(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get micromapHostCommands() {
    return this.#view.getUint32(24, LE);
  }
  
  set micromapHostCommands(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceOpacityMicromapPropertiesEXT {
  pNext?: AnyPointer;
  maxOpacity2StateSubdivisionLevel?: number;
  maxOpacity4StateSubdivisionLevel?: number;
}

export class PhysicalDeviceOpacityMicromapPropertiesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceOpacityMicromapPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceOpacityMicromapPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceOpacityMicromapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceOpacityMicromapPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceOpacityMicromapPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxOpacity2StateSubdivisionLevel !== undefined) this.maxOpacity2StateSubdivisionLevel = data.maxOpacity2StateSubdivisionLevel;
      if (data.maxOpacity4StateSubdivisionLevel !== undefined) this.maxOpacity4StateSubdivisionLevel = data.maxOpacity4StateSubdivisionLevel;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxOpacity2StateSubdivisionLevel() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxOpacity2StateSubdivisionLevel(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxOpacity4StateSubdivisionLevel() {
    return this.#view.getUint32(20, LE);
  }
  
  set maxOpacity4StateSubdivisionLevel(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitAccelerationStructureTrianglesOpacityMicromapEXT {
  pNext?: AnyPointer;
  indexType?: IndexType;
  indexBuffer?: DeviceOrHostAddressConstKHR;
  indexStride?: DeviceSize;
  baseTriangle?: number;
  usageCountsCount?: number;
  pUsageCounts?: AnyPointer;
  ppUsageCounts?: AnyPointer;
  micromap?: MicromapEXT;
}

export class AccelerationStructureTrianglesOpacityMicromapEXT implements BaseStruct {
  static size = 72;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAccelerationStructureTrianglesOpacityMicromapEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAccelerationStructureTrianglesOpacityMicromapEXT) {
    if (!data) {
      this.#data = new Uint8Array(AccelerationStructureTrianglesOpacityMicromapEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AccelerationStructureTrianglesOpacityMicromapEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AccelerationStructureTrianglesOpacityMicromapEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.indexType !== undefined) this.indexType = data.indexType;
      if (data.indexBuffer !== undefined) this.indexBuffer = data.indexBuffer;
      if (data.indexStride !== undefined) this.indexStride = data.indexStride;
      if (data.baseTriangle !== undefined) this.baseTriangle = data.baseTriangle;
      if (data.usageCountsCount !== undefined) this.usageCountsCount = data.usageCountsCount;
      if (data.pUsageCounts !== undefined) this.pUsageCounts = data.pUsageCounts;
      if (data.ppUsageCounts !== undefined) this.ppUsageCounts = data.ppUsageCounts;
      if (data.micromap !== undefined) this.micromap = data.micromap;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get indexType() {
    return this.#view.getUint32(16, LE);
  }
  
  set indexType(value: IndexType) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get indexBuffer() {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  set indexBuffer(value: DeviceOrHostAddressConstKHR) {
    throw new Error(`Unknown type: {"union":["u64","buffer"]}`);
  }
  
  get indexStride() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set indexStride(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get baseTriangle() {
    return this.#view.getUint32(40, LE);
  }
  
  set baseTriangle(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get usageCountsCount() {
    return this.#view.getUint32(44, LE);
  }
  
  set usageCountsCount(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get pUsageCounts() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set pUsageCounts(value: AnyPointer) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
  
  get ppUsageCounts() {
    return this.#view.getBigUint64(56, LE);
  }
  
  set ppUsageCounts(value: AnyPointer) {
    this.#view.setBigUint64(56, BigInt(anyPointer(value)), LE);
  }
  
  get micromap() {
    return this.#view.getBigUint64(64, LE);
  }
  
  set micromap(value: MicromapEXT) {
    this.#view.setBigUint64(64, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPipelinePropertiesIdentifierEXT {
  pNext?: AnyPointer;
  pipelineIdentifier?: number[];
}

export class PipelinePropertiesIdentifierEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelinePropertiesIdentifierEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelinePropertiesIdentifierEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelinePropertiesIdentifierEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelinePropertiesIdentifierEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelinePropertiesIdentifierEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineIdentifier !== undefined) this.pipelineIdentifier = data.pipelineIdentifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineIdentifier() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set pipelineIdentifier(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
}

export interface InitPhysicalDevicePipelinePropertiesFeaturesEXT {
  pNext?: AnyPointer;
  pipelinePropertiesIdentifier?: Bool32;
}

export class PhysicalDevicePipelinePropertiesFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelinePropertiesFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelinePropertiesFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelinePropertiesFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelinePropertiesFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelinePropertiesFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelinePropertiesIdentifier !== undefined) this.pipelinePropertiesIdentifier = data.pipelinePropertiesIdentifier;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelinePropertiesIdentifier() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelinePropertiesIdentifier(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
  pNext?: AnyPointer;
  shaderEarlyAndLateFragmentTests?: Bool32;
}

export class PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderEarlyAndLateFragmentTests !== undefined) this.shaderEarlyAndLateFragmentTests = data.shaderEarlyAndLateFragmentTests;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderEarlyAndLateFragmentTests() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderEarlyAndLateFragmentTests(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExportMetalObjectCreateInfoEXT {
  pNext?: AnyPointer;
  exportObjectType?: ExportMetalObjectTypeFlagBitsEXT;
}

export class ExportMetalObjectCreateInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalObjectCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalObjectCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalObjectCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalObjectCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalObjectCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.exportObjectType !== undefined) this.exportObjectType = data.exportObjectType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get exportObjectType() {
    return this.#view.getUint32(16, LE);
  }
  
  set exportObjectType(value: ExportMetalObjectTypeFlagBitsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitExportMetalObjectsInfoEXT {
  pNext?: AnyPointer;
}

export class ExportMetalObjectsInfoEXT implements BaseStruct {
  static size = 16;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalObjectsInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalObjectsInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalObjectsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalObjectsInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalObjectsInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalDeviceInfoEXT {
  pNext?: AnyPointer;
  mtlDevice?: MTLDevice_id;
}

export class ExportMetalDeviceInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalDeviceInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalDeviceInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalDeviceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalDeviceInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalDeviceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mtlDevice !== undefined) this.mtlDevice = data.mtlDevice;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mtlDevice() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlDevice(value: MTLDevice_id) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalCommandQueueInfoEXT {
  pNext?: AnyPointer;
  queue?: Queue;
  mtlCommandQueue?: MTLCommandQueue_id;
}

export class ExportMetalCommandQueueInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalCommandQueueInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalCommandQueueInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalCommandQueueInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalCommandQueueInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalCommandQueueInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.queue !== undefined) this.queue = data.queue;
      if (data.mtlCommandQueue !== undefined) this.mtlCommandQueue = data.mtlCommandQueue;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get queue() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set queue(value: Queue) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get mtlCommandQueue() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlCommandQueue(value: MTLCommandQueue_id) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalBufferInfoEXT {
  pNext?: AnyPointer;
  memory?: DeviceMemory;
  mtlBuffer?: MTLBuffer_id;
}

export class ExportMetalBufferInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalBufferInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalBufferInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalBufferInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalBufferInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalBufferInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.memory !== undefined) this.memory = data.memory;
      if (data.mtlBuffer !== undefined) this.mtlBuffer = data.mtlBuffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get memory() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set memory(value: DeviceMemory) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get mtlBuffer() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlBuffer(value: MTLBuffer_id) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImportMetalBufferInfoEXT {
  pNext?: AnyPointer;
  mtlBuffer?: MTLBuffer_id;
}

export class ImportMetalBufferInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMetalBufferInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMetalBufferInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImportMetalBufferInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMetalBufferInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMetalBufferInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mtlBuffer !== undefined) this.mtlBuffer = data.mtlBuffer;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mtlBuffer() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlBuffer(value: MTLBuffer_id) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalTextureInfoEXT {
  pNext?: AnyPointer;
  image?: Image;
  imageView?: ImageView;
  bufferView?: BufferView;
  plane?: ImageAspectFlagBits;
  mtlTexture?: MTLTexture_id;
}

export class ExportMetalTextureInfoEXT implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalTextureInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalTextureInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalTextureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalTextureInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalTextureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
      if (data.imageView !== undefined) this.imageView = data.imageView;
      if (data.bufferView !== undefined) this.bufferView = data.bufferView;
      if (data.plane !== undefined) this.plane = data.plane;
      if (data.mtlTexture !== undefined) this.mtlTexture = data.mtlTexture;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get imageView() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set imageView(value: ImageView) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get bufferView() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set bufferView(value: BufferView) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
  
  get plane() {
    return this.#view.getUint32(40, LE);
  }
  
  set plane(value: ImageAspectFlagBits) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get mtlTexture() {
    return this.#view.getBigUint64(48, LE);
  }
  
  set mtlTexture(value: MTLTexture_id) {
    this.#view.setBigUint64(48, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImportMetalTextureInfoEXT {
  pNext?: AnyPointer;
  plane?: ImageAspectFlagBits;
  mtlTexture?: MTLTexture_id;
}

export class ImportMetalTextureInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMetalTextureInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMetalTextureInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImportMetalTextureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMetalTextureInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMetalTextureInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.plane !== undefined) this.plane = data.plane;
      if (data.mtlTexture !== undefined) this.mtlTexture = data.mtlTexture;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get plane() {
    return this.#view.getUint32(16, LE);
  }
  
  set plane(value: ImageAspectFlagBits) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get mtlTexture() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set mtlTexture(value: MTLTexture_id) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalIOSurfaceInfoEXT {
  pNext?: AnyPointer;
  image?: Image;
  ioSurface?: IOSurfaceRef;
}

export class ExportMetalIOSurfaceInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalIOSurfaceInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalIOSurfaceInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalIOSurfaceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalIOSurfaceInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalIOSurfaceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.image !== undefined) this.image = data.image;
      if (data.ioSurface !== undefined) this.ioSurface = data.ioSurface;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get image() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set image(value: Image) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get ioSurface() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set ioSurface(value: IOSurfaceRef) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImportMetalIOSurfaceInfoEXT {
  pNext?: AnyPointer;
  ioSurface?: IOSurfaceRef;
}

export class ImportMetalIOSurfaceInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMetalIOSurfaceInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMetalIOSurfaceInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImportMetalIOSurfaceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMetalIOSurfaceInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMetalIOSurfaceInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.ioSurface !== undefined) this.ioSurface = data.ioSurface;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get ioSurface() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set ioSurface(value: IOSurfaceRef) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitExportMetalSharedEventInfoEXT {
  pNext?: AnyPointer;
  semaphore?: Semaphore;
  event?: Event;
  mtlSharedEvent?: MTLSharedEvent_id;
}

export class ExportMetalSharedEventInfoEXT implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitExportMetalSharedEventInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitExportMetalSharedEventInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ExportMetalSharedEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ExportMetalSharedEventInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ExportMetalSharedEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.semaphore !== undefined) this.semaphore = data.semaphore;
      if (data.event !== undefined) this.event = data.event;
      if (data.mtlSharedEvent !== undefined) this.mtlSharedEvent = data.mtlSharedEvent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get semaphore() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set semaphore(value: Semaphore) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
  
  get event() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set event(value: Event) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
  
  get mtlSharedEvent() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set mtlSharedEvent(value: MTLSharedEvent_id) {
    this.#view.setBigUint64(32, BigInt(anyPointer(value)), LE);
  }
}

export interface InitImportMetalSharedEventInfoEXT {
  pNext?: AnyPointer;
  mtlSharedEvent?: MTLSharedEvent_id;
}

export class ImportMetalSharedEventInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImportMetalSharedEventInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImportMetalSharedEventInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(ImportMetalSharedEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImportMetalSharedEventInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImportMetalSharedEventInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.mtlSharedEvent !== undefined) this.mtlSharedEvent = data.mtlSharedEvent;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get mtlSharedEvent() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set mtlSharedEvent(value: MTLSharedEvent_id) {
    this.#view.setBigUint64(16, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
  pNext?: AnyPointer;
  nonSeamlessCubeMap?: Bool32;
}

export class PhysicalDeviceNonSeamlessCubeMapFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceNonSeamlessCubeMapFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceNonSeamlessCubeMapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceNonSeamlessCubeMapFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceNonSeamlessCubeMapFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.nonSeamlessCubeMap !== undefined) this.nonSeamlessCubeMap = data.nonSeamlessCubeMap;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get nonSeamlessCubeMap() {
    return this.#view.getUint32(16, LE);
  }
  
  set nonSeamlessCubeMap(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDevicePipelineRobustnessFeaturesEXT {
  pNext?: AnyPointer;
  pipelineRobustness?: Bool32;
}

export class PhysicalDevicePipelineRobustnessFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelineRobustnessFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelineRobustnessFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelineRobustnessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelineRobustnessFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelineRobustnessFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.pipelineRobustness !== undefined) this.pipelineRobustness = data.pipelineRobustness;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get pipelineRobustness() {
    return this.#view.getUint32(16, LE);
  }
  
  set pipelineRobustness(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPipelineRobustnessCreateInfoEXT {
  pNext?: AnyPointer;
  storageBuffers?: PipelineRobustnessBufferBehaviorEXT;
  uniformBuffers?: PipelineRobustnessBufferBehaviorEXT;
  vertexInputs?: PipelineRobustnessBufferBehaviorEXT;
  images?: PipelineRobustnessImageBehaviorEXT;
}

export class PipelineRobustnessCreateInfoEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPipelineRobustnessCreateInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPipelineRobustnessCreateInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(PipelineRobustnessCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PipelineRobustnessCreateInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PipelineRobustnessCreateInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.storageBuffers !== undefined) this.storageBuffers = data.storageBuffers;
      if (data.uniformBuffers !== undefined) this.uniformBuffers = data.uniformBuffers;
      if (data.vertexInputs !== undefined) this.vertexInputs = data.vertexInputs;
      if (data.images !== undefined) this.images = data.images;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get storageBuffers() {
    return this.#view.getUint32(16, LE);
  }
  
  set storageBuffers(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get uniformBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set uniformBuffers(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vertexInputs() {
    return this.#view.getUint32(24, LE);
  }
  
  set vertexInputs(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get images() {
    return this.#view.getUint32(28, LE);
  }
  
  set images(value: PipelineRobustnessImageBehaviorEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDevicePipelineRobustnessPropertiesEXT {
  pNext?: AnyPointer;
  defaultRobustnessStorageBuffers?: PipelineRobustnessBufferBehaviorEXT;
  defaultRobustnessUniformBuffers?: PipelineRobustnessBufferBehaviorEXT;
  defaultRobustnessVertexInputs?: PipelineRobustnessBufferBehaviorEXT;
  defaultRobustnessImages?: PipelineRobustnessImageBehaviorEXT;
}

export class PhysicalDevicePipelineRobustnessPropertiesEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDevicePipelineRobustnessPropertiesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDevicePipelineRobustnessPropertiesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDevicePipelineRobustnessPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDevicePipelineRobustnessPropertiesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDevicePipelineRobustnessPropertiesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.defaultRobustnessStorageBuffers !== undefined) this.defaultRobustnessStorageBuffers = data.defaultRobustnessStorageBuffers;
      if (data.defaultRobustnessUniformBuffers !== undefined) this.defaultRobustnessUniformBuffers = data.defaultRobustnessUniformBuffers;
      if (data.defaultRobustnessVertexInputs !== undefined) this.defaultRobustnessVertexInputs = data.defaultRobustnessVertexInputs;
      if (data.defaultRobustnessImages !== undefined) this.defaultRobustnessImages = data.defaultRobustnessImages;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get defaultRobustnessStorageBuffers() {
    return this.#view.getUint32(16, LE);
  }
  
  set defaultRobustnessStorageBuffers(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get defaultRobustnessUniformBuffers() {
    return this.#view.getUint32(20, LE);
  }
  
  set defaultRobustnessUniformBuffers(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get defaultRobustnessVertexInputs() {
    return this.#view.getUint32(24, LE);
  }
  
  set defaultRobustnessVertexInputs(value: PipelineRobustnessBufferBehaviorEXT) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get defaultRobustnessImages() {
    return this.#view.getUint32(28, LE);
  }
  
  set defaultRobustnessImages(value: PipelineRobustnessImageBehaviorEXT) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitImageViewSampleWeightCreateInfoQCOM {
  pNext?: AnyPointer;
  filterCenter?: Offset2D;
  filterSize?: Extent2D;
  numPhases?: number;
}

export class ImageViewSampleWeightCreateInfoQCOM implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitImageViewSampleWeightCreateInfoQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitImageViewSampleWeightCreateInfoQCOM) {
    if (!data) {
      this.#data = new Uint8Array(ImageViewSampleWeightCreateInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < ImageViewSampleWeightCreateInfoQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(ImageViewSampleWeightCreateInfoQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.filterCenter !== undefined) this.filterCenter = data.filterCenter;
      if (data.filterSize !== undefined) this.filterSize = data.filterSize;
      if (data.numPhases !== undefined) this.numPhases = data.numPhases;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get filterCenter() {
    return new Offset2D(this.#data.subarray(16, 16 + Offset2D.size));
  }
  
  set filterCenter(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get filterSize() {
    return new Extent2D(this.#data.subarray(24, 24 + Extent2D.size));
  }
  
  set filterSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 24);
  }
  
  get numPhases() {
    return this.#view.getUint32(32, LE);
  }
  
  set numPhases(value: number) {
    this.#view.setUint32(32, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImageProcessingFeaturesQCOM {
  pNext?: AnyPointer;
  textureSampleWeighted?: Bool32;
  textureBoxFilter?: Bool32;
  textureBlockMatch?: Bool32;
}

export class PhysicalDeviceImageProcessingFeaturesQCOM implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageProcessingFeaturesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageProcessingFeaturesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageProcessingFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageProcessingFeaturesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageProcessingFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.textureSampleWeighted !== undefined) this.textureSampleWeighted = data.textureSampleWeighted;
      if (data.textureBoxFilter !== undefined) this.textureBoxFilter = data.textureBoxFilter;
      if (data.textureBlockMatch !== undefined) this.textureBlockMatch = data.textureBlockMatch;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get textureSampleWeighted() {
    return this.#view.getUint32(16, LE);
  }
  
  set textureSampleWeighted(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get textureBoxFilter() {
    return this.#view.getUint32(20, LE);
  }
  
  set textureBoxFilter(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get textureBlockMatch() {
    return this.#view.getUint32(24, LE);
  }
  
  set textureBlockMatch(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
}

export interface InitPhysicalDeviceImageProcessingPropertiesQCOM {
  pNext?: AnyPointer;
  maxWeightFilterPhases?: number;
  maxWeightFilterDimension?: Extent2D;
  maxBlockMatchRegion?: Extent2D;
  maxBoxFilterBlockSize?: Extent2D;
}

export class PhysicalDeviceImageProcessingPropertiesQCOM implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceImageProcessingPropertiesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceImageProcessingPropertiesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceImageProcessingPropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceImageProcessingPropertiesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceImageProcessingPropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.maxWeightFilterPhases !== undefined) this.maxWeightFilterPhases = data.maxWeightFilterPhases;
      if (data.maxWeightFilterDimension !== undefined) this.maxWeightFilterDimension = data.maxWeightFilterDimension;
      if (data.maxBlockMatchRegion !== undefined) this.maxBlockMatchRegion = data.maxBlockMatchRegion;
      if (data.maxBoxFilterBlockSize !== undefined) this.maxBoxFilterBlockSize = data.maxBoxFilterBlockSize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get maxWeightFilterPhases() {
    return this.#view.getUint32(16, LE);
  }
  
  set maxWeightFilterPhases(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get maxWeightFilterDimension() {
    return new Extent2D(this.#data.subarray(20, 20 + Extent2D.size));
  }
  
  set maxWeightFilterDimension(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 20);
  }
  
  get maxBlockMatchRegion() {
    return new Extent2D(this.#data.subarray(28, 28 + Extent2D.size));
  }
  
  set maxBlockMatchRegion(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get maxBoxFilterBlockSize() {
    return new Extent2D(this.#data.subarray(36, 36 + Extent2D.size));
  }
  
  set maxBoxFilterBlockSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
}

export interface InitPhysicalDeviceTilePropertiesFeaturesQCOM {
  pNext?: AnyPointer;
  tileProperties?: Bool32;
}

export class PhysicalDeviceTilePropertiesFeaturesQCOM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceTilePropertiesFeaturesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceTilePropertiesFeaturesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceTilePropertiesFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceTilePropertiesFeaturesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceTilePropertiesFeaturesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.tileProperties !== undefined) this.tileProperties = data.tileProperties;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get tileProperties() {
    return this.#view.getUint32(16, LE);
  }
  
  set tileProperties(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitTilePropertiesQCOM {
  pNext?: AnyPointer;
  tileSize?: Extent3D;
  apronSize?: Extent2D;
  origin?: Offset2D;
}

export class TilePropertiesQCOM implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitTilePropertiesQCOM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitTilePropertiesQCOM) {
    if (!data) {
      this.#data = new Uint8Array(TilePropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < TilePropertiesQCOM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(TilePropertiesQCOM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_TILE_PROPERTIES_QCOM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.tileSize !== undefined) this.tileSize = data.tileSize;
      if (data.apronSize !== undefined) this.apronSize = data.apronSize;
      if (data.origin !== undefined) this.origin = data.origin;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get tileSize() {
    return new Extent3D(this.#data.subarray(16, 16 + Extent3D.size));
  }
  
  set tileSize(value: Extent3D) {
    if (value[BUFFER].byteLength < Extent3D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 16);
  }
  
  get apronSize() {
    return new Extent2D(this.#data.subarray(28, 28 + Extent2D.size));
  }
  
  set apronSize(value: Extent2D) {
    if (value[BUFFER].byteLength < Extent2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 28);
  }
  
  get origin() {
    return new Offset2D(this.#data.subarray(36, 36 + Offset2D.size));
  }
  
  set origin(value: Offset2D) {
    if (value[BUFFER].byteLength < Offset2D.size) {
      throw new Error("Data buffer too small");
    }
    this.#data.set(value[BUFFER], 36);
  }
}

export interface InitPhysicalDeviceAmigoProfilingFeaturesSEC {
  pNext?: AnyPointer;
  amigoProfiling?: Bool32;
}

export class PhysicalDeviceAmigoProfilingFeaturesSEC implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceAmigoProfilingFeaturesSEC);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceAmigoProfilingFeaturesSEC) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceAmigoProfilingFeaturesSEC.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceAmigoProfilingFeaturesSEC.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceAmigoProfilingFeaturesSEC.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.amigoProfiling !== undefined) this.amigoProfiling = data.amigoProfiling;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get amigoProfiling() {
    return this.#view.getUint32(16, LE);
  }
  
  set amigoProfiling(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitAmigoProfilingSubmitInfoSEC {
  pNext?: AnyPointer;
  firstDrawTimestamp?: Deno.PointerValue;
  swapBufferTimestamp?: Deno.PointerValue;
}

export class AmigoProfilingSubmitInfoSEC implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitAmigoProfilingSubmitInfoSEC);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitAmigoProfilingSubmitInfoSEC) {
    if (!data) {
      this.#data = new Uint8Array(AmigoProfilingSubmitInfoSEC.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < AmigoProfilingSubmitInfoSEC.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(AmigoProfilingSubmitInfoSEC.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.firstDrawTimestamp !== undefined) this.firstDrawTimestamp = data.firstDrawTimestamp;
      if (data.swapBufferTimestamp !== undefined) this.swapBufferTimestamp = data.swapBufferTimestamp;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get firstDrawTimestamp() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set firstDrawTimestamp(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get swapBufferTimestamp() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set swapBufferTimestamp(value: Deno.PointerValue) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
  pNext?: AnyPointer;
  attachmentFeedbackLoopLayout?: Bool32;
}

export class PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.attachmentFeedbackLoopLayout !== undefined) this.attachmentFeedbackLoopLayout = data.attachmentFeedbackLoopLayout;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get attachmentFeedbackLoopLayout() {
    return this.#view.getUint32(16, LE);
  }
  
  set attachmentFeedbackLoopLayout(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceDepthClampZeroOneFeaturesEXT {
  pNext?: AnyPointer;
  depthClampZeroOne?: Bool32;
}

export class PhysicalDeviceDepthClampZeroOneFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceDepthClampZeroOneFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceDepthClampZeroOneFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceDepthClampZeroOneFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceDepthClampZeroOneFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceDepthClampZeroOneFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.depthClampZeroOne !== undefined) this.depthClampZeroOne = data.depthClampZeroOne;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get depthClampZeroOne() {
    return this.#view.getUint32(16, LE);
  }
  
  set depthClampZeroOne(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceAddressBindingReportFeaturesEXT {
  pNext?: AnyPointer;
  reportAddressBinding?: Bool32;
}

export class PhysicalDeviceAddressBindingReportFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceAddressBindingReportFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceAddressBindingReportFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceAddressBindingReportFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceAddressBindingReportFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceAddressBindingReportFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.reportAddressBinding !== undefined) this.reportAddressBinding = data.reportAddressBinding;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get reportAddressBinding() {
    return this.#view.getUint32(16, LE);
  }
  
  set reportAddressBinding(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitDeviceAddressBindingCallbackDataEXT {
  pNext?: AnyPointer;
  flags?: DeviceAddressBindingFlagsEXT;
  baseAddress?: DeviceAddress;
  size?: DeviceSize;
  bindingType?: DeviceAddressBindingTypeEXT;
}

export class DeviceAddressBindingCallbackDataEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceAddressBindingCallbackDataEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceAddressBindingCallbackDataEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceAddressBindingCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceAddressBindingCallbackDataEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceAddressBindingCallbackDataEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.baseAddress !== undefined) this.baseAddress = data.baseAddress;
      if (data.size !== undefined) this.size = data.size;
      if (data.bindingType !== undefined) this.bindingType = data.bindingType;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: DeviceAddressBindingFlagsEXT) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get baseAddress() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set baseAddress(value: DeviceAddress) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get size() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set size(value: DeviceSize) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
  
  get bindingType() {
    return this.#view.getUint32(40, LE);
  }
  
  set bindingType(value: DeviceAddressBindingTypeEXT) {
    this.#view.setUint32(40, Number(value), LE);
  }
}

export interface InitPhysicalDeviceOpticalFlowFeaturesNV {
  pNext?: AnyPointer;
  opticalFlow?: Bool32;
}

export class PhysicalDeviceOpticalFlowFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceOpticalFlowFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceOpticalFlowFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceOpticalFlowFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceOpticalFlowFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceOpticalFlowFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.opticalFlow !== undefined) this.opticalFlow = data.opticalFlow;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get opticalFlow() {
    return this.#view.getUint32(16, LE);
  }
  
  set opticalFlow(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceOpticalFlowPropertiesNV {
  pNext?: AnyPointer;
  supportedOutputGridSizes?: OpticalFlowGridSizeFlagsNV;
  supportedHintGridSizes?: OpticalFlowGridSizeFlagsNV;
  hintSupported?: Bool32;
  costSupported?: Bool32;
  bidirectionalFlowSupported?: Bool32;
  globalFlowSupported?: Bool32;
  minWidth?: number;
  minHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
  maxNumRegionsOfInterest?: number;
}

export class PhysicalDeviceOpticalFlowPropertiesNV implements BaseStruct {
  static size = 64;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceOpticalFlowPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceOpticalFlowPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceOpticalFlowPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceOpticalFlowPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceOpticalFlowPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.supportedOutputGridSizes !== undefined) this.supportedOutputGridSizes = data.supportedOutputGridSizes;
      if (data.supportedHintGridSizes !== undefined) this.supportedHintGridSizes = data.supportedHintGridSizes;
      if (data.hintSupported !== undefined) this.hintSupported = data.hintSupported;
      if (data.costSupported !== undefined) this.costSupported = data.costSupported;
      if (data.bidirectionalFlowSupported !== undefined) this.bidirectionalFlowSupported = data.bidirectionalFlowSupported;
      if (data.globalFlowSupported !== undefined) this.globalFlowSupported = data.globalFlowSupported;
      if (data.minWidth !== undefined) this.minWidth = data.minWidth;
      if (data.minHeight !== undefined) this.minHeight = data.minHeight;
      if (data.maxWidth !== undefined) this.maxWidth = data.maxWidth;
      if (data.maxHeight !== undefined) this.maxHeight = data.maxHeight;
      if (data.maxNumRegionsOfInterest !== undefined) this.maxNumRegionsOfInterest = data.maxNumRegionsOfInterest;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get supportedOutputGridSizes() {
    return this.#view.getUint32(16, LE);
  }
  
  set supportedOutputGridSizes(value: OpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get supportedHintGridSizes() {
    return this.#view.getUint32(20, LE);
  }
  
  set supportedHintGridSizes(value: OpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get hintSupported() {
    return this.#view.getUint32(24, LE);
  }
  
  set hintSupported(value: Bool32) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get costSupported() {
    return this.#view.getUint32(28, LE);
  }
  
  set costSupported(value: Bool32) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get bidirectionalFlowSupported() {
    return this.#view.getUint32(32, LE);
  }
  
  set bidirectionalFlowSupported(value: Bool32) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get globalFlowSupported() {
    return this.#view.getUint32(36, LE);
  }
  
  set globalFlowSupported(value: Bool32) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get minWidth() {
    return this.#view.getUint32(40, LE);
  }
  
  set minWidth(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get minHeight() {
    return this.#view.getUint32(44, LE);
  }
  
  set minHeight(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get maxWidth() {
    return this.#view.getUint32(48, LE);
  }
  
  set maxWidth(value: number) {
    this.#view.setUint32(48, Number(value), LE);
  }
  
  get maxHeight() {
    return this.#view.getUint32(52, LE);
  }
  
  set maxHeight(value: number) {
    this.#view.setUint32(52, Number(value), LE);
  }
  
  get maxNumRegionsOfInterest() {
    return this.#view.getUint32(56, LE);
  }
  
  set maxNumRegionsOfInterest(value: number) {
    this.#view.setUint32(56, Number(value), LE);
  }
}

export interface InitOpticalFlowImageFormatInfoNV {
  pNext?: AnyPointer;
  usage?: OpticalFlowUsageFlagsNV;
}

export class OpticalFlowImageFormatInfoNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpticalFlowImageFormatInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpticalFlowImageFormatInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(OpticalFlowImageFormatInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpticalFlowImageFormatInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpticalFlowImageFormatInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.usage !== undefined) this.usage = data.usage;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get usage() {
    return this.#view.getUint32(16, LE);
  }
  
  set usage(value: OpticalFlowUsageFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitOpticalFlowImageFormatPropertiesNV {
  pNext?: AnyPointer;
  format?: Format;
}

export class OpticalFlowImageFormatPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpticalFlowImageFormatPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpticalFlowImageFormatPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(OpticalFlowImageFormatPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpticalFlowImageFormatPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpticalFlowImageFormatPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.format !== undefined) this.format = data.format;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get format() {
    return this.#view.getUint32(16, LE);
  }
  
  set format(value: Format) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitOpticalFlowSessionCreateInfoNV {
  pNext?: AnyPointer;
  width?: number;
  height?: number;
  imageFormat?: Format;
  flowVectorFormat?: Format;
  costFormat?: Format;
  outputGridSize?: OpticalFlowGridSizeFlagsNV;
  hintGridSize?: OpticalFlowGridSizeFlagsNV;
  performanceLevel?: OpticalFlowPerformanceLevelNV;
  flags?: OpticalFlowSessionCreateFlagsNV;
}

export class OpticalFlowSessionCreateInfoNV implements BaseStruct {
  static size = 56;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpticalFlowSessionCreateInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpticalFlowSessionCreateInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(OpticalFlowSessionCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpticalFlowSessionCreateInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpticalFlowSessionCreateInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.width !== undefined) this.width = data.width;
      if (data.height !== undefined) this.height = data.height;
      if (data.imageFormat !== undefined) this.imageFormat = data.imageFormat;
      if (data.flowVectorFormat !== undefined) this.flowVectorFormat = data.flowVectorFormat;
      if (data.costFormat !== undefined) this.costFormat = data.costFormat;
      if (data.outputGridSize !== undefined) this.outputGridSize = data.outputGridSize;
      if (data.hintGridSize !== undefined) this.hintGridSize = data.hintGridSize;
      if (data.performanceLevel !== undefined) this.performanceLevel = data.performanceLevel;
      if (data.flags !== undefined) this.flags = data.flags;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get width() {
    return this.#view.getUint32(16, LE);
  }
  
  set width(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get height() {
    return this.#view.getUint32(20, LE);
  }
  
  set height(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get imageFormat() {
    return this.#view.getUint32(24, LE);
  }
  
  set imageFormat(value: Format) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get flowVectorFormat() {
    return this.#view.getUint32(28, LE);
  }
  
  set flowVectorFormat(value: Format) {
    this.#view.setUint32(28, Number(value), LE);
  }
  
  get costFormat() {
    return this.#view.getUint32(32, LE);
  }
  
  set costFormat(value: Format) {
    this.#view.setUint32(32, Number(value), LE);
  }
  
  get outputGridSize() {
    return this.#view.getUint32(36, LE);
  }
  
  set outputGridSize(value: OpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get hintGridSize() {
    return this.#view.getUint32(40, LE);
  }
  
  set hintGridSize(value: OpticalFlowGridSizeFlagsNV) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get performanceLevel() {
    return this.#view.getUint32(44, LE);
  }
  
  set performanceLevel(value: OpticalFlowPerformanceLevelNV) {
    this.#view.setUint32(44, Number(value), LE);
  }
  
  get flags() {
    return this.#view.getUint32(48, LE);
  }
  
  set flags(value: OpticalFlowSessionCreateFlagsNV) {
    this.#view.setUint32(48, Number(value), LE);
  }
}

export interface InitOpticalFlowSessionCreatePrivateDataInfoNV {
  pNext?: AnyPointer;
  id?: number;
  size?: number;
  pPrivateData?: AnyPointer;
}

export class OpticalFlowSessionCreatePrivateDataInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpticalFlowSessionCreatePrivateDataInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpticalFlowSessionCreatePrivateDataInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(OpticalFlowSessionCreatePrivateDataInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpticalFlowSessionCreatePrivateDataInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpticalFlowSessionCreatePrivateDataInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.id !== undefined) this.id = data.id;
      if (data.size !== undefined) this.size = data.size;
      if (data.pPrivateData !== undefined) this.pPrivateData = data.pPrivateData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get id() {
    return this.#view.getUint32(16, LE);
  }
  
  set id(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get size() {
    return this.#view.getUint32(20, LE);
  }
  
  set size(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pPrivateData() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pPrivateData(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitOpticalFlowExecuteInfoNV {
  pNext?: AnyPointer;
  flags?: OpticalFlowExecuteFlagsNV;
  regionCount?: number;
  pRegions?: AnyPointer;
}

export class OpticalFlowExecuteInfoNV implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitOpticalFlowExecuteInfoNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitOpticalFlowExecuteInfoNV) {
    if (!data) {
      this.#data = new Uint8Array(OpticalFlowExecuteInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < OpticalFlowExecuteInfoNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(OpticalFlowExecuteInfoNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.flags !== undefined) this.flags = data.flags;
      if (data.regionCount !== undefined) this.regionCount = data.regionCount;
      if (data.pRegions !== undefined) this.pRegions = data.pRegions;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get flags() {
    return this.#view.getUint32(16, LE);
  }
  
  set flags(value: OpticalFlowExecuteFlagsNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get regionCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set regionCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get pRegions() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set pRegions(value: AnyPointer) {
    this.#view.setBigUint64(24, BigInt(anyPointer(value)), LE);
  }
}

export interface InitPhysicalDeviceFaultFeaturesEXT {
  pNext?: AnyPointer;
  deviceFault?: Bool32;
  deviceFaultVendorBinary?: Bool32;
}

export class PhysicalDeviceFaultFeaturesEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceFaultFeaturesEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceFaultFeaturesEXT) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceFaultFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceFaultFeaturesEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceFaultFeaturesEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.deviceFault !== undefined) this.deviceFault = data.deviceFault;
      if (data.deviceFaultVendorBinary !== undefined) this.deviceFaultVendorBinary = data.deviceFaultVendorBinary;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get deviceFault() {
    return this.#view.getUint32(16, LE);
  }
  
  set deviceFault(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get deviceFaultVendorBinary() {
    return this.#view.getUint32(20, LE);
  }
  
  set deviceFaultVendorBinary(value: Bool32) {
    this.#view.setUint32(20, Number(value), LE);
  }
}

export interface InitDeviceFaultAddressInfoEXT {
  addressType?: DeviceFaultAddressTypeEXT;
  reportedAddress?: DeviceAddress;
  addressPrecision?: DeviceSize;
}

export class DeviceFaultAddressInfoEXT implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceFaultAddressInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceFaultAddressInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceFaultAddressInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceFaultAddressInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceFaultAddressInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.addressType !== undefined) this.addressType = data.addressType;
      if (data.reportedAddress !== undefined) this.reportedAddress = data.reportedAddress;
      if (data.addressPrecision !== undefined) this.addressPrecision = data.addressPrecision;
    }
  }
  
  get addressType() {
    return this.#view.getUint32(0, LE);
  }
  
  set addressType(value: DeviceFaultAddressTypeEXT) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get reportedAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set reportedAddress(value: DeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get addressPrecision() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set addressPrecision(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
}

export interface InitDeviceFaultVendorInfoEXT {
  description?: number[];
  vendorFaultCode?: Deno.PointerValue;
  vendorFaultData?: Deno.PointerValue;
}

export class DeviceFaultVendorInfoEXT implements BaseStruct {
  static size = 272;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceFaultVendorInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceFaultVendorInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceFaultVendorInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceFaultVendorInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceFaultVendorInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.description !== undefined) this.description = data.description;
      if (data.vendorFaultCode !== undefined) this.vendorFaultCode = data.vendorFaultCode;
      if (data.vendorFaultData !== undefined) this.vendorFaultData = data.vendorFaultData;
    }
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(0 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(0 + i * 1, Number(value[i]));
    }
  }
  
  get vendorFaultCode() {
    return this.#view.getBigUint64(256, LE);
  }
  
  set vendorFaultCode(value: Deno.PointerValue) {
    this.#view.setBigUint64(256, BigInt(value), LE);
  }
  
  get vendorFaultData() {
    return this.#view.getBigUint64(264, LE);
  }
  
  set vendorFaultData(value: Deno.PointerValue) {
    this.#view.setBigUint64(264, BigInt(value), LE);
  }
}

export interface InitDeviceFaultCountsEXT {
  pNext?: AnyPointer;
  addressInfoCount?: number;
  vendorInfoCount?: number;
  vendorBinarySize?: DeviceSize;
}

export class DeviceFaultCountsEXT implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceFaultCountsEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceFaultCountsEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceFaultCountsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceFaultCountsEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceFaultCountsEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.addressInfoCount !== undefined) this.addressInfoCount = data.addressInfoCount;
      if (data.vendorInfoCount !== undefined) this.vendorInfoCount = data.vendorInfoCount;
      if (data.vendorBinarySize !== undefined) this.vendorBinarySize = data.vendorBinarySize;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get addressInfoCount() {
    return this.#view.getUint32(16, LE);
  }
  
  set addressInfoCount(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get vendorInfoCount() {
    return this.#view.getUint32(20, LE);
  }
  
  set vendorInfoCount(value: number) {
    this.#view.setUint32(20, Number(value), LE);
  }
  
  get vendorBinarySize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set vendorBinarySize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
}

export interface InitDeviceFaultInfoEXT {
  pNext?: AnyPointer;
  description?: number[];
  pAddressInfos?: AnyPointer;
  pVendorInfos?: AnyPointer;
  pVendorBinaryData?: AnyPointer;
}

export class DeviceFaultInfoEXT implements BaseStruct {
  static size = 296;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceFaultInfoEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceFaultInfoEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceFaultInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceFaultInfoEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceFaultInfoEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.description !== undefined) this.description = data.description;
      if (data.pAddressInfos !== undefined) this.pAddressInfos = data.pAddressInfos;
      if (data.pVendorInfos !== undefined) this.pVendorInfos = data.pVendorInfos;
      if (data.pVendorBinaryData !== undefined) this.pVendorBinaryData = data.pVendorBinaryData;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get description() {
    const result: number[] = [];
    for (let i = 0; i < 256; i++) {
      result.push((() => {
        return this.#view.getUint8(16 + i * 1);
      })());
    }
    return result;
  }
  
  set description(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(16 + i * 1, Number(value[i]));
    }
  }
  
  get pAddressInfos() {
    return this.#view.getBigUint64(272, LE);
  }
  
  set pAddressInfos(value: AnyPointer) {
    this.#view.setBigUint64(272, BigInt(anyPointer(value)), LE);
  }
  
  get pVendorInfos() {
    return this.#view.getBigUint64(280, LE);
  }
  
  set pVendorInfos(value: AnyPointer) {
    this.#view.setBigUint64(280, BigInt(anyPointer(value)), LE);
  }
  
  get pVendorBinaryData() {
    return this.#view.getBigUint64(288, LE);
  }
  
  set pVendorBinaryData(value: AnyPointer) {
    this.#view.setBigUint64(288, BigInt(anyPointer(value)), LE);
  }
}

export interface InitDeviceFaultVendorBinaryHeaderVersionOneEXT {
  headerSize?: number;
  headerVersion?: DeviceFaultVendorBinaryHeaderVersionEXT;
  vendorID?: number;
  deviceID?: number;
  driverVersion?: number;
  pipelineCacheUUID?: number[];
  applicationNameOffset?: number;
  applicationVersion?: number;
  engineNameOffset?: number;
}

export class DeviceFaultVendorBinaryHeaderVersionOneEXT implements BaseStruct {
  static size = 48;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDeviceFaultVendorBinaryHeaderVersionOneEXT);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDeviceFaultVendorBinaryHeaderVersionOneEXT) {
    if (!data) {
      this.#data = new Uint8Array(DeviceFaultVendorBinaryHeaderVersionOneEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DeviceFaultVendorBinaryHeaderVersionOneEXT.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DeviceFaultVendorBinaryHeaderVersionOneEXT.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.headerSize !== undefined) this.headerSize = data.headerSize;
      if (data.headerVersion !== undefined) this.headerVersion = data.headerVersion;
      if (data.vendorID !== undefined) this.vendorID = data.vendorID;
      if (data.deviceID !== undefined) this.deviceID = data.deviceID;
      if (data.driverVersion !== undefined) this.driverVersion = data.driverVersion;
      if (data.pipelineCacheUUID !== undefined) this.pipelineCacheUUID = data.pipelineCacheUUID;
      if (data.applicationNameOffset !== undefined) this.applicationNameOffset = data.applicationNameOffset;
      if (data.applicationVersion !== undefined) this.applicationVersion = data.applicationVersion;
      if (data.engineNameOffset !== undefined) this.engineNameOffset = data.engineNameOffset;
    }
  }
  
  get headerSize() {
    return this.#view.getUint32(0, LE);
  }
  
  set headerSize(value: number) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get headerVersion() {
    return this.#view.getUint32(4, LE);
  }
  
  set headerVersion(value: DeviceFaultVendorBinaryHeaderVersionEXT) {
    this.#view.setUint32(4, Number(value), LE);
  }
  
  get vendorID() {
    return this.#view.getUint32(8, LE);
  }
  
  set vendorID(value: number) {
    this.#view.setUint32(8, Number(value), LE);
  }
  
  get deviceID() {
    return this.#view.getUint32(12, LE);
  }
  
  set deviceID(value: number) {
    this.#view.setUint32(12, Number(value), LE);
  }
  
  get driverVersion() {
    return this.#view.getUint32(16, LE);
  }
  
  set driverVersion(value: number) {
    this.#view.setUint32(16, Number(value), LE);
  }
  
  get pipelineCacheUUID() {
    const result: number[] = [];
    for (let i = 0; i < 16; i++) {
      result.push((() => {
        return this.#view.getUint8(20 + i * 1);
      })());
    }
    return result;
  }
  
  set pipelineCacheUUID(value: number[]) {
    for (let i = 0; i < value.length; i++) {
      this.#view.setUint8(20 + i * 1, Number(value[i]));
    }
  }
  
  get applicationNameOffset() {
    return this.#view.getUint32(36, LE);
  }
  
  set applicationNameOffset(value: number) {
    this.#view.setUint32(36, Number(value), LE);
  }
  
  get applicationVersion() {
    return this.#view.getUint32(40, LE);
  }
  
  set applicationVersion(value: number) {
    this.#view.setUint32(40, Number(value), LE);
  }
  
  get engineNameOffset() {
    return this.#view.getUint32(44, LE);
  }
  
  set engineNameOffset(value: number) {
    this.#view.setUint32(44, Number(value), LE);
  }
}

export interface InitDecompressMemoryRegionNV {
  srcAddress?: DeviceAddress;
  dstAddress?: DeviceAddress;
  compressedSize?: DeviceSize;
  decompressedSize?: DeviceSize;
  decompressionMethod?: MemoryDecompressionMethodFlagsNV;
}

export class DecompressMemoryRegionNV implements BaseStruct {
  static size = 40;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitDecompressMemoryRegionNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitDecompressMemoryRegionNV) {
    if (!data) {
      this.#data = new Uint8Array(DecompressMemoryRegionNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < DecompressMemoryRegionNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(DecompressMemoryRegionNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      if (data.srcAddress !== undefined) this.srcAddress = data.srcAddress;
      if (data.dstAddress !== undefined) this.dstAddress = data.dstAddress;
      if (data.compressedSize !== undefined) this.compressedSize = data.compressedSize;
      if (data.decompressedSize !== undefined) this.decompressedSize = data.decompressedSize;
      if (data.decompressionMethod !== undefined) this.decompressionMethod = data.decompressionMethod;
    }
  }
  
  get srcAddress() {
    return this.#view.getBigUint64(0, LE);
  }
  
  set srcAddress(value: DeviceAddress) {
    this.#view.setBigUint64(0, BigInt(value), LE);
  }
  
  get dstAddress() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set dstAddress(value: DeviceAddress) {
    this.#view.setBigUint64(8, BigInt(value), LE);
  }
  
  get compressedSize() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set compressedSize(value: DeviceSize) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get decompressedSize() {
    return this.#view.getBigUint64(24, LE);
  }
  
  set decompressedSize(value: DeviceSize) {
    this.#view.setBigUint64(24, BigInt(value), LE);
  }
  
  get decompressionMethod() {
    return this.#view.getBigUint64(32, LE);
  }
  
  set decompressionMethod(value: MemoryDecompressionMethodFlagsNV) {
    this.#view.setBigUint64(32, BigInt(value), LE);
  }
}

export interface InitPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
  pNext?: AnyPointer;
  shaderCoreMask?: Deno.PointerValue;
  shaderCoreCount?: number;
  shaderWarpsPerCore?: number;
}

export class PhysicalDeviceShaderCoreBuiltinsPropertiesARM implements BaseStruct {
  static size = 32;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderCoreBuiltinsPropertiesARM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderCoreBuiltinsPropertiesARM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreBuiltinsPropertiesARM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderCoreBuiltinsPropertiesARM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreBuiltinsPropertiesARM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderCoreMask !== undefined) this.shaderCoreMask = data.shaderCoreMask;
      if (data.shaderCoreCount !== undefined) this.shaderCoreCount = data.shaderCoreCount;
      if (data.shaderWarpsPerCore !== undefined) this.shaderWarpsPerCore = data.shaderWarpsPerCore;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderCoreMask() {
    return this.#view.getBigUint64(16, LE);
  }
  
  set shaderCoreMask(value: Deno.PointerValue) {
    this.#view.setBigUint64(16, BigInt(value), LE);
  }
  
  get shaderCoreCount() {
    return this.#view.getUint32(24, LE);
  }
  
  set shaderCoreCount(value: number) {
    this.#view.setUint32(24, Number(value), LE);
  }
  
  get shaderWarpsPerCore() {
    return this.#view.getUint32(28, LE);
  }
  
  set shaderWarpsPerCore(value: number) {
    this.#view.setUint32(28, Number(value), LE);
  }
}

export interface InitPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
  pNext?: AnyPointer;
  shaderCoreBuiltins?: Bool32;
}

export class PhysicalDeviceShaderCoreBuiltinsFeaturesARM implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceShaderCoreBuiltinsFeaturesARM);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceShaderCoreBuiltinsFeaturesARM) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreBuiltinsFeaturesARM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceShaderCoreBuiltinsFeaturesARM.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceShaderCoreBuiltinsFeaturesARM.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.shaderCoreBuiltins !== undefined) this.shaderCoreBuiltins = data.shaderCoreBuiltins;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get shaderCoreBuiltins() {
    return this.#view.getUint32(16, LE);
  }
  
  set shaderCoreBuiltins(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
  pNext?: AnyPointer;
  rayTracingInvocationReorder?: Bool32;
}

export class PhysicalDeviceRayTracingInvocationReorderFeaturesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingInvocationReorderFeaturesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingInvocationReorderFeaturesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingInvocationReorderFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingInvocationReorderFeaturesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingInvocationReorderFeaturesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayTracingInvocationReorder !== undefined) this.rayTracingInvocationReorder = data.rayTracingInvocationReorder;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayTracingInvocationReorder() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingInvocationReorder(value: Bool32) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

export interface InitPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
  pNext?: AnyPointer;
  rayTracingInvocationReorderReorderingHint?: RayTracingInvocationReorderModeNV;
}

export class PhysicalDeviceRayTracingInvocationReorderPropertiesNV implements BaseStruct {
  static size = 24;
  
  #data!: Uint8Array;
  #view!: DataView;
  
  get [BUFFER]() { return this.#data; }
  get [DATAVIEW]() { return this.#view; }
  
  constructor();
  constructor(init: InitPhysicalDeviceRayTracingInvocationReorderPropertiesNV);
  constructor(data: Uint8Array);
  constructor(data?: Uint8Array | InitPhysicalDeviceRayTracingInvocationReorderPropertiesNV) {
    if (!data) {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingInvocationReorderPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
    } else if (data instanceof Uint8Array) {
      if (data.byteLength < PhysicalDeviceRayTracingInvocationReorderPropertiesNV.size) {
        throw new Error("Data buffer too small");
      }
      this.#data = data;
      this.#view = new DataView(data.buffer, data.byteOffset);
    } else {
      this.#data = new Uint8Array(PhysicalDeviceRayTracingInvocationReorderPropertiesNV.size);
      this.#view = new DataView(this.#data.buffer, this.#data.byteOffset);
      this.sType = StructureType.STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
      if (data.pNext !== undefined) this.pNext = data.pNext;
      if (data.rayTracingInvocationReorderReorderingHint !== undefined) this.rayTracingInvocationReorderReorderingHint = data.rayTracingInvocationReorderReorderingHint;
    }
  }
  
  get sType() {
    return this.#view.getUint32(0, LE);
  }
  
  set sType(value: StructureType) {
    this.#view.setUint32(0, Number(value), LE);
  }
  
  get pNext() {
    return this.#view.getBigUint64(8, LE);
  }
  
  set pNext(value: AnyPointer) {
    this.#view.setBigUint64(8, BigInt(anyPointer(value)), LE);
  }
  
  get rayTracingInvocationReorderReorderingHint() {
    return this.#view.getUint32(16, LE);
  }
  
  set rayTracingInvocationReorderReorderingHint(value: RayTracingInvocationReorderModeNV) {
    this.#view.setUint32(16, Number(value), LE);
  }
}

/// Unions

/** // Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared. */
export class ClearColorValue {
  static size = 4;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < ClearColorValue.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/** // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared. */
export class ClearValue {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < ClearValue.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/** // Union of all the possible return types a counter result could return */
export class PerformanceCounterResultKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < PerformanceCounterResultKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class PerformanceValueDataINTEL {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < PerformanceValueDataINTEL.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class PipelineExecutableStatisticValueKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < PipelineExecutableStatisticValueKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class DeviceOrHostAddressKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < DeviceOrHostAddressKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class DeviceOrHostAddressConstKHR {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < DeviceOrHostAddressConstKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class AccelerationStructureGeometryDataKHR {
  static size = 64;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < AccelerationStructureGeometryDataKHR.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class DescriptorDataEXT {
  static size = 8;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < DescriptorDataEXT.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

export class AccelerationStructureMotionInstanceDataNV {
  static size = 152;
  
  #data: Uint8Array;
  #view: DataView;
  
  constructor(data: Uint8Array) {
    if (data.byteLength < AccelerationStructureMotionInstanceDataNV.size) {
      throw new Error("Data buffer too small");
    }
    this.#data = data;
    this.#view = new DataView(data.buffer);
  }
}

/// FFI Library
const lib = Deno.dlopen("vulkan-1", {
  "vkCreateInstance": {
    "parameters": [
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyInstance": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumeratePhysicalDevices": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceProcAddr": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "function"
  },
  "vkGetInstanceProcAddr": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "function"
  },
  "vkGetPhysicalDeviceProperties": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceQueueFamilyProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceMemoryProperties": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFeatures": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceImageFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateDevice": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDevice": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumerateInstanceVersion": {
    "parameters": [
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateInstanceLayerProperties": {
    "parameters": [
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateInstanceExtensionProperties": {
    "parameters": [
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateDeviceLayerProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEnumerateDeviceExtensionProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceQueue": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueSubmit": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkQueueWaitIdle": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkDeviceWaitIdle": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkAllocateMemory": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkMapMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkUnmapMemory": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "void"
  },
  "vkFlushMappedMemoryRanges": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkInvalidateMappedMemoryRanges": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceMemoryCommitment": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetBufferMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindBufferMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetImageMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindImageMemory": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetImageSparseMemoryRequirements": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceSparseImageFormatProperties": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueBindSparse": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCreateFence": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyFence": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetFences": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetFenceStatus": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkWaitForFences": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "u64"
    ],
    "result": "u32"
  },
  "vkCreateSemaphore": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySemaphore": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateEvent": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetEventStatus": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkSetEvent": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkResetEvent": {
    "parameters": [
      "pointer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCreateQueryPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetQueryPoolResults": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "usize",
      "buffer",
      "u64",
      "u32"
    ],
    "result": "u32"
  },
  "vkResetQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCreateBuffer": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateBufferView": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyBufferView": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateImage": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyImage": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageSubresourceLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateImageView": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyImageView": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateShaderModule": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyShaderModule": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreatePipelineCache": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipelineCache": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPipelineCacheData": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkMergePipelineCaches": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateGraphicsPipelines": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateComputePipelines": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipeline": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreatePipelineLayout": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPipelineLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateSampler": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySampler": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateDescriptorSetLayout": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorSetLayout": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateDescriptorPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetDescriptorPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkAllocateDescriptorSets": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeDescriptorSets": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkUpdateDescriptorSets": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateFramebuffer": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyFramebuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateRenderPass": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyRenderPass": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetRenderAreaGranularity": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateCommandPool": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkResetCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkAllocateCommandBuffers": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkFreeCommandBuffers": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkBeginCommandBuffer": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkEndCommandBuffer": {
    "parameters": [
      "pointer"
    ],
    "result": "u32"
  },
  "vkResetCommandBuffer": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "u32"
  },
  "vkCmdBindPipeline": {
    "parameters": [
      "pointer",
      "u32",
      "pointer"
    ],
    "result": "void"
  },
  "vkCmdSetViewport": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetScissor": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetLineWidth": {
    "parameters": [
      "pointer",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBias": {
    "parameters": [
      "pointer",
      "f32",
      "f32",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetBlendConstants": {
    "parameters": [
      "pointer",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBounds": {
    "parameters": [
      "pointer",
      "f32",
      "f32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilCompareMask": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilWriteMask": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilReference": {
    "parameters": [
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBindDescriptorSets": {
    "parameters": [
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBindIndexBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBindVertexBuffers": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdDraw": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexed": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "i32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexedIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatch": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatchIndirect": {
    "parameters": [
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "void"
  },
  "vkCmdCopyBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBlitImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdCopyBufferToImage": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImageToBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdUpdateBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdFillBuffer": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdClearColorImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdClearDepthStencilImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdClearAttachments": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResolveImage": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "pointer",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdResetEvent": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdWaitEvents": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "u32",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdPipelineBarrier": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "buffer",
      "u32",
      "buffer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBeginQuery": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdEndQuery": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdResetQueryPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdWriteTimestamp": {
    "parameters": [
      "pointer",
      "u32",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdCopyQueryPoolResults": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "pointer",
      "u64",
      "u64",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdPushConstants": {
    "parameters": [
      "pointer",
      "pointer",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBeginRenderPass": {
    "parameters": [
      "pointer",
      "buffer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdNextSubpass": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdEndRenderPass": {
    "parameters": [
      "pointer"
    ],
    "result": "void"
  },
  "vkCmdExecuteCommands": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceSurfaceSupportKHR": {
    "parameters": [
      "pointer",
      "u32",
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceSurfaceFormatsKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceSurfacePresentModesKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCreateSwapchainKHR": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySwapchainKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetSwapchainImagesKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkAcquireNextImageKHR": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkQueuePresentKHR": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceFeatures2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceProperties2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceFormatProperties2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceImageFormatProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetPhysicalDeviceQueueFamilyProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceMemoryProperties2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceSparseImageFormatProperties2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkTrimCommandPool": {
    "parameters": [
      "pointer",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalBufferProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalSemaphoreProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetPhysicalDeviceExternalFenceProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkEnumeratePhysicalDeviceGroups": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkGetDeviceGroupPeerMemoryFeatures": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkBindBufferMemory2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkBindImageMemory2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdSetDeviceMask": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDispatchBase": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCreateDescriptorUpdateTemplate": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyDescriptorUpdateTemplate": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkUpdateDescriptorSetWithTemplate": {
    "parameters": [
      "pointer",
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetBufferMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetImageSparseMemoryRequirements2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceBufferMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceImageMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceImageSparseMemoryRequirements": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateSamplerYcbcrConversion": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroySamplerYcbcrConversion": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDeviceQueue2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetDescriptorSetLayoutSupport": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCreateRenderPass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdBeginRenderPass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdNextSubpass2": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdEndRenderPass2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkGetSemaphoreCounterValue": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkWaitSemaphores": {
    "parameters": [
      "pointer",
      "buffer",
      "u64"
    ],
    "result": "u32"
  },
  "vkSignalSemaphore": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdDrawIndirectCount": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdDrawIndexedIndirectCount": {
    "parameters": [
      "pointer",
      "pointer",
      "u64",
      "pointer",
      "u64",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkGetBufferOpaqueCaptureAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetBufferDeviceAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetDeviceMemoryOpaqueCaptureAddress": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "u64"
  },
  "vkGetPhysicalDeviceToolProperties": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkCmdSetCullMode": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetFrontFace": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetPrimitiveTopology": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetViewportWithCount": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetScissorWithCount": {
    "parameters": [
      "pointer",
      "u32",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBindVertexBuffers2": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "buffer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetDepthTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthWriteEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthCompareOp": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBoundsTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilTestEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetStencilOp": {
    "parameters": [
      "pointer",
      "u32",
      "u32",
      "u32",
      "u32",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetRasterizerDiscardEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetDepthBiasEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdSetPrimitiveRestartEnable": {
    "parameters": [
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCreatePrivateDataSlot": {
    "parameters": [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    "result": "u32"
  },
  "vkDestroyPrivateDataSlot": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkSetPrivateData": {
    "parameters": [
      "pointer",
      "u32",
      "u64",
      "pointer",
      "u64"
    ],
    "result": "u32"
  },
  "vkGetPrivateData": {
    "parameters": [
      "pointer",
      "u32",
      "u64",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyBuffer2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdBlitImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyBufferToImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdCopyImageToBuffer2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResolveImage2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdSetEvent2": {
    "parameters": [
      "pointer",
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdResetEvent2": {
    "parameters": [
      "pointer",
      "pointer",
      "u64"
    ],
    "result": "void"
  },
  "vkCmdWaitEvents2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdPipelineBarrier2": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkQueueSubmit2": {
    "parameters": [
      "pointer",
      "u32",
      "buffer",
      "pointer"
    ],
    "result": "u32"
  },
  "vkCmdWriteTimestamp2": {
    "parameters": [
      "pointer",
      "u64",
      "pointer",
      "u32"
    ],
    "result": "void"
  },
  "vkCmdBeginRendering": {
    "parameters": [
      "pointer",
      "buffer"
    ],
    "result": "void"
  },
  "vkCmdEndRendering": {
    "parameters": [
      "pointer"
    ],
    "result": "void"
  },
} as const).symbols;

export class VulkanError extends Error {
  constructor(public code: Result) {
    super(`Vulkan error: ${code} (${Result[code]})`);
  }
}

/// Commands

export function CreateInstance(
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pInstance: AnyBuffer,
): Result {
  const ret = lib.vkCreateInstance(
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pInstance),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyInstance(
  instance: Instance,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyInstance(
    instance,
    anyBuffer(pAllocator),
  );
}

export function EnumeratePhysicalDevices(
  instance: Instance,
  pPhysicalDeviceCount: AnyBuffer,
  pPhysicalDevices: AnyBuffer,
): Result {
  const ret = lib.vkEnumeratePhysicalDevices(
    instance,
    anyBuffer(pPhysicalDeviceCount),
    anyBuffer(pPhysicalDevices),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetDeviceProcAddr(
  device: Device,
  pName: AnyBuffer,
): Deno.PointerValue {
  const ret = lib.vkGetDeviceProcAddr(
    device,
    anyBuffer(pName),
  );
  return ret;
}

export function GetInstanceProcAddr(
  instance: Instance,
  pName: AnyBuffer,
): Deno.PointerValue {
  const ret = lib.vkGetInstanceProcAddr(
    instance,
    anyBuffer(pName),
  );
  return ret;
}

export function GetPhysicalDeviceProperties(
  physicalDevice: PhysicalDevice,
  pProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceProperties(
    physicalDevice,
    anyBuffer(pProperties),
  );
}

export function GetPhysicalDeviceQueueFamilyProperties(
  physicalDevice: PhysicalDevice,
  pQueueFamilyPropertyCount: AnyBuffer,
  pQueueFamilyProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice,
    anyBuffer(pQueueFamilyPropertyCount),
    anyBuffer(pQueueFamilyProperties),
  );
}

export function GetPhysicalDeviceMemoryProperties(
  physicalDevice: PhysicalDevice,
  pMemoryProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceMemoryProperties(
    physicalDevice,
    anyBuffer(pMemoryProperties),
  );
}

export function GetPhysicalDeviceFeatures(
  physicalDevice: PhysicalDevice,
  pFeatures: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceFeatures(
    physicalDevice,
    anyBuffer(pFeatures),
  );
}

export function GetPhysicalDeviceFormatProperties(
  physicalDevice: PhysicalDevice,
  format: Format,
  pFormatProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceFormatProperties(
    physicalDevice,
    format,
    anyBuffer(pFormatProperties),
  );
}

export function GetPhysicalDeviceImageFormatProperties(
  physicalDevice: PhysicalDevice,
  format: Format,
  type: ImageType,
  tiling: ImageTiling,
  usage: ImageUsageFlags,
  flags: ImageCreateFlags,
  pImageFormatProperties: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceImageFormatProperties(
    physicalDevice,
    format,
    type,
    tiling,
    usage,
    flags,
    anyBuffer(pImageFormatProperties),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateDevice(
  physicalDevice: PhysicalDevice,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pDevice: AnyBuffer,
): Result {
  const ret = lib.vkCreateDevice(
    physicalDevice,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pDevice),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyDevice(
  device: Device,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyDevice(
    device,
    anyBuffer(pAllocator),
  );
}

export function EnumerateInstanceVersion(
  pApiVersion: AnyBuffer,
): Result {
  const ret = lib.vkEnumerateInstanceVersion(
    anyBuffer(pApiVersion),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function EnumerateInstanceLayerProperties(
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): Result {
  const ret = lib.vkEnumerateInstanceLayerProperties(
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function EnumerateInstanceExtensionProperties(
  pLayerName: AnyBuffer,
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): Result {
  const ret = lib.vkEnumerateInstanceExtensionProperties(
    anyBuffer(pLayerName),
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function EnumerateDeviceLayerProperties(
  physicalDevice: PhysicalDevice,
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): Result {
  const ret = lib.vkEnumerateDeviceLayerProperties(
    physicalDevice,
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function EnumerateDeviceExtensionProperties(
  physicalDevice: PhysicalDevice,
  pLayerName: AnyBuffer,
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): Result {
  const ret = lib.vkEnumerateDeviceExtensionProperties(
    physicalDevice,
    anyBuffer(pLayerName),
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetDeviceQueue(
  device: Device,
  queueFamilyIndex: number,
  queueIndex: number,
  pQueue: AnyBuffer,
): void {
  lib.vkGetDeviceQueue(
    device,
    queueFamilyIndex,
    queueIndex,
    anyBuffer(pQueue),
  );
}

export function QueueSubmit(
  queue: Queue,
  submitCount: number,
  pSubmits: AnyBuffer,
  fence: Fence,
): Result {
  const ret = lib.vkQueueSubmit(
    queue,
    submitCount,
    anyBuffer(pSubmits),
    fence,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function QueueWaitIdle(
  queue: Queue,
): Result {
  const ret = lib.vkQueueWaitIdle(
    queue,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DeviceWaitIdle(
  device: Device,
): Result {
  const ret = lib.vkDeviceWaitIdle(
    device,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function AllocateMemory(
  device: Device,
  pAllocateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pMemory: AnyBuffer,
): Result {
  const ret = lib.vkAllocateMemory(
    device,
    anyBuffer(pAllocateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pMemory),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function FreeMemory(
  device: Device,
  memory: DeviceMemory,
  pAllocator: AnyBuffer,
): void {
  lib.vkFreeMemory(
    device,
    memory,
    anyBuffer(pAllocator),
  );
}

export function MapMemory(
  device: Device,
  memory: DeviceMemory,
  offset: DeviceSize,
  size: DeviceSize,
  flags: MemoryMapFlags,
  ppData: AnyBuffer,
): Result {
  const ret = lib.vkMapMemory(
    device,
    memory,
    offset,
    size,
    flags,
    anyBuffer(ppData),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function UnmapMemory(
  device: Device,
  memory: DeviceMemory,
): void {
  lib.vkUnmapMemory(
    device,
    memory,
  );
}

export function FlushMappedMemoryRanges(
  device: Device,
  memoryRangeCount: number,
  pMemoryRanges: AnyBuffer,
): Result {
  const ret = lib.vkFlushMappedMemoryRanges(
    device,
    memoryRangeCount,
    anyBuffer(pMemoryRanges),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function InvalidateMappedMemoryRanges(
  device: Device,
  memoryRangeCount: number,
  pMemoryRanges: AnyBuffer,
): Result {
  const ret = lib.vkInvalidateMappedMemoryRanges(
    device,
    memoryRangeCount,
    anyBuffer(pMemoryRanges),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetDeviceMemoryCommitment(
  device: Device,
  memory: DeviceMemory,
  pCommittedMemoryInBytes: AnyBuffer,
): void {
  lib.vkGetDeviceMemoryCommitment(
    device,
    memory,
    anyBuffer(pCommittedMemoryInBytes),
  );
}

export function GetBufferMemoryRequirements(
  device: Device,
  buffer: Buffer,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetBufferMemoryRequirements(
    device,
    buffer,
    anyBuffer(pMemoryRequirements),
  );
}

export function BindBufferMemory(
  device: Device,
  buffer: Buffer,
  memory: DeviceMemory,
  memoryOffset: DeviceSize,
): Result {
  const ret = lib.vkBindBufferMemory(
    device,
    buffer,
    memory,
    memoryOffset,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetImageMemoryRequirements(
  device: Device,
  image: Image,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetImageMemoryRequirements(
    device,
    image,
    anyBuffer(pMemoryRequirements),
  );
}

export function BindImageMemory(
  device: Device,
  image: Image,
  memory: DeviceMemory,
  memoryOffset: DeviceSize,
): Result {
  const ret = lib.vkBindImageMemory(
    device,
    image,
    memory,
    memoryOffset,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetImageSparseMemoryRequirements(
  device: Device,
  image: Image,
  pSparseMemoryRequirementCount: AnyBuffer,
  pSparseMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetImageSparseMemoryRequirements(
    device,
    image,
    anyBuffer(pSparseMemoryRequirementCount),
    anyBuffer(pSparseMemoryRequirements),
  );
}

export function GetPhysicalDeviceSparseImageFormatProperties(
  physicalDevice: PhysicalDevice,
  format: Format,
  type: ImageType,
  samples: SampleCountFlagBits,
  usage: ImageUsageFlags,
  tiling: ImageTiling,
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceSparseImageFormatProperties(
    physicalDevice,
    format,
    type,
    samples,
    usage,
    tiling,
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
}

export function QueueBindSparse(
  queue: Queue,
  bindInfoCount: number,
  pBindInfo: AnyBuffer,
  fence: Fence,
): Result {
  const ret = lib.vkQueueBindSparse(
    queue,
    bindInfoCount,
    anyBuffer(pBindInfo),
    fence,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateFence(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pFence: AnyBuffer,
): Result {
  const ret = lib.vkCreateFence(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pFence),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyFence(
  device: Device,
  fence: Fence,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyFence(
    device,
    fence,
    anyBuffer(pAllocator),
  );
}

export function ResetFences(
  device: Device,
  fenceCount: number,
  pFences: AnyBuffer,
): Result {
  const ret = lib.vkResetFences(
    device,
    fenceCount,
    anyBuffer(pFences),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetFenceStatus(
  device: Device,
  fence: Fence,
): Result {
  const ret = lib.vkGetFenceStatus(
    device,
    fence,
  );
  if (ret === Result.SUCCESS || ret === Result.NOT_READY) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function WaitForFences(
  device: Device,
  fenceCount: number,
  pFences: AnyBuffer,
  waitAll: Bool32,
  timeout: Deno.PointerValue,
): Result {
  const ret = lib.vkWaitForFences(
    device,
    fenceCount,
    anyBuffer(pFences),
    waitAll,
    timeout,
  );
  if (ret === Result.SUCCESS || ret === Result.TIMEOUT) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateSemaphore(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pSemaphore: AnyBuffer,
): Result {
  const ret = lib.vkCreateSemaphore(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pSemaphore),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroySemaphore(
  device: Device,
  semaphore: Semaphore,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroySemaphore(
    device,
    semaphore,
    anyBuffer(pAllocator),
  );
}

export function CreateEvent(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pEvent: AnyBuffer,
): Result {
  const ret = lib.vkCreateEvent(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pEvent),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyEvent(
  device: Device,
  event: Event,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyEvent(
    device,
    event,
    anyBuffer(pAllocator),
  );
}

export function GetEventStatus(
  device: Device,
  event: Event,
): Result {
  const ret = lib.vkGetEventStatus(
    device,
    event,
  );
  if (ret === Result.EVENT_SET || ret === Result.EVENT_RESET) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function SetEvent(
  device: Device,
  event: Event,
): Result {
  const ret = lib.vkSetEvent(
    device,
    event,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function ResetEvent(
  device: Device,
  event: Event,
): Result {
  const ret = lib.vkResetEvent(
    device,
    event,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateQueryPool(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pQueryPool: AnyBuffer,
): Result {
  const ret = lib.vkCreateQueryPool(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pQueryPool),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyQueryPool(
  device: Device,
  queryPool: QueryPool,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyQueryPool(
    device,
    queryPool,
    anyBuffer(pAllocator),
  );
}

export function GetQueryPoolResults(
  device: Device,
  queryPool: QueryPool,
  firstQuery: number,
  queryCount: number,
  dataSize: Deno.PointerValue,
  pData: AnyBuffer,
  stride: DeviceSize,
  flags: QueryResultFlags,
): Result {
  const ret = lib.vkGetQueryPoolResults(
    device,
    queryPool,
    firstQuery,
    queryCount,
    dataSize,
    anyBuffer(pData),
    stride,
    flags,
  );
  if (ret === Result.SUCCESS || ret === Result.NOT_READY) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function ResetQueryPool(
  device: Device,
  queryPool: QueryPool,
  firstQuery: number,
  queryCount: number,
): void {
  lib.vkResetQueryPool(
    device,
    queryPool,
    firstQuery,
    queryCount,
  );
}

export function CreateBuffer(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pBuffer: AnyBuffer,
): Result {
  const ret = lib.vkCreateBuffer(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pBuffer),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyBuffer(
  device: Device,
  buffer: Buffer,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyBuffer(
    device,
    buffer,
    anyBuffer(pAllocator),
  );
}

export function CreateBufferView(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pView: AnyBuffer,
): Result {
  const ret = lib.vkCreateBufferView(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pView),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyBufferView(
  device: Device,
  bufferView: BufferView,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyBufferView(
    device,
    bufferView,
    anyBuffer(pAllocator),
  );
}

export function CreateImage(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pImage: AnyBuffer,
): Result {
  const ret = lib.vkCreateImage(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pImage),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyImage(
  device: Device,
  image: Image,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyImage(
    device,
    image,
    anyBuffer(pAllocator),
  );
}

export function GetImageSubresourceLayout(
  device: Device,
  image: Image,
  pSubresource: AnyBuffer,
  pLayout: AnyBuffer,
): void {
  lib.vkGetImageSubresourceLayout(
    device,
    image,
    anyBuffer(pSubresource),
    anyBuffer(pLayout),
  );
}

export function CreateImageView(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pView: AnyBuffer,
): Result {
  const ret = lib.vkCreateImageView(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pView),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyImageView(
  device: Device,
  imageView: ImageView,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyImageView(
    device,
    imageView,
    anyBuffer(pAllocator),
  );
}

export function CreateShaderModule(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pShaderModule: AnyBuffer,
): Result {
  const ret = lib.vkCreateShaderModule(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pShaderModule),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyShaderModule(
  device: Device,
  shaderModule: ShaderModule,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyShaderModule(
    device,
    shaderModule,
    anyBuffer(pAllocator),
  );
}

export function CreatePipelineCache(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pPipelineCache: AnyBuffer,
): Result {
  const ret = lib.vkCreatePipelineCache(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pPipelineCache),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyPipelineCache(
  device: Device,
  pipelineCache: PipelineCache,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyPipelineCache(
    device,
    pipelineCache,
    anyBuffer(pAllocator),
  );
}

export function GetPipelineCacheData(
  device: Device,
  pipelineCache: PipelineCache,
  pDataSize: AnyBuffer,
  pData: AnyBuffer,
): Result {
  const ret = lib.vkGetPipelineCacheData(
    device,
    pipelineCache,
    anyBuffer(pDataSize),
    anyBuffer(pData),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function MergePipelineCaches(
  device: Device,
  dstCache: PipelineCache,
  srcCacheCount: number,
  pSrcCaches: AnyBuffer,
): Result {
  const ret = lib.vkMergePipelineCaches(
    device,
    dstCache,
    srcCacheCount,
    anyBuffer(pSrcCaches),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateGraphicsPipelines(
  device: Device,
  pipelineCache: PipelineCache,
  createInfoCount: number,
  pCreateInfos: AnyBuffer,
  pAllocator: AnyBuffer,
  pPipelines: AnyBuffer,
): Result {
  const ret = lib.vkCreateGraphicsPipelines(
    device,
    pipelineCache,
    createInfoCount,
    anyBuffer(pCreateInfos),
    anyBuffer(pAllocator),
    anyBuffer(pPipelines),
  );
  if (ret === Result.SUCCESS || ret === Result.PIPELINE_COMPILE_REQUIRED_EXT) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateComputePipelines(
  device: Device,
  pipelineCache: PipelineCache,
  createInfoCount: number,
  pCreateInfos: AnyBuffer,
  pAllocator: AnyBuffer,
  pPipelines: AnyBuffer,
): Result {
  const ret = lib.vkCreateComputePipelines(
    device,
    pipelineCache,
    createInfoCount,
    anyBuffer(pCreateInfos),
    anyBuffer(pAllocator),
    anyBuffer(pPipelines),
  );
  if (ret === Result.SUCCESS || ret === Result.PIPELINE_COMPILE_REQUIRED_EXT) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyPipeline(
  device: Device,
  pipeline: Pipeline,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyPipeline(
    device,
    pipeline,
    anyBuffer(pAllocator),
  );
}

export function CreatePipelineLayout(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pPipelineLayout: AnyBuffer,
): Result {
  const ret = lib.vkCreatePipelineLayout(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pPipelineLayout),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyPipelineLayout(
  device: Device,
  pipelineLayout: PipelineLayout,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyPipelineLayout(
    device,
    pipelineLayout,
    anyBuffer(pAllocator),
  );
}

export function CreateSampler(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pSampler: AnyBuffer,
): Result {
  const ret = lib.vkCreateSampler(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pSampler),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroySampler(
  device: Device,
  sampler: Sampler,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroySampler(
    device,
    sampler,
    anyBuffer(pAllocator),
  );
}

export function CreateDescriptorSetLayout(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pSetLayout: AnyBuffer,
): Result {
  const ret = lib.vkCreateDescriptorSetLayout(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pSetLayout),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyDescriptorSetLayout(
  device: Device,
  descriptorSetLayout: DescriptorSetLayout,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyDescriptorSetLayout(
    device,
    descriptorSetLayout,
    anyBuffer(pAllocator),
  );
}

export function CreateDescriptorPool(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pDescriptorPool: AnyBuffer,
): Result {
  const ret = lib.vkCreateDescriptorPool(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pDescriptorPool),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyDescriptorPool(
  device: Device,
  descriptorPool: DescriptorPool,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyDescriptorPool(
    device,
    descriptorPool,
    anyBuffer(pAllocator),
  );
}

export function ResetDescriptorPool(
  device: Device,
  descriptorPool: DescriptorPool,
  flags: DescriptorPoolResetFlags,
): Result {
  const ret = lib.vkResetDescriptorPool(
    device,
    descriptorPool,
    flags,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function AllocateDescriptorSets(
  device: Device,
  pAllocateInfo: AnyBuffer,
  pDescriptorSets: AnyBuffer,
): Result {
  const ret = lib.vkAllocateDescriptorSets(
    device,
    anyBuffer(pAllocateInfo),
    anyBuffer(pDescriptorSets),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function FreeDescriptorSets(
  device: Device,
  descriptorPool: DescriptorPool,
  descriptorSetCount: number,
  pDescriptorSets: AnyBuffer,
): Result {
  const ret = lib.vkFreeDescriptorSets(
    device,
    descriptorPool,
    descriptorSetCount,
    anyBuffer(pDescriptorSets),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function UpdateDescriptorSets(
  device: Device,
  descriptorWriteCount: number,
  pDescriptorWrites: AnyBuffer,
  descriptorCopyCount: number,
  pDescriptorCopies: AnyBuffer,
): void {
  lib.vkUpdateDescriptorSets(
    device,
    descriptorWriteCount,
    anyBuffer(pDescriptorWrites),
    descriptorCopyCount,
    anyBuffer(pDescriptorCopies),
  );
}

export function CreateFramebuffer(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pFramebuffer: AnyBuffer,
): Result {
  const ret = lib.vkCreateFramebuffer(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pFramebuffer),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyFramebuffer(
  device: Device,
  framebuffer: Framebuffer,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyFramebuffer(
    device,
    framebuffer,
    anyBuffer(pAllocator),
  );
}

export function CreateRenderPass(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pRenderPass: AnyBuffer,
): Result {
  const ret = lib.vkCreateRenderPass(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pRenderPass),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyRenderPass(
  device: Device,
  renderPass: RenderPass,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyRenderPass(
    device,
    renderPass,
    anyBuffer(pAllocator),
  );
}

export function GetRenderAreaGranularity(
  device: Device,
  renderPass: RenderPass,
  pGranularity: AnyBuffer,
): void {
  lib.vkGetRenderAreaGranularity(
    device,
    renderPass,
    anyBuffer(pGranularity),
  );
}

export function CreateCommandPool(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pCommandPool: AnyBuffer,
): Result {
  const ret = lib.vkCreateCommandPool(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pCommandPool),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyCommandPool(
  device: Device,
  commandPool: CommandPool,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyCommandPool(
    device,
    commandPool,
    anyBuffer(pAllocator),
  );
}

export function ResetCommandPool(
  device: Device,
  commandPool: CommandPool,
  flags: CommandPoolResetFlags,
): Result {
  const ret = lib.vkResetCommandPool(
    device,
    commandPool,
    flags,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function AllocateCommandBuffers(
  device: Device,
  pAllocateInfo: AnyBuffer,
  pCommandBuffers: AnyBuffer,
): Result {
  const ret = lib.vkAllocateCommandBuffers(
    device,
    anyBuffer(pAllocateInfo),
    anyBuffer(pCommandBuffers),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function FreeCommandBuffers(
  device: Device,
  commandPool: CommandPool,
  commandBufferCount: number,
  pCommandBuffers: AnyBuffer,
): void {
  lib.vkFreeCommandBuffers(
    device,
    commandPool,
    commandBufferCount,
    anyBuffer(pCommandBuffers),
  );
}

export function BeginCommandBuffer(
  commandBuffer: CommandBuffer,
  pBeginInfo: AnyBuffer,
): Result {
  const ret = lib.vkBeginCommandBuffer(
    commandBuffer,
    anyBuffer(pBeginInfo),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function EndCommandBuffer(
  commandBuffer: CommandBuffer,
): Result {
  const ret = lib.vkEndCommandBuffer(
    commandBuffer,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function ResetCommandBuffer(
  commandBuffer: CommandBuffer,
  flags: CommandBufferResetFlags,
): Result {
  const ret = lib.vkResetCommandBuffer(
    commandBuffer,
    flags,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdBindPipeline(
  commandBuffer: CommandBuffer,
  pipelineBindPoint: PipelineBindPoint,
  pipeline: Pipeline,
): void {
  lib.vkCmdBindPipeline(
    commandBuffer,
    pipelineBindPoint,
    pipeline,
  );
}

export function CmdSetViewport(
  commandBuffer: CommandBuffer,
  firstViewport: number,
  viewportCount: number,
  pViewports: AnyBuffer,
): void {
  lib.vkCmdSetViewport(
    commandBuffer,
    firstViewport,
    viewportCount,
    anyBuffer(pViewports),
  );
}

export function CmdSetScissor(
  commandBuffer: CommandBuffer,
  firstScissor: number,
  scissorCount: number,
  pScissors: AnyBuffer,
): void {
  lib.vkCmdSetScissor(
    commandBuffer,
    firstScissor,
    scissorCount,
    anyBuffer(pScissors),
  );
}

export function CmdSetLineWidth(
  commandBuffer: CommandBuffer,
  lineWidth: number,
): void {
  lib.vkCmdSetLineWidth(
    commandBuffer,
    lineWidth,
  );
}

export function CmdSetDepthBias(
  commandBuffer: CommandBuffer,
  depthBiasConstantFactor: number,
  depthBiasClamp: number,
  depthBiasSlopeFactor: number,
): void {
  lib.vkCmdSetDepthBias(
    commandBuffer,
    depthBiasConstantFactor,
    depthBiasClamp,
    depthBiasSlopeFactor,
  );
}

export function CmdSetBlendConstants(
  commandBuffer: CommandBuffer,
  blendConstants: number,
): void {
  lib.vkCmdSetBlendConstants(
    commandBuffer,
    blendConstants,
  );
}

export function CmdSetDepthBounds(
  commandBuffer: CommandBuffer,
  minDepthBounds: number,
  maxDepthBounds: number,
): void {
  lib.vkCmdSetDepthBounds(
    commandBuffer,
    minDepthBounds,
    maxDepthBounds,
  );
}

export function CmdSetStencilCompareMask(
  commandBuffer: CommandBuffer,
  faceMask: StencilFaceFlags,
  compareMask: number,
): void {
  lib.vkCmdSetStencilCompareMask(
    commandBuffer,
    faceMask,
    compareMask,
  );
}

export function CmdSetStencilWriteMask(
  commandBuffer: CommandBuffer,
  faceMask: StencilFaceFlags,
  writeMask: number,
): void {
  lib.vkCmdSetStencilWriteMask(
    commandBuffer,
    faceMask,
    writeMask,
  );
}

export function CmdSetStencilReference(
  commandBuffer: CommandBuffer,
  faceMask: StencilFaceFlags,
  reference: number,
): void {
  lib.vkCmdSetStencilReference(
    commandBuffer,
    faceMask,
    reference,
  );
}

export function CmdBindDescriptorSets(
  commandBuffer: CommandBuffer,
  pipelineBindPoint: PipelineBindPoint,
  layout: PipelineLayout,
  firstSet: number,
  descriptorSetCount: number,
  pDescriptorSets: AnyBuffer,
  dynamicOffsetCount: number,
  pDynamicOffsets: AnyBuffer,
): void {
  lib.vkCmdBindDescriptorSets(
    commandBuffer,
    pipelineBindPoint,
    layout,
    firstSet,
    descriptorSetCount,
    anyBuffer(pDescriptorSets),
    dynamicOffsetCount,
    anyBuffer(pDynamicOffsets),
  );
}

export function CmdBindIndexBuffer(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
  indexType: IndexType,
): void {
  lib.vkCmdBindIndexBuffer(
    commandBuffer,
    buffer,
    offset,
    indexType,
  );
}

export function CmdBindVertexBuffers(
  commandBuffer: CommandBuffer,
  firstBinding: number,
  bindingCount: number,
  pBuffers: AnyBuffer,
  pOffsets: AnyBuffer,
): void {
  lib.vkCmdBindVertexBuffers(
    commandBuffer,
    firstBinding,
    bindingCount,
    anyBuffer(pBuffers),
    anyBuffer(pOffsets),
  );
}

export function CmdDraw(
  commandBuffer: CommandBuffer,
  vertexCount: number,
  instanceCount: number,
  firstVertex: number,
  firstInstance: number,
): void {
  lib.vkCmdDraw(
    commandBuffer,
    vertexCount,
    instanceCount,
    firstVertex,
    firstInstance,
  );
}

export function CmdDrawIndexed(
  commandBuffer: CommandBuffer,
  indexCount: number,
  instanceCount: number,
  firstIndex: number,
  vertexOffset: number,
  firstInstance: number,
): void {
  lib.vkCmdDrawIndexed(
    commandBuffer,
    indexCount,
    instanceCount,
    firstIndex,
    vertexOffset,
    firstInstance,
  );
}

export function CmdDrawIndirect(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
  drawCount: number,
  stride: number,
): void {
  lib.vkCmdDrawIndirect(
    commandBuffer,
    buffer,
    offset,
    drawCount,
    stride,
  );
}

export function CmdDrawIndexedIndirect(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
  drawCount: number,
  stride: number,
): void {
  lib.vkCmdDrawIndexedIndirect(
    commandBuffer,
    buffer,
    offset,
    drawCount,
    stride,
  );
}

export function CmdDispatch(
  commandBuffer: CommandBuffer,
  groupCountX: number,
  groupCountY: number,
  groupCountZ: number,
): void {
  lib.vkCmdDispatch(
    commandBuffer,
    groupCountX,
    groupCountY,
    groupCountZ,
  );
}

export function CmdDispatchIndirect(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
): void {
  lib.vkCmdDispatchIndirect(
    commandBuffer,
    buffer,
    offset,
  );
}

export function CmdCopyBuffer(
  commandBuffer: CommandBuffer,
  srcBuffer: Buffer,
  dstBuffer: Buffer,
  regionCount: number,
  pRegions: AnyBuffer,
): void {
  lib.vkCmdCopyBuffer(
    commandBuffer,
    srcBuffer,
    dstBuffer,
    regionCount,
    anyBuffer(pRegions),
  );
}

export function CmdCopyImage(
  commandBuffer: CommandBuffer,
  srcImage: Image,
  srcImageLayout: ImageLayout,
  dstImage: Image,
  dstImageLayout: ImageLayout,
  regionCount: number,
  pRegions: AnyBuffer,
): void {
  lib.vkCmdCopyImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    anyBuffer(pRegions),
  );
}

export function CmdBlitImage(
  commandBuffer: CommandBuffer,
  srcImage: Image,
  srcImageLayout: ImageLayout,
  dstImage: Image,
  dstImageLayout: ImageLayout,
  regionCount: number,
  pRegions: AnyBuffer,
  filter: Filter,
): void {
  lib.vkCmdBlitImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    anyBuffer(pRegions),
    filter,
  );
}

export function CmdCopyBufferToImage(
  commandBuffer: CommandBuffer,
  srcBuffer: Buffer,
  dstImage: Image,
  dstImageLayout: ImageLayout,
  regionCount: number,
  pRegions: AnyBuffer,
): void {
  lib.vkCmdCopyBufferToImage(
    commandBuffer,
    srcBuffer,
    dstImage,
    dstImageLayout,
    regionCount,
    anyBuffer(pRegions),
  );
}

export function CmdCopyImageToBuffer(
  commandBuffer: CommandBuffer,
  srcImage: Image,
  srcImageLayout: ImageLayout,
  dstBuffer: Buffer,
  regionCount: number,
  pRegions: AnyBuffer,
): void {
  lib.vkCmdCopyImageToBuffer(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstBuffer,
    regionCount,
    anyBuffer(pRegions),
  );
}

export function CmdUpdateBuffer(
  commandBuffer: CommandBuffer,
  dstBuffer: Buffer,
  dstOffset: DeviceSize,
  dataSize: DeviceSize,
  pData: AnyBuffer,
): void {
  lib.vkCmdUpdateBuffer(
    commandBuffer,
    dstBuffer,
    dstOffset,
    dataSize,
    anyBuffer(pData),
  );
}

/** transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification */
export function CmdFillBuffer(
  commandBuffer: CommandBuffer,
  dstBuffer: Buffer,
  dstOffset: DeviceSize,
  size: DeviceSize,
  data: number,
): void {
  lib.vkCmdFillBuffer(
    commandBuffer,
    dstBuffer,
    dstOffset,
    size,
    data,
  );
}

export function CmdClearColorImage(
  commandBuffer: CommandBuffer,
  image: Image,
  imageLayout: ImageLayout,
  pColor: AnyBuffer,
  rangeCount: number,
  pRanges: AnyBuffer,
): void {
  lib.vkCmdClearColorImage(
    commandBuffer,
    image,
    imageLayout,
    anyBuffer(pColor),
    rangeCount,
    anyBuffer(pRanges),
  );
}

export function CmdClearDepthStencilImage(
  commandBuffer: CommandBuffer,
  image: Image,
  imageLayout: ImageLayout,
  pDepthStencil: AnyBuffer,
  rangeCount: number,
  pRanges: AnyBuffer,
): void {
  lib.vkCmdClearDepthStencilImage(
    commandBuffer,
    image,
    imageLayout,
    anyBuffer(pDepthStencil),
    rangeCount,
    anyBuffer(pRanges),
  );
}

export function CmdClearAttachments(
  commandBuffer: CommandBuffer,
  attachmentCount: number,
  pAttachments: AnyBuffer,
  rectCount: number,
  pRects: AnyBuffer,
): void {
  lib.vkCmdClearAttachments(
    commandBuffer,
    attachmentCount,
    anyBuffer(pAttachments),
    rectCount,
    anyBuffer(pRects),
  );
}

export function CmdResolveImage(
  commandBuffer: CommandBuffer,
  srcImage: Image,
  srcImageLayout: ImageLayout,
  dstImage: Image,
  dstImageLayout: ImageLayout,
  regionCount: number,
  pRegions: AnyBuffer,
): void {
  lib.vkCmdResolveImage(
    commandBuffer,
    srcImage,
    srcImageLayout,
    dstImage,
    dstImageLayout,
    regionCount,
    anyBuffer(pRegions),
  );
}

export function CmdSetEvent(
  commandBuffer: CommandBuffer,
  event: Event,
  stageMask: PipelineStageFlags,
): void {
  lib.vkCmdSetEvent(
    commandBuffer,
    event,
    stageMask,
  );
}

export function CmdResetEvent(
  commandBuffer: CommandBuffer,
  event: Event,
  stageMask: PipelineStageFlags,
): void {
  lib.vkCmdResetEvent(
    commandBuffer,
    event,
    stageMask,
  );
}

export function CmdWaitEvents(
  commandBuffer: CommandBuffer,
  eventCount: number,
  pEvents: AnyBuffer,
  srcStageMask: PipelineStageFlags,
  dstStageMask: PipelineStageFlags,
  memoryBarrierCount: number,
  pMemoryBarriers: AnyBuffer,
  bufferMemoryBarrierCount: number,
  pBufferMemoryBarriers: AnyBuffer,
  imageMemoryBarrierCount: number,
  pImageMemoryBarriers: AnyBuffer,
): void {
  lib.vkCmdWaitEvents(
    commandBuffer,
    eventCount,
    anyBuffer(pEvents),
    srcStageMask,
    dstStageMask,
    memoryBarrierCount,
    anyBuffer(pMemoryBarriers),
    bufferMemoryBarrierCount,
    anyBuffer(pBufferMemoryBarriers),
    imageMemoryBarrierCount,
    anyBuffer(pImageMemoryBarriers),
  );
}

export function CmdPipelineBarrier(
  commandBuffer: CommandBuffer,
  srcStageMask: PipelineStageFlags,
  dstStageMask: PipelineStageFlags,
  dependencyFlags: DependencyFlags,
  memoryBarrierCount: number,
  pMemoryBarriers: AnyBuffer,
  bufferMemoryBarrierCount: number,
  pBufferMemoryBarriers: AnyBuffer,
  imageMemoryBarrierCount: number,
  pImageMemoryBarriers: AnyBuffer,
): void {
  lib.vkCmdPipelineBarrier(
    commandBuffer,
    srcStageMask,
    dstStageMask,
    dependencyFlags,
    memoryBarrierCount,
    anyBuffer(pMemoryBarriers),
    bufferMemoryBarrierCount,
    anyBuffer(pBufferMemoryBarriers),
    imageMemoryBarrierCount,
    anyBuffer(pImageMemoryBarriers),
  );
}

export function CmdBeginQuery(
  commandBuffer: CommandBuffer,
  queryPool: QueryPool,
  query: number,
  flags: QueryControlFlags,
): void {
  lib.vkCmdBeginQuery(
    commandBuffer,
    queryPool,
    query,
    flags,
  );
}

export function CmdEndQuery(
  commandBuffer: CommandBuffer,
  queryPool: QueryPool,
  query: number,
): void {
  lib.vkCmdEndQuery(
    commandBuffer,
    queryPool,
    query,
  );
}

export function CmdResetQueryPool(
  commandBuffer: CommandBuffer,
  queryPool: QueryPool,
  firstQuery: number,
  queryCount: number,
): void {
  lib.vkCmdResetQueryPool(
    commandBuffer,
    queryPool,
    firstQuery,
    queryCount,
  );
}

export function CmdWriteTimestamp(
  commandBuffer: CommandBuffer,
  pipelineStage: PipelineStageFlagBits,
  queryPool: QueryPool,
  query: number,
): void {
  lib.vkCmdWriteTimestamp(
    commandBuffer,
    pipelineStage,
    queryPool,
    query,
  );
}

export function CmdCopyQueryPoolResults(
  commandBuffer: CommandBuffer,
  queryPool: QueryPool,
  firstQuery: number,
  queryCount: number,
  dstBuffer: Buffer,
  dstOffset: DeviceSize,
  stride: DeviceSize,
  flags: QueryResultFlags,
): void {
  lib.vkCmdCopyQueryPoolResults(
    commandBuffer,
    queryPool,
    firstQuery,
    queryCount,
    dstBuffer,
    dstOffset,
    stride,
    flags,
  );
}

export function CmdPushConstants(
  commandBuffer: CommandBuffer,
  layout: PipelineLayout,
  stageFlags: ShaderStageFlags,
  offset: number,
  size: number,
  pValues: AnyBuffer,
): void {
  lib.vkCmdPushConstants(
    commandBuffer,
    layout,
    stageFlags,
    offset,
    size,
    anyBuffer(pValues),
  );
}

export function CmdBeginRenderPass(
  commandBuffer: CommandBuffer,
  pRenderPassBegin: AnyBuffer,
  contents: SubpassContents,
): void {
  lib.vkCmdBeginRenderPass(
    commandBuffer,
    anyBuffer(pRenderPassBegin),
    contents,
  );
}

export function CmdNextSubpass(
  commandBuffer: CommandBuffer,
  contents: SubpassContents,
): void {
  lib.vkCmdNextSubpass(
    commandBuffer,
    contents,
  );
}

export function CmdEndRenderPass(
  commandBuffer: CommandBuffer,
): void {
  lib.vkCmdEndRenderPass(
    commandBuffer,
  );
}

export function CmdExecuteCommands(
  commandBuffer: CommandBuffer,
  commandBufferCount: number,
  pCommandBuffers: AnyBuffer,
): void {
  lib.vkCmdExecuteCommands(
    commandBuffer,
    commandBufferCount,
    anyBuffer(pCommandBuffers),
  );
}

export function GetPhysicalDeviceSurfaceSupportKHR(
  physicalDevice: PhysicalDevice,
  queueFamilyIndex: number,
  surface: SurfaceKHR,
  pSupported: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceSurfaceSupportKHR(
    physicalDevice,
    queueFamilyIndex,
    surface,
    anyBuffer(pSupported),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPhysicalDeviceSurfaceCapabilitiesKHR(
  physicalDevice: PhysicalDevice,
  surface: SurfaceKHR,
  pSurfaceCapabilities: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    physicalDevice,
    surface,
    anyBuffer(pSurfaceCapabilities),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPhysicalDeviceSurfaceFormatsKHR(
  physicalDevice: PhysicalDevice,
  surface: SurfaceKHR,
  pSurfaceFormatCount: AnyBuffer,
  pSurfaceFormats: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceSurfaceFormatsKHR(
    physicalDevice,
    surface,
    anyBuffer(pSurfaceFormatCount),
    anyBuffer(pSurfaceFormats),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPhysicalDeviceSurfacePresentModesKHR(
  physicalDevice: PhysicalDevice,
  surface: SurfaceKHR,
  pPresentModeCount: AnyBuffer,
  pPresentModes: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceSurfacePresentModesKHR(
    physicalDevice,
    surface,
    anyBuffer(pPresentModeCount),
    anyBuffer(pPresentModes),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CreateSwapchainKHR(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pSwapchain: AnyBuffer,
): Result {
  const ret = lib.vkCreateSwapchainKHR(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pSwapchain),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroySwapchainKHR(
  device: Device,
  swapchain: SwapchainKHR,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroySwapchainKHR(
    device,
    swapchain,
    anyBuffer(pAllocator),
  );
}

export function GetSwapchainImagesKHR(
  device: Device,
  swapchain: SwapchainKHR,
  pSwapchainImageCount: AnyBuffer,
  pSwapchainImages: AnyBuffer,
): Result {
  const ret = lib.vkGetSwapchainImagesKHR(
    device,
    swapchain,
    anyBuffer(pSwapchainImageCount),
    anyBuffer(pSwapchainImages),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function AcquireNextImageKHR(
  device: Device,
  swapchain: SwapchainKHR,
  timeout: Deno.PointerValue,
  semaphore: Semaphore,
  fence: Fence,
  pImageIndex: AnyBuffer,
): Result {
  const ret = lib.vkAcquireNextImageKHR(
    device,
    swapchain,
    timeout,
    semaphore,
    fence,
    anyBuffer(pImageIndex),
  );
  if (ret === Result.SUCCESS || ret === Result.TIMEOUT || ret === Result.NOT_READY || ret === Result.SUBOPTIMAL_KHR) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function QueuePresentKHR(
  queue: Queue,
  pPresentInfo: AnyBuffer,
): Result {
  const ret = lib.vkQueuePresentKHR(
    queue,
    anyBuffer(pPresentInfo),
  );
  if (ret === Result.SUCCESS || ret === Result.SUBOPTIMAL_KHR) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPhysicalDeviceFeatures2(
  physicalDevice: PhysicalDevice,
  pFeatures: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceFeatures2(
    physicalDevice,
    anyBuffer(pFeatures),
  );
}

export function GetPhysicalDeviceProperties2(
  physicalDevice: PhysicalDevice,
  pProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceProperties2(
    physicalDevice,
    anyBuffer(pProperties),
  );
}

export function GetPhysicalDeviceFormatProperties2(
  physicalDevice: PhysicalDevice,
  format: Format,
  pFormatProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceFormatProperties2(
    physicalDevice,
    format,
    anyBuffer(pFormatProperties),
  );
}

export function GetPhysicalDeviceImageFormatProperties2(
  physicalDevice: PhysicalDevice,
  pImageFormatInfo: AnyBuffer,
  pImageFormatProperties: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceImageFormatProperties2(
    physicalDevice,
    anyBuffer(pImageFormatInfo),
    anyBuffer(pImageFormatProperties),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPhysicalDeviceQueueFamilyProperties2(
  physicalDevice: PhysicalDevice,
  pQueueFamilyPropertyCount: AnyBuffer,
  pQueueFamilyProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceQueueFamilyProperties2(
    physicalDevice,
    anyBuffer(pQueueFamilyPropertyCount),
    anyBuffer(pQueueFamilyProperties),
  );
}

export function GetPhysicalDeviceMemoryProperties2(
  physicalDevice: PhysicalDevice,
  pMemoryProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceMemoryProperties2(
    physicalDevice,
    anyBuffer(pMemoryProperties),
  );
}

export function GetPhysicalDeviceSparseImageFormatProperties2(
  physicalDevice: PhysicalDevice,
  pFormatInfo: AnyBuffer,
  pPropertyCount: AnyBuffer,
  pProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceSparseImageFormatProperties2(
    physicalDevice,
    anyBuffer(pFormatInfo),
    anyBuffer(pPropertyCount),
    anyBuffer(pProperties),
  );
}

export function TrimCommandPool(
  device: Device,
  commandPool: CommandPool,
  flags: CommandPoolTrimFlags,
): void {
  lib.vkTrimCommandPool(
    device,
    commandPool,
    flags,
  );
}

export function GetPhysicalDeviceExternalBufferProperties(
  physicalDevice: PhysicalDevice,
  pExternalBufferInfo: AnyBuffer,
  pExternalBufferProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceExternalBufferProperties(
    physicalDevice,
    anyBuffer(pExternalBufferInfo),
    anyBuffer(pExternalBufferProperties),
  );
}

export function GetPhysicalDeviceExternalSemaphoreProperties(
  physicalDevice: PhysicalDevice,
  pExternalSemaphoreInfo: AnyBuffer,
  pExternalSemaphoreProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceExternalSemaphoreProperties(
    physicalDevice,
    anyBuffer(pExternalSemaphoreInfo),
    anyBuffer(pExternalSemaphoreProperties),
  );
}

export function GetPhysicalDeviceExternalFenceProperties(
  physicalDevice: PhysicalDevice,
  pExternalFenceInfo: AnyBuffer,
  pExternalFenceProperties: AnyBuffer,
): void {
  lib.vkGetPhysicalDeviceExternalFenceProperties(
    physicalDevice,
    anyBuffer(pExternalFenceInfo),
    anyBuffer(pExternalFenceProperties),
  );
}

export function EnumeratePhysicalDeviceGroups(
  instance: Instance,
  pPhysicalDeviceGroupCount: AnyBuffer,
  pPhysicalDeviceGroupProperties: AnyBuffer,
): Result {
  const ret = lib.vkEnumeratePhysicalDeviceGroups(
    instance,
    anyBuffer(pPhysicalDeviceGroupCount),
    anyBuffer(pPhysicalDeviceGroupProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetDeviceGroupPeerMemoryFeatures(
  device: Device,
  heapIndex: number,
  localDeviceIndex: number,
  remoteDeviceIndex: number,
  pPeerMemoryFeatures: AnyBuffer,
): void {
  lib.vkGetDeviceGroupPeerMemoryFeatures(
    device,
    heapIndex,
    localDeviceIndex,
    remoteDeviceIndex,
    anyBuffer(pPeerMemoryFeatures),
  );
}

export function BindBufferMemory2(
  device: Device,
  bindInfoCount: number,
  pBindInfos: AnyBuffer,
): Result {
  const ret = lib.vkBindBufferMemory2(
    device,
    bindInfoCount,
    anyBuffer(pBindInfos),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function BindImageMemory2(
  device: Device,
  bindInfoCount: number,
  pBindInfos: AnyBuffer,
): Result {
  const ret = lib.vkBindImageMemory2(
    device,
    bindInfoCount,
    anyBuffer(pBindInfos),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdSetDeviceMask(
  commandBuffer: CommandBuffer,
  deviceMask: number,
): void {
  lib.vkCmdSetDeviceMask(
    commandBuffer,
    deviceMask,
  );
}

export function CmdDispatchBase(
  commandBuffer: CommandBuffer,
  baseGroupX: number,
  baseGroupY: number,
  baseGroupZ: number,
  groupCountX: number,
  groupCountY: number,
  groupCountZ: number,
): void {
  lib.vkCmdDispatchBase(
    commandBuffer,
    baseGroupX,
    baseGroupY,
    baseGroupZ,
    groupCountX,
    groupCountY,
    groupCountZ,
  );
}

export function CreateDescriptorUpdateTemplate(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pDescriptorUpdateTemplate: AnyBuffer,
): Result {
  const ret = lib.vkCreateDescriptorUpdateTemplate(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pDescriptorUpdateTemplate),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyDescriptorUpdateTemplate(
  device: Device,
  descriptorUpdateTemplate: DescriptorUpdateTemplate,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyDescriptorUpdateTemplate(
    device,
    descriptorUpdateTemplate,
    anyBuffer(pAllocator),
  );
}

export function UpdateDescriptorSetWithTemplate(
  device: Device,
  descriptorSet: DescriptorSet,
  descriptorUpdateTemplate: DescriptorUpdateTemplate,
  pData: AnyBuffer,
): void {
  lib.vkUpdateDescriptorSetWithTemplate(
    device,
    descriptorSet,
    descriptorUpdateTemplate,
    anyBuffer(pData),
  );
}

export function GetBufferMemoryRequirements2(
  device: Device,
  pInfo: AnyBuffer,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetBufferMemoryRequirements2(
    device,
    anyBuffer(pInfo),
    anyBuffer(pMemoryRequirements),
  );
}

export function GetImageMemoryRequirements2(
  device: Device,
  pInfo: AnyBuffer,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetImageMemoryRequirements2(
    device,
    anyBuffer(pInfo),
    anyBuffer(pMemoryRequirements),
  );
}

export function GetImageSparseMemoryRequirements2(
  device: Device,
  pInfo: AnyBuffer,
  pSparseMemoryRequirementCount: AnyBuffer,
  pSparseMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetImageSparseMemoryRequirements2(
    device,
    anyBuffer(pInfo),
    anyBuffer(pSparseMemoryRequirementCount),
    anyBuffer(pSparseMemoryRequirements),
  );
}

export function GetDeviceBufferMemoryRequirements(
  device: Device,
  pInfo: AnyBuffer,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetDeviceBufferMemoryRequirements(
    device,
    anyBuffer(pInfo),
    anyBuffer(pMemoryRequirements),
  );
}

export function GetDeviceImageMemoryRequirements(
  device: Device,
  pInfo: AnyBuffer,
  pMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetDeviceImageMemoryRequirements(
    device,
    anyBuffer(pInfo),
    anyBuffer(pMemoryRequirements),
  );
}

export function GetDeviceImageSparseMemoryRequirements(
  device: Device,
  pInfo: AnyBuffer,
  pSparseMemoryRequirementCount: AnyBuffer,
  pSparseMemoryRequirements: AnyBuffer,
): void {
  lib.vkGetDeviceImageSparseMemoryRequirements(
    device,
    anyBuffer(pInfo),
    anyBuffer(pSparseMemoryRequirementCount),
    anyBuffer(pSparseMemoryRequirements),
  );
}

export function CreateSamplerYcbcrConversion(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pYcbcrConversion: AnyBuffer,
): Result {
  const ret = lib.vkCreateSamplerYcbcrConversion(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pYcbcrConversion),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroySamplerYcbcrConversion(
  device: Device,
  ycbcrConversion: SamplerYcbcrConversion,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroySamplerYcbcrConversion(
    device,
    ycbcrConversion,
    anyBuffer(pAllocator),
  );
}

export function GetDeviceQueue2(
  device: Device,
  pQueueInfo: AnyBuffer,
  pQueue: AnyBuffer,
): void {
  lib.vkGetDeviceQueue2(
    device,
    anyBuffer(pQueueInfo),
    anyBuffer(pQueue),
  );
}

export function GetDescriptorSetLayoutSupport(
  device: Device,
  pCreateInfo: AnyBuffer,
  pSupport: AnyBuffer,
): void {
  lib.vkGetDescriptorSetLayoutSupport(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pSupport),
  );
}

export function CreateRenderPass2(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pRenderPass: AnyBuffer,
): Result {
  const ret = lib.vkCreateRenderPass2(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pRenderPass),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdBeginRenderPass2(
  commandBuffer: CommandBuffer,
  pRenderPassBegin: AnyBuffer,
  pSubpassBeginInfo: AnyBuffer,
): void {
  lib.vkCmdBeginRenderPass2(
    commandBuffer,
    anyBuffer(pRenderPassBegin),
    anyBuffer(pSubpassBeginInfo),
  );
}

export function CmdNextSubpass2(
  commandBuffer: CommandBuffer,
  pSubpassBeginInfo: AnyBuffer,
  pSubpassEndInfo: AnyBuffer,
): void {
  lib.vkCmdNextSubpass2(
    commandBuffer,
    anyBuffer(pSubpassBeginInfo),
    anyBuffer(pSubpassEndInfo),
  );
}

export function CmdEndRenderPass2(
  commandBuffer: CommandBuffer,
  pSubpassEndInfo: AnyBuffer,
): void {
  lib.vkCmdEndRenderPass2(
    commandBuffer,
    anyBuffer(pSubpassEndInfo),
  );
}

export function GetSemaphoreCounterValue(
  device: Device,
  semaphore: Semaphore,
  pValue: AnyBuffer,
): Result {
  const ret = lib.vkGetSemaphoreCounterValue(
    device,
    semaphore,
    anyBuffer(pValue),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function WaitSemaphores(
  device: Device,
  pWaitInfo: AnyBuffer,
  timeout: Deno.PointerValue,
): Result {
  const ret = lib.vkWaitSemaphores(
    device,
    anyBuffer(pWaitInfo),
    timeout,
  );
  if (ret === Result.SUCCESS || ret === Result.TIMEOUT) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function SignalSemaphore(
  device: Device,
  pSignalInfo: AnyBuffer,
): Result {
  const ret = lib.vkSignalSemaphore(
    device,
    anyBuffer(pSignalInfo),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdDrawIndirectCount(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
  countBuffer: Buffer,
  countBufferOffset: DeviceSize,
  maxDrawCount: number,
  stride: number,
): void {
  lib.vkCmdDrawIndirectCount(
    commandBuffer,
    buffer,
    offset,
    countBuffer,
    countBufferOffset,
    maxDrawCount,
    stride,
  );
}

export function CmdDrawIndexedIndirectCount(
  commandBuffer: CommandBuffer,
  buffer: Buffer,
  offset: DeviceSize,
  countBuffer: Buffer,
  countBufferOffset: DeviceSize,
  maxDrawCount: number,
  stride: number,
): void {
  lib.vkCmdDrawIndexedIndirectCount(
    commandBuffer,
    buffer,
    offset,
    countBuffer,
    countBufferOffset,
    maxDrawCount,
    stride,
  );
}

export function GetBufferOpaqueCaptureAddress(
  device: Device,
  pInfo: AnyBuffer,
): Deno.PointerValue {
  const ret = lib.vkGetBufferOpaqueCaptureAddress(
    device,
    anyBuffer(pInfo),
  );
  return ret;
}

export function GetBufferDeviceAddress(
  device: Device,
  pInfo: AnyBuffer,
): DeviceAddress {
  const ret = lib.vkGetBufferDeviceAddress(
    device,
    anyBuffer(pInfo),
  );
  return ret;
}

export function GetDeviceMemoryOpaqueCaptureAddress(
  device: Device,
  pInfo: AnyBuffer,
): Deno.PointerValue {
  const ret = lib.vkGetDeviceMemoryOpaqueCaptureAddress(
    device,
    anyBuffer(pInfo),
  );
  return ret;
}

export function GetPhysicalDeviceToolProperties(
  physicalDevice: PhysicalDevice,
  pToolCount: AnyBuffer,
  pToolProperties: AnyBuffer,
): Result {
  const ret = lib.vkGetPhysicalDeviceToolProperties(
    physicalDevice,
    anyBuffer(pToolCount),
    anyBuffer(pToolProperties),
  );
  if (ret === Result.SUCCESS || ret === Result.INCOMPLETE) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdSetCullMode(
  commandBuffer: CommandBuffer,
  cullMode: CullModeFlags,
): void {
  lib.vkCmdSetCullMode(
    commandBuffer,
    cullMode,
  );
}

export function CmdSetFrontFace(
  commandBuffer: CommandBuffer,
  frontFace: FrontFace,
): void {
  lib.vkCmdSetFrontFace(
    commandBuffer,
    frontFace,
  );
}

export function CmdSetPrimitiveTopology(
  commandBuffer: CommandBuffer,
  primitiveTopology: PrimitiveTopology,
): void {
  lib.vkCmdSetPrimitiveTopology(
    commandBuffer,
    primitiveTopology,
  );
}

export function CmdSetViewportWithCount(
  commandBuffer: CommandBuffer,
  viewportCount: number,
  pViewports: AnyBuffer,
): void {
  lib.vkCmdSetViewportWithCount(
    commandBuffer,
    viewportCount,
    anyBuffer(pViewports),
  );
}

export function CmdSetScissorWithCount(
  commandBuffer: CommandBuffer,
  scissorCount: number,
  pScissors: AnyBuffer,
): void {
  lib.vkCmdSetScissorWithCount(
    commandBuffer,
    scissorCount,
    anyBuffer(pScissors),
  );
}

export function CmdBindVertexBuffers2(
  commandBuffer: CommandBuffer,
  firstBinding: number,
  bindingCount: number,
  pBuffers: AnyBuffer,
  pOffsets: AnyBuffer,
  pSizes: AnyBuffer,
  pStrides: AnyBuffer,
): void {
  lib.vkCmdBindVertexBuffers2(
    commandBuffer,
    firstBinding,
    bindingCount,
    anyBuffer(pBuffers),
    anyBuffer(pOffsets),
    anyBuffer(pSizes),
    anyBuffer(pStrides),
  );
}

export function CmdSetDepthTestEnable(
  commandBuffer: CommandBuffer,
  depthTestEnable: Bool32,
): void {
  lib.vkCmdSetDepthTestEnable(
    commandBuffer,
    depthTestEnable,
  );
}

export function CmdSetDepthWriteEnable(
  commandBuffer: CommandBuffer,
  depthWriteEnable: Bool32,
): void {
  lib.vkCmdSetDepthWriteEnable(
    commandBuffer,
    depthWriteEnable,
  );
}

export function CmdSetDepthCompareOp(
  commandBuffer: CommandBuffer,
  depthCompareOp: CompareOp,
): void {
  lib.vkCmdSetDepthCompareOp(
    commandBuffer,
    depthCompareOp,
  );
}

export function CmdSetDepthBoundsTestEnable(
  commandBuffer: CommandBuffer,
  depthBoundsTestEnable: Bool32,
): void {
  lib.vkCmdSetDepthBoundsTestEnable(
    commandBuffer,
    depthBoundsTestEnable,
  );
}

export function CmdSetStencilTestEnable(
  commandBuffer: CommandBuffer,
  stencilTestEnable: Bool32,
): void {
  lib.vkCmdSetStencilTestEnable(
    commandBuffer,
    stencilTestEnable,
  );
}

export function CmdSetStencilOp(
  commandBuffer: CommandBuffer,
  faceMask: StencilFaceFlags,
  failOp: StencilOp,
  passOp: StencilOp,
  depthFailOp: StencilOp,
  compareOp: CompareOp,
): void {
  lib.vkCmdSetStencilOp(
    commandBuffer,
    faceMask,
    failOp,
    passOp,
    depthFailOp,
    compareOp,
  );
}

export function CmdSetRasterizerDiscardEnable(
  commandBuffer: CommandBuffer,
  rasterizerDiscardEnable: Bool32,
): void {
  lib.vkCmdSetRasterizerDiscardEnable(
    commandBuffer,
    rasterizerDiscardEnable,
  );
}

export function CmdSetDepthBiasEnable(
  commandBuffer: CommandBuffer,
  depthBiasEnable: Bool32,
): void {
  lib.vkCmdSetDepthBiasEnable(
    commandBuffer,
    depthBiasEnable,
  );
}

export function CmdSetPrimitiveRestartEnable(
  commandBuffer: CommandBuffer,
  primitiveRestartEnable: Bool32,
): void {
  lib.vkCmdSetPrimitiveRestartEnable(
    commandBuffer,
    primitiveRestartEnable,
  );
}

export function CreatePrivateDataSlot(
  device: Device,
  pCreateInfo: AnyBuffer,
  pAllocator: AnyBuffer,
  pPrivateDataSlot: AnyBuffer,
): Result {
  const ret = lib.vkCreatePrivateDataSlot(
    device,
    anyBuffer(pCreateInfo),
    anyBuffer(pAllocator),
    anyBuffer(pPrivateDataSlot),
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function DestroyPrivateDataSlot(
  device: Device,
  privateDataSlot: PrivateDataSlot,
  pAllocator: AnyBuffer,
): void {
  lib.vkDestroyPrivateDataSlot(
    device,
    privateDataSlot,
    anyBuffer(pAllocator),
  );
}

export function SetPrivateData(
  device: Device,
  objectType: ObjectType,
  objectHandle: Deno.PointerValue,
  privateDataSlot: PrivateDataSlot,
  data: Deno.PointerValue,
): Result {
  const ret = lib.vkSetPrivateData(
    device,
    objectType,
    objectHandle,
    privateDataSlot,
    data,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function GetPrivateData(
  device: Device,
  objectType: ObjectType,
  objectHandle: Deno.PointerValue,
  privateDataSlot: PrivateDataSlot,
  pData: AnyBuffer,
): void {
  lib.vkGetPrivateData(
    device,
    objectType,
    objectHandle,
    privateDataSlot,
    anyBuffer(pData),
  );
}

export function CmdCopyBuffer2(
  commandBuffer: CommandBuffer,
  pCopyBufferInfo: AnyBuffer,
): void {
  lib.vkCmdCopyBuffer2(
    commandBuffer,
    anyBuffer(pCopyBufferInfo),
  );
}

export function CmdCopyImage2(
  commandBuffer: CommandBuffer,
  pCopyImageInfo: AnyBuffer,
): void {
  lib.vkCmdCopyImage2(
    commandBuffer,
    anyBuffer(pCopyImageInfo),
  );
}

export function CmdBlitImage2(
  commandBuffer: CommandBuffer,
  pBlitImageInfo: AnyBuffer,
): void {
  lib.vkCmdBlitImage2(
    commandBuffer,
    anyBuffer(pBlitImageInfo),
  );
}

export function CmdCopyBufferToImage2(
  commandBuffer: CommandBuffer,
  pCopyBufferToImageInfo: AnyBuffer,
): void {
  lib.vkCmdCopyBufferToImage2(
    commandBuffer,
    anyBuffer(pCopyBufferToImageInfo),
  );
}

export function CmdCopyImageToBuffer2(
  commandBuffer: CommandBuffer,
  pCopyImageToBufferInfo: AnyBuffer,
): void {
  lib.vkCmdCopyImageToBuffer2(
    commandBuffer,
    anyBuffer(pCopyImageToBufferInfo),
  );
}

export function CmdResolveImage2(
  commandBuffer: CommandBuffer,
  pResolveImageInfo: AnyBuffer,
): void {
  lib.vkCmdResolveImage2(
    commandBuffer,
    anyBuffer(pResolveImageInfo),
  );
}

export function CmdSetEvent2(
  commandBuffer: CommandBuffer,
  event: Event,
  pDependencyInfo: AnyBuffer,
): void {
  lib.vkCmdSetEvent2(
    commandBuffer,
    event,
    anyBuffer(pDependencyInfo),
  );
}

export function CmdResetEvent2(
  commandBuffer: CommandBuffer,
  event: Event,
  stageMask: PipelineStageFlags2,
): void {
  lib.vkCmdResetEvent2(
    commandBuffer,
    event,
    stageMask,
  );
}

export function CmdWaitEvents2(
  commandBuffer: CommandBuffer,
  eventCount: number,
  pEvents: AnyBuffer,
  pDependencyInfos: AnyBuffer,
): void {
  lib.vkCmdWaitEvents2(
    commandBuffer,
    eventCount,
    anyBuffer(pEvents),
    anyBuffer(pDependencyInfos),
  );
}

export function CmdPipelineBarrier2(
  commandBuffer: CommandBuffer,
  pDependencyInfo: AnyBuffer,
): void {
  lib.vkCmdPipelineBarrier2(
    commandBuffer,
    anyBuffer(pDependencyInfo),
  );
}

export function QueueSubmit2(
  queue: Queue,
  submitCount: number,
  pSubmits: AnyBuffer,
  fence: Fence,
): Result {
  const ret = lib.vkQueueSubmit2(
    queue,
    submitCount,
    anyBuffer(pSubmits),
    fence,
  );
  if (ret === Result.SUCCESS) {
    return ret;
  } else {
    throw new VulkanError(ret as Result);
  }
}

export function CmdWriteTimestamp2(
  commandBuffer: CommandBuffer,
  stage: PipelineStageFlags2,
  queryPool: QueryPool,
  query: number,
): void {
  lib.vkCmdWriteTimestamp2(
    commandBuffer,
    stage,
    queryPool,
    query,
  );
}

export function CmdBeginRendering(
  commandBuffer: CommandBuffer,
  pRenderingInfo: AnyBuffer,
): void {
  lib.vkCmdBeginRendering(
    commandBuffer,
    anyBuffer(pRenderingInfo),
  );
}

export function CmdEndRendering(
  commandBuffer: CommandBuffer,
): void {
  lib.vkCmdEndRendering(
    commandBuffer,
  );
}
